<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数仓架构</title>
      <link href="/2020/12/13/DW/"/>
      <url>/2020/12/13/DW/</url>
      
        <content type="html"><![CDATA[<h2 id="数仓架构"><a href="#数仓架构" class="headerlink" title="数仓架构"></a>数仓架构</h2><h3 id="1-数据仓库"><a href="#1-数据仓库" class="headerlink" title="1. 数据仓库"></a>1. 数据仓库</h3><p>特点：</p><ol><li>面向主题<blockquote><p>电商，流量，交易。。。</p></blockquote></li><li>集成<blockquote><p>各个数据源：数据库，日志，爬虫。。。</p></blockquote></li><li>相对稳定<blockquote><p>主要用来查询，不是用来删除和修改</p></blockquote></li><li>反映历史变化<blockquote><p>N年的记录，每个月、每个季度、每年的汇总记录</p></blockquote></li><li>管理决策<blockquote><p>分析数据 -&gt; 指标</p></blockquote></li></ol><blockquote><p>数据湖指的是所有的原始数据，数据仓库指经过处理的原始数据（四层）</p></blockquote><h3 id="2-数据库和数据仓库的区别"><a href="#2-数据库和数据仓库的区别" class="headerlink" title="2. 数据库和数据仓库的区别"></a>2. 数据库和数据仓库的区别</h3><p>数据库： 联机事务处理和查询处理 OLTP<br>传统的数据仓库：主要是查询，用结果来支撑决策。联机分析处理 OLAP<br>大数据数据仓库：基于Hadoop的海量 分布式数据仓库<br>实时仓库：Flink + Kafka/Redis/HBase</p><h3 id="3-架构"><a href="#3-架构" class="headerlink" title="3. 架构"></a>3. 架构</h3><p>lambda：实时+ 数仓<br>kappa：实时<br>批流一体</p><h3 id="4-数仓分层"><a href="#4-数仓分层" class="headerlink" title="4. 数仓分层"></a>4. 数仓分层</h3><h4 id="4-1-分层"><a href="#4-1-分层" class="headerlink" title="4.1 分层"></a>4.1 分层</h4><ol><li>ODS(Operation Data Store)：原始数据</li><li>DWD(Data Warehouse Detail)：对原始数据进行清洗（去除空值、脏数据、超过极限范围的数据）、脱敏等，保存明细数据<ul><li>选择业务过程 -&gt; 声明粒度 -&gt; 确认维度 —&gt; 确认事实</li></ul></li><li>DWS(Data Warehouse Service)：按天进行轻度汇总，比如一个用户一天下单次数</li><li>DWT(Data Warehouse Topic)：对数据进行累计汇总，比如一个用户从注册那天开始至今一共下了多少次单</li><li>ADS(Application Data Store)：为各种统计报表提供数据</li></ol><blockquote><p>第3、4层不一定都有，甚至都没有，直接从第2层经过操作到第5层，中间没有保留中间表<br>并不能保证一定按照这个分层来进行。如果说过滤条件也比较少，甚至可以直接从ODS进行过滤后直接返回给用户。</p></blockquote><h4 id="4-2-为什么要分层"><a href="#4-2-为什么要分层" class="headerlink" title="4.2 为什么要分层"></a>4.2 为什么要分层</h4><ol><li>把复杂问题简单化：拆解每一个需求，方便定位问题</li><li>减少重复开发：提供模型的复用性</li><li>隔离原始数据：使真实数据和汇总数据解耦</li></ol><h3 id="5-数据集市和数据仓库的区别"><a href="#5-数据集市和数据仓库的区别" class="headerlink" title="5. 数据集市和数据仓库的区别"></a>5. 数据集市和数据仓库的区别</h3><p>数据集市是一个微型的数据仓库，通常有更少的数据，更少的主题区域，以及更少的历史数据，是部门级的。<br>数据仓库是企业级的。</p><h3 id="6-数据理论"><a href="#6-数据理论" class="headerlink" title="6. 数据理论"></a>6. 数据理论</h3><h4 id="6-1-范式"><a href="#6-1-范式" class="headerlink" title="6.1 范式"></a>6.1 范式</h4><ol><li>定义：范式可以理解为设计一张数据表的表结构</li><li>优点：降低数据的冗余性；数据保存多份，一次修改，需要修改多个表，很难保证数据的<strong>一致性</strong></li><li>缺点：获取数据的时候，需要通过Join连接来获取最后的数据</li><li>分类：<ol><li>第一范式：属性不可分割</li><li>第二范式：不能存在非主键字段<strong>部分函数依赖</strong>主键字段，可以消除部分数据冗余</li><li>第三范式：不能存在非主键字段<strong>传递函数依赖</strong>主键字段</li><li>BCNF、第四范式、第五范式。。。</li></ol></li></ol><blockquote><p>满足的范式越多，数据冗余性越低，但是表会越散，影响查询效率</p></blockquote><ol start="5"><li>函数依赖：完全函数依赖、部分函数依赖、传递函数依赖</li></ol><h4 id="6-2-OLTP-和-OLAP"><a href="#6-2-OLTP-和-OLAP" class="headerlink" title="6.2 OLTP 和 OLAP"></a>6.2 OLTP 和 OLAP</h4><ul><li>OLTP：传统数据库的主要应用，主要是基本的、日常的事务处理，比如银行交易</li><li>OLAP：数据仓库的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观的查询结果</li></ul><blockquote><p>OLTP 一般是关系建模方式，OLAP 一般是维度建模方式</p></blockquote><h4 id="6-3-关系建模和维度建模"><a href="#6-3-关系建模和维度建模" class="headerlink" title="6.3 关系建模和维度建模"></a>6.3 关系建模和维度建模</h4><p>关系建模符合3NF，表松散，表的数据量多，但是数据冗余性低。由于数据分布在很多的表中，这些数据可以更为灵活地被应用，功能性更强。</p><p>维度建模：基于维度和度量。维度就是事实，相当于用户进行的业务操作</p><h4 id="6-4-维度表和事实表"><a href="#6-4-维度表和事实表" class="headerlink" title="6.4 维度表和事实表"></a>6.4 维度表和事实表</h4><p>维度表：一般是对事实的描述信息，例如：用户、商品、日期、地区等<br>特征：维度表的范围很宽（具有多个属性，列比较多）；跟事实表相比，行数较小；内容比较固定，比如编码表</p><p>事实表：对应着业务事件，每一个业务都应该有一个事实表。<strong>事实</strong>对应了业务事件中的<strong>度量值</strong>。特征：行数很多；内容相对的窄，列数较少（维度外键 + 度量值）；经常发生变化</p><p>事实表又分为如下三种：</p><ol><li>事务型事实表<ul><li>以每个事务或事件为单位，一旦插入就不会再作修改，更新方式就只能是增量方式</li></ul></li><li>周期型快照事实表<ul><li>不会保留所有数据，只保留固定时间间隔的数据</li><li>事务型事实表用来保存所有的数据。比如购物车数据，不需要记录每一次加减，只要汇总每一天最后的那个状态就行。</li></ul></li><li>累积型快照事实表<ul><li>用于跟踪业务事实的变化。</li></ul></li></ol><blockquote><p>这三种像是针对关系型数据库如何设计表来说的，根据表类型的不同，来决定每天同步数据到数仓的方式是全量还是增量。<br>比如第一种因为只会新增数据，所以每天增量同步到数仓即可；第二种需要全量同步；第三种将新增变化数据同步之后，还需要再做一步整合。</p></blockquote><blockquote><p>事实表一般是动词，维度表一般是名词。</p></blockquote><h3 id="7-星型模型、雪花模型、星座模型"><a href="#7-星型模型、雪花模型、星座模型" class="headerlink" title="7. 星型模型、雪花模型、星座模型"></a>7. 星型模型、雪花模型、星座模型</h3><p>雪花模型和星型模型的区别主要是在维度的层级，标准的星型模型维度只有一层，雪花模型可能会涉及多层。<br>多个事实表可能会使用相同的维度表，组合起来就是星座模型。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>数仓最重要的是什么？<br>数据的准确性。数仓最终是为了支撑决策，决策的前提要保证数据的准确性。</p><p>如何保证数据的准确性？<br>元数据的建设与管理是其中重要的一个环节。元数据建设的目标是打通数据接入到加工 ，再到数据消费整个链路，规范元数据体系与模型，提供统一的元数据服务出口，保障元数据产出的稳定性和质量。首先梳理清楚元仓底层数据，对元数据做分类，如计算元数据、存储元数据、质量元数据等，减少数据重复建设，保障数据的唯一性。<br>另外， 要丰富表和字段使用说明，方便使用和理解。根据元仓底层数据构建元仓中间层，建设元数据基础宽表，也就是元数据中间层，打通从数据产生到消费整个链路。<br>也可在粒度、规范等方面展开，见仁见智。</p><p>如何做数据治理？数据资产管理呢？<br>在明确数据治理是数据管理的一部分之后，下一个问题就是定义数据管理。治理相对容易界定，它是用来明确相关角色、工作责任和工作流程的，确保数据资产能长期有序地、可持续地得到管理。<br>而数据管理则是一个更为广泛的定义，它与任何时间采集和应用数据的可重复流程的方方面面都紧密相关。<br>其实在数仓的整个链路中数据治理的理念是渗入其中的，在ETL过程中开发人员会对数据清洗这其实就是治理的一部分，再加上后期数据资产的管理和落定都有数据治理的渗入。</p><p>如何控制数据质量？<br>1.数据质量保证原则：完整性，准确性，数据质量，及时性，一致性<br>2.数据质量方法：数据资产等级的划定<br>3.数据加工过程卡点校验<br>4.风险点监控：针对在线或者离线数据的监控<br>5.质量衡量：故障等级的划定以及数据质量的事件的记录</p><p>元数据的理解？元数据管理系统？<br>元数据主要记录数据仓库中模型的定义、各层级间的映射关系、监 控数据仓库的数据状态及 ETL 的任务运行状态。<br>元数据有重要的应用价值，是数据管理、数据内容、数据应用的基础，在数据管理方面为集团数据提供在计算、存储、成本、质量、安全、模型等治理领域上的数据支持。<br>元数据管理系统： 首先梳理清楚元仓底层数据，对元数据做分类，如计算元数据、存储元数据、质量元数据等，减少数据重复建设，保障数据的唯一性。<br>另外， 要丰富表和字段使用说明，方便使用和理解。根据元仓底层数据构建元仓中间层，建设元数据基础宽表，也就是元数据中间层，打通从数据产生到消费整个链路</p>]]></content>
      
      
      <categories>
          
          <category> DW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 容器</title>
      <link href="/2020/12/09/Java-4/"/>
      <url>/2020/12/09/Java-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java 容器"></a>Java 容器</h2><ul><li>Collection<ul><li>List：可以重复<ul><li>CopyOnWriteArrayList</li><li>Vector</li><li>ArrayList</li><li>LinkedList</li></ul></li><li>Set：不可重复<ul><li>HashSet &amp; LinkedHashSet：HashSet无序，哈希表；LinkedHashSet 通过链表可以实现有序</li><li>SortedSet &amp; TreeSet：有序，红黑树</li><li>EnumSet</li><li>CopyOnWriteArraySet</li><li>ConcurrentSkipListSet</li></ul></li><li>Queue：主要是针对多线程 JUC<ul><li>Deque：双端队列<ul><li>ArrayDeque 实现类</li><li>LinkedList 实现类</li><li>BlockingDeque 接口 JUC重点</li></ul></li><li><strong>BlockingQueue</strong>：阻塞队列<ul><li>ArrayBlockingQueue</li><li>PriorityBlockingQueue</li><li>LinkedBlockingQueue</li><li>TransferQueue &amp; LinkedTransferQueue：有一定容量，但是一个生产者放进去一个值，如果没消费者来消费，就会一直在等待</li><li>SynchronousQueue：容量为空，必须放进去一个值才能拿，也必须拿走了才能继续生产。和LinkedTransferQueue的区别就是SynchronousQueue没有容量</li><li>Delayqueue</li></ul></li><li>PriorityQueue：小顶堆或大顶堆（具体是什么堆，通过自定义comparator），只拿最上面的那一个。由于底层实现是堆（即二叉树）实现的，所以并不能保证线程同步。如果要支持并发，需要用PriorityBlockingQueue。</li><li>ConcurrentLinkedQueue</li><li>DelayQueue</li></ul></li></ul></li><li>Map<ul><li>HashMap &amp; LinkedHashMap</li><li>TreeMap</li><li>WeakHashMap</li><li>IdentityHashMap</li><li><strong>ConcurrentHashMap</strong></li><li>ConcurrentSkipListMap</li></ul></li></ul><p>为什么没有 ConcurrentTreeMap？因为树上锁的话一般就需要锁一整棵树，影响效率；同时对树进行修改，如果底层是红黑树，修改数据可能导致整棵树的转换。<br>ConcurrentHashMap 无法保证顺序，如果要高并发+顺序，可以使用 ConcurrentSkipListMap</p><p>CAS和Synchronized的效率比较:</p><ol><li>Synchronized的过程：无锁 -&gt; 偏向锁 -&gt; 自旋锁 -&gt; 重量锁</li><li>如果线程不是很多，或者执行操作的时间不是很长的时候，cas可能会好一点</li></ol><p>vector 和 arraylist 相似，都是动态数组，但是两者有不同</p><ol><li>vector 里面方法全是 synchronized 的</li><li>vector 包含了很多传统的方法，这些方法不属于集合框架</li></ol><p>ArrayList 不带锁，如果要带锁的话，<code>Collections.SynchronizedList(list)</code> 返回的就是加了锁的list，这个集合类方法会在所有操作上加一个 synchronized<br>LinkedList 不带锁，如果要带锁的话，<code>Collections.SynchronizedList(list)</code> 返回的就是加了锁的list<br>ArrayList 和 LinkedList 的区别：</p><ol><li>ArrayList 底层是数组实现，LinkedList 底层是双向链表实现</li><li>ArrayList 查询快；LinkedList 增删快 =&gt; 原因是数组增删要移动数据，链表查询要移动指针</li></ol><blockquote><p>存储形式：<br>顺序存储 数组 查询快，增删慢<br>链式存储 链表 查询慢，增删快<br>散列存储 哈希 数组+链表 查询和增删很快 </p></blockquote><p>HashMap、LinkedHashMap 和 Treemap 的区别：</p><ol><li><p>HashMap 无序；LinkedHashMap 通过链表维护Key的插入顺序；TreeMap 通过红黑树来维护Key的自然顺序或者自定义顺序，但不是插入顺序。</p><blockquote><p>HashTable 不允许key或value为空；put get 方法都加上了synchronized，线程同步，性能较低。如果要用线程同步的HashMap可以用 ConcurrentHashMap</p></blockquote></li><li><p>HashMap 底层是 数组+链表，链表长度大于8的时候，转成红黑树；LinkedHashMap 比HashMap 多维护一个双向链表，可以按照插入顺序从头部或尾部迭代；</p><blockquote><p>LinkedHashMap 在HashMap 的基础上进行拓展，数组不变，链表增加了before和after，也就是将所有的kv（不论在数组的哪一个槽位）都通过前后指针连了起来。<br>LinkedHashMap 通过accessOrder 来决定是按照插入顺序还是访问顺序，accessOrder = true，会调用 afterNodeAccess() 方法，HashMap也调用了不过是空方法，LinkedHashMap 通过这个方法将访问的节点也就是kv放到链表的最后。另外在accessOrder = true的模式下，迭代LinkedHashMap的同时去查询数据，会导致fail-fast，因为afterNodeAccess()会修改modCount，迭代的顺序已经改变。<br>LinkedHashMap 重写了 containsValue()，HashMap 是双循环去遍历，而因为kv都通过双链表关联起来了，LinkedHashMap 可以通过直接通过head遍历链表；containsKey() 还是用的 HashMap 的，直接通过hashcode来遍历。</p></blockquote></li><li><p>HashMap 和 LinkedHashMap 的操作时间复杂度在O(1)，TreeMap 是红黑树，时间复杂度在O(logn)</p></li></ol><p>HashSet 、TreeSet 和 LinkedHashSet 的区别：</p><ol><li><p>HashSet 无序，基于HashMap来实现；LinkedHashSet 有序， 基于 LinkedHashMap 来实现的。</p></li><li><p>TreeSet 是 SortedSet 接口的唯一实现类（NavigableSet 接口继承 SortedSet 接口，TreeSet 实现 NavigableSet 接口），通过comparator方法来实现有序。在底层实现上，是通过Treemap的结构，也就是红黑树来实现存储。TreeSet 不允许存放null值。放入的对象必须实现HashCode()方法，放入的对象，是以hashcode作为标识的，而具有相同内容的string对象，hashcode是一样的。</p></li><li><p>Set 集合要求存储的元素比较重写hashcode和equals方法。比如HashSet的存放时，会先用hashcode来找位置，然后用equals来判断是否重复。</p><blockquote><p>== 判断的是内存中的地址，equals 比较内存中存放的值是否相等</p></blockquote></li></ol><p>CopyOnWriteArrayList：在JUC包下面，基于写时复制，并发的读，当需要修改的(add、set、remove)时候，加锁，先复制整个容器，修改元素，将原容器的引用指向新的容器。适合读多写少。</p><blockquote><p>copyonwrite的思想应该和redis在持久化实现的过程是一致的，即并发读，当需要修改的时候，只把需要修改的那部分复制出来进行修改，然后把引用的指针指向新的内容。这个类在实现copyonwrite的时候是复制整个容器。</p></blockquote><p>CopyOnWriteArraySet：底层用的也是 CopyOnWriteArrayList 类，在add、remove修改的时候需要加锁，复制整个容器</p><p>Queue 接口<br>|              | 引发异常                                                | 返回特殊值                                                   |<br>| ———— | ——————————————————- | :———————————————————– |<br>| 插入         | add（如果不能插入抛出异常）                             | offer（不超过容量的情况下插入，如果无法插入的话返回false）。在容量受限的队列中，offer要优于add |<br>| 移除头部元素 | remove（如果队列为空，返回NoSuchElementException异常）  | poll（如果队列为空，返回false）                              |<br>| 返回头部数据 | element（如果队列为空，返回NoSuchElementException异常） | peek（如果队列为空，返回null）                               |</p><p>Deque：继承Queue接口，双端队列，允许头部或尾部进行操作</p><blockquote><p>LinkedList 也实现了这个接口方法，add 是直接在链表的尾部加入，还可以从头部加入，addfirst或者offerfirst</p></blockquote><p>ArrayDeque：实现Deque接口，是一个双向数组，或者叫循环数组。普通数组下标0是第一个元素，下标最大的是最后一个元素，在最后进行操作还可以，但是如果在头部进行操作，就需要移动所有的数据下标，而ArrayDeque通过循环数组就解决了这个问题。具体是通过移动head和tail的下标来实现。计算个数的时候通过位运算获得<code>return (tail - head) &amp; (elements.length - 1);</code>每当add数据的时候，都会判断head是否等于tail，如果是的话就扩容，所以head=tail只会出现在初始化的时候。</p><p><img src="https://images.weserv.nl/?url=https://img-blog.csdn.net/20160413143417742" alt></p><p><a href="https://mxxct4git.github.io/2020/08/11/Thread-2/"><strong>BlockingQueue</strong> 同步队列中的堵塞队列</a></p><p><strong>BlockingQueue</strong>：阻塞队列</p><p>注意事项：</p><ol><li>不接受null元素</li><li>可以限定容量</li><li>主要用于实现 生产者消费者 队列，但它另外还支持 Collection 接口</li><li>线程安全</li></ol><blockquote><p>公平锁和非公平锁：公平锁即一个线程组里能保证每个线程都拿到锁，那么这个锁就是公平锁。如果保证不了每个线程都拿到锁，即存在有线程饿死，那么这个锁就是非公平锁。ReentrantLock 默认是非公平锁。<br>比如：t1获取锁，t2等待，t1释放，t2正准备获取t3插队，t3获取锁，t2继续等待。这就是非公平锁，可能会因为线程抢占问题而导致某个线程一直在等待。如果是公平锁的话，t3会发现等待队列有人，就不会随意抢占了。</p></blockquote><p>ArrayBlockingQueue：基于数组，有界，初始化时限定容量，不会扩容。生产和消费公用一个锁，即两者不会真正并行。可以设置锁是否公平。<br>PriorityBlockingQueue：基于优先级（优先级的判断通过构造函数传入的Compator对象来决定），无界阻塞队列。生产和消费公用一个锁，即两者不会真正并行。不会阻塞生产者，统一使用的是offer()，由于队列是无界的，会一直放进去数据；但是消费的时候如果队列为空，会一直等待。如果生产者速度远大于消费者，某一刻会导致OOM。<br>LinkedBlockingQueue：基于链表，如果不指定容量，默认是Integer.MAX_VALUE，相当于无界，为了避免内存问题一般指定容量。内部有takeLock和putLock，保证了生产和消费可以并行执行，并且都是非公平锁。<a href="https://blog.csdn.net/tonywu1992/article/details/83419448" target="_blank" rel="noopener">LinkedBlockingQueue</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Removes a node from head of queue.</span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">  // assert takeLock.isHeldByCurrentThread();</span><br><span class="line">  // assert head.item == null;</span><br><span class="line">  Node&lt;E&gt; h = head;</span><br><span class="line">  Node&lt;E&gt; first = h.next;</span><br><span class="line">  h.next = h; // help GC</span><br><span class="line">  head = first;</span><br><span class="line">  E x = first.item;</span><br><span class="line">  first.item = null;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransferQueue &amp; LinkedTransferQueue：无界。transfer() 方法将元素给消费者，如果没有消费者就会堵塞生产者；tryTransfer() 将元素立刻给一个消费者，如果没有消费者就返回false，不会将元素放入队列，还可以指定等待时间。<a href="https://www.cnblogs.com/lighten/p/7505355.html" target="_blank" rel="noopener">LinkedTransferQueue</a><br>SynchronousQueue：容量为空，必须放进去一个值才能拿，也必须拿走了才能继续生产。和LinkedTransferQueue的区别就是SynchronousQueue没有容量<br>DelayQueue：无界。元素只有当指定的延迟时间到了，才能从里面获取到元素。即不会堵塞生产者，但是会堵塞消费者。使用场景比如用来管理一个超时未响应的连接队列。<br>ConcurrentLinkedQueue：通过CAS来实现</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 引用</title>
      <link href="/2020/12/08/Java-3/"/>
      <url>/2020/12/08/Java-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-引用"><a href="#Java-引用" class="headerlink" title="Java 引用"></a>Java 引用</h2><h3 id="1-引用类型"><a href="#1-引用类型" class="headerlink" title="1. 引用类型"></a>1. 引用类型</h3><ul><li>强引用<ul><li>栈 -&gt; 堆</li><li>只要堆中对象可达，就不会被回收</li></ul></li><li>软引用<ul><li>需要 <code>import SoftReference</code> </li><li>栈 -&gt; 堆中会创建一个 <code>SoftReference</code>对象，这个对象里会有一个<code>value</code> -&gt; 这个<code>value</code>指向了堆中的一个对象，也就是真正的值</li><li>当堆中的内存不够的时候，软引用指向的对象就会被回收</li><li>应用：适合做缓存，比如图片</li></ul></li><li>弱引用<ul><li>需要 <code>import WeakReference</code></li><li>栈 -&gt; 堆中会创建一个 <code>WeakReference</code>对象，这个对象里会有一个<code>value</code> -&gt; 这个<code>value</code>指向了堆中的一个对象，也就是真正的值</li><li>当弱引用遇到gc就会被回收</li><li>应用：为了解决内存泄露问题，比如<code>ThreadLocal</code></li></ul></li><li>虚引用<ul><li>需要 <code>import PhantomReference</code></li><li>应用：管理堆外内存。流程大概如下：OS读取数据，会放在内存里，之前的处理方式（比如BIO)会把这一部分内存复制到JVM内存中，来回复制，一方面是效率低下，另一方面容易造成内存溢出，因为JVM无法及时清理外面的内存。现在通过虚引用（NIO中的DirectByteBuffer）可以直接在JVM中创建一个指向堆外内存的对象，当JVM中的对象被回收的时候（应该就是处理完数据了），回收这个动作可以通过监听Queue探测到，这时候就可以由GC来回收堆外内存的对象。</li></ul></li></ul><h3 id="2-ThreadLocal中的弱引用"><a href="#2-ThreadLocal中的弱引用" class="headerlink" title="2. ThreadLocal中的弱引用"></a>2. ThreadLocal中的弱引用</h3><blockquote><p>ThreadLocal的设计初衷：提供线程内部的局部变量，在本线程内可以随意使用，隔离其他线程</p></blockquote><p>每一个Thread对象，都包含一个 <code>ThreadLocal.ThreadLocalMap threadLocals</code> 的属性。</p><p>以 <code>static ThreadLocal&lt;String&gt; localVar = new ThreadLocal&lt;&gt;();</code>为例，这个 <code>map</code> 的 <code>key</code> 就是 <code>localVar</code>，<code>value</code> 就是一个字符串，这个字符串是在每一个线程中，通过 <code>localVar.set(&quot;xxx&quot;)</code> 设置的</p><blockquote><p>ThreadLocal 在 get、set 的时候会首先获取到 Thread.currentThread()，然后再根据线程拿到 threadLocals  这个map，然后在map中进行操作，保证了只是针对当前线程的变量进行操作</p></blockquote><p><code>ThreadLocalMap</code> 中的每一对 <code>key,value</code> 都是存放在 <code>Entry</code> 中的，而 <code>Entry</code> 继承了 WeakReference，并在构造函数中将 <code>key</code> 作为了弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment"> * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment"> * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment"> * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment"> * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment"> * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">  Object value;</span><br><span class="line"></span><br><span class="line">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">    <span class="keyword">super</span>(k);</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用到弱引用？避免内存溢出。为啥会内存溢出？</p><p><code>Thread --&gt; ThreadLocal.ThreadLocalMap&lt;localVar, &quot;xxx&quot;&gt;</code> 其中 <code>localVar</code> 是弱引用</p><p><code>Thread</code> 中含有指向 <code>ThreadLocal</code> 类下的 <code>ThreadLocalMap</code> 这个对象的变量</p><p>创建一个 <code>ThreadLocal&lt;String&gt; localVar</code>，如果不是弱引用， <code>localVar = null</code>，对应的<code>ThreadLocalMap</code>中的<code>key</code>就是<code>null</code>，理论上应该回收 ``ThreadLocal<code>对象，但是并不会，因为</code>ThreadLocal.ThreadLocalMap<code>还被某个线程强引用（生产上的线程多数都是一直在运行的），就会导致</code>ThreadLocalMap<code>中的内存一直无法被回收。现在是弱引用，即</code>localVar = null`，如果这时候GC扫描到了就可以回收，哪怕线程正在进行。</p><blockquote><p>简单来说就是，ThreadLocalMap 这块内存，除了 ThreadLocal 指向它，Thread 也指向它，ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value</p></blockquote><p>仅仅是把<code>key</code>置为<code>null</code>是不够的，因为<code>value</code>还是不会被回收掉，<code>key=null</code>的<code>Entry</code>的<code>value</code>还存在一个强引链 <code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>，导致内存泄漏。所以正确的做法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">localVar.set(<span class="string">"zhangsan"</span>);</span><br><span class="line">localVar.remove();<span class="comment">// 调用remove()方法删除entry，底层调用expungeStaleEntry()方法，如果key=null，就把value置为null；如果key不为null，就通过开放寻址法将kv从Entry[] tab里移除</span></span><br></pre></td></tr></table></figure><p>在ThreadLocal的get、set方法以及扩容时，会清理掉key=null的Entry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     int len = tab.length;</span><br><span class="line"></span><br><span class="line">     while (e != null) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">         if (k == key)</span><br><span class="line">             return e;</span><br><span class="line">         if (k == null)</span><br><span class="line">             expungeStaleEntry(i);</span><br><span class="line">         else</span><br><span class="line">             i = nextIndex(i, len);</span><br><span class="line">         e = tab[i];</span><br><span class="line">     &#125;</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先在索引位置去拿到一个Entry e，如果e不为null并且key相同返回e；如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询。</p><p>虽然ThreadLocal本身也做了避免内存泄露的优化，但是上述成功前提是需要调用get、set方法 =&gt; 大多数情况下还是手动调用 remove() 更好 =&gt; JDK 建议就是把 <code>ThreadLocal</code> 变量定义成<code>private static</code>的，这样的话<code>ThreadLocal</code>的生命周期就更长，就会一直存在<code>ThreadLocal</code>的强引用，所以<code>ThreadLocal</code>也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，所以我们需要调用 <code>remove</code>，防止内存泄露。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LFU</title>
      <link href="/2020/12/08/LFU/"/>
      <url>/2020/12/08/LFU/</url>
      
        <content type="html"><![CDATA[<h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>LFU（Least Frequently Used ，最近最少使用算法）</p><p>算法描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造容量为 capacity 的缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 在缓存中查询 key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 将 key 和 val 存入缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get(key)</code>方法会去缓存中查询键<code>key</code>，如果<code>key</code>存在，则返回<code>key</code>对应的<code>val</code>，否则返回 -1。</p><p><code>put(key, value)</code>方法插入或修改缓存。如果<code>key</code>已存在，则将它对应的值改为<code>val</code>；如果<code>key</code>不存在，则插入键值对<code>(key, val)</code>。</p><p>当缓存达到容量<code>capacity</code>时，则应该在插入新的键值对之前，删除使用频次（后文用<code>freq</code>表示）最低的键值对。如果<code>freq</code>最低的键值对有多个，则删除其中最旧的那个。</p><p>思路：</p><ol><li>需要有一个HashMap来保存key到val的映射，用来计算 <code>get(key)</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; keyToVal;</span><br></pre></td></tr></table></figure><ol start="2"><li>需要有一个HashMap来保存<code>key</code>到<code>freq</code>的映射，用来计算每一个key的频次</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>算法的核心需求(思路)</p><ol><li>需要<code>freq</code>到<code>key</code>的映射，用来找到最小<code>freq</code>对应的<code>key</code></li><li>如果要满足上一条，快速找到最小<code>freq</code>是多少，可以通过一个变量<code>minFreq</code>来记录当前最小<code>freq</code>，避免遍历</li><li>可能会有多个<code>key</code>拥有相同的<code>freq</code>，所以<code>freq</code>和<code>key</code>是一对多的关系，那么就需要维护一个<code>freq</code>到key对应的映射关系</li><li>为了保证快速查找并删除最旧的<code>key</code>，就需要保证<code>freq</code>对应的<code>key</code>的映射列表应该是有<strong>顺序</strong>的</li><li>需要能够<strong>快速删除<code>key</code>列表中的任何一个key</strong>。如果频次为<code>freq</code>的<code>key</code>被访问了，它的频次应该变成<code>freq+1</code>，此时应该从freq对应的<code>key</code>列表中删除，并把<code>key</code>加入到<code>freq+1</code>对应的key列表中 =&gt; 就是需要提高它的频次</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line"><span class="keyword">int</span> minFreq;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>如果用 LinkedList 可以满足第3、4条，但是链表不能快速访问某一个节点，所以不能满足第5条快速删除</p></blockquote><p>综上，<code>LFUCache</code> 类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line">    <span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br><span class="line">    <span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="keyword">int</span> minFreq;</span><br><span class="line">    <span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        keyToFreq = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        <span class="keyword">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyToVal.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 增加key对应的频次</span></span><br><span class="line">        increaseFreq(key); </span><br><span class="line">        <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 避免初始化的时候capacity参数异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cap &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 KV 表已经存在这个key</span></span><br><span class="line">        <span class="comment">// 修改对应的val，频次+1</span></span><br><span class="line">        <span class="keyword">if</span> (keyToVal.containsKey(key)) &#123;</span><br><span class="line">            keyToVal.put(key, val);</span><br><span class="line">            increaseFreq(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 KV 表不存在这个key</span></span><br><span class="line">        <span class="comment">// 并且当前容量已满，就需要删除最小频次的key</span></span><br><span class="line">        <span class="keyword">if</span> (keyToVal.size() &gt;= <span class="keyword">this</span>.cap) &#123;</span><br><span class="line">            removeMinFreqKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前容量未满，插入key和val，并且key对应的freq置为1</span></span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// putIfAbsent 如果有这个key的话就不进行任何操作，此处相当于对1这个key进行初始化</span></span><br><span class="line">        freqToKeys.putIfAbsent(<span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">        freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">        <span class="comment">// 插入最新的key之后，最小的freq肯定是1</span></span><br><span class="line">        <span class="keyword">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先，能进入到这个函数的时候，keyToFreq 和 freqToKeys 一定保存过这个key了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 KF 表中key对应的频次+1</span></span><br><span class="line">        <span class="keyword">int</span> freq = keyToFreq.get(key);</span><br><span class="line">        keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fk 表中删除freq对应的列表中的key</span></span><br><span class="line">        freqToKeys.get(freq).remove(key);</span><br><span class="line">        freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">        freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 freq 对应的列表空了，就移除这个freq</span></span><br><span class="line">        <span class="keyword">if</span> (freqToKeys.get(freq).size() == <span class="number">0</span>) &#123;</span><br><span class="line">            freqToKeys.remove(freq);</span><br><span class="line">            <span class="comment">// 如果这个 freq 又恰好是 minFreq，更新 minFreq</span></span><br><span class="line">          <span class="comment">// 这个地方容易忘记更新</span></span><br><span class="line">            <span class="keyword">if</span> (freq == <span class="keyword">this</span>.minFreq) &#123;</span><br><span class="line">                <span class="keyword">this</span>.minFreq++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeMinFreqKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// FK 表中最小freq对应的列表中 最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">        LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="keyword">this</span>.minFreq);</span><br><span class="line">        <span class="keyword">int</span> deleteKey = keyList.iterator().next();</span><br><span class="line">        keyList.remove(deleteKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 freq 对应的列表空了，就移除这个freq</span></span><br><span class="line">        <span class="keyword">if</span>(keyList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            freqToKeys.remove(<span class="keyword">this</span>.minFreq);</span><br><span class="line">            <span class="comment">// 这里不需要更新 minFreq，因为后面会紧跟一个put操作，minFreq 会被置为1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 KV 表</span></span><br><span class="line">        keyToVal.remove(deleteKey);</span><br><span class="line">        <span class="comment">// 更新 KF 表</span></span><br><span class="line">        keyToFreq.remove(deleteKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> LFU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LFU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 深入学习</title>
      <link href="/2020/11/30/Docker-5/"/>
      <url>/2020/11/30/Docker-5/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-深入学习"><a href="#Docker-深入学习" class="headerlink" title="Docker 深入学习"></a>Docker 深入学习</h2><p><a href="https://docs.docker.com/reference/" target="_blank" rel="noopener">官方帮助文档</a></p><h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">$ docker --help</span><br><span class="line">用法:  docker COMMAND                                                                                                             </span><br><span class="line">A self-sufficient runtime for containers                                                                                           </span><br><span class="line">选项:                                                                                                                           </span><br><span class="line">      --config string      Location of client config files (default                                                                </span><br><span class="line">                           &quot;C:\\Users\\junchow\\.docker&quot;)                                                                          </span><br><span class="line">  -D, --debug              开启debug模式</span><br><span class="line">  -H, --host list          Daemon socket(s) to connect to                                                                          </span><br><span class="line">  -l, --log-level string   设置日志级别，级别分为debug|info|warn|error|fatal，默认为info。                                                                             </span><br><span class="line">      --tls                Use TLS; implied by --tlsverify                                                                         </span><br><span class="line">      --tlscacert string   Trust certs signed only by this CA (default                                                             </span><br><span class="line">                           &quot;C:\\Users\\junchow\\.docker\\machine\\machines\\default\\ca.pem&quot;)                                      </span><br><span class="line">      --tlscert string     Path to TLS certificate file (default                                                                   </span><br><span class="line">                           &quot;C:\\Users\\junchow\\.docker\\machine\\machines\\default\\cert.pem&quot;)                                    </span><br><span class="line">      --tlskey string      Path to TLS key file (default                                                                           </span><br><span class="line">                           &quot;C:\\Users\\junchow\\.docker\\machine\\machines\\default\\key.pem&quot;)                                     </span><br><span class="line">      --tlsverify          Use TLS and verify the remote (default true)                                                            </span><br><span class="line">  -v, --version            终端打印显示版本信息并退出                                                                                                                                   </span><br><span class="line">管理命令:                                                                                                               </span><br><span class="line">  config      管理Docker配置</span><br><span class="line">  container   管理容器                                                                                                    </span><br><span class="line">  image       管理镜像</span><br><span class="line">  network     管理网络</span><br><span class="line">  node        管理Swarm节点</span><br><span class="line">  plugin      管理插件</span><br><span class="line">  secret      管理Docker安全</span><br><span class="line">  service     管理服务</span><br><span class="line">  swarm       管理Swarm集群</span><br><span class="line">  system      管理Docker系统</span><br><span class="line">  trust       Manage trust on Docker images                                                                                        </span><br><span class="line">  volume      管理卷</span><br><span class="line">                                                                                                                                   </span><br><span class="line">命令:                                                                                                                          </span><br><span class="line">  attach      将标准输入和标准输出连接到正在运行的容器                                        </span><br><span class="line">  build       使用dockerfile文件创建镜像                                                                                     </span><br><span class="line">  commit      从容器的修改项中创建新的镜像</span><br><span class="line">  cp          将容器的目录或文件复制到本地文件系统中</span><br><span class="line">  create      创建一个新的镜像</span><br><span class="line">  diff        检查容器文件系统的修改</span><br><span class="line">  events      实时输出docker服务器中发生的事件</span><br><span class="line">  exec        从外部运行容器内部的命令</span><br><span class="line">  export      将容器的文件系统到处为tat文件包</span><br><span class="line">  history     显示镜像的历史</span><br><span class="line">  images      输出镜像列表</span><br><span class="line">  import      从压缩为tar文件的文件系统中创建镜像</span><br><span class="line">  info        显示当前系统信息、docker容器与镜像个数、设置信息等</span><br><span class="line">  inspect     使用JSON格式显示容器与镜像的详细信息</span><br><span class="line">  kill        向容器发送kill信号关闭容器</span><br><span class="line">  load        从tar文件或标准输入中加载镜像</span><br><span class="line">  login       登录docker注册服务器</span><br><span class="line">  logout      退出docker注册服务器</span><br><span class="line">  logs        输出容器日志信息</span><br><span class="line">  pause       暂停容器中正在运行的所有进程</span><br><span class="line">  port        查看容器的端口是否处于开放状态</span><br><span class="line">  ps          输出容器列表</span><br><span class="line">  pull        从注册服务器中拉取一个镜像或仓库</span><br><span class="line">  push        将镜像推送到docker注册服务器</span><br><span class="line">  rename      重命名一个容器</span><br><span class="line">  restart     重启一个或多个容器</span><br><span class="line">  rm          删除一个或多个容器，若没有指定标签则删除lastest标签。</span><br><span class="line">  rmi         删除一个或多个镜像，若没有指定标签则删除lastest标签。                                                </span><br><span class="line">  run         在一个新容器中中运行命令，用于指定镜像创建容器。</span><br><span class="line">  save        将一个或多个镜像保存为tar包             </span><br><span class="line">  search      从Docker Hub中搜索镜像</span><br><span class="line">  start       启动一个或多个已经停止的容器</span><br><span class="line">  stats       查看各个容器占用内存、CPU的情况                                                     </span><br><span class="line">  stop        停止一个或多个正在运行的容器</span><br><span class="line">  tag         设置镜像标签</span><br><span class="line">  top         显示容器中正在运行的进程信息</span><br><span class="line">  unpause     重启pause命令暂停的容器</span><br><span class="line">  update      更新一个或多个容器的配置</span><br><span class="line">  version     显示docker版本信息</span><br><span class="line">  wait        等待容器终止然后输出退出码</span><br><span class="line">Run &apos;docker COMMAND --help&apos; for more information on a command.</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4933701-c9c04d73e0eae5fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/935/format/webp" alt="命令小结"></p><h4 id="1-1-镜像命令"><a href="#1-1-镜像命令" class="headerlink" title="1.1 镜像命令"></a>1.1 镜像命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker images   # 查询本机上所有的镜像</span><br><span class="line"></span><br><span class="line"># 可选项</span><br><span class="line">-a 显示全部</span><br><span class="line">-q 只显示镜像ID</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名</span><br><span class="line"></span><br><span class="line"># 可选项</span><br><span class="line">-f=stars=3000  # 搜索STARS大于3000的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名[:tag]</span><br><span class="line"></span><br><span class="line">针对不同版本，如果有一样的镜像文件，就不需要重复下载了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker imi -f 镜像id                   # 删除指定镜像</span><br><span class="line">docker imi -f 镜像id 镜像id 镜像id      # 删除多个镜像</span><br><span class="line">docker imi -f $(docker images -q)     # 把$里面当成参数传递进去，获取所有的镜像id，然后全部删除</span><br></pre></td></tr></table></figure><h4 id="1-2-容器命令"><a href="#1-2-容器命令" class="headerlink" title="1.2 容器命令"></a>1.2 容器命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"># 参数说明</span><br><span class="line">--name=&quot;Name&quot;   容器名字，用来区分容器</span><br><span class="line">-d              后台方式运行</span><br><span class="line">-i -t           使用交互方式运行，进入容器查看内容</span><br><span class="line">-p              指定容器的端口 -p 8080:8000</span><br><span class="line">    -p 主机端口:容器端口  # 进行映射</span><br><span class="line">    -p 容器端口</span><br><span class="line">-P              随机指定端口</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 列出所有正在运行的容器</span><br><span class="line"></span><br><span class="line"># 可选项</span><br><span class="line">-a      # 列出所有容器</span><br><span class="line">-n=?    # 列出前n个容器</span><br><span class="line">-q      # 只显示容器ID</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit 退出容器并停止</span><br><span class="line">ctrl+P+Q 大写模式下，退出容器且不停止</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dcoker rm 容器ID</span><br><span class="line">docker rm -f $(docker ps -q) 删除所有的容器ID</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID</span><br><span class="line">docker restart 容器ID</span><br><span class="line">docker stop 容器ID</span><br><span class="line">docker kill 容器ID   # 强制停止容器</span><br></pre></td></tr></table></figure><h4 id="1-3-常用其他命令"><a href="#1-3-常用其他命令" class="headerlink" title="1.3 常用其他命令"></a>1.3 常用其他命令</h4><p>通过 <code>docker run -d 镜像名</code> 来启动，然后通过 <code>docker ps</code> 会发现容器停止了</p><p>=&gt; docker 容器使用后台运行，就必须要有一个前台进程，docker 发现没有应用，就会自动停止<br>eg：nginx 容器启动后发现没有提供服务就会自动停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs     # 查看日志</span><br><span class="line"></span><br><span class="line"># 可选项</span><br><span class="line">-t  # 时间戳</span><br><span class="line">-f  # 持续输出日志</span><br><span class="line">    --tail number   # 显示最后的number条日志</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID   # 查看容器中的进程信息，其中pid是进程id，ppid是父进程id</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID/镜像ID   # 查看容器/镜像元数据，在下面有一个 layers 里面是镜像文件的每一层文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">很多容器都是后台运行，需要进入容器，修改一些配置</span><br><span class="line"></span><br><span class="line">方式一：</span><br><span class="line">docker exec -it 容器ID /bin/bash    # 以命令行的方式来进行交互</span><br><span class="line"># 进入容器后会开启一个新的终端，可以在终端里操作</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">docker attach 容器ID    # 会进入到正在执行的终端，不会启动新的进程</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:容器内的路径 主机路径  # 将容器中的文件拷贝到主机中</span><br></pre></td></tr></table></figure><h4 id="1-4-测试安装tomcat"><a href="#1-4-测试安装tomcat" class="headerlink" title="1.4 测试安装tomcat"></a>1.4 测试安装tomcat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br><span class="line">docker run -d -p 主机端口:8080 --name tomcat01 tomcat</span><br><span class="line"></span><br><span class="line">访问主机端口，发现404</span><br><span class="line">docker exec -it tomcat01 /bin/bash</span><br><span class="line">进入到webapps文件夹下面，发现是空的，原因是官方镜像删减了很多功能，只留下了能运行的最基本的功能</span><br><span class="line">解决方法：可以把 webapps.dist 下面的内容复制到 webapps 文件夹下即可</span><br><span class="line">但是这样的解决方法又太麻烦了，不能每次上线都进入容器部署 =&gt; 数据卷</span><br></pre></td></tr></table></figure><h4 id="1-5-测试安装ES"><a href="#1-5-测试安装ES" class="headerlink" title="1.5 测试安装ES"></a>1.5 测试安装ES</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stats    # 查看各个容器占用内存、CPU的情况</span><br><span class="line">∵ es非常耗内存 ∴ 可以修改配置文件，来增加内存的限制，-e 设置最小内存和最大内存</span><br><span class="line"></span><br><span class="line">docker run -d --name elasticserch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms256m -Xms512m&quot; elasticsearch:7.6.2</span><br></pre></td></tr></table></figure><h3 id="2-可视化-portainer"><a href="#2-可视化-portainer" class="headerlink" title="2. 可视化 portainer"></a>2. 可视化 portainer</h3><p>一个可视化管理方案，直接用docker来安装即可，做好主机端口映射</p><h3 id="3-联合文件系统"><a href="#3-联合文件系统" class="headerlink" title="3. 联合文件系统"></a>3. 联合文件系统</h3><p>镜像是一种轻量级、可执行的独立软件包，包含某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><p>UFS(UnionFS) 联合文件系统，是一种分层、轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加。类似于Git版本控制，每一次<strong>提交（操作）</strong>都记为一层。如果连个软件有共用的某一层文件，比如都基于linux，那么都可以去挂在这一层的linux的文件，就可以复用。</p><p>ufs里面包含比如</p><ul><li>bootfs: 包含bootloader和kernel，bootloader主要是引导加载kernal，类似于启动系统的时候会有一个加载过程，当系统启动后，这个加载的程序就可以关闭了 =&gt; 加载的这部分就是可以复用的部分</li><li>rootfs: 在bootfs之上，包含的就是典型的linux系统的 <code>/dev, /proc, /bin, /etc</code> 等标准目录和文件 =&gt; 比如linux的容器，占的内存很小，是因为镜像文件只需要包含rootfs里最基本的命令、工具即可，可以使用主机的kernel，这样的话可以提高效率</li></ul><p>所有的镜像都起始于一个基础镜像层，当进行修改或增加新的内容的时候，就会在当前镜像层之上，创建一个新的镜像层</p><p>镜像都是只读的，当容器启动时，一个新的可写层（容器层）就会加载到镜像层的顶部</p><p>通过 commit 来将容器层和镜像层进行合并打包，变成一个新的镜像文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 目标镜像名[:tag]</span><br></pre></td></tr></table></figure><h3 id="5-数据卷"><a href="#5-数据卷" class="headerlink" title="5. 数据卷"></a>5. 数据卷</h3><ol><li>每次修改配置文件都需要进入到容器很麻烦</li><li>数据不应该放在容器中，否则删除容器，数据就丢失了</li></ol><p>=&gt; 在容器外部提供一个映射路径，类似于数据共享技术，通过卷技术，也就是目录的挂载，将容器内的目录，挂在到linux上面，来实现容器数据的持久化和同步操作，容器之间也可以数据共享。</p><blockquote><p>容器里面的目录就像是快捷方式，宿主机的文件才是真实的</p></blockquote><p>实现方式：</p><ol><li>直接使用命令来挂载 -v <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录 镜像名 /bin/bash</span><br><span class="line"></span><br><span class="line">docker run --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -p 3310:3306 -v testconf2:/etc/mysql/conf.d -v /Users/mxxct/mysqldata:/var/lib/mysql -d mysql:5.7</span><br></pre></td></tr></table></figure></li></ol><p>通过 <code>docker inspect 容器ID</code> 查看元数据，在 <code>Mounts</code> 里可以看到挂载的详细信息</p><ul><li>匿名挂载<br>  不指定主机名，直接写容器内目录 <code>-v 容器内目录</code></li><li>具名挂载<br>  也可以分为两种<ul><li>指定主机目录 <code>-v 主机目录:容器内目录</code></li><li>不指定主机目录，只是写一个名字 <code>-v xxx:容器内目录</code> 这时候会默认映射到主机 <code>/var/lib/docker/volumes/xxx/_data</code> 这个文件夹下面（在MacOS下面没找到这个路径）</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls    # 查看所有的卷</span><br><span class="line">docker volume inspect 卷名字    # 查看具体数据卷的信息，这里卷名字是指具名挂载的那个名字</span><br></pre></td></tr></table></figure><blockquote><p>可以在容器内目录后面添加权限控制<br>eg: -v 主机目录:容器内目录:ro/rw<br>ro readonly; rw readwrite 默认是rw，如果是ro就表示这个路径只能从主机上来操作，容器内只是读权限</p></blockquote><ol start="2"><li>通过 DockerFile 在构建镜像是指定 VOLUME</li></ol><blockquote><p>这里是一个匿名挂载</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;vol1&quot;, &quot;vol2&quot;]</span><br><span class="line">CMD echo &quot;---- end ----&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>直接创建文件然后执行 <code>docker build</code> 可能会提示 <code>error checking context：can&#39;t stat xxx</code> 错误，这个提示基本是权限不够外加目录结构不对<br>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mkdir dockerfile</span><br><span class="line">chmod 777 dockerfile</span><br><span class="line">touch file1</span><br><span class="line">vi file1</span><br><span class="line">docker build -f /Users/mxxct/dockerfile/file1 -t test/centos:1.0 .</span><br><span class="line"></span><br><span class="line">(base) localhost:dockerfile mxxct$ docker build -f /Users/mxxct/dockerfile/file1 -t test/centos:1.0 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM centos</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">3c72a8ed6814: Pull complete </span><br><span class="line">Digest: sha256:76d24f3ba3317fa945743bb3746fbaf3a0b752f10b10376960de01da70685fbd</span><br><span class="line">Status: Downloaded newer image for centos:latest</span><br><span class="line"> ---&gt; 0d120b6ccaa8</span><br><span class="line">Step 2/4 : VOLUME [&quot;vol1&quot;, &quot;vol2&quot;]</span><br><span class="line"> ---&gt; Running in 7cc3997837d7</span><br><span class="line">Removing intermediate container 7cc3997837d7</span><br><span class="line"> ---&gt; b55d348b6981</span><br><span class="line">Step 3/4 : CMD echo &quot;---- end ----&quot;</span><br><span class="line"> ---&gt; Running in 083ad85879af</span><br><span class="line">Removing intermediate container 083ad85879af</span><br><span class="line"> ---&gt; 11c45d147425</span><br><span class="line">Step 4/4 : CMD /bin/bash</span><br><span class="line"> ---&gt; Running in e7d39262c201</span><br><span class="line">Removing intermediate container e7d39262c201</span><br><span class="line"> ---&gt; ee8398f6597c</span><br><span class="line">Successfully built ee8398f6597c</span><br><span class="line">Successfully tagged test/centos:1.0</span><br></pre></td></tr></table></figure><p>创建好镜像后，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ee8398f6597c /bin/bash</span><br><span class="line"></span><br><span class="line">[root@2adb0cbdc19f /]# ls -l</span><br><span class="line">total 56</span><br><span class="line">lrwxrwxrwx   1 root root    7 May 11  2019 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root  360 Dec  1 06:23 dev</span><br><span class="line">drwxr-xr-x   1 root root 4096 Dec  1 06:23 etc</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 11  2019 home</span><br><span class="line">lrwxrwxrwx   1 root root    7 May 11  2019 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx   1 root root    9 May 11  2019 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------   2 root root 4096 Aug  9 21:40 lost+found</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 11  2019 media</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 11  2019 mnt</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 11  2019 opt</span><br><span class="line">dr-xr-xr-x 159 root root    0 Dec  1 06:23 proc</span><br><span class="line">dr-xr-x---   2 root root 4096 Aug  9 21:40 root</span><br><span class="line">drwxr-xr-x  11 root root 4096 Aug  9 21:40 run</span><br><span class="line">lrwxrwxrwx   1 root root    8 May 11  2019 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 11  2019 srv</span><br><span class="line">dr-xr-xr-x  12 root root    0 Dec  1 06:23 sys</span><br><span class="line">drwxrwxrwt   7 root root 4096 Aug  9 21:40 tmp</span><br><span class="line">drwxr-xr-x  12 root root 4096 Aug  9 21:40 usr</span><br><span class="line">drwxr-xr-x  20 root root 4096 Aug  9 21:40 var</span><br><span class="line">drwxr-xr-x   2 root root 4096 Dec  1 06:23 vol1</span><br><span class="line">drwxr-xr-x   2 root root 4096 Dec  1 06:23 vol2</span><br></pre></td></tr></table></figure><p>这里有 vol1 和 vol2 两个目录，然后去查看容器的元数据信息，会发现在 Mounts 这里已经把两个卷给挂在出去了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;baeff06c4bf78f14c8135dbdc5ae238bb513cf8375af699b47c602d3e3a0a529&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/baeff06c4bf78f14c8135dbdc5ae238bb513cf8375af699b47c602d3e3a0a529/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;vol1&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;4cbbd6edd2093b5098b6d9994bc380c992445842c1b19a942816b090a8841e13&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/4cbbd6edd2093b5098b6d9994bc380c992445842c1b19a942816b090a8841e13/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;vol2&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="6-数据卷容器"><a href="#6-数据卷容器" class="headerlink" title="6. 数据卷容器"></a>6. 数据卷容器</h3><blockquote><p>容器数据卷是容器实现数据持久化的一种机制，数据卷容器是一种特殊的容器<br>这个主要是通过类似，用于容器间的数据同步，不是容器和主机之间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name docker01 imageID</span><br><span class="line">docker run -it --name docker02 --volumes-from docker01 imageID</span><br><span class="line"></span><br><span class="line">docker01中有挂载的文件夹</span><br><span class="line">通过 --volumes-from 让docker02继承docker01的挂载文件夹，此时docker01挂载出去的文件夹里的数据的任何修改在docker02也可以看到，同时在docker02上做的修改docker01也可以看到。docker01就是数据卷容器。</span><br></pre></td></tr></table></figure><blockquote><p>删除docker01的话，挂载的文件夹数据依然存在，本质是因为他们都挂载到主机的目录下，只要主机对应目录存在，数据就不会丢失<br>docker01相当于映射主机数据目录的地址（想成一个快捷方式），docker02拿到这个映射地址（快捷方式），放到自己的mount里面</p></blockquote><h3 id="7-DockerFile"><a href="#7-DockerFile" class="headerlink" title="7. DockerFile"></a>7. DockerFile</h3><blockquote><p>通过 docker history imageID 可以查看一个镜像的构建过程</p></blockquote><p>基础知识</p><ol><li>每个关键字指令都必须是大写</li><li>按顺序从上到下执行</li><li><code>#</code> 是注释</li><li>每一个指令都会创建并提交一个新的镜像层。（docker run之后会创建一个可写容器）</li></ol><p>指令说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM        # 指定基础镜像</span><br><span class="line">MAINtAINER  # 指定维护者信息，姓名+邮箱</span><br><span class="line">RUN         # 镜像构建的时候需要运行的命令</span><br><span class="line">ADD         # 添加内容，会自动解压，比如tomcat压缩包</span><br><span class="line">WORKDIR     # 镜像的工作目录</span><br><span class="line">VOLUME      # 设置卷，挂载主机目录</span><br><span class="line">EXPOSE      # 指定暴露的端口，或者通过 -p 指定</span><br><span class="line">CMD         # 指定容器启动时要运行的命令，只有最后一个会生效，可被替代 </span><br><span class="line">ENTRYPOINT  # 指定容器启动时要运行的命令，可以追加命令</span><br><span class="line">ONBUILD     # 当构建一个被继承 DockerFile 这个时候会运行ONBUILD的指令，触发指令</span><br><span class="line">COPY        # 类似ADD，将文件拷贝到镜像中</span><br><span class="line">ENV         # 构建的时候设置环境变量</span><br></pre></td></tr></table></figure><p><code>CMD [&quot;ls&quot;, &quot;-a&quot;]</code> 这时候的命令相当于 “ls -a”。只有当执行 <code>docker run imageID</code> 的时候才会执行最后一个CMD的命令。(<code>docker run -it imageID</code>这时候是通过命令行交互，所以不会执行CMD)</p><p>如果执行 <code>docker run imageID -l</code> 想执行 <code>ls -al</code> 命令会报错，即CMD命令会被替代，不会追加。<br>换成 <code>ENTRYPOINT</code> 再执行 <code>docker run imageID -l</code> 就可以执行 <code>ls -al</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">COPY 主机路径/readme.txt 容器内路径</span><br><span class="line">ADD 主机路径/xxxx.tar 容器内路径    # ADD添加的文件会自动解压</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /user/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /user/local/jdk1.8.0_11</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /user/local/apache-tomcat-9.0.22</span><br><span class="line">ENV CATALINA_BASH /user/local/apache-tomcat-9.0.22</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /user/local/apache-tomcat-9.0.22/bin/startup.sh &amp;&amp; tail -f /user/local/apache-tomcat-9.0.22/bin/logs/catalinas.out</span><br></pre></td></tr></table></figure><h3 id="8-Docker-网络"><a href="#8-Docker-网络" class="headerlink" title="8. Docker 网络"></a>8. Docker 网络</h3><p>每次启动一个程序，Linux 就会相应创建一个新的网卡地址 =&gt; veth-pair 一对虚拟设备接口，一端连着协议，一端彼此相连 =&gt; 每启动一个容器，docker会创建一对网卡连接地址，一端在主机，一端在容器</p><blockquote><p>Linux 虚拟网络设别 veth-pair。三个经典实验，直接相连、通过 Bridge 相连和通过 OVS 相连</p></blockquote><p>两个docker容器进行通信，需要先走到docker0，也就是类似于docker的路由器，通过广播或注册的方式，路由器会知道下一个容器的网络地址，然后转发请求连接。Docker0就相当于一个网桥的角色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --link 通过link可以将两个容器网络连接起来，但是这是单向的，A link B, 只是A可以连接B，想B连接A的话还需要再配置B</span><br><span class="line">link 操作相当于在容器内的 hosts 文件中写进去映射关系</span><br></pre></td></tr></table></figure><p>不推荐 <code>--link</code>。因为 link 用的是 docker0，而docker0不支持容器名称映射，只能写死ip，如果牵扯到ip迁移，就需要重新配置一遍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls   # 查看所有的docker网络</span><br></pre></td></tr></table></figure><p>网络模式</p><ul><li><p>bridge： 桥接（docker默认）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net bridge     # 不写的话也默认有这个bridge</span><br></pre></td></tr></table></figure></li><li><p>none：不配置</p></li><li><p>host：和主机共享网络</p></li><li><p>container：容器网络连通（用得少，局限很大）</p></li></ul><p>自定义创建网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br></pre></td></tr></table></figure><p>创建的容器基于各自不同的网络，可以保证同一类容器使用的是自己的网络ip。但是如果是两类容器想互相连接呢？网络打通。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect [option] container network   # 将一个容器连接到一个网关上，相当于一个容器两个ip地址。</span><br></pre></td></tr></table></figure><h3 id="9-Docker-Compose"><a href="#9-Docker-Compose" class="headerlink" title="9. Docker Compose"></a>9. Docker Compose</h3><p>目的：定义运行多个容器，避免一个个的运维容器<br>步骤：</p><ol><li>DockerFile</li><li>docker-compose.yml</li><li>run <code>docker-compose up</code></li></ol><blockquote><p>配置项里有一个 deploy.replicas 可以设置副本，集群部署的时候使用这个参数</p></blockquote><p>单机</p><h3 id="10-Docker-Swam"><a href="#10-Docker-Swam" class="headerlink" title="10. Docker Swam"></a>10. Docker Swam</h3><p>相当于是搭建一个小集群，有manager有worker。</p><p>集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init# 初始化节点</span><br><span class="line">docker swarm join-token manager# 加入一个节点，并将该节点作为manager</span><br><span class="line">docker swarm join-token worker# 加入一个节点，并将该节点作为worker</span><br></pre></td></tr></table></figure><h3 id="11-Raft-协议"><a href="#11-Raft-协议" class="headerlink" title="11. Raft 协议"></a>11. Raft 协议</h3><blockquote><p>拜占庭将军问题：很久很久以前，拜占庭是东罗马帝国的首都。那个时候罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信使传递消息。在打仗的时候，拜占庭军队内所有将军必需达成一致的共识，才能更好地赢得胜利。但是，在军队内有可能存有叛徒，扰乱将军们的决定。这时候，在已知有成员不可靠的情况下，其余忠诚的将军需要在不受叛徒或间谍的影响下达成一致的协议。莱斯利·兰伯特（ Leslie Lamport ）通过这个比喻，表达了计算机网络中所存在的一致性问题。这个问题被称为拜占庭将军问题。</p></blockquote><blockquote><p>二将军问题：白军驻扎在沟渠里，蓝军则分散在沟渠两边。白军比任何一支蓝军都更为强大，但是蓝军若能同时合力进攻则能够打败白军。他们不能够远程的沟通，只能派遣通信兵穿过沟渠去通知对方蓝军协商进攻时间。是否存在一个能使蓝军必胜的通信协议，这就是两将军问题。</p></blockquote><blockquote><p>二将军问题探讨的是不可靠信道下两方的通信准确性问题，而拜占庭将军问题探讨的是多方通信结果一致性和决策正确性的问题。<br>准确性是指发送的是什么，接收的就是什么；一致性是在节点更多的情况下的准确性；正确性是无论收到的通信结果是否有干扰（不完全满足一致性），正常工作的节点能够做出正确的决策。</p></blockquote><p>=&gt; 二将军问题可以通过TCP3次握手来解决；拜占庭将军问题可以通过Raft/Paxos（谷哥Chubby）/ZAB（zookeeper）/PBFT（区块链）几种算法解决。另外 PS：raft，zab，paxos解决的是节点故障问题，而非拜占庭问题(节点故意欺骗)。PBFT解决了拜占庭问题。</p><p><a href="https://mp.weixin.qq.com/s/bMY5unx7OijlaDmj6fVKOA" target="_blank" rel="noopener">Raft协议 </a></p><p>Raft 协议的具体流程：</p><ol><li>在最初，还没有一个主节点的时候，所有节点的身份都是Follower。每一个节点都有自己的计时器，当计时达到了超时时间（Election Timeout），该节点会转变为Candidate。</li><li>成为Candidate的节点，会首先给自己投票，然后向集群中其他所有的节点发起请求，要求大家都给自己投票。</li><li>其他收到投票请求且还未投票的Follower节点会向发起者投票，发起者收到反馈通知后，票数增加。</li><li>当得票数超过了集群节点数量的一半，该节点晋升为Leader节点。Leader节点会立刻向其他节点发出通知，告诉大家自己才是老大。收到通知的节点全部变为Follower，并且各自的计时器清零。</li></ol><p>这里需要说明一点，每个节点的超时时间都是不一样的。比如A节点的超时时间是3秒，B节点的超时时间是5秒，C节点的超时时间是4秒。这样一来，A节点将会最先发起投票请求，而不是所有节点同时发起。为什么这样设计呢？设想如果所有节点同时发起投票，必然会导致大家的票数差不多，形成僵局，谁也当不成老大。</p><p>那么，成为Leader的节点是否就坐稳了老大的位置呢？并不是。Leader节点需要每隔一段时间向集群其他节点发送心跳通知，表明你们的老大还活着。一旦Leader节点挂掉，发不出通知，那么计时达到了超时时间的Follower节点会转变为Candidate节点，发起选主投票，周而复始……</p><p>数据同步的流程：</p><ol><li>由客户端提交数据到Leader节点</li><li>由Leader节点把数据复制到集群内所有的Follower节点。如果一次复制失败，会不断进行重试</li><li>Follower节点们接收到复制的数据，会反馈给Leader节点</li><li>如果Leader节点接收到超过半数的Follower反馈，表明复制成功。于是提交自己的数据，并通知客户端数据提交成功。</li><li>由Leader节点通知集群内所有的Follower节点提交数据，从而完成数据同步流程。</li></ol><p><a href="https://www.jianshu.com/p/2bceacd60b8a" target="_blank" rel="noopener">ZAB协议</a></p><h3 id="12-容器服务"><a href="#12-容器服务" class="headerlink" title="12. 容器服务"></a>12. 容器服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker service create -p ip:端口 --name my-service xxx</span><br><span class="line"><span class="meta">#</span> 和 docker run 的区别是，run是容器启动，不具备扩缩容的概念；service是服务启动，可以自动扩缩容</span><br><span class="line"></span><br><span class="line">docker service ps my-service# 查看服务进程</span><br><span class="line">docker service ls# 查看服务列表，这里有一个 replicas，表示当前服务的副本</span><br><span class="line">docker servie update --replicas N my-service# 将 my-service 自动扩容到 N 个副本</span><br><span class="line">docker service scale my-service=N# 将 my-service 自动扩容到 N 个副本</span><br><span class="line"></span><br><span class="line">有一个 --mode 参数，默认是 replicated，可以改成 global</span><br><span class="line">replicated 只能在worker节点中运行，global的话manager节点也可以运行</span><br></pre></td></tr></table></figure><p>灰度发布：金丝雀发布</p><p>命令 -&gt; manager节点调用api -&gt; schedule api -&gt; worker节点创建并维护容器服务</p><p>镜像使用的os版本不统一，比如Linux基于的os不一样，版本不一样，命令缺失，阉割版和增肥版都不统一，数据文件可能都修改了位置等等</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas</title>
      <link href="/2020/11/29/Arthas/"/>
      <url>/2020/11/29/Arthas/</url>
      
        <content type="html"><![CDATA[<h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><h3 id="1-官方教程"><a href="#1-官方教程" class="headerlink" title="1. 官方教程"></a>1. 官方教程</h3><p>下载官方jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br><span class="line">启动后会列出所有的Java进程，用户可以选择需要诊断的目标进程。输入序号即可。成功监听后会打印 Arthas LOGO</span><br></pre></td></tr></table></figure><h3 id="2-指令"><a href="#2-指令" class="headerlink" title="2. 指令"></a>2. 指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard</span><br></pre></td></tr></table></figure><p>查看当前系统的实时数据面板<br>输入Q或Ctrl+C退出dashboard命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 1</span><br></pre></td></tr></table></figure><p>打印线程ID 1的栈<br>Arthas支持管道，可以用 <code>thread 1 | grep &#39;main(&#39;</code> 查找到main class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d *MathGame</span><br></pre></td></tr></table></figure><p>查找JVM里已加载的类，如果搜索的是接口，还会搜索所有的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm -d java.math.RoundingMode</span><br></pre></td></tr></table></figure><p>查找类的具体函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad demo.MathGame</span><br></pre></td></tr></table></figure><p>反编译代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * &apos;&#123;params, throwExp&#125;&apos;</span><br></pre></td></tr></table></figure><p>第一个参数是类名，支持通配；第二个参数是函数名，支持通配；第三个参数是返回值表达式，内置对象有<br>loader<br>clazz<br>method<br>target<br>params<br>returnObj<br>throwExp<br>isBefore<br>isThrow<br>isReturn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit/quit</span><br></pre></td></tr></table></figure><p>退出Arthas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop</span><br></pre></td></tr></table></figure><p>彻底退出Arthas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl</span><br></pre></td></tr></table></figure><p>动态执行代码</p><p><code>trace</code><br>跟踪类</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Arthas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arthas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁实现</title>
      <link href="/2020/11/25/Redis-7/"/>
      <url>/2020/11/25/Redis-7/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZO3ZKMzm3Vmc5L6icEx7JtA3QWLj02ROzbS9Nc3Ws5nCNAXS0RoKfvGXzibXwHAcUSPrrQbouSnI9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p><p>电商场景，当用户下单的时候，redis 里库存只有一件，并发执行的时候可能会造成<strong>库存超卖问题</strong></p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZO3ZKMzm3Vmc5L6icEx7JtAOxHO6gxicqjzJAcGEVLiaibiafgnibsXbScFI9FewYrk20USwQ7HvaDjyWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p><p>通过在执行第二步加锁，可以保证并发请求在下单的时候操作是串行化的，但是并发增多，增加一台机器</p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZO3ZKMzm3Vmc5L6icEx7JtA5AxlRwFCcEXicQqThGCeTmdWvybbFoSRJ4XFEWIkCAtEalQmjYWDQWg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p><p>此时还是会造成<strong>库存超卖问题</strong>。原因是：两个系统运行在两个不同的JVM里面，他们加的锁只对属于自己JVM里面的线程有效，对于其他JVM的线程是无效的。即 <strong>Java提供的原生锁机制在多机部署场景下失效了</strong></p><p>分布式锁：redis 或 zookeeper</p><h3 id="1-Redis-实现方式"><a href="#1-Redis-实现方式" class="headerlink" title="1. Redis 实现方式"></a>1. Redis 实现方式</h3><p>思路：在redis中设置一个值表示加了锁，然后释放锁的时候就把这个key删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 获取锁</span><br><span class="line">// NX是指如果key不存在就成功，key存在返回false，PX可以指定过期时间</span><br><span class="line">SET anyLock unique_value NX PX 30000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 释放锁：通过执行一段lua脚本</span><br><span class="line">// 释放锁涉及到两条指令，这两条指令不是原子性的</span><br><span class="line">// 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的</span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>需要注意的地方：</p><ol><li>一定要用SET key value NX PX milliseconds 命令<br> 如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(key永久存在)</li><li>value 要具有唯一性<br> 这个是为了在解锁的时候，需要验证value是和加锁的一致才删除key。<br> 这是避免了一种情况：假设A获取了锁，过期时间30s，此时35s之后，锁已经自动释放了，A去释放锁，但是此时可能B获取了锁。A客户端就不能删除B的锁了。</li></ol><p>这样有可能会有一个问题是：设置了key的过期时间，但是业务处理逻辑的时间可能大于过期时间，这样A获取了锁，但是处理超时了，key被过期，B获取了锁，也有可能会恶性循环</p><p>组件 <em>Redission</em> 实现</p><ol><li>redisson所有指令都通过lua脚本执行，redis支持lua脚本原子性执行</li><li>redisson中有一个watchdog的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔10秒帮你把key的超时时间设为30s。这样的话，就算一直持有锁也不会出现key过期了，其他线程获取到锁的问题了。同时也保证了没有死锁的产生，哪怕机器宕机，key也会在时间到了之后自己过期</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">// 加锁逻辑</span><br><span class="line">private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) &#123;</span><br><span class="line">    if (leaseTime != -1) &#123;</span><br><span class="line">        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用一段lua脚本，设置一些key、过期时间</span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    ttlRemainingFuture.addListener(new FutureListener&lt;Long&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void operationComplete(Future&lt;Long&gt; future) throws Exception &#123;</span><br><span class="line">            if (!future.isSuccess()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Long ttlRemaining = future.getNow();</span><br><span class="line">            // lock acquired</span><br><span class="line">            if (ttlRemaining == null) &#123;</span><br><span class="line">                // 看门狗逻辑</span><br><span class="line">                scheduleExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">              &quot;if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then &quot; +</span><br><span class="line">                  &quot;redis.call(&apos;hset&apos;, KEYS[1], ARGV[2], 1); &quot; +</span><br><span class="line">                  &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]); &quot; +</span><br><span class="line">                  &quot;return nil; &quot; +</span><br><span class="line">              &quot;end; &quot; +</span><br><span class="line">              &quot;if (redis.call(&apos;hexists&apos;, KEYS[1], ARGV[2]) == 1) then &quot; +</span><br><span class="line">                  &quot;redis.call(&apos;hincrby&apos;, KEYS[1], ARGV[2], 1); &quot; +</span><br><span class="line">                  &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]); &quot; +</span><br><span class="line">                  &quot;return nil; &quot; +</span><br><span class="line">              &quot;end; &quot; +</span><br><span class="line">              &quot;return redis.call(&apos;pttl&apos;, KEYS[1]);&quot;,</span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 看门狗最终会调用了这里</span><br><span class="line">private void scheduleExpirationRenewal(final long threadId) &#123;</span><br><span class="line">    if (expirationRenewalMap.containsKey(getEntryName())) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这个任务会延迟10s执行</span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run(Timeout timeout) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            // 这个操作会将key的过期时间重新设置为30s</span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line"></span><br><span class="line">            future.addListener(new FutureListener&lt;Boolean&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void operationComplete(Future&lt;Boolean&gt; future) throws Exception &#123;</span><br><span class="line">                    expirationRenewalMap.remove(getEntryName());</span><br><span class="line">                    if (!future.isSuccess()) &#123;</span><br><span class="line">                        log.error(&quot;Can&apos;t update lock &quot; + getName() + &quot; expiration&quot;, future.cause());</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (future.getNow()) &#123;</span><br><span class="line">                        // reschedule itself</span><br><span class="line">                        // 通过递归调用本方法，无限循环延长过期时间</span><br><span class="line">                        scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    if (expirationRenewalMap.putIfAbsent(getEntryName(), new ExpirationEntry(threadId, task)) != null) &#123;</span><br><span class="line">        task.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ZooKeeper-实现方式"><a href="#2-ZooKeeper-实现方式" class="headerlink" title="2. ZooKeeper 实现方式"></a>2. ZooKeeper 实现方式</h3><p>Zookeeper是一种提供配置管理、分布式协同以及命名的中心化服务。</p><p>zk的模型是这样的：zk包含一系列的节点，叫做znode，就好像文件系统一样每个znode表示一个目录，然后znode有一些特性：</p><ul><li>有序节点<ul><li>假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点<br>zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号<br>也就是说，如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。</li></ul></li><li>临时节点<ul><li>客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。</li></ul></li><li>事件监听<ul><li>在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper有如下四种事件：<ul><li>节点创建</li><li>节点删除</li><li>节点数据修改</li><li>子节点变更</li></ul></li></ul></li></ul><p>实现分布式锁的思路</p><ol><li>使用zk的临时节点和有序节点，每个线程获取锁就是在zk创建一个临时有序的节点，比如在/lock/目录下。</li><li>创建节点成功后，获取/lock目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点</li><li>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。</li><li>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</li></ol><p>比如当前线程获取到的节点序号为 <code>/lock/003</code>，然后所有的节点列表为<code>[/lock/001,/lock/002,/lock/003]</code>，则对/lock/002这个节点添加一个事件监听器。<br>如果锁释放了，会唤醒下一个序号的节点，然后重新执行第3步，判断是否自己的节点序号是最小。比如<code>/lock/001</code>释放了，<code>/lock/002</code>监听到事件，此时节点集合为<code>[/lock/002,/lock/003]</code>，则<code>/lock/002</code>为最小序号节点，获取到锁。</p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLblQkicuWPYZicf1yqrpficlt2bhIqLu3VOmTM6qIyibrPc87X2dAoNibxOJ03vtJiaMKfKm0jic7l2rcSng/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 和 MySQL 数据不一致性</title>
      <link href="/2020/11/25/Redis-6/"/>
      <url>/2020/11/25/Redis-6/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-和-MySQL-数据不一致性"><a href="#Redis-和-MySQL-数据不一致性" class="headerlink" title="Redis 和 MySQL 数据不一致性"></a>Redis 和 MySQL 数据不一致性</h2><p><a href="https://zhuanlan.zhihu.com/p/91770135" target="_blank" rel="noopener">参考地址</a></p><p>具体如何去解决还得结合业务去综合考虑。</p><p>下面几个方式可能比较通用</p><h3 id="1-双删法"><a href="#1-双删法" class="headerlink" title="1. 双删法"></a>1. 双删法</h3><p>写流程</p><ol><li>先删除缓存</li><li>写更新数据库</li><li>再次删除缓存 =&gt; 避免在第二步的时候有读请求访问数据库，然后把旧的值写入到缓存中</li></ol><p>读流程</p><ol><li>先读缓存</li><li>缓存没有就读数据库</li><li>更新缓存</li></ol><p>这其实是一种懒加载，即只有当读的时候才会从数据库把最新的值加载到缓存里，是读流程激活的加载，而不是写流程在写入新值的时候自动刷新加载</p><p>主动加载的话，万一多个并行操作同时对一个key进行更新，需要考虑操作的幂等性，采用MQ的分区机制来保证同一分区内的操作都是顺序串行化执行</p><p>双删失败如何处理？</p><ol><li>设置缓存过期时间，从理论上来说，给缓存设置过期时间，是保证<strong>最终一致性</strong>的解决方案</li><li>重试 =&gt; 重试有业务通过mq重试以及组件消费mysql的binlog再写入mq重试两种方式</li></ol><h3 id="2-异步延迟删除"><a href="#2-异步延迟删除" class="headerlink" title="2. 异步延迟删除"></a>2. 异步延迟删除</h3><p>在双删的基础上，采用 异步延迟删除</p><ol><li>先删除缓存</li><li>写更新数据库</li><li>触发异步写入串行化MQ（也可以采取一种key+version的分布式锁</li><li>MQ接受再次删除缓存</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase WAL日志</title>
      <link href="/2020/11/16/HBase-3/"/>
      <url>/2020/11/16/HBase-3/</url>
      
        <content type="html"><![CDATA[<h2 id="HBase-WAL日志"><a href="#HBase-WAL日志" class="headerlink" title="HBase WAL日志"></a>HBase WAL日志</h2><p><a href="https://www.cnblogs.com/frankdeng/p/9310278.html" target="_blank" rel="noopener">参考网址1</a><br><a href="http://hbasefly.com/2017/07/02/hbase-sequenceid/" target="_blank" rel="noopener">参考网址2</a></p><p><strong>每一个region servser维护一个或多个Hlog（1.X版本可以开启multiwal），而不是每一个region一个日志</strong>。这样不同 region(可能来自来自不同 table) 的日志会混在一起，这样做的目的是不断追加单个文件相对于同时写多个文件而言，可以减少磁盘寻址次数，因此可以提高对 table 的写性能。带来的麻烦是，如果一台 region server 下线，为了恢复其上的 region，需要将 region server 上的 log 进行拆分，然后分发到其它 region server 上进行恢复。</p><p><img src="https://images.weserv.nl/?url=http://hbasefly.com/wp-content/uploads/2017/07/11.png" alt="HLog文件基本结构"></p><p>HLog中日志单元WALEntry表示一次行级更新的最小追加单元（图中红色/黄色小方框）。它由两部分组成：HLogKey和WALEdit，HLogKey中包含多个属性信息，包含table name、region name、sequenceid等；WALEdit用来表示一个事务中的更新集合，一次行级事务可以原子操作同一行中的多个列。上图中WALEdit包含多个KeyValue。</p><h3 id="1-sequenceID"><a href="#1-sequenceID" class="headerlink" title="1. sequenceID"></a>1. sequenceID</h3><p>问题：</p><ol><li>memstore中的数据flush到hdfs中后，HLog对应的数据是不是可以删除了？不然HLog会无限增长</li><li>HBase中单个HLog都有固定大小，日志文件最大个数也有设置，默认最大文件数量是8。如果文件数量超过了这个值，就必须删除最老的日志。那么如何知道HLog日志对应的所有数据都已经flush到磁盘？（如果知道哪些数据没有罗盘，就可以强制进行flush，然后删除HLog）</li><li>regionserver宕机之后memstore中的数据会丢失，可以通过HLog进行恢复，哪些数据需要恢复？哪些不需要恢复？</li></ol><p>=&gt; 都需要一种介质来表示Memstore中数据Flush的那个点对应HLog哪个位置 =&gt; sequenceId 自增序号，每个region维护属于自己的id，不同region的id相互独立</p><p><img src="https://images.weserv.nl/?url=http://hbasefly.com/wp-content/uploads/2017/07/12.png" alt="sequenceID"></p><h4 id="1-HLog-什么时候可以过期回收"><a href="#1-HLog-什么时候可以过期回收" class="headerlink" title="1. HLog 什么时候可以过期回收"></a>1. HLog 什么时候可以过期回收</h4><p><img src="https://images.weserv.nl/?url=http://hbasefly.com/wp-content/uploads/2017/07/13.png" alt="回收HLog"></p><p>虚线右侧部分为超过单个HLog大小阈值后切分形成的一个HLog文件，问题是这个文件什么时候可以被系统回收删除。理论上来说只需要这个文件上所有Region对应的最大sequenceid已经落盘就可以删除，比如下图中如果RegionA对应的最大sequenceid(5)已经落盘，同时RegionB对应的最大sequenceid(5)也落盘，那该HLog就可以被删除。</p><p>RegionServer会为每个Region维护了一个变量oldestUnflushedSequenceId（<strong>实际上是和每个Store一一对应</strong>，为了方便讲解，此处暂且认为是Region，不影响原理），表示这个Region最早的还未落盘的seqid，即这个seqid之前的所有数据都已经落盘。</p><p>下图是flush过程中oldestUnflushedSequenceId变量变化的示意图，初始时为null，假设在某一时刻阶段二RegionA(红色方框)要执行flush，中间HLog中sequenceId为1~4对应的数据将会落盘，在执行flush之前，HBase会append一个空的Entry到HLog，仅为获取下一个sequenceId(5)，并将这个sequenceId赋给OldestUnflushedSequenceId-RegionA。如图中第三阶段OldestUnflushedSequenceId-RegionA指向sequenceId为5的Entry。</p><p><img src="https://images.weserv.nl/?url=http://hbasefly.com/wp-content/uploads/2017/07/14.png" alt></p><p>可见，每次flush之后这个变量就会往前移动一段距离。</p><p><img src="https://images.weserv.nl/?url=http://hbasefly.com/wp-content/uploads/2017/07/15.png" alt></p><p>场景一中右侧HLog还有未落盘的数据（sequenceid=5还未落盘），因此不能删除；而场景二中右侧HLog的所有数据都已经落盘，所以这个HLog理论上就已经可以被删除回收。</p><blockquote><p>如果在当前HLog中存在一个regionA的oldestUnflushedSequenceId小于当前HLog文件中regionA最大的sequenceId，那么就不能删除这个HLog文件；如果到达了HLog的最大文件数量，必须要删除这个文件，那么就对regionA中执行flush操作，将数据落盘</p></blockquote><h3 id="2-RegionServer宕机恢复replay日志时哪些WALEntry需要被回放，哪些会被skip"><a href="#2-RegionServer宕机恢复replay日志时哪些WALEntry需要被回放，哪些会被skip" class="headerlink" title="2. RegionServer宕机恢复replay日志时哪些WALEntry需要被回放，哪些会被skip"></a>2. RegionServer宕机恢复replay日志时哪些WALEntry需要被回放，哪些会被skip</h3><p>理论上来说只需要回放Memstore中没有落地的数据对应的WALEntry，已经落地数据对应的WALEntry可以skip。可问题是RegionServer已经宕机了，<code>&lt;region, oldestUnflushedSequenceId&gt;</code> 对应信息肯定没有了。如何是好？想办法持久化呗，上文分析oldestUnflushedSequenceId变量是flush时产生的一个变量，这个变量完全可以<strong>以flush的时候以元数据的形式写到HFile中</strong></p><p><code>org.apache.hadoop.hbase.regionserver.StoreFlusher</code> 类</p><p><img src="https://images.weserv.nl/?url=http://hbasefly.com/wp-content/uploads/2017/07/17.png" alt></p><p>这样Region在宕机迁移重新打开之后加载HFile元数据就可以恢复出这个核心变量oldestUnflushedSequenceId（本次flush所生成的所有HFlie中都存储同一个sequenceId），这个sequenceId在恢复出来之后就可以用来在回放WALEntry的时候过滤哪些Entry需要被回放，哪些会被skip。</p><h4 id="2-1-附加问题"><a href="#2-1-附加问题" class="headerlink" title="2.1 附加问题"></a>2.1 附加问题</h4><p>Q: 有没有可能一次flush所生成的所有HFile中存储的sequenceId出现不一致，比如：region中所有store（store1、store2）都执行flush，其中store1执行flush成功，此时oldestUnflushedSequenceId变量成功追加到对应的HFile中；但在store2执行flush之前RegionServer发生宕机异常，store2对应的oldestUnflushedSequenceId变量还是上个文件对应的sequenceId，这种情况下回放数据会不会有影响？如果有，为什么？如果没有，是什么机制保证的？</p><p>A: 到目前为止，上面所有分析都基于一个事实：hbase中flush操作是region级别操作，即每次执行flush都需要整个region中的所有store全都执行flush。接下来作为延伸阅读内容，对Per-CF Flush比较感兴趣的可以继续阅读，Per-CF Flush允许系统对某个或某些列组单独执行flush。实现原理与上文所分析内容基本相似。不同的是上文中oldestUnflushedSequenceId是与region一一对应的，Per-CF Flush中这个参数需要细化到store，与store一一对应。</p><h3 id="3-Per-CF-Flush"><a href="#3-Per-CF-Flush" class="headerlink" title="3. Per-CF Flush"></a>3. Per-CF Flush</h3><p>region级别flush确实存在不少问题，在多个列族的情况下其中一个store大小超过了阈值（128M），不论其他store多大多小都会强制落盘，有些很小的列族（几兆）落盘后形成很多特别小的文件，对hbase的读并不是一件好事。</p><p><strong>per-cf flush允许单个store执行flush，该feature在1.0.0以上版本已经存在，在1.2.0版本设置为默认策略。</strong> 实现这个功能有两个必要的工作，其一是提出一种新的flush策略能够在多个列族中选择一个或者多个单独进行进行flush，目前新策略称为FlushLargerStoresPolicy，即选择当前最大的一个store进行flush。其二是必须将oldestUnflushedSequenceId的粒度从region细化到store，即从<code>map&lt;region, oldestUnflushedSequenceId&gt;</code>改为<code>map&lt;region, map&lt;store, oldestUnflushedSequenceId&gt;&gt;</code>，上文所述三个问题的判断逻辑也需要修改为store级别判断逻辑。这里使用store级别判断逻辑简单对问题一和问题三进行复盘。</p><p><strong>Per-CF Flush策略下，HLog在什么时候可以过期回收？</strong><br>region级别的判断逻辑主要依赖于<code>map&lt;region, oldestUnflushedSequenceId&gt;</code>，详见上文。store级别的数据结构改为了<code>map&lt;region, map&lt;store, oldestUnflushedSequenceId&gt;&gt;</code>，其实很容易经过简单的转化又变回region级别，<code>map&lt;store, oldestUnflushedSequenceId&gt;</code>找到最小的oldestUnflushedSequenceId称为minSeqNum，这样region级别的数据结构就变出来了 – <code>map&lt;region, minSeqNum&gt;</code>，其他逻辑都不用变。</p><p>=&gt; 根据每个store的id，可以取到region的最小id，然后按照这个最小id来进行flush</p><p><strong>Per-CF Flush策略下，RegionServer宕机恢复replay日志时哪些数据需要被回放，哪些会被skip？</strong><br>这个问题稍微复杂一点，第一个关注的问题是回放粒度的问题。需要回过头来看看HLog中Entry的组成，如图可以知道一个Entry由WALKey和WAKEdit两部分构成，WALKey包含一些基本信息，本文重点关注sequenceId这个变量；WALEdit包含插入\更新的KeyValue集合，这里需要重点注意，<strong>这些KeyValue可能包含一行中多个列族（列），因此可以说WALEdit会包含多个store更新的KeyValue。</strong></p><p><img src="https://images.weserv.nl/?url=http://hbasefly.com/wp-content/uploads/2017/07/18.png" alt></p><p>在All-CF Flush策略下，我们以HLog-Entry为粒度进行数据回放没有任何问题，但是在Per-CF Flush策略下就不再行得通。因为一个HLog-Entry中多个CF的KeyValue是混在一起的，可能部分KV已经落盘，其他部分还没有。因此需要将回放粒度减小到KeyValue级别，一个一个KeyValue分别进行检查回放。</p><p>回放粒度问题摸清了，再来关注哪些KeyValue需要被回放，哪些会被skip。上文说过，每次flush的时候对应的oldestUnflushedSequenceId会被持久化到HFile的元数据中。在All-CF Flush策略下，一次flush操作中整个region所有store所持久化的oldestUnflushedSequenceId都相同，因此回放的时候HLog-Entry的sequenceId只需要与这一个oldestUnflushedSequenceId比较就可以，大的话就需要回放，小的话就skip。但在Per-CF的场景下又不再行得通，一个region中不同store都有自己独立的oldestUnflushedSequenceId，因此回放的时候需要根据KeyValue找到对应store，在与该store中的oldestUnflushedSequenceId比较，大的话需要回放，小的话skip。</p><blockquote><p>hbase shell 中查看原始数据<br>scan ‘MODEL_GROUP_STRUCTURE:STRUCTURE_COMPLAINT_LABEL_H’, {FORMATTER =&gt; ‘toString’, LIMIT =&gt; 10}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM SafePoint</title>
      <link href="/2020/11/12/JVM-2/"/>
      <url>/2020/11/12/JVM-2/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM-SafePoint"><a href="#JVM-SafePoint" class="headerlink" title="JVM SafePoint"></a>JVM SafePoint</h2><p>在多线程环境下，为了能正确回收不再使用的内存，安全回收需要满足以下两个条件</p><ol><li>堆内存的变化是受控制的，最好所有的线程都停止</li><li>堆中的对象是已知的，不再使用的对象都可以找到</li></ol><p>∴ JVM 是在 SafePoint 点时才进行回收，所谓 SafePoint 即Java线程执行到某个位置时，JVM能够安全可控地回收对象</p><p>如何到达 SafePoint</p><p>说到这里就要提到如何使线程中断，一般有两种方式：主动式和被动式。主动式JVM设置一个全局变量，线程去按照某种策略检查这个变量一旦发现是Safe Point就主动挂起，被动式就是发个信号，例如关机、Control+C，带来的问题就是不可控，发信号的时候不知道线程处于什么状态。这里HostSop虚拟机采用的是主动式使线程中断。</p><p>既然JVM使用的是主动性主动到达安全点，那么应该在什么地方设置全局变量呢？显然不能随意设置全局变量，进入安全点有个默认策略那就是：“避免程序长时间运行而不进入Safe Point”，程序要GC了必须要等线程进入安全点，如果线程长时间不进入安全点这样就比较糟糕了，因此安全点主要咋以下位置设置：</p><ol><li><p>循环的末尾</p></li><li><p>方法返回前</p></li><li><p>调用方法的call之后</p></li><li><p>抛出异常的位置</p></li></ol><p>安全区域</p><p>安全点完美的解决了如何进入GC问题，实际情况可能比这个更复杂，但是如果程序长时间不执行，比如线程调用的sleep方法，这时候程序无法响应JVM中断请求这时候线程无法到达安全点，显然JVM也不可能等待程序唤醒，这时候就需要安全区域了。</p><p>安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方GC都是安全的，安全区域可以看做是安全点的一个扩展。线程执行到安全区域的代码时，首先标识自己进入了安全区域，这样GC时就不用管进入安全区域的线层了，线层要离开安全区域时就检查JVM是否完成了GC Roots枚举，如果完成就继续执行，如果没有完成就等待直到收到可以安全离开的信号。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok</title>
      <link href="/2020/11/07/Lombok-1/"/>
      <url>/2020/11/07/Lombok-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p><a href="https://mp.weixin.qq.com/s/stgNcFH-NLnrqX6ZhzX33A" target="_blank" rel="noopener">参考网址</a></p><p>在类上使用注解 <code>@Data</code>，会在编译时自动添加 Setter-Getter 方法。</p><p>有一个需要避免踩坑的地方：属性名前两个字母都需要小写，前两个字母如果是小写大写会出现问题！<br>解决：</p><ol><li>修改属性名字，让第二个字母小写，或者说是规定所有的属性的前两个字母必须小写</li><li>如果数据库已经设计好，并且前后端接口对接好了，不想修改，那就专门为这种特殊的属性使用idea生成get-set方法复制代码</li></ol><p>现象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class NMetaVerify&#123;</span><br><span class="line">    private NMetaType nMetaType;</span><br><span class="line">    private Long id;</span><br><span class="line">    ....其他属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用Mybatis插入数据的时候，发现，其他属性都能正常的插入，但是就是nMetaType属性在数据库一直是null．</p><p>原因：</p><p>Lombok对于第一个字母小写，第二个字母大写的属性生成的get-set方法和Mybatis以及idea或者说是Java官方认可的get-set方法生成的不一样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class NMetaVerify &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private NMetaType nMetaType;</span><br><span class="line">    private Date createTime;</span><br><span class="line">    </span><br><span class="line">    public void lombokFound()&#123;</span><br><span class="line">        NMetaVerify nMetaVerify = new NMetaVerify();</span><br><span class="line">        nMetaVerify.setNMetaType(NMetaType.TWO); //注意：nMetaType的set方法为setNMetaType，第一个n字母大写了，</span><br><span class="line">        nMetaVerify.getNMetaType();                                  //getxxxx方法也是大写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>idea，Mybatis，Java官方默认的行为为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class NMetaVerify &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private NMetaType nMetaType;</span><br><span class="line">    private Date createTime;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NMetaType getnMetaType() &#123;//注意：nMetaType属性的第一个字母小写</span><br><span class="line">        return nMetaType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setnMetaType(NMetaType nMetaType) &#123;//注意：nMetaType属性的第一个字母小写</span><br><span class="line">        this.nMetaType = nMetaType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getCreateTime() &#123;</span><br><span class="line">        return createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCreateTime(Date createTime) &#123;</span><br><span class="line">        this.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis(3.4.6版本)解析get-set方法获取属性名字的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.ibatis.reflection.property;</span><br><span class="line"></span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.reflection.ReflectionException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Clinton Begin</span><br><span class="line"> */</span><br><span class="line">public final class PropertyNamer &#123;</span><br><span class="line"></span><br><span class="line">     private PropertyNamer() &#123;</span><br><span class="line">         // Prevent Instantiation of Static Class</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    public static String methodToProperty(String name) &#123;</span><br><span class="line">      if (name.startsWith(&quot;is&quot;)) &#123;//is开头的一般是bool类型，直接从第二个(索引)开始截取(简单粗暴)</span><br><span class="line">          name = name.substring(2);</span><br><span class="line">      &#125; else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) &#123;//set-get的就从第三个(索引)开始截取</span><br><span class="line">          name = name.substring(3);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          throw new ReflectionException(&quot;Error parsing property name &apos;&quot; + name + &quot;&apos;.  Didn&apos;t start with &apos;is&apos;, &apos;get&apos; or &apos;set&apos;.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">           //下面这个判断很重要，可以分成两句话开始解释，解释如下</span><br><span class="line">            //第一句话：name.length()==1</span><br><span class="line">            //       对于属性只有一个字母的，例如private int x;</span><br><span class="line">            //          对应的get-set方法是getX();setX(int x);</span><br><span class="line">            //第二句话：name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))</span><br><span class="line">            //      属性名字长度大于1，并且第二个(代码中的charAt(1)，这个1是数组下标)字母是小写的</span><br><span class="line">            //      如果第二个char是大写的，那就直接返回name</span><br><span class="line">      if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) &#123;</span><br><span class="line">          name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);//让属性名第一个字母小写，然后加上后面的内容</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isProperty(String name) &#123;</span><br><span class="line">       return name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;) || name.startsWith(&quot;is&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isGetter(String name) &#123;</span><br><span class="line">       return name.startsWith(&quot;get&quot;) || name.startsWith(&quot;is&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isSetter(String name) &#123;</span><br><span class="line">       return name.startsWith(&quot;set&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis解析get-set方法为属性名字测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void foundPropertyNamer() &#123;</span><br><span class="line">    String isName = &quot;isName&quot;;</span><br><span class="line">    String getName = &quot;getName&quot;;</span><br><span class="line">    String getnMetaType = &quot;getnMetaType&quot;;</span><br><span class="line">    String getNMetaType = &quot;getNMetaType&quot;;</span><br><span class="line"></span><br><span class="line">    Stream.of(isName,getName,getnMetaType,getNMetaType)</span><br><span class="line">            .forEach(methodName-&gt;System.out.println(&quot;方法名字是:&quot;+methodName+&quot; 属性名字:&quot;+ PropertyNamer.methodToProperty(methodName)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法名字是:isName 属性名字:name </span><br><span class="line">方法名字是:getName 属性名字:name </span><br><span class="line">方法名字是:getnMetaType 属性名字:nMetaType //这个以及下面的属性第二个字母都是大写，所以直接返回name</span><br><span class="line">方法名字是:getNMetaType 属性名字:NMetaType</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phoenix 异步创建索引</title>
      <link href="/2020/11/07/Phoenix-4/"/>
      <url>/2020/11/07/Phoenix-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Phoenix-异步创建索引"><a href="#Phoenix-异步创建索引" class="headerlink" title="Phoenix 异步创建索引"></a>Phoenix 异步创建索引</h2><p>当表数据量过大的时候，创建索引会报错，可以修改服务器端的 <code>hbase.rpc.timeout</code>，默认是1分钟，可以自定义时间。也可以异步创建索引，通过在语句后面添加<code>async</code> 关键字。</p><p>需要注意的是：</p><ol><li>异步创建索引只支持全局索引</li><li>执行async语句只是第一步，还需要通过执行jar包来保证索引真正的建立</li></ol><h3 id="1-为什么只支持全局索引？"><a href="#1-为什么只支持全局索引？" class="headerlink" title="1. 为什么只支持全局索引？"></a>1. 为什么只支持全局索引？</h3><p>首先是本地索引和全局索引的一些概念和区别</p><ul><li><p>本地索引</p><ul><li>适合写多读少的情况</li><li>索引数据直接写在原表里，<strong>不会新建一张表</strong>。在 <code>phoenix-sqlline</code> 里执行 <code>!tables</code> 的确会发现创建的本地索引表，但是那个只是一个映射，并不是单独存在的。由于索引数据直接写在表里，所以原表的数据量=原始数据+索引数据。</li><li>本地索引rowkey的设计规则: 原数据region的start key+”\x00”+二级索引字段1+”\x00”+二级索引字段2(复合索引)…+”\x00”+原rowkey。</li><li>索引数据和真实数据存放在同一台机器上，减少了网络传输的开销。同理，创建索引后的rowkey的最开始的部分是 <em>原数据region的start key</em>，这样在通过二级索引定位到数据后，可以在当前的region中直接找到数据，减少网络开销。减少网络开销，也意味着写入的速度会变快。但是多了一步通过rowkey查找数据的过程，所以读的过程就不如直接读取列族里的数据的速度快。</li></ul></li><li><p>全局索引</p><ul><li><p>适合读多写少的情况</p></li><li><p>索引数据会单独存在一张表里。</p></li><li><p>全局索引必须是查询语句中所有列都包含在全局索引中，它才会生效。</p><blockquote><p>Select * 不会命中索引<br>select 具体的字段 from table where col …<br>col 必须是第一个主键或者是索引里包含的字段才会命中索引<br>如果索引表包含 a、b 三个字段，where 里有 a 和 c 两个字段，那么也不会走索引，因为c不在索引里，发现索引走不通，只能走全表</p></blockquote></li><li><p>为了命中索引，要把需要查询的字段通过 include 关键字来一起写入索引表里，也就是覆盖索引。</p><blockquote><p>Phoenix 不能保证主表和索引表对应Region的本地化，所以也就无法根据索引表的结果再去查主表</p></blockquote></li><li><p>写入数据的同时需要往索引表同步写数据，而索引表是分布在不同的数据节点上的，跨节点的数据传输带来了较大的性能消耗，所以写慢；但是查询的时候，如果命中了索引表，那就直接把数据带出来了，读会快。</p></li></ul></li></ul><p>综上，本地索引不是表，全局索引才是表，而async是针对表的一种方式，所以只能作用于全局索引</p><h3 id="2-如何执行async"><a href="#2-如何执行async" class="headerlink" title="2. 如何执行async"></a>2. 如何执行async</h3><ol><li>首先是需要创建一个全局索引，同时使用 async</li></ol><p><code>create index XXX on database.tablename(col1, col2) include(col3, col4) async</code></p><p>此时去看这个表，会发现 <code>index_state</code> 字段的值是 building，说明索引表还没创建好，这是因为 async 关键字会初始化一个mr作业，只是把创建索引的数据文件准备好，还没有正式开始</p><ol start="2"><li>执行mr作业</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase org.apache.phoenix.mapreduce.index.IndexTool \</span><br><span class="line">--schema 库名 --data-table 表名 --index-table 索引表名 \</span><br><span class="line">--output-path hdfs路径指向一个文件件即可</span><br></pre></td></tr></table></figure><blockquote><p>库名、表名、索引表名尽量都不要小写</p></blockquote><p>这个命令执行后可能会报错，遇到 org.apache.phoenix.mapreduce.index.IndexTool 依赖的jar没法加载，那就可以换一个方式执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ./本地文件夹路径:/data1/cloudera/parcels/PHOENIX/lib/phoenix/phoenix-5.0.0-cdh6.2.0-client.jar  org.apache.phoenix.mapreduce.index.IndexTool   --schema 库名 --data-table 表名 --index-table 索引表名     --output-path hdfs路径指向一个文件件即可</span><br></pre></td></tr></table></figure><blockquote><p>本地文件夹里需要包含 hbase yarn hdfs 的配置文件 </p></blockquote><p>如果遇到 <code>java.io.IOException: Can&#39;t get Master Kerberos principal for use as renewer</code> 说明缺少yarn的配置文件</p><p>如果遇到 <code>org.apache.hadoop.security.AccessControlException: Permission denied: user=phoenix, access=WRITE, inode=&quot;/user&quot;:hdfs:supergroup:drwxr-xr-x</code> 需要在 <code>hbase-site.xml</code> 文件里添加 <code>hbase.fs.tmp.dir</code> 配置项，值是hdfs上一个有读写权限的目录路径。<br>原因：从 org.apache.phoenix.mapreduce.index.IndexTool 开始追代码，会找到 org.apache.hadoop.hbase.mapreduce.HFileOutputFormat2，在配置mr作业的时候，<code>configurePartitioner()</code> 方法里 <code>String hbaseTmpFsDir = conf.get(&quot;hbase.fs.tmp.dir&quot;, HConstants.DEFAULT_TEMPORARY_HDFS_DIRECTORY);</code> 会去读取配置文件里的这个值，默认是 <code>&quot;/user/&quot; + System.getProperty(&quot;user.name&quot;) + &quot;/hbase-staging&quot;</code></p><h3 id="3-附"><a href="#3-附" class="headerlink" title="3. 附"></a>3. 附</h3><ol><li>查询执行计划，判断是否命中索引表</li></ol><table><thead><tr><th align="center">内容</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">CLIENT</td><td align="center">表明操作在客户端执行还是服务端执行，客户端尽量返回少的数据。若为 SERVER 表示在服务端执行。</td></tr><tr><td align="center">FILTER BY expression</td><td align="center">返回和过滤条件匹配的结果。</td></tr><tr><td align="center">FULL SCAN OVER tableName</td><td align="center">表明全表扫描某张业务表。</td></tr><tr><td align="center">RANGE SCAN OVER tableName [ … ]</td><td align="center">表明代表范围扫描某张表，括号内代表 rowkey 的开始和结束。</td></tr><tr><td align="center">ROUND ROBIN</td><td align="center">无 ORDER BY 操作时, ROUND ROBIN 代表最大化客户端的并行化。</td></tr><tr><td align="center">x-CHUNK</td><td align="center">执行此操作的线程数。</td></tr><tr><td align="center">PARALLEL x-WAY</td><td align="center">表明合并多少并行的扫描。</td></tr><tr><td align="center">EST_BYTES_READ</td><td align="center">执行查询时预计扫描的总字节数。</td></tr><tr><td align="center">EST_ROWS_READ</td><td align="center">执行查询时预计扫描多少行。</td></tr><tr><td align="center">EST_INFO_TS</td><td align="center">收集查询信息的 epoch time</td></tr></tbody></table><ol start="2"><li>在创建索引的过程中，发现了一个可能是版本bug的地方，已提官网issue，链接如下</li></ol><p><a href="https://issues.apache.org/jira/projects/PHOENIX/issues/PHOENIX-6215?filter=updatedrecently" target="_blank" rel="noopener">官网issue地址</a></p><p>问题：如果在创建本地索引时，有一个字段设置了default value，在生成的索引表里就只会显示默认值，不管是什么类型；如果这个类型是tinyint的话，还可能会造成之后主键的数据，原表的数据是对的，但是索引表是错的，如果命中了索引表，那么就返回的是错误的数据。</p><p>可能的解：<code>RowKeyColumnExpression</code> 和 <code>RowKeyValueAccessor</code> 两个类。</p><blockquote><p>对表字段的修改，只能修改 char、varchar、decimal 等类型的长度，不可以直接修改类型，比如修改integer到bigint，会导致修改之后出现乱码，应该也是因为phoenix在对column index下标进行切分的时候，每个类型有自己的长度，随便修改类型，会导致数据转换错误</p></blockquote><ol start="3"><li>union all 在使用时遇到问题</li></ol><p>类似问题在 <a href="https://stackoverflow.com/questions/40100813/apache-phoenix-join-fails-encountered-exception-in-sub-plan-0-execution" target="_blank" rel="noopener">Encountered exception in sub plan [0] execution</a></p><p>描述：<code>select user_id from (select user_id from table union all select user_id from table) where user_id in (select user_id from table)</code> 这个sql执行后报 NullPointerException；换成 <code>select t1.user_id from (select user_id from table union all select user_id from table)t1 inner join (select user_id from table)t2 on t1.user_id = t2.user_id</code> 也会报错，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Error: Encountered exception in sub plan [0] execution. (state=,code=0)</span><br><span class="line">java.sql.SQLException: Encountered exception in sub plan [0] execution.</span><br><span class="line">        at org.apache.phoenix.execute.HashJoinPlan.iterator(HashJoinPlan.java:209)</span><br><span class="line">        at org.apache.phoenix.execute.DelegateQueryPlan.iterator(DelegateQueryPlan.java:139)</span><br><span class="line">        at org.apache.phoenix.jdbc.PhoenixStatement$1.call(PhoenixStatement.java:291)</span><br><span class="line">        at org.apache.phoenix.jdbc.PhoenixStatement.execute(PhoenixStatement.java:1830)</span><br><span class="line">        ...</span><br><span class="line">Caused by: org.apache.phoenix.schema.TableNotFoundException: ERROR 1012 (42M03): Table undefined. tableName=unionSchemaName.unionTableName</span><br><span class="line">        at org.apache.phoenix.query.ConnectionQueryServicesImpl.getAllTableRegions(ConnectionQueryServicesImpl.java:604)</span><br><span class="line">        ....</span><br></pre></td></tr></table></figure><p>参考链接写的那个方式，改成 <code>select /*+ USE_SORT_MERGE_JOIN */ t1.user_id from (select user_id from table union all select user_id from table)t1 inner join (select user_id from table)t2 on t1.user_id = t2.user_id</code> 就可以了，从官方文档上看，是将广播哈希连接替换成了排序合并连接。但是官网给的前提是<strong>当连接的两端都大于服务器端内存的容量时</strong>使用这一个hint，具体底层实现还不清楚。</p><p>附：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHOENIX_OPTS=&quot;-Dsun.security.krb5.principal=phoenix&quot;</span><br><span class="line">/usr/java/jdk1.8.0_121/bin/java $PHOENIX_OPTS  -cp &quot;/etc/hbase/conf:/etc/hbase/conf:/data/cloudera/parcels/PHOENIX-5.0.0-cdh6.2.0.p0.1308267/lib/phoenix/bin/../phoenix-5.0.0-cdh6.2.0-client.jar:::/etc/hadoop/conf:/etc/hadoop/conf:/data/cloudera/parcels/CDH-6.2.0-1.cdh6.2.0.p0.967373/lib/hadoop/libexec/../../hadoop/lib/*:/data/cloudera/parcels/CDH-6.2.0-1.cdh6.2.0.p0.967373/lib/hadoop/libexec/../../hadoop/.//*:/data/cloudera/parcels/CDH-6.2.0-1.cdh6.2.0.p0.967373/lib/hadoop/libexec/../../hadoop-hdfs/./:/data/cloudera/parcels/CDH-6.2.0-1.cdh6.2.0.p0.967373/lib/hadoop/libexec/../../hadoop-hdfs/lib/*:/data/cloudera/parcels/CDH-6.2.0-1.cdh6.2.0.p0.967373/lib/hadoop/libexec/../../hadoop-hdfs/.//*:/data/cloudera/parcels/CDH/lib/hadoop-mapreduce/.//*:/data/cloudera/parcels/CDH-6.2.0-1.cdh6.2.0.p0.967373/lib/hadoop/libexec/../../hadoop-yarn/lib/*:/data/cloudera/parcels/CDH-6.2.0-1.cdh6.2.0.p0.967373/lib/hadoop/libexec/../../hadoop-yarn/.//*&quot; -Dlog4j.configuration=file:/data/penglin/log4j.properties sqlline.SqlLine -d org.apache.phoenix.jdbc.PhoenixDriver -u jdbc:phoenix:host241.slave.dev.cluster.enn.cn:2181:/hbase -n none -p none --color=true --fastConnect=false --verbose=true --incremental=false --isolation=TRANSACTION_READ_COMMITTED</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Phoenix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Phoenix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整型溢出</title>
      <link href="/2020/11/04/Int/"/>
      <url>/2020/11/04/Int/</url>
      
        <content type="html"><![CDATA[<h2 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h2><p><a href="https://mp.weixin.qq.com/s/62-CRwuwX7t-LAkzNLIWMw" target="_blank" rel="noopener">参考网址</a></p><p>数学上一个数的平方当然大于等于 0，但对于大多数编程语言，当 46341 &lt;= int x &lt;= 65535 时，x 的平方结果会是负数。</p><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><ul><li>bit 位： 0和1</li><li>byte 字节：1个字节有8个比特位</li></ul><h3 id="2-补码"><a href="#2-补码" class="headerlink" title="2. 补码"></a>2. 补码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0b0000 = 0</span><br><span class="line">0b1111 = 15</span><br></pre></td></tr></table></figure><p>如果要表示负数，那么就采用补码方式，把二进制的最高位作为符号位，即最高位系数需要加一个符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0b1000 = -1 * 8 = -8</span><br><span class="line">0b1011 = -1 * 8 + 2 + 1 = -5</span><br><span class="line">0b1111 = -1 * 8 + 4 + 2 + 1 = -1</span><br></pre></td></tr></table></figure><p>所以int可以表示 [-2^32, 2^32-1] 的整数，同时 -Integer.MIN_VALUE 还是等于 Integer.MIN_VALUE，即最小负数的绝对值还是自己，所以负数的相反数不一定是正数。同时最大整数+1会导致符号位进位变为1，结果是一个负数。</p><h3 id="3-乘法"><a href="#3-乘法" class="headerlink" title="3. 乘法"></a>3. 乘法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    0b0011 × 0b0011</span><br><span class="line">= 0b0011 × (0b0100 - 1) </span><br><span class="line">= 0b1100 - 0b0011 </span><br><span class="line">= 0b1001</span><br></pre></td></tr></table></figure><p>3 * 3 = 3 * ( 4 - 1) 左移2位，补零，再减1，看着没问题，但是当牵涉到补码的时候，就会发现结果变成了 -7</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Int </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Int </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2020/11/04/BinarySearch/"/>
      <url>/2020/11/04/BinarySearch/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484507&idx=1&sn=36b8808fb8fac0e1906493347d3c96e6&chksm=9bd7fa53aca0734531ec9f37127c0f371344e1690918888dfb1cfdf043c40c0b43d1121e5851&scene=21#wechat_redirect" target="_blank" rel="noopener">参考网址1</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485044&idx=1&sn=e6b95782141c17abe206bfe2323a4226&chksm=9bd7f87caca0716aa5add0ddddce0bfe06f1f878aafb35113644ebf0cf0bfe51659da1c1b733&scene=21#wechat_redirect" target="_blank" rel="noopener">参考网址2</a></p><p>适合场景：</p><ul><li>寻找一个数</li><li>寻找左侧边界</li><li>寻找右侧边界</li></ul><p>最大的一个前提是：需要在单调区间内</p><h3 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target)&#123;</span><br><span class="line">    int left = 0, right = ...;</span><br><span class="line">    while(...)&#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if(nums[mid] == target)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;else if(nums[mid] &gt; target)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;else if(nums[mid] &lt; target)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-寻找一个数"><a href="#2-寻找一个数" class="headerlink" title="2. 寻找一个数"></a>2. 寻找一个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0; </span><br><span class="line">    int right = nums.length - 1; // 注意</span><br><span class="line"></span><br><span class="line">    while(left &lt;= right) &#123; // 注意</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid - 1; // 注意</span><br><span class="line">        &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0; </span><br><span class="line">    int right = nums.length; // 注意</span><br><span class="line"></span><br><span class="line">    while(left &lt; right) &#123; // 注意</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid; // 注意</span><br><span class="line">        &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>while(left &lt;= right) 这里是 &lt;= 是因为要把区间里所有的数据都判断一遍，如果是 while(left &lt; right) 那么 left = right 的这个下标对应的数据就没有进行判断，可以修改return来达到最终目标 <code>while(left &lt; right){...} return nums[left] == target ? left : -1;</code></p></blockquote><ol start="3"><li>此算法有什么缺陷？<br>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。<br>比如说给你有序数组 nums = [1,2,2,2,3]，target = 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。<br>这样的需求很常见。你也许会说，找到一个 target 索引，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</li></ol><h3 id="3-寻找左侧边界"><a href="#3-寻找左侧边界" class="headerlink" title="3. 寻找左侧边界"></a>3. 寻找左侧边界</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length == 0) return -1;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = nums.length; // 注意</span><br><span class="line"></span><br><span class="line">    while (left &lt; right) &#123; // 注意</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; // 注意</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br><span class="line">②</span><br><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length == 0) return -1;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = nums.length - 1; // 注意</span><br><span class="line"></span><br><span class="line">    while (left &lt;= right) &#123; // 注意</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - 1; // 注意</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后要检查 left 越界的情况</span><br><span class="line">    if (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        return -1;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int right = nums.length</code> 表示 [left, right) 范围内的数据都要考虑，而 right 对应的数据不做考虑，所以当 <code>nums[mid] &gt; target</code> 时， <code>right = mid</code> 即可。而当 <code>nums[mid] == target</code> 时，因为目标是拿到做边界，所以需要让 <code>right = mid</code> 来压缩区间范围，向左靠拢</p><p>更推荐第一种，从左侧边界这个点考虑，需要求出来的是一个index，小于这个index的所有数据都是小于target的，而不去关心右侧边界具体是什么，那么搜索区间保证是 [left, right) 即可</p><h3 id="4-寻找右侧边界"><a href="#4-寻找右侧边界" class="headerlink" title="4. 寻找右侧边界"></a>4. 寻找右侧边界</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length == 0) return -1;</span><br><span class="line">    int left = 0, right = nums.length;</span><br><span class="line"></span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left - 1; // 注意</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">②</span><br><span class="line">int right_bound(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0, right = nums.length - 1;</span><br><span class="line">    while (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125; else if (nums[mid] == target) &#123;</span><br><span class="line">            // 别返回，锁定右侧边界</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后要检查 right 越界的情况</span><br><span class="line">    if (right &lt; 0 || nums[right] != target)</span><br><span class="line">        return -1;</span><br><span class="line">    return right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nums[mid] == target</code> 时压缩右侧区间，所以让 <code>left = mid + 1</code>。最后返回 <code>left - 1</code> 和 <code>right - 1</code>是一样的，因为 while 退出的时候，left 和 right 相等，-1 可以这样想，如果 <code>nums[mid] == target</code> 时，<code>left = mid + 1</code> 也就是 <code>mid = left - 1</code>，最后返回的时候，left 对应的值不是等于 target 的下标，而 -1 后的 mid 有可能符合结果。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>在寻找左侧或右侧边界的时候，设想 <code>nums=[1, 2, 2, 2, 3]</code>，需要target=2的左侧和右侧，保证 [left, right) 左闭右开的搜索区间</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> BinarySearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BinarySearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阶乘相关</title>
      <link href="/2020/11/03/Factorial/"/>
      <url>/2020/11/03/Factorial/</url>
      
        <content type="html"><![CDATA[<h2 id="阶乘相关"><a href="#阶乘相关" class="headerlink" title="阶乘相关"></a>阶乘相关</h2><h3 id="1-问题分类"><a href="#1-问题分类" class="headerlink" title="1. 问题分类"></a>1. 问题分类</h3><ol><li>输入一个非负整数 n，请你计算阶乘 n! 的结果末尾有几个 0</li><li>输入一个非负整数 K，请你计算有多少个 n，满足 n! 的结果末尾恰好有 K 个 0。</li></ol><h4 id="1-1-求-n-的结果末尾有几个-0"><a href="#1-1-求-n-的结果末尾有几个-0" class="headerlink" title="1.1 求 n! 的结果末尾有几个 0"></a>1.1 求 n! 的结果末尾有几个 0</h4><p>n! = 1 * 2 * 3 * … * n</p><p>产生1个0，一定是 2 * 5 产生的，所以求0的个数就可以转换成 n! 能拆成多少个因子 2 和 5 =&gt; 每一个偶数都可以拆出来最少一个因子 2，所以目标改成求能拆出来多少个因子 5</p><p>假设 n = 25，那么 25! 里面包含了多少个因子5结果末尾就有多少个0<br>25 / 5 = 5 =&gt; 这个结果表示，25里有<strong>5</strong>个是5的倍数的因子，即5、10、15、20、25这样5个，这些因子最少可以提供一个因子5<br>同时，对于 25 本身来说可以拆成 5<em>5，还可以提供*</em>1**个因子5<br>∴ 25! 的结果末尾有 5 + 1 = 6个0</p><p>假设 n = 125，那么 125! 里面包含了多少个因子5结果末尾就有多少个0<br>125 / 5 = 25 =&gt; 这个结果表示，125里有<strong>25</strong>个是5的倍数的因子，即5、10、15、20、25…125这样25个，这些因子最少可以提供一个因子5<br>125 / (5<em>5) = 5 =&gt; 这个结果表示，125 里还有<strong>5</strong>个是25的倍数的因子，这些因子还可以再提供1个因子5<br>125本身来说可以拆成 `5</em>5<em>5`，还可以提供*</em>1**个因子5<br>∴ 125! 的结果末尾有 25 + 5 + 1 = 31个0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int trailingZeroes(int n) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    long divisor = 5;</span><br><span class="line">    while (divisor &lt;= n) &#123;</span><br><span class="line">        res += n / divisor;</span><br><span class="line">        divisor *= 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里divisor变量使用 long 型，因为假如n比较大，考虑 while 循环的结束条件，divisor可能出现整型溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int trailingZeroes(int n) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int d = n; d / 5 &gt; 0; d = d / 5) &#123;</span><br><span class="line">        res += d / 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-求满足-n-结果末尾有k个0的个数"><a href="#1-2-求满足-n-结果末尾有k个0的个数" class="headerlink" title="1.2 求满足 n! 结果末尾有k个0的个数"></a>1.2 求满足 n! 结果末尾有k个0的个数</h4><p>首先可以暴力穷举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int res = 0;</span><br><span class="line">for (int n = 0; n &lt; +inf; n++) &#123;</span><br><span class="line">    if (trailingZeroes(n) &lt; K) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if (trailingZeroes(n) &gt; K) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (trailingZeroes(n) == K) &#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br></pre></td></tr></table></figure><p><strong>对于这种具有单调性的函数，用 for 循环遍历，可以用二分查找进行降维打击</strong></p><p>搜索有多少个n满足trailingZeroes(n) == K，其实就是在问，<strong>满足条件的n最小是多少，最大是多少，最大值和最小值一减，就可以算出来有多少个n满足条件了</strong>，也就是二分查找的<em>左边界</em>和<em>右边界</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">long leftBound(int K) &#123;</span><br><span class="line">    long lo = 0, hi = 10;</span><br><span class="line">    while (lo &lt; hi) &#123;</span><br><span class="line">        long mid = lo + (hi - lo) / 2;</span><br><span class="line">        if (trailingZeroes(mid) &lt; K) &#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125; else if (trailingZeroes(mid) &gt; K) &#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long rightBound(int K) &#123;</span><br><span class="line">    long lo = 0, hi = 10;</span><br><span class="line">    while (lo &lt; hi) &#123;</span><br><span class="line">        long mid = lo + (hi - lo) / 2;</span><br><span class="line">        if (trailingZeroes(mid) &lt; K) &#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125; else if (trailingZeroes(mid) &gt; K) &#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前针对这道题来说，单纯解题而言，有一个思路是：这个题只能是0或者5。要不然找不到，找到的话就肯定是5个，因为假设找到的数是25，那么26 27 28 29一定也符合。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Factorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Factorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 查询结果自动封装为map，出现null而没有字段名</title>
      <link href="/2020/11/03/Mybatis-1/"/>
      <url>/2020/11/03/Mybatis-1/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis-查询结果自动封装为map，出现null而没有字段名"><a href="#MyBatis-查询结果自动封装为map，出现null而没有字段名" class="headerlink" title="MyBatis 查询结果自动封装为map，出现null而没有字段名"></a>MyBatis 查询结果自动封装为map，出现null而没有字段名</h2><ol><li>问题</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select a, b, c from table</span><br><span class="line">&gt;&gt; </span><br><span class="line">a   b   c</span><br><span class="line"></span><br><span class="line">1      </span><br><span class="line">// 查询结果中，第一条数据这三个字段都是null，没有值，第二条数据只有a字段有值，在自动封装为hashmap返回时的结果如下：</span><br><span class="line">[</span><br><span class="line">    null,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;a&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>原因：</li></ol><p>org.apache.ibatis.executor.resultset.DefaultResultSetHandler 类下面找到 <code>getRowValue</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix) throws SQLException &#123;</span><br><span class="line">final ResultLoaderMap lazyLoader = new ResultLoaderMap();</span><br><span class="line">Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">if (rowValue != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">    final MetaObject metaObject = configuration.newMetaObject(rowValue);</span><br><span class="line">    boolean foundValues = this.useConstructorMappings;</span><br><span class="line">    if (shouldApplyAutomaticMappings(resultMap, false)) &#123;</span><br><span class="line">    foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span><br><span class="line">    &#125;</span><br><span class="line">    foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span><br><span class="line">    foundValues = lazyLoader.size() &gt; 0 || foundValues;</span><br><span class="line">    rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null;</span><br><span class="line">&#125;</span><br><span class="line">return rowValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对 rowValue 赋值的时候，会去判断语句查询是否有值 或者 configuration.isReturnInstanceForEmptyRow() 这个配置项是否为true，如果前面都是false的话，就置为null，也就是最后返回结果里null的原因</p><table><thead><tr><th align="center">参数</th><th align="center">含义</th><th align="center">有效值</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">callSettersOnNulls</td><td align="center">指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。</td><td align="center">true `</td><td align="center">` false</td></tr><tr><td align="center">returnInstanceForEmptyRow</td><td align="center">当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2）</td><td align="center">true `</td><td align="center">` false</td></tr></tbody></table><ol start="3"><li>解决：</li></ol><p>在 mybatis-config.xml 文件里添加两个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">&lt;!--        指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法--&gt;</span><br><span class="line">        &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;!--        当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）--&gt;</span><br><span class="line">        &lt;setting name=&quot;returnInstanceForEmptyRow&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>在 application.properties 里去指定 mybatis-config.xml 的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.config-location: mybatis-config.xml</span><br></pre></td></tr></table></figure><p>或者在注册sqlFactory的时候，去指定configLocation</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean.setConfigLocation(new DefaultResourceLoader().getResource(&quot;classpath:mybatis-config.xml&quot;));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 内存管理</title>
      <link href="/2020/10/29/JVM-1/"/>
      <url>/2020/10/29/JVM-1/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM-内存管理"><a href="#JVM-内存管理" class="headerlink" title="JVM 内存管理"></a>JVM 内存管理</h2><p><a href="https://www.cnblogs.com/alsf/p/9017447.html" target="_blank" rel="noopener">参考文档</a></p><h3 id="1-堆和栈"><a href="#1-堆和栈" class="headerlink" title="1. 堆和栈"></a>1. 堆和栈</h3><p>JVM内存划分：</p><ol><li>寄存器（程序计数器PC拿到指令地址，放入指令寄存器IR中，cpu执行指令）</li><li>本地方法区</li><li>方法区</li><li>栈内存（stack）<ul><li>由编译器自动分配，存放函数的参数值，局部变量的值（定义在方法中的都是局部变量，方法外的是全局变量，for循环内部也是局部变量）</li><li>先加载函数才能进行局部变量的定义，所以方法先进栈，再定义变量，变量离开作用域后释放，生命周期都很短</li></ul></li><li>堆内存（heap，不是数据结构中的堆）<ul><li>由程序猿分配释放，如果程序猿不释放，程序结束时由GC回收</li><li>存储的是数组和对象，凡是new的都在堆中，实体（对象）里面封装了多个数据，一个数据消失，实体不会消失，还可以用，所以堆不会随时释放，会由GC不定时回收</li></ul></li></ol><blockquote><p>int[] arr = new int[3];<br>主函数进栈 -&gt; 在栈中定义一个 arr 变量 -&gt; 在堆里通过new开辟一个空间，这个空间会产生一个地址，这个地址下的所有所有会进行初始化 -&gt; 把内存的地址赋值给 arr<br>int[] arr = null; arr不做任何指向，null的作用就是取消引用数据类型的指向</p></blockquote><h4 id="1-1-堆"><a href="#1-1-堆" class="headerlink" title="1.1 堆"></a>1.1 堆</h4><p>堆又分为</p><ul><li>新生代<ul><li>新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成</li><li>新建的对象都是由新生代分配内存</li><li>新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例</li></ul></li><li>老年代<ul><li>用于存放新生代中经过多次垃圾回收仍然存活的对象</li></ul></li></ul><p><img src="https://images.weserv.nl/?url=https://images2018.cnblogs.com/blog/779030/201805/779030-20180510001611099-127788676.png" alt="堆结构"></p><p><img src="https://images.weserv.nl/?url=https://images2018.cnblogs.com/blog/779030/201805/779030-20180510003027516-1618059091.png" alt="堆结构"></p><h4 id="1-2-栈"><a href="#1-2-栈" class="headerlink" title="1.2 栈"></a>1.2 栈</h4><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果</p><p>当一个方法执行结束的时候，方法会出栈，方法内部的变量也会跟着出栈，当局部变量出栈之后，堆中new出来的内存空间就会变的不可达，当GC回收的时候就会去回收那些不可达的区域</p><h3 id="2-GC"><a href="#2-GC" class="headerlink" title="2. GC"></a>2. GC</h3><ol><li>新生代GC<br> 新生代通常存活时间较短，因此基于<strong>复制算法</strong>来进行回收，所谓复制算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中<br> 新生代满了后，会把对象转移到旧生代，然后清空继续装载，当旧生代也满了后，就会报outofmemory的异常</li><li>老年代GC<br> 老年代对象存活的时间比较长，比较稳定。因此采用<strong>标记（Mark）算法</strong>来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase进阶</title>
      <link href="/2020/10/26/HBase-2/"/>
      <url>/2020/10/26/HBase-2/</url>
      
        <content type="html"><![CDATA[<h2 id="HBase进阶"><a href="#HBase进阶" class="headerlink" title="HBase进阶"></a>HBase进阶</h2><p><a href="http://hbasefly.com/2017/07/02/hbase-sequenceid/" target="_blank" rel="noopener">HBase中的HLog</a><br><a href="http://hbasefly.com/2019/10/18/hbase-memstore-evolution/" target="_blank" rel="noopener">HBase中的MemStore</a></p><h3 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h3><p><img src="https://images.weserv.nl/?url=https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180402125111282-1966599087.png" alt="架构图"></p><p><img src="https://images.weserv.nl/?url=https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180402130346713-706113248.png" alt="物理存储"></p><p>master负责管理多个region server，一个region server里有多个region。<br>一个表会划分多个region，起初只有一个，数据增多，region增大到一定程度会拆分成2个region<br>一个表最终被保存在多个region server里</p><p>hmaster挂了不影响读写，但是 create table 这种涉及元数据的操作，如果hmaster挂了就会报错（因为客户端可以直接跟zookeeper进行会话，拿到region sever地址，就可以直接读写访问对应的region）</p><p>一个region里有多个store，一个store代表一个列族。（region按照行键来划分，所以相当于每一行有几个列族就有几个store）<br>store包括两部分：内存中的memstore和磁盘的storefile。写数据会先写到memstore，当数据达到阈值（默认64M）后 region server 会启动 flushcache 进行将数据写到 storefile里，每次形成一个storefile<br>当storefile文件的数量增长到一定阈值后，系统会进行合并（minor、major），在合并过程中会进行版本合并和删除工作（major），形成更大的storefile<br>当一个region所有storefile的大小和数量超过一定阈值后，会把当前的region分割为两个，并由hmaster分配到相应的regionserver，实现负载均衡<br>客户端检索数据，先在memstore找，找不到再去blockcache查找，找不到再找storefile，即：client-&gt;memstore-&gt;blockcache-&gt;storefile。如果读到了会把数据放到blockcache里缓存，方便下次读取</p><p>Region是HBase中存储和负载均衡的最小单元,不同的Region可以分布在不同的 Region Server上<br>Region由一个或者多个Store组成，每个store保存一个columns family<br>每个Strore又由一个memStore和0至多个StoreFile组成<br>memstore为写入缓存，blockcache为读取缓存</p><h3 id="2-写数据"><a href="#2-写数据" class="headerlink" title="2. 写数据"></a>2. 写数据</h3><ol><li>Client 向 zk 发送请求，请求 meta 表所有的 regionServer</li><li>zk 返回 regionServer 地址</li><li>Client 获取到 meta 表，请求对应的 region 所在的 regionServer</li><li>返回 meta 表数据</li><li>Client 向 regionServer 发送写数据请求</li><li>写入 wal(write ahead log)</li><li>将数据写入 memstore</li><li>regionServer 反馈给 Client 写入成功</li></ol><blockquote><p>在 0.9 版本（低版本）时，还存在一个 -ROOT- 表，作用是为了避免meta表过大而拆分为多个子表，可以通过 -ROOT- 表来对meta表进行管理</p></blockquote><p>第6步和第7步 具体流程如下：</p><ul><li><p>hbase-server-2.3 版本 搜索 <strong>HRegion</strong> 类，再搜索 <strong>STEP 1</strong>，<code>doMiniBatchMutate(BatchOperation&lt;?&gt; batchOp)</code> 方法即为写数据的部分</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// STEP 1. Try to acquire as many locks as we can and build mini-batch of operations with locked rows =&gt; 写入之前先获取锁</span><br><span class="line"></span><br><span class="line">// STEP 2. Update mini batch of all operations in progress with  LATEST_TIMESTAMP timestamp</span><br><span class="line">// We should record the timestamp only after we have acquired the rowLock,</span><br><span class="line">// otherwise, newer puts/deletes are not guaranteed to have a newer timestamp =&gt; client如果不传时间戳，会自动获取服务器端的时间戳</span><br><span class="line"></span><br><span class="line">// STEP 3. Build WAL edit</span><br><span class="line">// STEP 4. Append the WALEdits to WAL and sync.</span><br><span class="line"></span><br><span class="line">// STEP 5. Write back to memStore</span><br></pre></td></tr></table></figure></li><li><p>hbase-server-1.3 版本 <code>doMiniBatchMutate(BatchOperation&lt;?&gt; batchOp)</code> 方法不一样。也是先 <code>Build WAL edit</code>，写入日志，但是并没有先同步，而且先写入memstore，在 finally 那里去判断 wal log 是否同步成功，如果不成功，回滚 memstore 记录</p></li></ul><p>写数据时会先向hlog写（方便memstore里的数据丢失后根据hlog恢复，向hlog中写数据的时候也是优先写入内存，后台会有一个线程定期异步刷写数据到hdfs，如果hlog的数据也写入失败，那么数据就会发生丢失）<br>频繁的溢写会导致产生很多的小文件，因此会进行文件的合并，文件在合并的时候有两种方式，minor和major，minor表示小范围文件的合并，major表示将所有的storefile文件都合并成一个</p><h3 id="3-Flush-过程"><a href="#3-Flush-过程" class="headerlink" title="3. Flush 过程"></a>3. Flush 过程</h3><p>当写数据到一定程度之后，会把内存中的数据flush到磁盘，配置项在 hbase-default.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. habse.regionserver.global.memstore.size</span><br><span class="line">默认大小为内存大小的0.4。当regionserver的所有的memstore的大小超过这个值的时候，会阻塞客户端的读写</span><br><span class="line">2. habse.regionserver.global.memstore.size.lower.limit</span><br><span class="line">默认大小为第一个配置项的大小的0.95。即从这个值开始flush到内存，如果写数据过快，超过flush的速度，导致memstore逐渐变大，达到堆大小的0.4，那么就会暂停读写操作，专注于flush，直到memstore的大小下降</span><br><span class="line">3. hbase.regionserver.optionalcacheflushinterval</span><br><span class="line">默认为1个小时（当前内存最后一次编辑时间+1个小时），自动flush到磁盘</span><br><span class="line"></span><br><span class="line">4. hbase.hregion.memstore.flush.size</span><br><span class="line">单个region里memstore大小。默认为128M，超过这个大小就会刷写</span><br><span class="line"></span><br><span class="line">5. hbase.regionserver.max.logs</span><br><span class="line">如果wal的文件数量达到这个值（默认32），就会刷写</span><br><span class="line"></span><br><span class="line">6. hbase.regionserver.hlog.blocksize</span><br><span class="line">默认HDFS 2.x版本默认的blocksize大小</span><br></pre></td></tr></table></figure><h3 id="4-读数据"><a href="#4-读数据" class="headerlink" title="4. 读数据"></a>4. 读数据</h3><ol><li>Client 向 zk 发送请求，请求 meta 表所有的 regionServer</li><li>zk 返回 regionServer 地址</li><li>Client 获取到 meta 表，请求对应的 region 所在的 regionServer</li><li>返回 meta 表数据</li><li>Client 向 regionServer 发送读数据请求</li><li>同时会读 memstore 和 storefile，如果 storefile 里有数据，会加载到 blockcache 中，然后把数据做一个合并，取时间戳最大的那条数据返回给client，并且将数据写入到 blockcache</li><li>遵循的大体流程是 client-&gt;memstore-&gt;blockcache-&gt;storefile。如果读到了会把数据放到blockcache里缓存，方便下次读取</li></ol><blockquote><p>同时去读内存和磁盘，是为了避免磁盘的时间戳大于内存的时间戳，即put数据的时候设置了老时间戳</p></blockquote><h3 id="5-compact-合并"><a href="#5-compact-合并" class="headerlink" title="5. compact 合并"></a>5. compact 合并</h3><p>memstore不断flush到磁盘，生成hfile。<br>minor compactions 会把多个文件hfile合并为一个大的hfile<br>major compactions 会把所有hfile合并为一个hfile，默认是7天，但是生产上应该关闭，会非常消耗资源，应在空闲时间手动触发</p><blockquote><p>compact 会 rewrite hfile to a single storefile 重写的过程会下载hdfs文件，然后重新写入，所以很消耗资源</p></blockquote><p><code>hbase.hstore.compactionThreshold</code> 是一个store（列族）允许的hfile个数，超过这个个数就会合并</p><h3 id="6-region-split-切分"><a href="#6-region-split-切分" class="headerlink" title="6. region split 切分"></a>6. region split 切分</h3><p>region 交给不同服务器，缓解热点问题 =&gt; hfile 不断拆分，文件越来越大，到最后有可能还是会导致热点问题的存在，因为有的文件特别大，查的数据都在这个文件里 =&gt; 建表的时候实现 预分区</p><p>HBase 默认分区规则<br>memstore.flush.size=128MB<br>max.store.size=10G</p><p>分区规则：Min(R^2 * “hbase.hregion.memstore.flush.size”, “hbase.hregion.max.filesize”)</p><p>第一次拆分大小为：min(10G，11128M)=128M // 一开始的时候就一个region，当数据量达到128M时，会一分为二，变成2个region，然后会往第二个region里写数据，但是第一个不会写，处于半满状态 =&gt; 之前分裂的region都不会再被写入数据，处于半满状态<br>第二次拆分大小为：min(10G，33128M)=1152M<br>第三次拆分大小为：min(10G，55128M)=3200M<br>第四次拆分大小为：min(10G，77128M)=6272M<br>第五次拆分大小为：min(10G，99128M)=10G<br>第五次拆分大小为：min(10G，1111128M)=10G // 最大是10G</p><p>官方建议使用一个列族，避免的问题是：有的列族很多数据，有的列族可能只有几条数，按照region切分，然后flush到磁盘，可能会产生很多的小文件</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink（暂时）</title>
      <link href="/2020/10/20/Flink/"/>
      <url>/2020/10/20/Flink/</url>
      
        <content type="html"><![CDATA[<h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p>是一个框架和分布式处理引擎，用于对<strong>无界和有界数据流</strong>进行<strong>状态</strong>计算</p><p>lambda架构<br><img src="https://images.weserv.nl/?url=https://easyreadfs.nosdn.127.net/image_ce0fd6e4dc8c41d6b9b832e339d2b3ce" alt="Lambda架构"></p><p>storm<br>    - 低延迟 毫秒级<br>    - 消息保障能力弱，消息传输可能重复但不会丢失<br>    - 吞吐量低<br>spark streaming<br>    - 以固定时间间隔（几秒钟）处理一段段的批处理作业（微批）<br>    - 高延迟（秒级）<br>    - 能够保证消息传输不会丢失也不会重复<br>    - 高吞吐<br>flink<br>    - 支持原生流处理，即数据可以一条一条的进行处理<br>    - 低延迟 毫秒级<br>    - 能够保证消息传输不会丢失也不会重复<br>    - 高吞吐</p><p>为什么是flink？1. 低延迟(毫秒级) 2. 高吞吐(每秒千万级) 3. 数据准确性（exactly-once） 4. 易用性（SQL/Table API/DataStream API）</p><table><thead><tr><th align="center">\</th><th align="center">spark streaming</th><th align="center">flink</th></tr></thead><tbody><tr><td align="center">流处理</td><td align="center">数据需要打包成batch，这就会导致有延迟（秒级别），相当于一个伪实时</td><td align="center">将数据全部当成流处理</td></tr><tr><td align="center">数据模型</td><td align="center">RDD，DStream实际上也是一组组小批数据RDD的集合</td><td align="center">数据流，以及事件序列</td></tr><tr><td align="center">运行时架构</td><td align="center">批计算，将DAG划分为不同的stage，一个完成后才可以计算下一个</td><td align="center">标准的流执行模式，一个事件在一个节点处理完后才可以直接发往下一个节点进行处理</td></tr></tbody></table><p>流处理和批处理的区别？比如同样是max(温度)，spark streaming返回的是当前这一批有界数据的最大温度，而flink会返回从程序开始一直到此刻最大的温度 =&gt; 批是一种有界数据的概念，而流数据的话无界，最大最小值的话会考虑从头开始到现在的整个数据。同样，flink可以通过window api开窗，来做批处理</p><p>SQL/Table API(dynamic tables)<br>DataStream API(streams, windows)<br>ProcessFunction(events, state, time)</p><p>DataFlow 模型</p><ul><li>数据从上一个 Operation 节点直接 Push 到下一个 Operation 节点。</li><li>各节点可以分布在不同的 Task 线程中运行，数据在 Operation 之间传递。</li><li>同样具有 Shuffle 过程，但是数据不像 MapReduce 模型，Reduce 从 Map 端拉取数据，而是由上游把数据推给下游。</li><li>实现框架有 Apache Storm 和 Apache Flink。</li></ul><p>watermark &amp;&amp; window &amp;&amp; allowedLatest</p><ul><li>watermark：由eventTime - 允许数据乱序的时间M秒得到，只增不减，即只有当当前数据对应的watermark大于之前的，才会更新watermark</li><li>window：每N秒一段时间间隔</li><li>allowedLatest：设置窗口销毁延迟时间，及到时间了，但是还允许一定时间内的数据迟到</li></ul><p>keyby(int… fields) // 0 代表第一个元素<br>keyby(String… fields) // 声明为public的字段名或类的get方法，主要是方便了datastream嵌套复合类型比如tuple或者pojo类的时候<br>keyby(new KeySelector&lt;T,K&gt;()) // 覆写getKey方法，来自定义返回key分组</p><p>除了env可以设置并行度，每一个算子也都可以单独设置并行度，包括 <code>print().setParallelism()</code>。默认并行度是cpu核数。一般来说，一个流的并行度，可以认为是其所有算子的并行度里最大的那个并行度。</p><p>一个流所需要的slot数量不一定就是流中所有算子的并行度的加和。事实上，flink 允许先后操作的算子放入到同一个slot里面（子任务共享slot），这样可以减少数据的shuffle；在共享slot的情况下，可能会出现一个slot实现了source、transformation到sink的所有操作，即保留了整个流的pipeline过程，这个在 flink-yarn.xml 里有注释说是允许的。</p><p>flink运行时组件：</p><ul><li>jobmanager<ul><li>拿到客户端提交的jar包，这个jar包包括：作业图（jobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库等等；把jobgraph转换成一个物理层面的数据流图–执行图（executionGraph），包含了所有可以并发执行的任务；向rm申请slot资源，并分发到taskmanager上运行</li><li>还负责维护类似检查点（checkpoint）这样的操作</li></ul></li><li>taskmanager<ul><li>taskmanager数量 * 每个taskmanager下面对应的slot数量 = 整个集群最大的能够运行任务数量</li><li>在内存中划分出一部分，称为slot，用来运行task。宏观来理解的话，可以把taskmanager想成是一个jvm进程，每一个slot是运行在上面的线程，只是对内存进行隔离，每个slot有自己的内存资源</li></ul></li><li>resourcemanager<ul><li>主要是管理slot资源，每个taskmanager下面的slot都会在rm里进行注册</li></ul></li><li>dispatcher<ul><li>提供rest接口，提交app的时候会自动启动，把app交给jobmanager；</li><li>webUI界面。并不是必需的</li></ul></li></ul><p>flink执行图可以分为四层，或者四个过程</p><ul><li>streamgraph：用户通过stream api编写的代码生成的最初的图，包含source、transformation、sink的一个拓扑结构</li><li>jobgraph：客户端在提交作业到jobmanager之前，会自动根据streamgraph进行合并优化，将符合条件的多个任务合并在一起作为一个任务，减少数据传输</li><li>executiongraph：jobmanager根据jobgraph来生成executiongraph，将任务拆成可并行化的过程，交给taskmanager；<strong>调度层最核心的数据结构</strong></li><li>物理执行图：taskmanager上部署task后形成的图，并不是一个具体的数据结构</li></ul><p>数据传输形式</p><ul><li>one-to-one(forwarding)<ul><li>map、filter、flatmap等算子都是one-to-one的关系，即可以直接在同一个slot上执行计算</li><li>类似于spark的窄依赖</li></ul></li><li>redistributing<ul><li>stream的分区发生改变。每一个算子的子任务根据所选择的transformation然后发送数据到不同的分区</li><li>比如keyby是基于hashcode重分区，而broadcast和rebalance会随机重新分区</li><li>类似于spark的宽依赖，shuffle过程</li></ul></li></ul><p>什么样的任务可以被合并在一起？相同并行度的one-to-one操作，满足这两个条件，flink会把相邻的算子合并在一起，放在同一个slot里面进行计算，减少网络传输。通过在算子后面调用 <code>.filter(..).disableChaing()</code> 可以断开合并的任务链，<code>.filter(..).startNewChain()</code> 开始合并新的任务链。</p><p>针对某一个算子过程，可能会很复杂或者有特殊需求，需要单独放在一个slot里运行？在算子后面调用 <code>slotSharingGroup(&quot;key&quot;)</code>，表示从当前算子开始，之后的所有操作都会放在一个slot里面，通过 key 来区分多个slot共享组。默认slot共享组的key是”dafault”。</p><p>DataStream API</p><ul><li>source<ul><li>env.addSource()</li></ul></li><li>transformation<ul><li>map</li><li>flatmap</li><li>filter</li><li>keyby<ul><li>同一个key肯定在同一个分区，<strong>但是同一个分区不一定只有一个key</strong>，2个key的数据经过hash可能被分到同一个分区里</li></ul></li><li>滚动聚合算子（rollingAggregation）<ul><li>针对KeyedStream每一个支流做聚合</li><li>以min和minby为例，如果是min()只会返回指定字段的最小值，如果是minby则会返回指定字段的最小值对应的那一整个对象</li><li>聚合算子（sum、max、min、maxBy、minBy）底层实现是调用 keyedStream.aggregate() 方法，只是创建的ComparableAggregator的AggregationType不一样，分别是SUM, MAX, MIN, MAXBY, MINBY。ComparableAggregator类继承了AggregationFunction，而AggregationFunction则实现了ReduceFunction接口，所以ComparableAggregator类实现了reduce方法，首先是通过Comparator来比较两个对象，然后会判断byAggregate是否为真，即是否是minby或maxby操作，如果是的话，再判断isfirst是否为真，即当出现多个同样值的时候，是返回第一个还是返回最后一个</li></ul></li><li>reduce<ul><li>自定义 reduce() 方法需要继承 ReduceFunction 类</li></ul></li><li>split和select<ul><li>split 将 DataStream 会转换成 SplitStream，select 从一个splitStream里通过tag来获取一个或多个DataStream</li><li>被遗弃，使用 sideoutput 替代</li></ul></li><li>connect和map<ul><li>connect 将两个DataStream合并为一个ConnectedStreams。此时数据只是放在了一个流里，数据本身和形式并不发生任何的变化</li><li>map、flatmap、keyby等算子实现的function，会单独作用于每一个datastream</li></ul></li><li>union </li></ul></li><li>sink<ul><li>kafka<ul><li>初始化FlinkKafkaProducer的时候有三个构造函数，不加kafkaProducersPoolSize、加kafkaProducersPoolSize和一个带着自定义分区的函数。一般用前两个就行，如果说业务数据需要根据某种条件将数据写入到N多个topic中，可以用第三个，实现KeyedSerializationSchema类getTargetTopic()方法，<a href="https://bbs.huaweicloud.com/blogs/148532" target="_blank" rel="noopener">参考地址</a></li><li>FlinkKafkaConsumer 消费过程：<br>  父类FlinkKafkaConsumerBase<ol><li>initializeState()：从最后一个成功的checkpoint中获取各个partition的offset到restoredState中。</li><li>open()：从restoredState中获取这个subTask所消费的topic的partition的起始offset，保存到subscribedPartitionsToStartOffsets中；如果这是一个第一次向topic消费的job的subTask，那么Flink根据job的并行度以及这个subTask的index均匀的分配partition给这个subTask消费。此时，partition的起始offset就由我们在上文中介绍的配置来决定。</li><li>run(): 如果subscribedPartitionsToStartOffsets不为空，创建KafkaFetcher，执行其runFetchLoop()。</li></ol></li></ul></li><li>redis</li></ul></li></ul><p><a href="https://www.jianshu.com/p/45b03390b258" target="_blank" rel="noopener">窗口和水位线的参考网址1</a><br><a href="https://www.cnblogs.com/shengyang17/p/11798549.html" target="_blank" rel="noopener">窗口和水位线的参考网址2</a></p><p>Window类型</p><ul><li>时间窗口<ul><li>滚动时间窗口 Tumbling Window<ul><li>参数只有一个 window size，没有重叠；区间范围是左闭右开</li></ul></li><li>滑动时间窗口 Sliding Window<ul><li>参数有两个 window size 和 slide step，可以有重叠</li></ul></li><li>会话窗口<ul><li>设置一个timeout时间，如果一段时间没有接收到新的数据，就会生成一个新的窗口</li></ul></li></ul></li><li>计数窗口<ul><li>滚动计数窗口</li><li>滑动计数窗口</li></ul></li></ul><p>Window API</p><p>在<code>keyby()</code>之后调用<code>.window()</code>方法，或者<code>dataStream.windowAll()</code>。一般是前者。也可以直接调用 <code>.timeWindow()</code>，传一个参数就是滚动事件窗口，传两个参数就是滑动时间窗口。如果要用到offset，那就只能用window()。</p><p><code>.countWindow()</code> 底层调用的是 GlobalWindows 方法，全局窗口是把所有数据都放在一个窗口里，需要设置 trigger 触发器和 evictor 移除器，来保证窗口是什么时候触发什么情况下移除数据</p><p>org.apache.flink.streaming.api.windowing.assigners 包下面有各个窗口分配器的类，比如 TumblingEventTimeWindows、TumblingProcessingTimeWindows 等，在 window() 方法中，需要指定窗口分配器，比如 <code>window(TumblingProcessingTimeWindows.of(windowSize, offset))</code>，windowSize 就是窗口大小，offset是指和整点的偏移量，比如8点05到9点05，那就是偏移5分钟，Time.minutes(5)。offset的主要作用是时区</p><p>窗口的意义：把无限的数据流进行切分，得到有限的数据集进行处理<br>窗口函数 WindowedStream 函数</p><ul><li>增量聚合函数<ul><li>每条数据到来都会进行计算，保持一个简单的状态</li><li>ReduceFunction, AggregateFunction</li></ul></li><li>全量窗口函数<br>  -先把窗口所有数据收集起来，等到计算的时候再遍历所有的数据<ul><li>ProcessWindowFunction</li></ul></li></ul><p>窗口相关的其他可选API</p><ul><li>trigger(): 触发器，定义window什么时候关闭，触发计算并输出结果</li><li>evictor(): 移除器，定义移除某些数据的逻辑</li><li>allowedLateness(): 允许一定时间内迟到的数据也划分在上一个窗口里进行计算，这个时间是以watermark为准，不是eventTime</li><li>sideOutPutLateData(): 将迟到的数据放入侧输出流</li><li>getSideOutPut(): 获取侧输出流，在所有计算完之后，dataStream.getSideOutPut(tag).print() 输出</li></ul><p><img src="https://images.weserv.nl/?url=https://img2018.cnblogs.com/i-beta/1247221/202002/1247221-20200206122152873-34522436.png" alt="Window API总览"></p><p>时间语义</p><ul><li>eventTime: 事件创建的时间</li><li>ingestionTime: 数据进入Flink的时间</li><li>processTime: 执行操作算子的本地系统时间，与机器相关</li></ul><p>使用 eventTime</p><ol><li>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</li><li>然后和watermark一起搭配使用，来处理乱序数据</li></ol><p>waterMark 的意义：解决乱序问题<br>waterMark 的传递：上游向下游传递是通过广播传递给它分区的所有下游，而下游会保存所有上游的watermark然后取最小的那个来计算。<br><img src="https://img2018.cnblogs.com/i-beta/1247221/202002/1247221-20200206131937614-983019032.png" alt="watermark的传递"></p><p>watermark 的引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.assignTimestampsAndWatermarks(AssignerWithPeriodicWatermarks) // 隔一段时间，周期性生成waterMark，这个周期时间在env.setStreamTimeCharacteristic() 默认值是200毫秒，也可以自定义设置</span><br><span class="line">eg:</span><br><span class="line">.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor(maxOutOfOrderness)) 去重写extractTimestamp()方法，提取eventTime，在BoundedOutOfOrdernessTimestampExtractor类下getCurrentWatermark()方法里，会先通过eventTime-maxOutOfOrderness得到一个时间戳，会和已有的watermark比较，取最大值。maxOutOfOrderness指的是一个窗口延迟时间，maxOutOfOrderness设置的太大，窗口计算的结果就太慢，太小的话计算的结果准确性就下降了</span><br><span class="line"></span><br><span class="line">.assignTimestampsAndWatermarks(AssignerWithPunctuatedWatermarks) // 每来一条数据都会生成一个watermark</span><br></pre></td></tr></table></figure><p>窗口起始时间的确定<br>以 TumblingEventTimeWindows 为例，有一个 assignWindows() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Collection&lt;TimeWindow&gt; assignWindows(Object element, long timestamp, WindowAssignerContext context) &#123;</span><br><span class="line">    if (timestamp &gt; Long.MIN_VALUE) &#123;</span><br><span class="line">        // Long.MIN_VALUE is currently assigned when no timestamp is present</span><br><span class="line">        // offset 默认是 0</span><br><span class="line">        long start = TimeWindow.getWindowStartWithOffset(timestamp, offset, size);</span><br><span class="line">        return Collections.singletonList(new TimeWindow(start, start + size));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Record has Long.MIN_VALUE timestamp (= no timestamp marker). &quot; +</span><br><span class="line">                &quot;Is the time characteristic set to &apos;ProcessingTime&apos;, or did you forget to call &quot; +</span><br><span class="line">                &quot;&apos;DataStream.assignTimestampsAndWatermarks(...)&apos;?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static long getWindowStartWithOffset(long timestamp, long offset, long windowSize) &#123;</span><br><span class="line">    return timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">    // offset默认是0，+windowSize再取余，相当于没加，所以相当于 timestamp - timestam%windowSize</span><br><span class="line">    // 相当于取了一个windowSize的整数倍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flink 有状态的数据流</p><p>状态<br>比如聚合计算的一些结果，需要保存下来，这个就算是任务的状态。可以认为是一个本地变量，flink会进行状态管理，包括状态一致性、故障处理以及高效存储和访问</p><ul><li><p>算子状态 Operatior State</p><ul><li>作用范围限定为算子任务，由同一并行任务所处理的所有数据都可以访问到相同的状态，比如最小值，同一个task下的所有数据都可以访问到，但是不同的task访问不到，因为不在同一个内存下</li><li>算子状态的数据结构<ul><li>列表状态 list state: 将状态表示为一组数据的列表</li><li>联合列表状态 union list state</li><li>广播状态 broadcast state</li></ul></li></ul></li><li><p>键控状态 keyed State</p><ul><li>同一个分区下，可能有不同的key，针对这些key，会保存每一个key自己的一个状态实例</li><li>键控状态的数据结构<ul><li>值状态</li><li>列表状态</li><li>映射状态</li><li>聚合状态</li></ul></li></ul></li><li><p>状态后端 State Backends</p><ul><li><p>主要负责本地的状态管理，以及将检查点状态写入远程存储</p></li><li><p>主要有3种</p><ul><li><p>MemoryStateBackend</p><ul><li>内存级的状态后端，会将键控状态作为内存中的对象进行管理，将它们存储在taskmanager的jvm堆上，而将checkpoint存储在jobmanager中</li><li>特点：快速，低延迟，但不稳定</li></ul></li><li><p>FsStateBackend</p><ul><li>将checkpoint存到远程的持久化文件系统，而对于本地状态，跟MemoryStateBackend一样，也会存在taskmanager的jvm堆上</li><li>特点：同时拥有内存级的本地访问速度，和更好的容错保证。但是如果系统特别庞大，taskmanager堆上的内存都不足以存储下，就有第三种状态后端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 状态后端</span><br><span class="line">// env.setStateBackend(new FsStateBackend(String checkpointDataUri, boolean asynchronousSnapshots));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>RocksDBStateBackend</p><ul><li>将所有状态序列化后，存入本地的RocksDB中存储。相当于落入磁盘，不会丢数，但是会影响速度</li><li>需要再引入 flink-statebackend-rocksdb 依赖</li></ul></li></ul></li></ul></li></ul><p>从运行时上下文拿到状态 =&gt; 需要在 richFunction 里面去拿到上下文</p><p>比如温度监控，同一个传感器如果这一次的温度和上一次的温度相差十度，就预警。需要把上一条数据的温度不断更新在状态里，然后进行比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dataStream.keyBy().flatmap(new TempAlert(温度阈值))</span><br><span class="line"></span><br><span class="line">class TempAlert extends RichFlatMapFunction&#123;</span><br><span class="line">    private int threshold = 0;</span><br><span class="line">    private ValueState lastTempValueState = getRuntimeContext().getState(new ValueStateDescriptor(&quot;last-temp&quot;, Double.class));</span><br><span class="line">    public TempAlert(int i) &#123;</span><br><span class="line">        this.threshold = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void flatMap(Object value, Collector out) throws Exception &#123;</span><br><span class="line">        // 先获取上一条数据的温度值</span><br><span class="line">        double lastTemp = (double) lastTempValueState.value();</span><br><span class="line">        if(Math.abs(value.getTemp() - lastTemp) &gt;= threshold)&#123;</span><br><span class="line">            out.collect(&quot;预警信息&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 更新温度值</span><br><span class="line">        lastTempValueState.update(value.getTemp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessFunction<br>本身也继承了 AbstractRichFunction， 即实现了 RichFunction，即加强版的富函数，可以拿到各种上下文、变量、状态，还可以实现分流输出的效果</p><p>context.timeService().registerEventTimeTimer(long time) // 注册一个定时器，然后重写 <code>onTimer(long timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</code>方法； 可以注册多个定时器，只要参数time不一样，就是不一样的定时器，但是实现的话都是 onTimer() 方法，通过判断timestamp（onTimer()方法被激活时的时间戳）的不一样，来执行不同的操作。类似于在同一个闹钟app设置定时，根据时间来区分，激活方法都是一样的，只是去判断当前timestamp是哪一个，来执行不同的操作</p><p>比如连续N秒钟，温度一直上升，就发送预警信息。如果用滚动窗口或者滑动窗口的话，有一定问题：第一个窗口前1秒是下降，后面的N-1秒是上升；第二个窗口，前面N-1秒是上升，最后1秒是下降。这样两个窗口都不会报警，但是实际上是应该报警的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">dataStream.keyBy().process(new TempWarning(连续时长))</span><br><span class="line"></span><br><span class="line">class TempAlert2 extends KeyedProcessFunction &#123;</span><br><span class="line">    // 保存上一个温度值进行比较</span><br><span class="line">    private ValueState lastTempValueState = getRuntimeContext().getState(new ValueStateDescriptor(&quot;last-temp&quot;, Double.class));</span><br><span class="line"></span><br><span class="line">    // 保存上一个注册定时器的时间戳，用于删除</span><br><span class="line">    private ValueState timerTsValueState = getRuntimeContext().getState(new ValueStateDescriptor(&quot;timerTs&quot;, Long.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int timeSpan = 0;</span><br><span class="line">    public TempAlert2(int i) &#123;</span><br><span class="line">        this.timeSpan = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void processElement(Object value, Context ctx, Collector out) throws Exception &#123;</span><br><span class="line">        // 取出状态</span><br><span class="line">        double lastTemp = (double) lastTempValueState.value();</span><br><span class="line">        long timerTs = (long) timerTsValueState.value();</span><br><span class="line"></span><br><span class="line">        // 更新上一次的温度值</span><br><span class="line">        lastTempValueState.update(lastTemp);</span><br><span class="line"></span><br><span class="line">        // 温度上升并且没有注册过定时器，那就注册一个以当前时间戳开始的一个定时器</span><br><span class="line">        // timerTs 默认值是0，所以等于0的时候说明是第一次进行判断</span><br><span class="line">        if(value.getTemp() &gt; lastTemp &amp;&amp; timerTs == 0)&#123;</span><br><span class="line">            // 按照当前处理时间 + timeSpan 作为时间戳来注册定时器，也可以按照eventTime来设置时间戳</span><br><span class="line">            long ts = ctx.timerService().currentProcessingTime() + this.timeSpan*1000;</span><br><span class="line">            ctx.timerService().registerProcessingTimeTimer(ts);</span><br><span class="line">            timerTsValueState.update(ts);</span><br><span class="line"></span><br><span class="line">        &#125;else if(value.getTemp() &lt; lastTemp)&#123;</span><br><span class="line">            // 如果温度下降，那么需要删除定时器</span><br><span class="line">            ctx.timerService().deleteProcessingTimeTimer(timerTs);</span><br><span class="line">            timerTsValueState.getClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onTimer(long timestamp, OnTimerContext ctx, Collector out) throws Exception &#123;</span><br><span class="line">        out.collect(&quot;传感器 &quot; + ctx.getCurrentKey() + &quot; 的温度在 &quot; + this.timeSpan/1000 + &quot;秒内连续上升&quot;);</span><br><span class="line">        // 清空这一次的定时器，至于温度状态是否清空，如果清空了，就相当于再重新走一遍流程</span><br><span class="line">        timerTsValueState.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现分流输出的时候，通过 <code>ctx.output(OutputTag&lt;X&gt; outputTag, X value);</code> 方法来实现</p><p>容错机制</p><p>一致性检查点 checkpoints: 在某个时间点对<strong>所有任务</strong>的状态进行一次快照(一个任务的状态可能很快就可以被更新，但是所有任务都做完，所有状态合并出来的快照的时间可能就会比较慢)；这个时间点应该是所有任务都恰好处理完一个相同的输入数据的时候，比如针对偏移量5做快照，进行了keyby分区，那么应该保存所有分区在执行完偏移量5的数据之后的那个状态。当恢复的时候是恢复最近一次成功保存的检查点，然后会重新提交偏移量，这个就提供了 <strong>exactly-once</strong> 的一致性保证</p><blockquote><p>类似于 jvm 的 safepoint</p></blockquote><p>检查点的实现算法</p><ul><li>一种简单的想法<ul><li>暂停应用，保存状态到检查点，再重新恢复应用</li></ul></li><li>flink 的改进和实现<ul><li>基于 Chandy-Lamport 算法的分布式快照</li><li>将检查点的保存和数据处理分离开，不暂停整个应用，哪一个分区做完了就先做一个合照，等所有分区都做了合照之后再拼起来就可以了</li></ul></li></ul><p>检查点屏障 checkpoint barrier: 类似于watermark，在处理数据的时候会打上一个barrier，就可以把一条流上的数据按照不同的检查点分开。当前 barrier 前面到来的数据导致的状态更改，都会包含在当前 barrier 所属的检查点中；当前 barrier 后面到来的数据导致的状态更改，都会包含在后面的检查点</p><p>jobmanager 会发送一个命令，告诉source，然后source会在数据里插入一个barrier，当task执行到对应的数据时，就知道这里需要做一次检查点保存。</p><p>barrier 对齐: 类似于watermark会从上游广播到所有的下游，而下游会分区来保存所有的watermark，然后取最小值来计算。barrier也会从上游广播到所有的下游，对于下游来说，如果其中一个流source1的barrier先到，意味着这个流的数据已经计算完了，而其他流的barrier还没到，此时source1的数据如果继续到的话，会先缓存起来，要等其他流的barrier到，计算完了之后保存好状态，再从缓存的数据开始陆续计算。</p><p>如果barrier不对齐，其中快的流的数据不断计算，状态就会不断更新，慢的流快照保存，再次恢复上一次成功检查点快照的时候，快的流那边就会重复消费数据，就变成了 <strong>At Least Once</strong>。</p><blockquote><p>前面说的都是 flink 内部的 <strong>Exactly-Once</strong> 和  <strong>At Least Once</strong>，如果每1分钟快照一次，处理数据之后提交给mysql，在chk-100成功快照一次之后，过了30秒，程序down了，恢复到chk-100时的状态，那么就会有30秒的数据会被重复提交到mysql，也就是说还需要一个<strong>端对端</strong>的<strong>精确一次</strong>实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// checkpoint 默认时间间隔是500L</span><br><span class="line">env.enableCheckpointing(1000L, CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line">// checkpoint 超时时间，快的流等慢的流，超过这个时间就作废</span><br><span class="line">env.getCheckpointConfig().setCheckpointTimeout(60000L);</span><br><span class="line">// 最大同时checkpoint个数 默认是1</span><br><span class="line">env.getCheckpointConfig().setMaxConcurrentCheckpoints(5);</span><br><span class="line">// 两个checkpoint执行的最小间隔，如果配了这一个，上面的最大同时执行个数就不会生效</span><br><span class="line">env.getCheckpointConfig().setMinPauseBetweenCheckpoints(500L);</span><br><span class="line">// 能够允许checkpoint失败的次数</span><br><span class="line">env.getCheckpointConfig().setTolerableCheckpointFailureNumber(10);</span><br></pre></td></tr></table></figure><p><code>env.setStateBackend(new FsStateBackend(String checkpointDataUri, boolean asynchronousSnapshots));</code> 在设置状态后端这里，FsStateBackend 还有第二个参数，是否异步快照，即如果为true，当快的流计算完了，会把自己的状态先缓存到文件里，然后继续执行下面的计算，当慢的流计算完了之后再去合并快照</p><p>重启策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 重启3次，中间要间隔10秒</span><br><span class="line">env.setRestartStrategy(RestartStrategies.fixedDelayRestart(3, 10000L));</span><br></pre></td></tr></table></figure><p>保存点 SavePoint<br>类似于checkpoint的实现，savepoint是自定义设置的保存功能，需要写出来触发创建操作，会同时保存一些额外的元数据上下文的信息<br>作用：有计划的手动备份；暂停和重启应用；版本迁移等等<br>注意：要恢复savepoint的话需要保证计算流的拓扑结构是一样的，也就是算子应该是不变的，最好在算子后面添加 <code>.uid(String)</code>，这样在恢复的时候可以更有针对性</p><p>状态一致性<br>每个算子任务都有自己的计算状态，一条数据不应该丢失，也不应该重复计算（重复计算指的是不能叠加计算）</p><p>状态一致性分类</p><ul><li>at-most-once: 任务故障时，什么也不做，丢数就丢数。这样的话会没有快照的开销，速度会变快，准确性会下降。比如直播视频，因为网络问题，丢帧也是可以接受的，udp协议</li><li>at-least-once: 数据不会丢，数据可能被处理多次，即计算结果可能会进行叠加计算</li><li>exactly-onde: 数据不会丢，只会处理一次</li></ul><p>端到端的 exactly-once</p><ul><li>内部保证：checkpoint</li><li>source：可重设数据的读取位置</li><li>sink：从故障恢复时，数据不会重复写入到外部系统<ul><li>幂等写入</li><li>事务写入</li></ul></li></ul><p>幂等写入 Idempotent Writes<br>思路：e的导数还是e。<br>含义：一个操作，可以重复执行很多次，但只导致一次结果更改，也就是说，后面再重复执行的操作就不起作用了。<br>实现：类似于hashmap，数据修改是针对于同一个key的，修改再多次也只相当于是一次。比如redis、mysql提交的时候，按照key来写入数据，那重复写入的话也不会影响到数据的变化，相当于是一次更新<br>缺点：1-&gt;5-&gt;10-&gt;1-&gt;5-&gt;10 在第一个10的位置发生故障，导致数据重复发送，产生数据跳变</p><p>事务写入 Transactional Writes<br>思路：事务对应这checkpoint，等到checkpoint真正完成的时候，才把所有对应的结果放入到sink端中<br>实现：1. 预写日志 2. 两阶段提交</p><p>预写日志 Write-Ahead-Log WAL<br>实现：把结果数据先当成状态保存，然后在收到checkpoint完成的通知后，一次性批量写入sink端。DataStream API提供了一个模板类 GenericWriteAheadSink 来实现<br>缺点：由于checkpoint不能设置的太小（间隔太小的话，整个流就不断在做快照了，都没时间处理数据了），所以这一批数据到sink端会需要一定的时间，延迟性会比较高；另外从日志中批量写入到sink端时，如果写到一半sink端故障了，恢复的时候针对另一半没写入的日志数据如何处理也是一个问题</p><p>两阶段提交 Two-Phase-Commit 2PC<br>实现：对于每一个checkpoint，sink端会启动一个事务，将所有计算得到的数据都放入到事务里，然后写入到外部系统，但是并不提交，只是预提交（此时如果checkpoint挂了可以回滚事务）。当收到checkpoint<strong>完成</strong>的通知后，再提交事务，数据就会真正写入。Flink提供了 TwoPhaseCommitSinkFunction 抽象类，eg: kafkaProducer<br>要求：对外部 sink 端的要求会比较高————需要支持事务；支持预写入；可以回滚；提交事务必须是幂等操作</p><blockquote><p>也许状态很多，需要等所有状态都合并成快照之后才能提交事务。而不是看到下一个barrier的时候就提交。看到新的barrier会继续新的计算，放在新的事务里，当checkpoint完成之后，才会提交上一个事务</p></blockquote><table><thead><tr><th align="center">sink\source</th><th align="center">不可重置</th><th align="center">可重置</th></tr></thead><tbody><tr><td align="center">任意</td><td align="center">At-most-once</td><td align="center">At-least-once（故障恢复时会出现暂时的不一致，数据跳变）</td></tr><tr><td align="center">幂等</td><td align="center">At-most-once</td><td align="center">Exactly-once</td></tr><tr><td align="center">预写日志</td><td align="center">At-most-once</td><td align="center">At-least-once</td></tr><tr><td align="center">两阶段提交</td><td align="center">At-most-once</td><td align="center">Exactly-once</td></tr></tbody></table><p>Flink + Kafka 端到端状态一致性的保证</p><ul><li>内部：利用checkpoint机制，把状态存盘，发生故障的时候可以恢复</li><li>source：kafka Consumer 作为source，可以把偏移量保存下来，故障恢复时可以重置偏移量，重新消费数据</li><li>sink：FlinkKafkaProducer 底层继承了 TwoPhaseCommitSinkFunction 类</li></ul><p>综上：</p><ol><li>jobmanager在source数据流插入barrier</li><li>task看到barrier，就开始保存自己的状态，把数据写入到sink的事务里</li><li>sink看到barrier，创建新的事务，当上一个barrier完成的时候，提交上一个事务</li></ol><p>Table API 和 Flink SQL</p><blockquote><p>需要引入 flink-table-planner 依赖，会自动引入 bridge 依赖。可以引入 flink-table-planner-blink 版本，比flink-table-planner要更完善一些。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建table环境</span><br><span class="line">StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line">// 从外部链接创建一张表</span><br><span class="line">①tableEnv.connect().createTemporaryTable(&quot;myTable1&quot;);</span><br><span class="line">// 从已有的数据流生成一张表</span><br><span class="line">②Table dataTable = tableEnv.fromDataStream(dataStream);</span><br><span class="line"></span><br><span class="line">// 基于 Table API 查询算子得到一张表 2种形式</span><br><span class="line">①Table resultTable1 = tableEnv.from(&quot;myTable1&quot;).select().filter()</span><br><span class="line">②Table resultTable1 = dataTable.select(&quot;id, temp&quot;).filter(&quot;id = \&quot;sensor_1\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">// 基于SQL来查询得到一张表</span><br><span class="line">②tableEnv.createTemporaryView(&quot;myTable2&quot;, dataTable);</span><br><span class="line">②Table resultTable2 = tableEnv.sqlQuery(&quot;select * from myTable2&quot;); // 表名和创建的那个view的名字需要是一样的</span><br><span class="line"></span><br><span class="line">①Table resultTable2 = tableEnv.sqlQuery(&quot;select * from myTable1&quot;); // 因为前面指定了表名，所以这里直接写就可以了</span><br><span class="line"></span><br><span class="line">// 输出最后的结果</span><br><span class="line">DataStream&lt;Row&gt; rowDataStream = tableEnv.toAppendStream(resultTable, Types.ROW(Types.INT, Types.LONG));</span><br><span class="line">rowDataStream.print();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存穿透、缓存击穿、缓存雪崩</title>
      <link href="/2020/10/20/Redis-5/"/>
      <url>/2020/10/20/Redis-5/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存穿透、缓存击穿、缓存雪崩"><a href="#缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩"></a>缓存穿透、缓存击穿、缓存雪崩</h2><p><a href="https://www.cnblogs.com/xichji/p/11286443.html" target="_blank" rel="noopener">参考网址1</a><br><a href="https://blog.csdn.net/kongtiao5/article/details/82771694" target="_blank" rel="noopener">参考网址2</a><br><a href="https://blog.csdn.net/wsdc0521/article/details/106907436" target="_blank" rel="noopener">参考网址3</a></p><h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><p>含义：当查询Redis中没有的数据时，该查询会下沉到数据库层，同时数据库层也没有该数据，当这种情况大量出现或被恶意攻击时，接口的访问全部透过Redis访问数据库，而数据库中也没有这些数据，我们称这种现象为”缓存穿透”。缓存穿透会穿透Redis的保护，提升底层数据库的负载压力，同时这类穿透查询没有数据返回也造成了网络和计算资源的浪费。</p><p>解决：</p><ol><li>在接口访问层对用户做校验，如接口传参、登陆状态、n秒内访问接口的次数</li><li>利用布隆过滤器，将数据库层有的数据key存储在位数组中，以判断访问的key在底层数据库中是否存在<ul><li>假设bloomfilter设置了3个hash，一个key对应3个bit位，假设所有key经过hash后对应的bit位都不一样，那么3个key差不多是1B(8bit)，1MB就可以存储100万个key</li><li>bloomfilter可以判断数据一定不存在或者可能存在，对于可能存在的key再下沉到数据库查询</li></ul></li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li></ol><h3 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h3><p>含义：穿透表示底层数据库没有数据且缓存内也没有数据，击穿表示底层数据库有数据而缓存内没有数据。当热点数据key从缓存内失效时，大量访问同时请求这个数据，就会将查询下沉到数据库层，此时数据库层的负载压力会骤增，我们称这种现象为”缓存击穿”。</p><p>解决：</p><ol><li>延长热点key的过期时间或者设置永不过期，如排行榜，首页等一定会有高并发的接口</li><li>利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据，一旦查到数据就缓存至Redis内，避免其他大量请求同时穿过Redis访问底层数据库</li></ol><h3 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h3><p>含义：缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p>解决：</p><ol><li>延长热点key的过期时间或者设置永不过期，如排行榜，首页等一定会有高并发的接口</li><li>在可接受的时间范围内随机设置key的过期时间，分散key的过期时间，以防止大量的key在同一时刻过期</li></ol><h3 id="4-缓存预热"><a href="#4-缓存预热" class="headerlink" title="4. 缓存预热"></a>4. 缓存预热</h3><p>含义：当系统上线时，缓存内还没有数据，如果直接提供给用户使用，每个请求都会穿过缓存去访问底层数据库，如果并发大的话，很有可能在上线当天就会宕机，因此我们需要在上线前先将数据库内的热点数据缓存至Redis内再提供出去使用，这种操作就成为”缓存预热”。</p><p>解决：比较通用的方式是写个批任务，在启动项目时或定时去触发将底层数据库内的热点数据加载到缓存内。</p><h3 id="5-缓存更新"><a href="#5-缓存更新" class="headerlink" title="5. 缓存更新"></a>5. 缓存更新</h3><p>含义：缓存服务（Redis）和数据服务（底层数据库）是相互独立且异构的系统，在更新缓存或更新数据的时候无法做到原子性的同时更新两边的数据，因此在并发读写或第二步操作异常时会遇到各种数据不一致的问题。</p><blockquote><p>第二步操作异常：缓存和数据的操作顺序中，第二个动作报错。如数据库被更新，新数据缓存的时候出错，缓存内数据仍是旧版本；</p></blockquote><p>缓存更新的设计模式有四种：</p><ul><li>Cache aside：查询：先查缓存，缓存没有就查数据库，然后加载至缓存内；更新：先更新数据库，然后让缓存失效；或者先失效缓存然后更新数据库</li><li>Read through：在查询操作中更新缓存，即当缓存失效时，Cache Aside 模式是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载</li><li>Write through：在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库</li><li>Write behind caching：俗称write back，在更新数据的时候，只更新缓存，不更新数据库，缓存会异步地定时批量更新数据库</li></ul><h3 id="6-缓存降级"><a href="#6-缓存降级" class="headerlink" title="6. 缓存降级"></a>6. 缓存降级</h3><p>缓存降级是指当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，即使是有损部分其他服务，仍然需要保证主服务可用。可以将其他次要服务的数据进行缓存降级，从而提升主服务的稳定性。</p><p>降级的目的是保证核心服务可用，即使是有损的。如去年双十一的时候淘宝购物车无法修改地址只能使用默认地址，这个服务就是被降级了，这里阿里保证了订单可以正常提交和付款，但修改地址的服务可以在服务器压力降低，并发量相对减少的时候再恢复。</p><p>降级可以根据实时的监控数据进行自动降级也可以配置开关人工降级。是否需要降级，哪些服务需要降级，在什么情况下再降级，取决于大家对于系统功能的取舍。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的跳表</title>
      <link href="/2020/10/15/Redis-4/"/>
      <url>/2020/10/15/Redis-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis中的跳表"><a href="#Redis中的跳表" class="headerlink" title="Redis中的跳表"></a>Redis中的跳表</h2><p><a href="https://www.cnblogs.com/lfri/p/9991925.html" target="_blank" rel="noopener">参考网址1</a><br><a href="https://www.cnblogs.com/hunternet/p/11248192.html" target="_blank" rel="noopener">参考网址2</a></p><p>redis 数据类型 zset 实现有序集合，底层使用的数据结构是跳表。</p><p>源码在 <code>src/t_zset.c</code> 文件中，相关数据结构的定义在 <code>src/server.h</code> 文件中。(4.0版本)</p><p>元素有序的时候，如果是数组，可以通过二分查找来提速；如果是链表，如何提速？ =&gt; 跳表，插入/删除/搜索 都是O(logn)</p><blockquote><p>第一层索引 n/2 个节点，第二层 n/4 个节点，第三层 n/8，第K层 n/(2^k)<br>假设第K层有2个节点，即 n/(2^k) = 2 =&gt; k = log2(n) - 1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    <span class="comment">// 头节点，尾节点</span></span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    unsigned <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        unsigned <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h3 id="1-跳表-SkipList"><a href="#1-跳表-SkipList" class="headerlink" title="1. 跳表 SkipList"></a>1. 跳表 SkipList</h3><p>在 <code>java.util.concurrent.ConcurrentSkipListMap/ConcurrentSkipListSet</code> 类中也有实现</p><p>查询链表时会从头到尾的遍历链表，最坏的时间复杂度是O(N)，这是一次比较一个值，如果跳着1个元素来进行比较（比较下标为2n+1的元素），那么就相当于一次性比较2个元素，效率就会提高 =&gt; 跳表</p><p><img src="https://images.weserv.nl/?url=https://img2018.cnblogs.com/blog/1365470/201811/1365470-20181120213521027-836921723.png" alt="查询"></p><blockquote><p>跳表是牺牲空间来换取时间，除了最底层是最原始的数据外，其他的每一层，其实都相当于是一个索引，最理想的是按照第一层1级跳，第二层2级跳，第三层4级跳，第四层8级跳。。。但是考虑到有插入，如果插入的时候还要保证这个递增关系，那么就要调整当前的数据结构，时间太长，所以是否插入会有一个25%概率比较</p></blockquote><p><img src="https://images.weserv.nl/?url=https://img2018.cnblogs.com/blog/1365470/201811/1365470-20181120213055029-767111953.png" alt="插入"></p><blockquote><p>插入有一个地方需要注意，最底层肯定是要插入数据的，然后产生一个随机数，根据幂次定律，越大的值生成的几率越小。</p></blockquote><h3 id="2-如何确定层数"><a href="#2-如何确定层数" class="headerlink" title="2. 如何确定层数"></a>2. 如何确定层数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int zslRandomLevel(void)&#123;</span><br><span class="line">    int level = 1;</span><br><span class="line">    while((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))</span><br><span class="line">        level += 1;</span><br><span class="line">    retrun (level &lt; ZSKIPLST_MAXLAVEL) ? level : ZSKIPLST_MAXLAVEL;</span><br><span class="line">&#125;</span><br><span class="line">// 0xFFFF 65535</span><br><span class="line">// ZSKIPLIST_P 默认为 0.25</span><br><span class="line">// define ZSKIPLST_MAXLAVEL 64 常量值为64</span><br></pre></td></tr></table></figure><h3 id="3-为什么使用跳跃表，而不是平衡树等用来做有序元素的查找"><a href="#3-为什么使用跳跃表，而不是平衡树等用来做有序元素的查找" class="headerlink" title="3. 为什么使用跳跃表，而不是平衡树等用来做有序元素的查找"></a>3. 为什么使用跳跃表，而不是平衡树等用来做有序元素的查找</h3><ol><li>跳跃表的时间复杂度和红黑树是一样的，而且实现简单</li><li>在并发的情况下，红黑树在插入删除的时候可能需要做rebalance的操作，这样的操作可能会涉及到整个树的其他部分；而链表的操作就会相对局部，只需要关注插入删除的位置即可，只要多个线程操作的地方不一样，就不会产生冲突</li></ol><blockquote><p>开发者的解释:<br>There are a few reasons:</p><ol><li>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees. =&gt; 并不是非常耗费内存。控制好ZSKIPLIST_P的值，内存消耗和平衡树差不多</li><li>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees. =&gt; 有序集合经常会进行 zrange 或 zrevrange 这样的范围查找，跳表里的双向链表可以十分方便的进行这操作</li><li>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.<br>About the Append Only durability &amp; speed, I don’t think it is a good idea to optimize Redis at cost of more code and more complexity for a use case that IMHO should be rare for the Redis target (fsync() at every command). Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway. =&gt; 实现简单，zrank 还能达到O(logn)的时间复杂度</li></ol></blockquote><blockquote><p>About threads: our experience shows that Redis is mostly I/O bound. I’m using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your link is so fast that you can saturate a single core, is running multiple instances of Redis (no locks, almost fully scalable linearly with number of cores), and using the “Redis Cluster” solution that I plan to develop in the future.</p></blockquote><p>在 src/t_zset.c 文件中，主要有两个结构，zskiplist 和 zskiplistNode，前者保存跳跃表信息（如表头节点、表尾节点、长度），而 zskiplistNode 用于保存节点<br>另外，跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。这一点也是redis针对跳表这个结构做出的优化之一。具体的优化点为：</p><ul><li>允许重复分值，即多个节点允许相同的分值，但是每个节点的成员对象必须是唯一的</li><li>比较的时候不仅仅是分值，还有整个对象，即分值相同，按照成员对象大小排序</li><li>在第一层有一个back指针，适用于 ZREVRANGE 方法，允许从尾部到头部来遍历列表</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的一些问题</title>
      <link href="/2020/10/15/Redis-3/"/>
      <url>/2020/10/15/Redis-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis的一些问题"><a href="#Redis的一些问题" class="headerlink" title="Redis的一些问题"></a>Redis的一些问题</h2><p>Remote Dictionary Server</p><p>底层C写的</p><p>类似于 mysql，可以把最近的query和对应的结果保存下来 =&gt; hashquery 存入到缓存里，如果其他用户的query的hash值是一样的，说明查询是一样的，直接从缓存里读出来结果 =&gt; 多级缓存，目的是将最初的query进行过滤、优化，尽可能只让最后的事务操作落到DB中，缓解DB压力</p><h3 id="1-redis出现的原因"><a href="#1-redis出现的原因" class="headerlink" title="1. redis出现的原因"></a>1. redis出现的原因</h3><p>数据文件过大，查询变慢 -&gt; 因为要走 全量扫描</p><p>数据存储的2个位置</p><ul><li>磁盘<br>  影响指标<ul><li>带宽/吞吐：百兆/s – G/s</li><li>寻址时间：毫秒</li></ul></li><li>内存<br>  纳秒级别</li></ul><p>mysql 查询快的原因是因为数据会分成block/datapage来保存，通过B+树建立索引，避免了全表扫描。</p><p>当mysql中的表非常大的时候，查询会很慢吗？</p><ul><li>如果是一条sql命中了索引的话，还是很快的</li><li>如果是并发量很大的话，并且命中索引后指向的是独立的datapage，那么mysql会把每一个datapage拉到内存中查询，一个datapage是4k大小，如果请求量过大，磁盘带宽跟不上，会导致查询变慢</li></ul><p>同样的数据，在内存中占的大小比在磁盘中占的大小要小很多。因为有指针，数据复用的现象。</p><p>=&gt; 把热点数据放入到内存中，就是 redis，类似的还有 memcache。java 借助 LinkedHashMap 实现 LRU</p><h3 id="2-redis-特征"><a href="#2-redis-特征" class="headerlink" title="2. redis 特征"></a>2. redis 特征</h3><p><a href="https://redis.io/topics/faq" target="_blank" rel="noopener">关于单线程以及其他问题的官方回答</a></p><ul><li>绝大部分请求是纯粹的内存操作</li><li>worker 单线程串行的<ul><li>关于线程这个问题，影响的瓶颈在于IO通信。Redis 4.x 之后，对数据的具体计算过程等是单线程的，对数据的获取、返回客户端等是多线程的（IO Threads）</li></ul></li><li>value 类型且每个类型有自己的本地方法。比如存入一个数组 <code>[a,b,c]</code>，客户端要c的下标，redis有数组的index方法可以直接返回2，不需要返回整个数组，在客户端进行计算。相比之下 memcache 就是单纯的 kv 格式，都是string</li><li>客户端的访问是并发的，通过epoll解决</li></ul><p>内存操作 + 单线程避免锁、上下文竞争切换 + 非阻塞IO + value 的数据结构专门设计 =&gt; 速度快</p><p>多线程的弊端：一致性。redis的数据要多线程，一定要加锁，会退化成串行，不如单线程。</p><p>单线程的弊端：cpu利用率不高。redis单线程已足够用了，如果想继续压榨cpu，就多开实例，相当于多开redis服务器。</p><p>redis 的 worker单线程，但是IO Thread可以是多线程 !!!</p><p>客户端C1、C2并发请求，IO Thread1 可以读取C1的数据data1，IO Thread2 可以读取C2的数据data2。然后把数据交给单线程的worker来依次计算data1，data2，保证数据是串行的，不会发生错误。worker计算后的数据可以再交给对应的 IO Thread 分别返回给C1、C2。[Redis 6.x 版本的IO Threads多线程]</p><p>但是存在问题，即先计算data2后计算data1，理论上来说C1、C2请求负载均衡到不同服务器，本来就可能是无序的状态。优化的话，比如在负载均衡的时候，根据uri来分组，绑定到一个连接池里，交给一个connection里，就可以按照顺序来处理（不是很懂，但是io thread多线程是存在的）</p><h3 id="3-跟踪redis启动后的线程情况"><a href="#3-跟踪redis启动后的线程情况" class="headerlink" title="3. 跟踪redis启动后的线程情况"></a>3. 跟踪redis启动后的线程情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install strace</span><br><span class="line">strace -ff -O ./strace_out/out ./redis-server</span><br><span class="line">在启动redis-server的同时，将对系统的调用情况输出到 ./strace_out/ 目录下的，文件名前缀 out</span><br></pre></td></tr></table></figure><h3 id="4-redis-持久化"><a href="#4-redis-持久化" class="headerlink" title="4. redis 持久化"></a>4. redis 持久化</h3><p>memcache 不支持持久化</p><p>指令 BGSAVE 会在后台执行将数据持久化到磁盘，底层调用的是 copyOnWrite 方法，内核中clone指令（类似于fork指令）</p><p>copyOnWrite–当前线程A读取数据提供服务，启动线程B来持久化数据，指向的物理空间数据地址都是同一个。如果此时数据发生变化，A指向新的数据地址，B不变。</p><p>cow 具体原理: 在内存里已经有一部分数据了，此时执行持久化指令，不可能复制一份数据，可能存不下，存下也是浪费。所以新起一个线程B，不耽误正在提供服务的线程A，线程指B向的数据的物理地址和线程A是一样的，如果同一个key在持久化的时候被修改了，那么在内存中重新开辟一个地址，线程A指向新的物理地址。</p><h3 id="5-CPU中断与内核"><a href="#5-CPU中断与内核" class="headerlink" title="5. CPU中断与内核"></a>5. CPU中断与内核</h3><p>内核常驻在内存中。</p><p>CPU 里有晶振时间中断，每秒震荡很多次，将一秒分成了很多的时间片，每一个设备占用时间片的时候会拿到中断号（类似于时间片号），内核里有一个回调函数，通过中断号可以获取到数据在内存中的地址，这样CPU就可以在对应的时间片内去获取数据处理数据，从而达到切换程序的效果。</p><p>内核的指令 clone、select、epoll、read、write、sendfile</p><h3 id="6-BIO-gt-NIO-gt-epoll（多路复用）"><a href="#6-BIO-gt-NIO-gt-epoll（多路复用）" class="headerlink" title="6. BIO -&gt; NIO -&gt; epoll（多路复用）"></a>6. BIO -&gt; NIO -&gt; epoll（多路复用）</h3><ul><li>BIO: 客户端请求数据，发送一个key，如果这时候数据还没到，没有value，会一直等着，导致用户进程的阻塞。即一个连接一个线程</li><li>NIO: 客户端每次请求的key都扔到一个线程里，哪个线程能获取到value了，就把数据返回。即一个连接N个线程<ul><li>缺点: 如果请求量特别多，会导致线程过多（几十万的请求量就相当于几十万的线程），不断循环线程的时间复杂度是 O(N)，影响效率。所以通过内核指令 select，在内核里维护一个fds(fileDescription)的数组，数组里是需要监听的socket对象。当其中一个数据到了，就会启动CPU中断，select() 返回，启动一个线程，让socket接收数据。缺点就是需要多次遍历数组，不知道是哪一个socket拿到了数据，另外还得从等待队列中移除被唤醒的进程。</li></ul></li><li>epoll(多路复用): 通过内核的epoll指令，redis可以知道哪一个客户端（socket）的数据已经准备好了，然后串行获取数据，计算结果返回给客户端<ul><li>调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</li><li>调用epoll_ctl向epoll对象中添加这100万个连接的socket</li><li>调用epoll_wait收集发生的事件的连接（添加到一个双向链表里）</li></ul></li></ul><h3 id="7-零拷贝"><a href="#7-零拷贝" class="headerlink" title="7. 零拷贝"></a>7. 零拷贝</h3><p>kafka、nginx 零拷贝技术大同小异</p><p>客户端请求数据 socket -&gt; 调用内核 sendfile 指令 -&gt; 获取文件数据（文件描述符fd）并缓存到内核中 -&gt; 直接返回网卡到客户端 </p><h3 id="8-expire-过期删除"><a href="#8-expire-过期删除" class="headerlink" title="8. expire 过期删除"></a>8. expire 过期删除</h3><p>redis 维护了一个 expire dict字典（因为不是所有的key都会过期，设置为过期的单独保存到字典中，可以更节省内存）来保存会过期的key，用到数据的时候会先检查key是否过期，过期则删除，然后返回错误。这是惰性删除，如果数据不被查找可能不会删除，造成内存浪费，所以同时有一个定时执行的函数，servercron，会在一定时间内，随机选出来字典里的数据，如果过期删除，否则再随机选择，直到规定的时间结束。这个时间有长有短，即servercron的运行时间有长有短。一般执行短的删除，每隔一段时间执行一次长的删除。</p><h3 id="9-value-的五个类型"><a href="#9-value-的五个类型" class="headerlink" title="9. value 的五个类型"></a>9. value 的五个类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    // 类型 一共5个类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line"></span><br><span class="line">    // 编码 字符串--raw 数值--int ...</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">    // 对象最后一次被访问的时间</span><br><span class="line">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class="line"></span><br><span class="line">    // 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    // 指向实际值的指针</span><br><span class="line">    void *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ol><li><p>string</p><ul><li><p>数值可以按string保存，对于已经进行过计算的数值，在<code>encoding</code>里会把这个value设置为int，这样下次再计算的时候直接计算，而不需要判断是否能转换成数值。第一次进行计算的时候是需要进行判断的。</p><ul><li>比如对于秒杀场景，初始化值10是string，第一次-1会判断10能不能转换为数字，如果可以-1，就把<code>encoding</code>设置为<code>int</code>（<code>encoding=raw</code> 表示字符串），下一次-1的时候直接-1，省略了判断的过程，提高效率</li></ul></li><li><p>bitmap 位图 8个比特位，首位默认是0，遵循ascii码。但是如果 offset 超过7，那么redis会自动拓展这个位图到设置的那个长度</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setbit k1 1 1 # 偏移量1的位置设置为1</span><br><span class="line">get k1 # 返回 &quot;@&quot; 01000000 二进制64，对应的是 @</span><br><span class="line">setbit k1 7 1 # 偏移量7的位置设置为1</span><br><span class="line">get k1 # 返回 &quot;A&quot; 01000001 二进制65，对应的是 A</span><br></pre></td></tr></table></figure><ul><li>bitcount 可以统计出value里有多少个1，换算到字节的话，长度/8，可以减少存储空间；</li><li>bitop 可以进行二进制的与或非操作</li><li>适用场景：<ol><li>统计用户在一段时间内登陆次数，比如一年365，length就是365，登陆就置为1</li><li>活跃用户的统计</li><li>权限控制 类似于linux的chmod 777</li><li>布隆过滤器 redis自带</li></ol></li></ul></li></ul></li><li><p>list</p><ul><li>按放入顺序 有序</li><li>value 保存是双向链表的结构，同时key保存了头元素和尾元素的指针，访问头尾都是O(1)</li><li>插入、弹出有方向区别，为了模拟不同的数据结构。同向：栈；异向：队列。通过index指令还可以模拟数组。</li><li>适用场景：数据共享</li></ul></li><li><p>set</p><ul><li>去重 无序，当元素变多之后元素可能顺序和之前也不一样。<ul><li>java hashset 底层实现是hashmap，只不过value设置为null，当元素变多，会触发rehash，导致元素顺序更不一样</li></ul></li><li>适用场景：随机事件；差集可以做推荐好友，交集可以做推荐共同好友</li></ul></li><li><p>hash </p><ul><li>即hashmap，通过 hset key field value 来设置；通过 hgetall key 可以直接返回field和value</li><li>适用场景：商品详情页，可以把商品的一整套信息放在一起</li></ul></li><li><p>zset: 排序的 set</p><ul><li>跳表 =&gt; 实现有序集合 <a href="https://mxxct4git.github.io/2020/10/15/Redis-4/">跳转到对跳表的说明</a></li></ul></li></ol><h3 id="10-持久化"><a href="#10-持久化" class="headerlink" title="10. 持久化"></a>10. 持久化</h3><p>两种方式：</p><ol><li>RDB<ul><li>快照恢复速度快，但是可能会丢失大量数据</li></ul></li><li>AOF<ul><li>日志完整，但是恢复速度慢，同时可能存在冗余日志</li><li>存在冗余日志 =&gt; 4.x 之后版本会自动开启对aof日志的重写，即对同一key的操作日志，只保留有效的最近一次的日志，aof文件超过64MB的时候会自动触发</li></ul></li></ol><p>使用方法：</p><ul><li>4.x 之前版本<ul><li>默认开启 rdb 关闭 aof。如果开启了 aof 那么 rdb 就不生效 =&gt; 即不推荐 aof，因为过多的io会造成redis性能下降</li></ul></li><li>4.x 之后版本<ul><li>混合使用 rdb + aof =&gt; 持久化的时候，会生成一个aof文件，这个文件包含两部分，第一部分是此刻 rdb 的数据，第二部分是此刻后追加的日志记录 =&gt; 类比于 hdfs，数据保存的形式为 fsimage + edits.log</li></ul></li></ul><h3 id="11-压力测试"><a href="#11-压力测试" class="headerlink" title="11. 压力测试"></a>11. 压力测试</h3><p>eg: <code>redis-benchmark -c 客户端连接数（默认50） -n 请求数（默认10万） -q(quiet 不输出多余日志) -t(设置测试的命令列表) set(只测试set一个)</code></p><p>影响效率的几点：</p><ol><li>网络IO -&gt; 物理地址ip、局域网 是否走DNS转换等</li><li>磁盘IO -&gt; aof 文件写的频率，默认是 <code>appendfsync=appendfsync</code>，如果改成 <code>appendfsync=always</code> 即每一次操作都落入到日志文件里，会降低redis的处理效率</li></ol><h3 id="12-分布式部署"><a href="#12-分布式部署" class="headerlink" title="12. 分布式部署"></a>12. 分布式部署</h3><p>分布式要解决的两个问题</p><ol><li>单点故障 -&gt; 主从复制 -&gt; 为了保证其中一个挂了，另一个能顶替，那么就需要做到<strong>数据同步</strong></li><li>单个结点压力大 -&gt; 分片集群，即将数据分片，将不同片的数据放在不同机器上，缓解访问压力 -&gt; 不需要做到数据同步</li></ol><blockquote><p>redis 的数据分片就是每个节点负责不同的槽位，hash(key)%65536</p></blockquote><h4 id="12-1-主从复制中数据同步的方式"><a href="#12-1-主从复制中数据同步的方式" class="headerlink" title="12.1 主从复制中数据同步的方式"></a>12.1 主从复制中数据同步的方式</h4><blockquote><p>分布式CAP定理 – Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），最多只能同时三个特性中的两个，三者不可兼得<br>P 指的是节点之间的网络通信，一般情况来说网络故障很正常，所以只能在CA之间进行取舍<br>但是对于银行转账这样的涉及金融，C是一定需要的，那么就在AP之间取舍</p></blockquote><ol><li>强一致性<ul><li>client 发送请求，主节点同步把请求发给子节点，只有两个节点都成功，才返回给client成功 =&gt; 如果子节点挂了，主节点会一直等子节点重启、执行命令、返回请求，影响效率，即<strong>强一致性破坏可用性</strong></li></ul></li><li>弱一致性（redis默认使用这种）<ul><li>client 发送请求，主节点执行成功，返回给client，同时把请求异步发给子节点，但并不能保证子节点一定执行成功 =&gt; 可能会影响一部分数据的一致性 =&gt; 如果redis的使用场景是为了缓存热点数据的话，丢一部分数据没有问题；如果是做分布式锁的话，可能会出现问题</li></ul></li><li>最终一致性<ul><li>client 发送请求，主节点执行成功，返回给client，同时把请求写入到一个位置（类似于黑盒的一个可靠的集群），子节点会读取这个位置的记录，一条条指令执行，也许会有延迟，但是能保证数据最终的一样，哪怕子节点掉了，也可以重新读记录</li><li>HDFS 中两个namenode之间共享数据来保证数据同步靠的是 journalnode（这也是一个集群，N个节点） ，思想就是：一条数据在journalnode集群里保证至少 <code>n/2 + 1</code> 个节点记录这个成功即可，这个集群会自动在n个journalnode里找到最新版本的数据来更新数据</li><li>类似思想也存在于 zookeeper、哨兵、kafka等，<a href="https://zhuanlan.zhihu.com/p/31727291" target="_blank" rel="noopener">参考Paxos</a></li></ul></li></ol><h4 id="12-2-AKF-拆分原则"><a href="#12-2-AKF-拆分原则" class="headerlink" title="12.2 AKF 拆分原则"></a>12.2 AKF 拆分原则</h4><p>分片集群，每个节点管理一部分数据 -&gt; 存在某个节点挂了，无法访问某一部分数据的情况 -&gt; 是否针对每一个节点做HA？需要针对业务做结合</p><p>AKF 拆分原则：通过加机器可以解决容量和可用性问题</p><ul><li>X轴：水平复制，HA 高可用</li><li>Y轴：按照业务切分，比如分业务分库</li><li>Z轴：数据分区（切片）</li></ul><h3 id="13-Redis-问题画像"><a href="#13-Redis-问题画像" class="headerlink" title="13. Redis 问题画像"></a>13. Redis 问题画像</h3><p><img src="(https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_jpg/HXiabut2oicnMyMyOXqNMBnsfPlk3KNRkGtia3JscZOBWk5Cy36uVXUIF2Cuw5qpS8ZqX0t8LVjHPxSl6zFHY7dSg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_jpg/HXiabut2oicnMyMyOXqNMBnsfPlk3KNRkGHyjmYQe6zWSnq4IxhKFJaZENND5L6pC70xYU3Suh8O8fpYXXFGTrTg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Distcp 跨集群同步</title>
      <link href="/2020/10/09/Hive-8/"/>
      <url>/2020/10/09/Hive-8/</url>
      
        <content type="html"><![CDATA[<h2 id="Distcp-跨集群同步"><a href="#Distcp-跨集群同步" class="headerlink" title="Distcp 跨集群同步"></a>Distcp 跨集群同步</h2><h3 id="1-使用方法及原理"><a href="#1-使用方法及原理" class="headerlink" title="1. 使用方法及原理"></a>1. 使用方法及原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop distcp srcPath tarPath</span><br><span class="line">会把srcPath和tarPath下的所有目录、文件信息放入到 _distcp_src_files 和 _distcp_dst_files 两个临时文件中，具体文件内容的拷贝工作交给多个map任务，会导致一个问题，就是文件过多那么map任务数就会很多，每个datanode有一个上限，极少数情况下可能会超过上限，导致数据文件拷贝不全。</span><br></pre></td></tr></table></figure><p>org.apache.hadoop.tools.DistCp 类中会解析 srcPath tarPath ，将之前的临时文件先删除，然后一个含有随机数的临时文件夹路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Path createMetaFolderPath() throws Exception &#123;</span><br><span class="line">    Configuration configuration = this.getConf();</span><br><span class="line">    Path stagingDir = JobSubmissionFiles.getStagingDir(new Cluster(configuration), configuration);</span><br><span class="line">    Path metaFolderPath = new Path(stagingDir, &quot;_distcp&quot; + String.valueOf(rand.nextInt()));</span><br><span class="line">    return metaFolderPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到临时文件的路径，SequenceFile文件，即Key/Value结构的序列化文件，这个文件里将存放所有需要拷贝的源目录/文件信息列表。其中Key是源文件的Text格式的相对路径，即relPath；而Value则记录源文件的FileStatus格式的org.apache.hadoop.fs.FileStatus信息，这里FileStatus是hadoop已经封装好了的描述HDFS文件信息的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected Path getFileListingPath() throws IOException &#123;</span><br><span class="line">    String fileListPathStr = this.metaFolder + &quot;/fileList.seq&quot;;</span><br><span class="line">    Path path = new Path(fileListPathStr);</span><br><span class="line">    return new Path(path.toUri().normalize().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在createJob()里主要有两个地方需要注意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Job createJob() throws IOException &#123;</span><br><span class="line">    job.setInputFormatClass(DistCpUtils.getStrategy(this.getConf(), this.context)); </span><br><span class="line">    job.setJarByClass(CopyMapper.class);</span><br><span class="line">    return job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setInputFormatClass() 保证了mapper的数据读取格式是从getStrategy(getConf(), inputOptions)得到的，底层是由 UniformSizeInputFormat.class 类定义的，这个类继承自InputFormat.class，MR中所有的输入格式类都继承自InputFormat，这是一个抽象类。<br>InputFormat抽象类仅有两个抽象方法</p><ul><li>List<inputsplit>getSplits()，获取由输入文件计算出输入分片(InputSplit)，解决数据或文件分割成片问题</inputsplit></li><li>RecordReader&lt;K,V&gt;createRecordReader()，创建RecordReader，从InputSplit中读取数据，解决读取分片中数据问题</li></ul><p>CopyMapper.class中则定义了每个map的工作逻辑，也就是拷贝的核心逻辑。这个类里最核心的两个方法是 setup()和map()。setup()中完成map方法的一些初始化工作，在DISTCP中，这个方法里会设定对端的目标路径，并做一些参数设置和判断工作</p><p>而 map(Text relPath, CopyListingFileStatus sourceFileStatus, Context context) 中通过参数可以发现就是对UniformSizeInputFormat类里分片后的数据里的每一行进行处理，每行里存放的就是 fileList.seq文件每行的内容。</p><blockquote><p>CommonCliOptions 解析命令行参数</p></blockquote><h3 id="2-几个问题"><a href="#2-几个问题" class="headerlink" title="2. 几个问题"></a>2. 几个问题</h3><h4 id="2-1-文件数量过多，导致map过多，超过datanode上限，导致数据文件拷贝不全"><a href="#2-1-文件数量过多，导致map过多，超过datanode上限，导致数据文件拷贝不全" class="headerlink" title="2.1 文件数量过多，导致map过多，超过datanode上限，导致数据文件拷贝不全"></a>2.1 文件数量过多，导致map过多，超过datanode上限，导致数据文件拷贝不全</h4><h4 id="2-2-提示信息非常少，如果是-调度器-gt-作业-gt-distcp-gt-mrJob，-此时输出的信息应该是-mrJob的，也就是distcp的信息，而不是作业的信息，可能会导致调度器无法拿到作业执行信息从而导致作业调度失败"><a href="#2-2-提示信息非常少，如果是-调度器-gt-作业-gt-distcp-gt-mrJob，-此时输出的信息应该是-mrJob的，也就是distcp的信息，而不是作业的信息，可能会导致调度器无法拿到作业执行信息从而导致作业调度失败" class="headerlink" title="2.2 提示信息非常少，如果是 调度器 -&gt; 作业 -&gt; distcp -&gt; mrJob， 此时输出的信息应该是 mrJob的，也就是distcp的信息，而不是作业的信息，可能会导致调度器无法拿到作业执行信息从而导致作业调度失败"></a>2.2 提示信息非常少，如果是 调度器 -&gt; 作业 -&gt; distcp -&gt; mrJob， 此时输出的信息应该是 mrJob的，也就是distcp的信息，而不是作业的信息，可能会导致调度器无法拿到作业执行信息从而导致作业调度失败</h4><h4 id="2-3-长尾问题-？"><a href="#2-3-长尾问题-？" class="headerlink" title="2.3 长尾问题 ？"></a>2.3 长尾问题 ？</h4><h3 id="3-分区表的跨集群同步问题"><a href="#3-分区表的跨集群同步问题" class="headerlink" title="3. 分区表的跨集群同步问题"></a>3. 分区表的跨集群同步问题</h3><p>不管是普通的表还是分区表，都需要刷新元数据，<code>invalidate metadata table xxx</code></p><p>分区表还需要手动添加分区，<code>alter table xxx add if not exists partition(key1=&quot;value1&quot;, key2=&quot;value2&quot;) partition(key1=&quot;value3&quot;, key2=&quot;value4&quot;)</code></p><p>hive shell 通过 <code>msck repair table xxx</code> 可以自动去读取hdfs下文件信息，来添加元数据中不存在的分区信息，但是存在jdbc连接时不识别 msck 指令的情况</p><h3 id="4-hive同步phoenix"><a href="#4-hive同步phoenix" class="headerlink" title="4. hive同步phoenix"></a>4. hive同步phoenix</h3><p><a href="http://phoenix.apache.org/hive_storage_handler.html" target="_blank" rel="noopener">官网地址</a></p><p>官网提供的一个方案是可以在hive创建表，然后存储上指定phoenix的一个方法，<code>org.apache.phoenix.hive.PhoenixStorageHandler</code>，通过一些配置来完成。但是会存在一些问题，比如hive与phoenix的数据类型转换问题，bigint、int；还有string的长度限制等</p><p>∴ 跨集群表同步（parquet格式） + hive同步phoenix的方案解决如下</p><ol><li>首先将集群1的hive表通过元数据直接复制到集群2来创建</li><li>对于未分区的表，直接复制文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FSDataInputStream input = batchClusterFS.open(path);</span><br><span class="line">FSDataOutputStream output = queryClusterFS.create(new Path(queryHiveTablePath,fileName), true);</span><br><span class="line">IOUtils.copyBytes(input, output,queryClusterFS.getConf(), true);</span><br></pre></td></tr></table></figure><p>如果是分区的表（eg：impala），递归复制文件夹下的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(files).parallel().forEach(dirPath -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        FileUtil.copy(batchClusterFS, dirPath.getPath(), queryClusterFS, new Path(queryHiveTable.getSd().getLocation()), false, queryClusterFS.getConf());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        logger.error(&quot;&gt;&gt; 分区表拷贝失败 dirPath: &#123;&#125;, error: &#123;&#125; &quot;, dirPath, e);</span><br><span class="line">        table.setDistStatus(CrossClusterHiveTableCopy.FAIL_STATUS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>都需要刷新元数据信息</p><ol start="3"><li>遍历集群2hive表对应的hdfs文件，需要将hive中字段的类型和phoenix类型进行转换，<code>org.apache.phoenix.schema.types</code>，比如hive的string转phoenix的varchar；hive的array转phoenix的VARCHAR[]。</li></ol><blockquote><p>如果一个字段长度可能会一直变，考虑到不能随便修改phphonenix的字段长度，也不能把字段长度设置的太大，可以将hive的字段设置为array，对应phoenix的VARCHAR[]，这就是一个变长字符数组。<br>hive中的array类型，从hive元数据中可以查到以下信息：data_type=2003,column_size=0；对应phoenix的数据类型是VARCHAR[], column_size为null，是变长数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">这里的dataType是varchar[]；PVarcharArray 是 org.apache.phoenix.schema.types.PVarcharArray，是phoenix的类型</span><br><span class="line">if (dataType instanceof PVarcharArray) &#123;</span><br><span class="line">    // org.apache.hadoop.io.ArrayWritable</span><br><span class="line">    ArrayWritable aw = (ArrayWritable) value;</span><br><span class="line">    ArrayList strArr = new ArrayList();</span><br><span class="line">    for (Writable wr : aw.get()) &#123;</span><br><span class="line">        strArr.add(wr.toString());</span><br><span class="line">&#125;</span><br><span class="line">Array array = phoenixConn.createArrayOf(&quot;VARCHAR&quot;, strArr.toArray());</span><br><span class="line">JobLogger.log(&quot;&gt;&gt; type: varchar[] size &#123;&#125; &quot;, strArr.size());</span><br><span class="line">statement.setArray(i + 1, array);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2020/09/28/Singleton/"/>
      <url>/2020/09/28/Singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class EHan &#123;</span><br><span class="line">    private static EHan instance = new EHan();</span><br><span class="line">    private EHan()&#123;&#125;</span><br><span class="line">    public static EHan getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：没有线程安全问题<br>缺点：在初始化时就创建好了，浪费内存空间</p><h3 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h3><h4 id="2-1-线程不安全"><a href="#2-1-线程不安全" class="headerlink" title="2.1 线程不安全"></a>2.1 线程不安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class LHan &#123;</span><br><span class="line">    private static LHan instance;</span><br><span class="line">    private LHan()&#123;&#125;</span><br><span class="line">    public static LHan getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new LHan();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：只有当用的时候才检查是否有实例，没有才创建<br>缺点：有线程安全与不安全两种，区别在于是否有 synchronized 关键字</p><h4 id="2-2-线程安全"><a href="#2-2-线程安全" class="headerlink" title="2.2 线程安全"></a>2.2 线程安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class LHan &#123;</span><br><span class="line">    private static LHan instance;</span><br><span class="line">    private LHan()&#123;&#125;</span><br><span class="line">    public static synchronized LHan getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new LHan();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-DCL"><a href="#3-DCL" class="headerlink" title="3. DCL"></a>3. DCL</h3><p>由于线程安全的懒汉式的 synchronized 是加在方法上的，如果该方法里还有其他的一些代码，会降低执行效率，加锁的粒度太粗，所以可以进而改写下面这个</p><h4 id="3-1-懒汉式优化后的一种写法"><a href="#3-1-懒汉式优化后的一种写法" class="headerlink" title="3.1 懒汉式优化后的一种写法"></a>3.1 懒汉式优化后的一种写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class LHan &#123;</span><br><span class="line">    private static LHan instance;</span><br><span class="line">    private LHan()&#123;&#125;</span><br><span class="line">    public static LHan getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                instance = new LHan();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种写法也存在一定问题，当线程A在判断instance==null后停住了，此时还没有创建实例；线程B抢到了资源，发现instance==null，也会进入到代码块，于是A和B都会创建一个实例。</p><h4 id="3-2-DCL-单例模式"><a href="#3-2-DCL-单例模式" class="headerlink" title="3.2 DCL 单例模式"></a>3.2 DCL 单例模式</h4><p>Double Check Lock 两次检查，中间插入一个lock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LHan &#123;</span><br><span class="line">    private static volatile LHan instance; // 必须要加 volatile</span><br><span class="line">    private LHan()&#123;&#125;</span><br><span class="line">    public static LHan getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123; // 这一层判断是为了提高效率。锁竞争很耗费时间和效率，避免多个线程每一次getInstance都要进入到同步代码块</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new LHan();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能会存在，A在第一层判断结束后停住，B进入同步代码块，new一个对象实例，进行一定操作后，把instance置为null，然后A进入同步代码块，会再次new一个对象。解决：添加版本号。</p><h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4. 静态内部类"></a>4. 静态内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class SingletionHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static final Singleton getInstance()&#123;</span><br><span class="line">        return SingletionHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Singleton </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程一些问题</title>
      <link href="/2020/09/28/Thread-5/"/>
      <url>/2020/09/28/Thread-5/</url>
      
        <content type="html"><![CDATA[<h2 id="线程一些问题"><a href="#线程一些问题" class="headerlink" title="线程一些问题"></a>线程一些问题</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>单线程和多线程 表象化的一种理解：线程就是程序执行的路径，单线程就是只有一条路径，多线程就是多条路径</p><p>进程：一个程序装载到内存里，分配好资源如网络等等。是分配资源的最基本单位</p><p>线程：程序开始运行，将一条条指令放到cpu里执行。是调度执行的最基本单位</p><p>CPU：ALU（算术逻辑单元，负责计算） + Registers（寄存器，存储数据） + PC（计数器，记录执行到哪一条指令，记录指令地址）</p><p>一个核在同一时刻只能运行一个线程。<br>但是目前也存在线程撕裂者，即超线程：由于ALU速度大于Registers，所以如果一个ALU搭配一套Registers+PC即是一个线程，如果一个ALU搭配两套Registers+PC就是超线程，省略了线程上下文切换的时间。</p><p>线程切换（上下文切换）：运行T1线程时，会把T1的数据放入寄存器中计算，如果时间到了需要切换时，会把T1的数据地址等等放入到缓存中，把T2的数据放入到寄存器中</p><p>线程数并不是越大越好，因为CPU要保证所有的线程都有执行的机会，会浪费很多时间在线程切换上。</p><p>哪怕是单核CPU设置多线程也有意义。多线程是为了提高CPU利用效率，一个程序并不是全部时刻都在占用CPU。</p><h3 id="2-线程的可见性"><a href="#2-线程的可见性" class="headerlink" title="2. 线程的可见性"></a>2. 线程的可见性</h3><p>一个线程对共享变量值的修改，能够及时的被其他线程看到。</p><p>JVM中关于各种变量（线程共享变量）的访问规则</p><ol><li>所有的变量都存储在主内存中。</li><li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）。</li><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li><li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量的传递需要通过主内存来完成。</li></ol><p>原理：<br>线程1对共享变量的修改要想被线程2及时看到</p><ol><li>把工作内存1中更新过的共享变量刷新到主内存中</li><li>将主内存中最新的共享变量的值更新到工作内存2中</li></ol><p>实现方式：</p><ol><li>synchronized</li><li>volatile</li></ol><p><img src="https://images.weserv.nl/?url=https://img-blog.csdn.net/20180402191722152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnUxMjMxMjNmdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="pic1"></p><h4 id="2-1-synchronized-实现可见性以及原子性"><a href="#2-1-synchronized-实现可见性以及原子性" class="headerlink" title="2.1 synchronized 实现可见性以及原子性"></a>2.1 synchronized 实现可见性以及原子性</h4><p>JMM关于synchronized的两条规定：</p><ol><li>线程解锁前（退出synchronized代码块之前），必须把共享变量的最新值刷新到主内存中，也就是说线程退出synchronized代码块值后，主内存中保存的共享变量的值已经是最新的了</li><li>线程加锁时（进入synchronized代码块之后），将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li></ol><p>两者结合：线程解锁前对共享变量的修改在下次加锁时对其他线程可见</p><p>根据以上推出线程执行互斥代码的过程：<br>1.获得互斥锁（进入synchronized代码块）<br>2.清空工作内存<br>3.从主内存拷贝变量的最新副本到工作内存<br>4.执行代码<br>5.将更改后的共享变量的值刷新到主内存<br>6.释放互斥锁（退出synchronized代码块）</p><h4 id="2-2-volatile-实现可见性"><a href="#2-2-volatile-实现可见性" class="headerlink" title="2.2 volatile 实现可见性"></a>2.2 volatile 实现可见性</h4><p>volatile 特性：</p><ol><li>能够保证volatile变量的可见性</li><li>不能保证volatile变量复合操作的原子性</li></ol><p>如何实现内存的可见性？</p><ol><li>对volatile变量执行写操作时，会在写操作后加入一条store屏障指令 =&gt; <strong>写后存(store)</strong></li><li>对volatile变量执行读操作时，会在读操作前加入一条load屏障指令 =&gt; <strong>读前读(load)</strong></li></ol><p>通俗的讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</p><p>为什么不能保证volatile变量复合操作的原子性？<br>通俗的讲，volatile不能加锁，对number++;的操作会被多个线程交叉执行，导致出现不同的结果</p><h4 id="2-4-synchronized-和-volatile-区别"><a href="#2-4-synchronized-和-volatile-区别" class="headerlink" title="2.4 synchronized 和 volatile 区别"></a>2.4 synchronized 和 volatile 区别</h4><ol><li>volatile 不需要加锁，更轻量级</li><li>volatile 只保证可见性，不保证原子性</li></ol><h3 id="3-线程的-as-if-serial"><a href="#3-线程的-as-if-serial" class="headerlink" title="3. 线程的 as-if-serial"></a>3. 线程的 as-if-serial</h3><p>这个主要针对的是单线程。多线程肯定不能保证顺序。</p><p>单线程 as-if-serial 语义 – 单线程两条语句，并不一定按顺序执行。但是重排序必须保证最后执行结果的一致性。</p><p>原因：有的指令执行不占用cpu，但是耗时长；有的指令占用cpu，耗时短。</p><h4 id="3-1-指令重排序与内存屏障"><a href="#3-1-指令重排序与内存屏障" class="headerlink" title="3.1 指令重排序与内存屏障"></a>3.1 指令重排序与内存屏障</h4><p>代码书写的顺序与实际执行的顺序不同，原因是编译器或处理器为了提高程序性能而做的优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">编译器重排</span><br><span class="line">// 优化前</span><br><span class="line">int x = 1;</span><br><span class="line">int y = 2;</span><br><span class="line">int a1 = x * 1;</span><br><span class="line">int b1 = y * 1;</span><br><span class="line">int a2 = x * 2;</span><br><span class="line">int b2 = y * 2;</span><br><span class="line"></span><br><span class="line">// 优化后</span><br><span class="line">int x = 1;</span><br><span class="line">int y = 2;</span><br><span class="line">int a1 = x * 1;</span><br><span class="line">int a2 = x * 2;</span><br><span class="line">int b1 = y * 1;</span><br><span class="line">int b2 = y * 2;</span><br><span class="line">CPU只读一次的x和y值。不需反复读取寄存器来交替x和y值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">处理器重排</span><br><span class="line">// 初始化</span><br><span class="line">int a = 0;</span><br><span class="line">int b = 0;</span><br><span class="line">int x = 0;</span><br><span class="line">int y = 0;</span><br><span class="line"></span><br><span class="line">// 处理器A执行</span><br><span class="line">a = 1;</span><br><span class="line">x = b;</span><br><span class="line">// 处理器B执行</span><br><span class="line">b = 2;</span><br><span class="line">y = a;</span><br></pre></td></tr></table></figure><p><img src="https://images.weserv.nl/?url=https://upload-images.jianshu.io/upload_images/9930763-bec61c919d66e2db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/663/format/webp" alt="pic2"></p><p>变量全部存储在主内存。a=1 这个操作在A处理器本地缓存中处理，此时a变量最新的值没有刷新到主内存中，此时B处理器从主内存中读a的值就会返回0。同理y也可能被赋值为0。</p><p>针对这种情况，处理器提供四种内存屏障 – LoadLoadBarrier、StoreStoreBarrier、LoadStoreBarrier、StoreLoadBarrier。Load是读，Store是写。屏障前的指令必须全部执行完，才能执行屏障后的指令。</p><h3 id="4-对象的创建过程"><a href="#4-对象的创建过程" class="headerlink" title="4. 对象的创建过程"></a>4. 对象的创建过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class T&#123;</span><br><span class="line">    int m = 8;</span><br><span class="line">&#125;</span><br><span class="line">T t = new T();</span><br></pre></td></tr></table></figure><p>对应的汇编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 new #2 &lt;T&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 invokespecial #3 &lt;T.&lt;init&gt;&gt;</span><br><span class="line">7 astore_1</span><br><span class="line">8 return</span><br></pre></td></tr></table></figure><p><code>0 new #2 &lt;T&gt;</code> 负责在内存中申请一块内存，此时成员变量都是默认值，即m=0<br><code>4 invokespecial #3 &lt;T.&lt;inti&gt;&gt;</code> 执行初始化，此时m=8<br><code>7 astore_1</code> 建立t和T的关联关系</p><h3 id="4-DCL-单例模式需要加-volatile-吗"><a href="#4-DCL-单例模式需要加-volatile-吗" class="headerlink" title="4. DCL 单例模式需要加 volatile 吗"></a>4. DCL 单例模式需要加 volatile 吗</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LHan &#123;</span><br><span class="line">    private static volatile LHan instance; // 必须要加 volatile</span><br><span class="line">    private LHan()&#123;&#125;</span><br><span class="line">    public static LHan getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123; // 这一层判断是为了提高效率。锁竞争很耗费时间和效率，避免多个线程每一次getInstance都要进入到同步代码块</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new LHan();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-对象的创建过程"><a href="#4-1-对象的创建过程" class="headerlink" title="4.1 对象的创建过程"></a>4.1 对象的创建过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class T&#123;</span><br><span class="line">    int m = 8;</span><br><span class="line">&#125;</span><br><span class="line">T t = new T();</span><br></pre></td></tr></table></figure><p>对应的汇编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 new #2 &lt;T&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 invokespecial #3 &lt;T.&lt;init&gt;&gt;</span><br><span class="line">7 astore_1</span><br><span class="line">8 return</span><br></pre></td></tr></table></figure><p><code>0 new #2 &lt;T&gt;</code> 负责在内存中申请一块内存，此时成员变量都是默认值，即m=0<br><code>4 invokespecial #3 &lt;T.&lt;inti&gt;&gt;</code> 执行初始化，此时m=8<br><code>7 astore_1</code> 建立t和T的关联关系</p><h4 id="4-2-必须要加-volatile-的原因"><a href="#4-2-必须要加-volatile-的原因" class="headerlink" title="4.2 必须要加 volatile 的原因"></a>4.2 必须要加 volatile 的原因</h4><p>A -&gt; getInstance -&gt; new 一个对象，在创建过程中，如果指令发生重排，即先执行了 <code>0 new #2 &lt;T&gt;</code>，然后 <code>7 astore_1</code> 和 <code>4 invokespecial #3 &lt;T.&lt;inti&gt;&gt;</code> 发生重排，此时 instance 不为null，但是变量均为默认值</p><p>B -&gt; getInstance -&gt; 不为null，直接返回，获取到的变量值为默认值，会发生错误</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phoenix创建索引源码过程</title>
      <link href="/2020/09/27/Phoenix-3/"/>
      <url>/2020/09/27/Phoenix-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Phoenix创建索引源码过程"><a href="#Phoenix创建索引源码过程" class="headerlink" title="Phoenix创建索引源码过程"></a>Phoenix创建索引源码过程</h2><p>org.apache.phoenix.index.IndexMaintainer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public byte[] buildRowKey(ValueGetter valueGetter, ImmutableBytesWritable rowKeyPtr, byte[] regionStartKey, byte[] regionEndKey, long ts)  &#123;</span><br><span class="line">    ImmutableBytesWritable ptr = new ImmutableBytesWritable();</span><br><span class="line"></span><br><span class="line">//判断是否是构建本地索引，考虑两个条件：1.本地索引是否开启 2.startRK 是否传进来了</span><br><span class="line">    boolean prependRegionStartKey = isLocalIndex &amp;&amp; regionStartKey != null;</span><br><span class="line">    boolean isIndexSalted = !isLocalIndex &amp;&amp; nIndexSaltBuckets &gt; 0;</span><br><span class="line"></span><br><span class="line">//如果开启本地索引，则在数据前面添加前缀，判断startRK是否是region起始startRK，如果是则使用该region的EndRK</span><br><span class="line">    int prefixKeyLength =</span><br><span class="line">            prependRegionStartKey ? (regionStartKey.length != 0 ? regionStartKey.length</span><br><span class="line">                    : regionEndKey.length) : 0;</span><br><span class="line">    TrustedByteArrayOutputStream stream = new TrustedByteArrayOutputStream(estimatedIndexRowKeyBytes + (prependRegionStartKey ? prefixKeyLength : 0));</span><br><span class="line"></span><br><span class="line">// 构建数据流对象，对数据进行put</span><br><span class="line">    DataOutput output = new DataOutputStream(stream);</span><br></pre></td></tr></table></figure><p>如果是本地索引，则在rowkey前加入startrowkey索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// For local indexes, we must prepend the row key with the start region key</span><br><span class="line">if (prependRegionStartKey) &#123;</span><br><span class="line">    if (regionStartKey.length == 0) &#123;</span><br><span class="line">        // 如果startRK为null，则其实使用的endRK</span><br><span class="line">        output.write(new byte[prefixKeyLength]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        output.write(regionStartKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否有加盐，如果有，则增加一个标志位，后面再更改这个标志位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (isIndexSalted) &#123;</span><br><span class="line">    output.write(0); // will be set at end to index salt byte</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在索引视图id不为null，会在索引rowkey中加入视图id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (viewIndexId != null) &#123;</span><br><span class="line">    output.write(viewIndexId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dataRowKeySchema是数据表的信息，忽略在视图变量的中常量值，并标记出原表pk的rowkey的offset 和 length，方便后面定位数据表rowkey插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for (int i = dataPosOffset; i &lt; dataRowKeySchema.getFieldCount(); i++) &#123;</span><br><span class="line">    Boolean hasValue=dataRowKeySchema.next(ptr, i, maxRowKeyOffset);</span><br><span class="line">    // Ignore view constants from the data table, as these</span><br><span class="line">    // don&apos;t need to appear in the index (as they&apos;re the</span><br><span class="line">    // same for all rows in this index)</span><br><span class="line">    if (!viewConstantColumnBitSet.get(i)) &#123;</span><br><span class="line">        int pos = rowKeyMetaData.getIndexPkPosition(i-dataPosOffset);</span><br><span class="line">        if (Boolean.TRUE.equals(hasValue)) &#123;</span><br><span class="line">            dataRowKeyLocator[0][pos] = ptr.getOffset();</span><br><span class="line">            dataRowKeyLocator[1][pos] = ptr.getLength();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dataRowKeyLocator[0][pos] = 0;</span><br><span class="line">            dataRowKeyLocator[1][pos] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑索引的数据的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 获取表达式索引，表达式索引默认值都为1，未开启的时候isNullAble为true</span><br><span class="line"></span><br><span class="line">Iterator&lt;Expression&gt; expressionIterator = indexedExpressions.iterator();</span><br><span class="line"></span><br><span class="line">//  nIndexedColumns 的构成是索引列+主键 如果是组合索引，则循环多个索引列</span><br><span class="line">for (int i = 0; i &lt; nIndexedColumns; i++) &#123;</span><br><span class="line">    PDataType dataColumnType;</span><br><span class="line">    boolean isNullable;</span><br><span class="line">    SortOrder dataSortOrder;</span><br><span class="line"></span><br><span class="line">// dataPkPosition为-1则表示为表达式索引，否则为属性索引</span><br><span class="line">    if (dataPkPosition[i] == EXPRESSION_NOT_PRESENT) &#123;</span><br><span class="line">       Expression expression = expressionIterator.next();</span><br><span class="line">       dataColumnType = expression.getDataType();</span><br><span class="line">       dataSortOrder = expression.getSortOrder();</span><br><span class="line">        isNullable = expression.isNullable();</span><br><span class="line">       expression.evaluate(new ValueGetterTuple(valueGetter, ts), ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//  主键pk 走这个分支</span><br><span class="line">    else &#123;</span><br><span class="line">        Field field = dataRowKeySchema.getField(dataPkPosition[i]);</span><br><span class="line">        dataColumnType = field.getDataType();</span><br><span class="line">        ptr.set(rowKeyPtr.get(), dataRowKeyLocator[0][i], dataRowKeyLocator[1][i]);</span><br><span class="line">        dataSortOrder = field.getSortOrder();</span><br><span class="line">        isNullable = field.isNullable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 考虑列值的顺序，考虑字节的比较，考虑索引列的顺序</span><br><span class="line"></span><br><span class="line">// 判断查询是否desc，默认为asc。</span><br><span class="line">    boolean isDataColumnInverted = dataSortOrder != SortOrder.ASC;</span><br><span class="line"></span><br><span class="line">// 获取索引列的的数据类型，详情看后面getIndexColumnDataType函数</span><br><span class="line">    PDataType indexColumnType = IndexUtil.getIndexColumnDataType(isNullable, dataColumnType);</span><br><span class="line"></span><br><span class="line">//根据数据列返回不同的datatype，判断该列是否可比较。不可比较的列有decimal，varchar，boolean，Binary</span><br><span class="line">    boolean isBytesComparable = dataColumnType.isBytesComparableWith(indexColumnType);</span><br><span class="line"></span><br><span class="line">// 获取列是否是逆序的</span><br><span class="line">    boolean isIndexColumnDesc = descIndexColumnBitSet.get(i);</span><br><span class="line">    if (isBytesComparable &amp;&amp; isDataColumnInverted == isIndexColumnDesc) &#123;</span><br><span class="line">        output.write(ptr.get(), ptr.getOffset(), ptr.getLength());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!isBytesComparable)  &#123;</span><br><span class="line"></span><br><span class="line">// 让不可比较的类型具有可比性</span><br><span class="line">            indexColumnType.coerceBytes(ptr, dataColumnType, dataSortOrder, SortOrder.getDefault());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 按位取异或值，二进制数比较肯定是字典序，从最高位开始比较，直到遇到第一个不一样的位，这个位上哪个数等于1哪个数就较大。 </span><br><span class="line">        if (isDataColumnInverted != isIndexColumnDesc) &#123;</span><br><span class="line">            writeInverted(ptr.get(), ptr.getOffset(), ptr.getLength(), output);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            output.write(ptr.get(), ptr.getOffset(), ptr.getLength());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 判断数据是不是一个固定长度的字段，如果不是根据数据的正序逆序添加一个标志位</span><br><span class="line">    if (!indexColumnType.isFixedWidth()) &#123;</span><br><span class="line">        output.writeByte(SchemaUtil.getSeparatorByte(rowKeyOrderOptimizable, ptr.getLength() == 0, isIndexColumnDesc ? SortOrder.DESC : SortOrder.ASC));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充开始的加盐部分的字节位，规则是根据数据做hash，然后再对nIndexSaltBuckets取余</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (isIndexSalted) &#123;</span><br><span class="line">    // Set salt byte</span><br><span class="line">    byte saltByte = SaltingUtil.getSaltingByte(indexRowKey, SaltingUtil.NUM_SALTING_BYTES, length-SaltingUtil.NUM_SALTING_BYTES, nIndexSaltBuckets);</span><br><span class="line">    indexRowKey[0] = saltByte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回所有的生成的rowkey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return indexRowKey.length == length ? indexRowKey : Arrays.copyOf(indexRowKey, length);</span><br></pre></td></tr></table></figure><p>根据数据列返回不同的datatype，判断该列是否可比较。不可比较的列有decimal，varchar，boolean，Binary等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Since we cannot have nullable fixed length in a row key</span><br><span class="line">// we need to translate to variable length. The verification that we have a valid index</span><br><span class="line">// row key was already done, so here we just need to convert from one built-in type to</span><br><span class="line">// another.</span><br><span class="line">public static PDataType getIndexColumnDataType(boolean isNullable, PDataType dataType) &#123;</span><br><span class="line">    if (dataType == null || !isNullable || !dataType.isFixedWidth()) &#123;</span><br><span class="line">        return dataType;</span><br><span class="line">    &#125;</span><br><span class="line">    // for fixed length numeric types and boolean</span><br><span class="line">    if (dataType.isCastableTo(PDecimal.INSTANCE)) &#123;</span><br><span class="line">        return PDecimal.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    // for CHAR</span><br><span class="line">    if (dataType.isCoercibleTo(PVarchar.INSTANCE)) &#123;</span><br><span class="line">        return PVarchar.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PBinary.INSTANCE.equals(dataType)) &#123;</span><br><span class="line">        return PVarbinary.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Unsupported non nullable type &quot; + dataType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让数据有可比性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected static int toBytes(BigDecimal v, byte[] result, final int offset, int length) &#123;</span><br><span class="line">    // From scale to exponent byte (if BigDecimal is positive): (-(scale+(scale % 2 == 0 : 0 : 1)) / 2 + 65) | 0x80</span><br><span class="line">    // If scale % 2 is 1 (i.e. it&apos;s odd), then multiple last base-100 digit by 10</span><br><span class="line">    // For example: new BigDecimal(BigInteger.valueOf(1), -4);</span><br><span class="line">    // (byte)((-(-4+0) / 2 + 65) | 0x80) = -61</span><br><span class="line">    // From scale to exponent byte (if BigDecimal is negative): ~(-(scale+1)/2 + 65 + 128) &amp; 0x7F</span><br><span class="line">    // For example: new BigDecimal(BigInteger.valueOf(1), 2);</span><br><span class="line">    // ~(-2/2 + 65 + 128) &amp; 0x7F = 63</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Phoenix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Phoenix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 搭建 Redis 集群</title>
      <link href="/2020/09/24/Redis-2/"/>
      <url>/2020/09/24/Redis-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Mac-搭建-Redis-集群"><a href="#Mac-搭建-Redis-集群" class="headerlink" title="Mac 搭建 Redis 集群"></a>Mac 搭建 Redis 集群</h2><p><a href="https://www.jianshu.com/p/e5b046b8dcbf" target="_blank" rel="noopener">参考文档</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>安装docker<br>brew cask install docker</p><p>在设置里选择 Docker Engine，添加国内下载镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://hub-mirror.c.163.com/&quot;,</span><br><span class="line">    &quot;https://reg-mirror.qiniu.com&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;experimental&quot;: false,</span><br><span class="line">  &quot;debug&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd redis-cluster</span><br><span class="line">git clone https://github.com/carwestsam/redis-cluster-in-docker-osx.git</span><br></pre></td></tr></table></figure><p>自动下载redis集群项目到目录下，该项目会自动添加到docker文件中</p><figure class="highlight plain"><figcaption><span>redis-cluster-in-docker-osx```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改每一个端口文件下redis.conf文件，注释掉密码</span><br></pre></td></tr></table></figure><h1 id="requirepass-“myredis”"><a href="#requirepass-“myredis”" class="headerlink" title="requirepass “myredis”"></a>requirepass “myredis”</h1><h1 id="masterauth-“myredis”"><a href="#masterauth-“myredis”" class="headerlink" title="masterauth “myredis”"></a>masterauth “myredis”</h1><pre><code>修改start.sh文件，去掉 --password myredis 避免密码验证`bash start.sh` 启动项目会自动下载需要的文件`redis-cli -c -p 7000` 进入到redis命令行</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java.util.function 包</title>
      <link href="/2020/09/21/Function-1/"/>
      <url>/2020/09/21/Function-1/</url>
      
        <content type="html"><![CDATA[<h2 id="java-util-function-包"><a href="#java-util-function-包" class="headerlink" title="java.util.function 包"></a>java.util.function 包</h2><h3 id="1-Function"><a href="#1-Function" class="headerlink" title="1. Function"></a>1. Function</h3><p>接收一个参数，并返回一个结果</p><h3 id="2-BiFunction"><a href="#2-BiFunction" class="headerlink" title="2. BiFunction"></a>2. BiFunction</h3><p>接收两个参数，并返回一个结果</p><h3 id="3-BinaryOperator"><a href="#3-BinaryOperator" class="headerlink" title="3. BinaryOperator"></a>3. BinaryOperator</h3><p>二元操作符，根据两个参数来返回一个计算结果。继承 BiFunction，具体写法上会更加简单，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Integer&gt; func = (n1, n2) -&gt; n1 + n2;</span><br><span class="line">func.apply(1, 2);</span><br></pre></td></tr></table></figure><p>apply 就相当于是一个传参的过程，具体返回结果需要看 func 具体实现过程。</p><p>默认函数里实现了 minBy / maxBy 两种，可以自己实现 Comparator 然后传到方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) &#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        return (a, b) -&gt; comparator.compare(a, b) &gt;= 0 ? a : b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-Predicate"><a href="#4-Predicate" class="headerlink" title="4. Predicate"></a>4. Predicate</h3><p>对某种类型的数据进行判断，从而得到一个boolean值结果</p><h4 id="4-1-test"><a href="#4-1-test" class="headerlink" title="4.1 test"></a>4.1 test</h4><p>Predicate 接口中包含一个抽象方法: boolean test(T t) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class Demo01Predicate &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method(s -&gt; s.length() &gt; 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method(Predicate&lt;String&gt; predicate) &#123;</span><br><span class="line">        boolean veryLong = predicate.test(&quot;HelloWorld&quot;);</span><br><span class="line">        System.out.println(&quot;字符串很长吗:&quot; + veryLong); // 字符串很长吗:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断的标准是传入的Lambda表达式逻辑</p><h4 id="4-2-and-与"><a href="#4-2-and-与" class="headerlink" title="4.2 and 与"></a>4.2 and 与</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">源码：</span><br><span class="line">default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    return (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class DemoPredicateAnd &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        boolean isValid = method(</span><br><span class="line">                // String.contains()方法，仅当此字符串包含指定的字符值序列时返回true。</span><br><span class="line">                s -&gt; s.contains(&quot;H&quot;),</span><br><span class="line">                s -&gt; s.contains(&quot;W&quot;)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(&quot;字符串符合要求吗:&quot; + isValid); // 字符串符合要求吗:false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean method(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) &#123;</span><br><span class="line">        boolean isValid = one.and(two).test(&quot;Hello world&quot;);</span><br><span class="line">        return isValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-or-或"><a href="#4-3-or-或" class="headerlink" title="4.3 or 或"></a>4.3 or 或</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">源码：</span><br><span class="line">default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    return (t) -&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-negate-取反"><a href="#4-4-negate-取反" class="headerlink" title="4.4 negate 取反"></a>4.4 negate 取反</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default Predicate&lt;T&gt; negate() &#123;</span><br><span class="line">    return (t) -&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java - JUF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2020/09/18/Redis-1/"/>
      <url>/2020/09/18/Redis-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a href="https://mp.weixin.qq.com/s/jNVJHJOPUv6V9cRU8M75Hw" target="_blank" rel="noopener">参考网址</a></p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p><ul><li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li><li>Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))</li><li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）</li></ul><h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h3><h4 id="2-1-Key-Value"><a href="#2-1-Key-Value" class="headerlink" title="2.1 Key-Value"></a>2.1 Key-Value</h4><p>任何二进制序列都可以作为Redis的Key使用（例如普通的字符串或一张JPEG图片）。</p><ul><li>不要使用过长的Key。例如使用一个1024字节的key就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</li><li>Key短到缺失了可读性也是不好的，例如”u1000flw”比起”user:1000:followers”来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</li><li>最好使用统一的规范来设计Key，比如”object-type:id:attr”，以这一规范设计出的Key可能是”user:1000”或”comment:1234:reply-to”</li><li>Redis允许的最大Key长度是512MB（对Value的长度限制也是512MB）</li></ul><h4 id="2-2-String"><a href="#2-2-String" class="headerlink" title="2.2 String"></a>2.2 String</h4><p>Redis的基础数据类型只有 String。</p><p>与 String 相关的常用命令：</p><ul><li>SET ：为一个key设置value，可以设置过期时间，-1为永久有效，时间复杂度O(1)</li><li>GET ：获取某个key对应的value，时间复杂度O(1)</li><li>GETSET ：为一个key设置value，并返回该key的原value，时间复杂度O(1)</li><li>MSET ：为多个key设置value，时间复杂度O(N) -&gt; 参数为 <code>Map&lt;byte[], byte[]&gt;</code> <ul><li>底层实现的时候还是for循环一个个set进去，mset和set的效率差别在是否需要销毁连接，通过pipeline的方式可以一次性发送过去多条指令，但是通过连接池实现时连接会一直存在，此时的效率差距就不是很大了</li><li>由于底层是for循环，那么根据数据的key，计算出槽位，按照槽位来分组，通过 ParallelStream 来并行处理相同槽位的数据，可以提高上下行效率</li></ul></li><li>MSETNX ：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N)</li><li>MGET ：获取多个key对应的value，时间复杂度O(N)</li></ul><p>虽然Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上：</p><ul><li>INCR ：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li><li>INCRBY ：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li><li>DECR/DECRBY ：同INCR/INCRBY，自增改为自减。</li></ul><p>INCR/DECR系列命令要求操作的value类型为String，并可以转换为64位带符号的整型数字，否则会返回错误。也就是说，进行INCR/DECR系列命令的value，必须在[-2^63 ~ 2^63 - 1]范围内。</p><h4 id="2-3-其他存储形式"><a href="#2-3-其他存储形式" class="headerlink" title="2.3 其他存储形式"></a>2.3 其他存储形式</h4><h3 id="3-数据持久化"><a href="#3-数据持久化" class="headerlink" title="3. 数据持久化"></a>3. 数据持久化</h3><h4 id="3-1-RDB"><a href="#3-1-RDB" class="headerlink" title="3.1 RDB"></a>3.1 RDB</h4><p>采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。</p><p>可以在配置文件中配置多个Redis进行快照保存的时机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save [seconds] [changes]</span><br><span class="line">意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存</span><br></pre></td></tr></table></figure><ul><li>RDB的优点：<ul><li>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。</li><li>每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。</li><li>使用RDB文件进行数据恢复比使用AOF要快很多。</li></ul></li><li>RDB的缺点：<ul><li>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</li><li>如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。</li></ul></li></ul><h4 id="3-2-AOF"><a href="#3-2-AOF" class="headerlink" title="3.2 AOF"></a>3.2 AOF</h4><p>采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。</p><p>缺点：恢复速度慢，因为恢复的时候需要遍历日记文件；对一个key不断进行操作，记录多次，有冗余，针对这一点可以对日志冗余的部分进行合并重写</p><h3 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4. 内存管理"></a>4. 内存管理</h3><p>提前预估设置最大内存使用大小，避免无限制占用内存。</p><p>在内存占用达到了maxmemory后，再向Redis写入数据时，Redis会：</p><ul><li>根据配置的数据淘汰策略尝试淘汰数据，释放空间</li><li>如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行</li></ul><p>在为Redis设置maxmemory时，需要注意：</p><ul><li>如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间，如果maxmemory过于接近主机的可用内存，导致数据同步时内存不足。所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。</li></ul><h3 id="5-数据淘汰机制"><a href="#5-数据淘汰机制" class="headerlink" title="5. 数据淘汰机制"></a>5. 数据淘汰机制</h3><p>Redis 提供5种数据淘汰策略：</p><ul><li>volatile-lru：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key</li><li>allkeys-lru：使用LRU算法进行数据淘汰，所有的key都可以被淘汰</li><li>volatile-random：随机淘汰数据，只淘汰设定了有效期的key</li><li>allkeys-random：随机淘汰数据，所有的key都可以被淘汰</li><li>volatile-ttl：淘汰剩余有效期最短的key</li></ul><h3 id="6-PipeLining"><a href="#6-PipeLining" class="headerlink" title="6. PipeLining"></a>6. PipeLining</h3><p>比起多次传输数据不如一次性传输多个数据 =&gt; mset 一次性传输一个map的key-value的效率要高于多次set传输key-value的效率 =&gt; 前提是set返回的结果并不是迫切需要的</p><h3 id="7-性能调优"><a href="#7-性能调优" class="headerlink" title="7. 性能调优"></a>7. 性能调优</h3><p>尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。</p><p>针对Redis的性能优化，主要从下面几个层面入手：</p><ul><li>最初的也是最重要的，确保没有让Redis执行耗时长的命令</li><li>使用pipelining将连续执行的命令组合执行</li><li>操作系统的Transparent huge pages功能必须关闭：<br><code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code></li><li>如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。</li><li>检查数据持久化策略</li><li>考虑引入读写分离机制</li></ul><h3 id="8-长耗时命令"><a href="#8-长耗时命令" class="headerlink" title="8. 长耗时命令"></a>8. 长耗时命令</h3><p>避免使用 O(N) 的指令。</p><h3 id="9-为什么只有16384个槽"><a href="#9-为什么只有16384个槽" class="headerlink" title="9. 为什么只有16384个槽"></a>9. 为什么只有16384个槽</h3><p><a href="https://www.cnblogs.com/rjzheng/p/11430592.html" target="_blank" rel="noopener">参考</a></p><p>客户端请求的key，根据 <code>HASH_SLOT=CRC16(key) mod 16384</code> 计算出需要映射到哪一个分片上，然后 redis 会到相应的节点进行操作。</p><p>CRC16 算法产生的hash值有16bit，该算法可以产生2^16-=65536个值。换句话说，值是分布在0~65535之间。那作者在做mod运算的时候，为什么不mod65536，而选择mod16384？</p><p><a href="https://github.com/antirez/redis/issues/2576" target="_blank" rel="noopener">作者回答</a></p><blockquote><p>The reason is:<br>Normal heartbeat packets carry the full configuration of a node, that can be replaced in an idempotent way with the old in order to update an old config. This means they contain the slots configuration for a node, in raw form, that uses 2k of space with16k slots, but would use a prohibitive 8k of space using 65k slots.<br>At the same time it is unlikely that Redis Cluster would scale to more than 1000 mater nodes because of other design tradeoffs.<br>So 16k was in the right range to ensure enough slots per master with a max of 1000 maters, but a small enough number to propagate the slot configuration as a raw bitmap easily. Note that in small clusters the bitmap would be hard to compress because when N is small the bitmap would have slots/N bits set that is a large percentage of bits set.</p></blockquote><p>当两个节点meet之后，会定期进行通信，交换数据信息。这个数据信息包括节点id、ip、端口号以及本节点负责的槽位信息等等。在消息头里最占空间的是 <code>myslots[CLUSTER_SLOTS/8]</code>，大小为 <code>16384÷8÷1024=2kb</code>，myslots 是一个char数组，每一位代表一个槽，该位为1表示这个槽属于这个节点。</p><p>数据消息体里会携带一定数量的其他节点信息用于交换 =&gt; 节点数量越多，消息体内容越大。</p><p>∴ 如果槽位过多，那么消息体占的内容越大，65536个槽对应8k，浪费带宽；同时也不会有太多的节点，16384足够用</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phoenix的一些问题</title>
      <link href="/2020/09/10/Phoenix-2/"/>
      <url>/2020/09/10/Phoenix-2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Phoenix索引"><a href="#1-Phoenix索引" class="headerlink" title="1. Phoenix索引"></a>1. Phoenix索引</h3><ul><li><p>全局索引：适合读多写少的场景。写数据时因为索引表分布在不同数据节点，跨节点数据传输带来巨大的性能消耗。</p><ul><li>全局索引必须是查询语句中所有列都包含在全局索引中，它才会生效。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create index my_index on my_table (v3);</span><br><span class="line">select v1 from my_table where v3 = &apos;13406157616&apos;;</span><br><span class="line">此时不会走索引，因为检索列不在全局索引中，有以下三种方法使它使用索引：</span><br><span class="line">1. 使用覆盖索引</span><br><span class="line">CREATE INDEX cover_index ON my_table(v3) INCLUDE (v1);</span><br><span class="line">2. 使用 Hint 强制索引</span><br><span class="line">SELECT /*+ INDEX(my_table my_index) */ v1 FROM my_table WHERE v3 = &apos;13406157616&apos;;</span><br><span class="line">3. 使用本地索引</span><br><span class="line">CREATE LOCAL INDEX local_index on my_table (v3);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>本地索引：适合读少写多的场景。在本地生成一个索引表。</p></li><li><p>覆盖索引：配合全局索引使用，避免回表查询。</p></li><li><p>函数索引：适合拼接式字符串查询？。</p></li></ul><p>创建索引的时候有可能因为表的数据量过大，导致索引表的数据量过大，导致发生超时异常，创建出来的索引表不完整，此时可以通过异步索引创建来解决 – 在创建索引的语句最后添加一个 async，执行语句会直接返回结果，但是索引表状态是处于building。</p><p>每一个put/delete操作执行前，会先写入到主表的 Write Ahead Log (WAL) 中，如果出现HBase服务器宕机，则可以从WAL中回放执行之前没有完成的操作，用来保证高并发、持久化的日志保存与回放机制。因为索引表的更新可能会落后于主表一小部分。</p><p><a href="https://images.weserv.nl/?url=https://images2015.cnblogs.com/blog/668023/201608/668023-20160825165419007-57626050.png" target="_blank" rel="noopener">HBase WAL架构</a></p><p>WAL日志文件使用的是Hadoop Sequence文件格式，其主要特点：</p><ol><li>二进制格式。row key, family, qualifier, timestamp, value等HBase byte[]数据，都原封不动地顺序写入文件。</li><li>Sequence文件中，每隔若干行，会插入一个16字节的魔数作为分隔符。这样如果文件损坏，导致某一行残缺不全，可以通过这个魔数分隔符跳过这一行，继续读取下一个完整的行。</li><li>支持压缩。可以按行压缩。也可以按块压缩（将多行打成一个块）</li></ol><h3 id="2-Phoenix加盐"><a href="#2-Phoenix加盐" class="headerlink" title="2. Phoenix加盐"></a>2. Phoenix加盐</h3><p>加盐的目的是为了让数据分散到不同机器，缓解查询压力</p><p>如果行键即数据，单调增加，那么数据会分布在一个region里，可能会造成热点问题 =&gt; 通过添加 SALT_BUCKETS = Num(0 – 256) 来对行键添加一个字节，使得数据能更均匀分布到各个region中。</p><p>其中0是关闭对数据表添加了盐分的索引的盐析的一种特殊方式（因为默认情况下，索引与其数据表具有相同数量的盐桶）</p><p>由于加盐表不会顺序存储数据，因此严格的顺序扫描不会以自然排序的方式返回所有数据。强制进行顺序扫描的子句（例如带有LIMIT的子句）可能会返回与普通表不同的数据顺序。</p><p>new_row_key = (++index % BUCKETS_NUMBER) + original_key</p><h3 id="3-主键查询"><a href="#3-主键查询" class="headerlink" title="3. 主键查询"></a>3. 主键查询</h3><p>通过关键字 <code>!primarykeys table</code> 或者下面这段查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">TENANT_ID TABLE_CAT,TABLE_SCHEM,TABLE_NAME ,COLUMN_NAME,KEY_SEQ,PK_NAME,CASE WHEN SORT_ORDER = 1 THEN &apos;D&apos; ELSE &apos;A&apos; END ASC_OR_DESC,ExternalSqlTypeId(DATA_TYPE) AS DATA_TYPE,SqlTypeName(DATA_TYPE) AS TYPE_NAME,COLUMN_SIZE,DATA_TYPE TYPE_ID,VIEW_CONSTANT from SYSTEM.&quot;CATALOG&quot; &quot;SYSTEM.TABLE&quot; where</span><br><span class="line">TABLE_SCHEM = &apos;MODEL_GROUP_RULE_ACCOUNT_TEST&apos;</span><br><span class="line">and TABLE_NAME = &apos;ECEJ_CALLING_CENTER_H&apos;</span><br><span class="line">and COLUMN_NAME is not null</span><br><span class="line">and COLUMN_FAMILY is null</span><br><span class="line">order by TENANT_ID,TABLE_SCHEM,TABLE_NAME ,COLUMN_NAME</span><br></pre></td></tr></table></figure><h3 id="4-修改字段长度"><a href="#4-修改字段长度" class="headerlink" title="4. 修改字段长度"></a>4. 修改字段长度</h3><p>当创建好phoenix的表后， 默认情况下phoenix不允许修改字段类型和长度。但是可以通过直接修改 SYSTEM.CATALOG 里的数据达到目的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upsert into SYSTEM.CATALOG (TENANT_ID,TABLE_SCHEM,TABLE_NAME,COLUMN_NAME,COLUMN_FAMILY,DATA_TYPE,COLUMN_SIZE) values(&apos;&apos;,&apos;库&apos;,&apos;表&apos;,&apos;字段&apos;,&apos;0&apos;,12,50);</span><br></pre></td></tr></table></figure><blockquote><p>注意 data_type 和 column_size<br>数据类型的转换在 org.apache.phoenix.schema.types</p></blockquote><p>测试发现，即使上面的上SQL执行成功，重新执行 upsert 往表里插入数据，DEBIT_AMOUNT(初始长度6)超过初始长度的还是不能成功</p><p>经过查看源码发现，在 <code>SYSTEM.CATALOG</code> 上有协处理器， 这个里面有表元数据缓存，默认要三个小时过期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.phoenix.cache.GlobalCache</span><br><span class="line">long maxTTL = this.config.getLong(&quot;phoenix.coprocessor.maxMetaDataCacheTimeToLiveMs&quot;, 1800000L);</span><br><span class="line">          long maxSize = this.config.getLong(&quot;phoenix.coprocessor.maxMetaDataCacheSize&quot;, 20971520L);</span><br></pre></td></tr></table></figure><p>猜想修改长度后三小时能生效<br>或者在<code>hbase shell</code> 中 先 <code>disable SYSTEM.CATALOG</code>, 然后在 <code>enable SYSTEM.CATALOG</code></p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Phoenix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Phoenix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2020/09/10/MySQL-1/"/>
      <url>/2020/09/10/MySQL-1/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p><a href="https://mp.weixin.qq.com/s/ygsG_B4fQmSxNinIpAq72A" target="_blank" rel="noopener">参考文档</a></p><h3 id="1-多页结构"><a href="#1-多页结构" class="headerlink" title="1. 多页结构"></a>1. 多页结构</h3><p>OS存储数据按页来存储，一页是4KB，读取数据也是一次读一页，原因是程序局部性的概念，大意是“一个程序在访问了一条数据之后，在之后会有极大的可能再次访问这条数据和访问这条数据的相邻数据”。</p><p>MySQL的InnoDb引擎中，一页是16KB。页内部存储数据是采用了链表的结构，链表的查询很慢，采用的优化措施就是在每一页添加页目录。每个目录项会存放自己这个目录项当中最小的id，在查询时先找在哪个目录，然后再逐条查找。而这种方式能成立的原因在于数据库在用户插入数据时会默认按照主键排序，否则按照页目录来查找就会出现问题。</p><p>在开辟新页的时候，我们插入的数据不一定是放在新开辟的页上，而是要进行所有页的数据比较，来决定这条插入的数据放在哪一页上，而完成数据插入之后，最终的多页结构就会如下：</p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueceu5zyASlL2O8XwIduorm2ASuQc426uLBf1IAeqbMBGrMtDwB55ibicUwfmZdN1GG7icRLgqiaKCMdA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="多页结构"></p><p>页与页之间通过指针关联，也算是链表结构，所以在多页查询时也会出现查询效率低的情况。优化方式和页内部数据的优化一样，即创建一个目录页来管理页，存放的是页的地址以及这一页中最小的数据。</p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueceu5zyASlL2O8XwIduormFthFItV6J6tnB4hLP4SwIH2aibRlJiaThrEkoAFVejkyyMjJNr9CsrXQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="最终版多页结构"></p><p>在查询时先在目录页中查询，对比最小地址，找到相应页的地址，然后进入到页中查看这一页的目录，找到数据。这个最终的结构就是B+树。</p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueceu5zyASlL2O8XwIduormSzm8lME2RWyXPmuMyMCficTFbJBelrsibZM2CuBIObo7PicEGFSc7tFOQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="转为B+树结构"></p><p>其中的每个节点就可以理解为是一个页，而叶子节点也就是数据页，除了叶子节点以外的节点就是目录页。</p><p>B+树的优势：</p><ol><li>由于叶子节点上存放了所有的数据，并且有指针相连，每个叶子节点在逻辑上是相连的，所以对于范围查找比较友好。</li><li>B+树的所有数据都在叶子节点上，所以B+树的查询效率稳定，一般都是查询3次。</li><li>B+树有利于数据库的扫描。</li><li>B+树有利于磁盘的IO，因为他的层高基本不会因为数据扩大而增高（三层树结构大概可以存放两千万数据量。）</li></ol><h3 id="2-页的结构"><a href="#2-页的结构" class="headerlink" title="2. 页的结构"></a>2. 页的结构</h3><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_jpg/eQPyBffYbueceu5zyASlL2O8XwIduorm6rweXEicm7ECh5QVAJWf0cbJZUqn5vV3W4qFYhCIibKQHum4NVZMdlng/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p><p>File Header 字段用于记录 Page 的头信息，其中比较重要的是 FIL_PAGE_PREV 和 FIL_PAGE_NEXT 字段，通过这两个字段，我们可以找到该页的上一页和下一页，实际上所有页通过两个字段可以形成一条双向链表。</p><p>Page Header 字段用于记录 Page 的状态信息。接下来的 Infimum 和 Supremum 是两个伪行记录，Infimum（下确界）记录比该页中任何主键值都要小的值，Supremum （上确界）记录比该页中任何主键值都要大的值，这个伪记录分别构成了页中记录的边界。</p><p>User Records 中存放的是实际的数据行记录，具体的行记录结构将在本文的第二节中详细介绍。Free Space 中存放的是空闲空间，被删除的行记录会被记录成空闲空间。Page Directory 记录着与二叉查找相关的信息。File Trailer 存储用于检测数据完整性的校验和等数据。</p><h3 id="3-聚簇索引和非聚簇索引"><a href="#3-聚簇索引和非聚簇索引" class="headerlink" title="3. 聚簇索引和非聚簇索引"></a>3. 聚簇索引和非聚簇索引</h3><p>所谓聚簇索引，就是将索引和数据放到一起，找到索引也就找到了数据，我们刚才看到的B+树索引就是一种聚簇索引，而非聚簇索引就是将数据和索引分开，查找时需要先查找到索引，然后通过索引回表找到相应的数据。InnoDB有且只有一个聚簇索引，而MyISAM中都是非聚簇索引。</p><h3 id="4-联合索引的最左前缀匹配原则"><a href="#4-联合索引的最左前缀匹配原则" class="headerlink" title="4. 联合索引的最左前缀匹配原则"></a>4. 联合索引的最左前缀匹配原则</h3><p>多个字段建立的联合索引，只要有主键，就是一个聚簇索引；其他索引都是非聚簇索引，在叶子节点里不在有数据，而是存了一个主键索引，通过主键索引回表查询数据。</p><ul><li>最左前缀匹配原则，MySQL会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如 a=3 and b=4 and c&gt;5 and d=6,如果建立(a,b,c,d)顺序的索引，d是无法使用索引的，如果建立(a,b,d,c)的索引则都可以使用到，a、b、d的顺序可以任意调整。</li><li>=和in可以乱序，比如 a=1 and b=2 and c=3 建立(a,b,c)索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id, age, weight, name 字段 按照age,weight建立一个联合索引 </span><br><span class="line"></span><br><span class="line">SELECT * FROM user where age&gt;1</span><br><span class="line"></span><br><span class="line">这条语句不会走索引，但是可以走索引。这句话是什么意思呢？这条SQL很特殊，由于其存在可以比较的索引，所以它走索引也可以查询出结果，但是由于这种情况是范围查询并且是全字段查询，如果走索引，还需要进行回表，MySQL查询优化器就会认为走索引的效率比全表扫描还要低，所以MySQL会去优化它，让他直接进行全表扫描。</span><br></pre></td></tr></table></figure><blockquote><p>explain 查看执行计划的优化，大概流程如下</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个 。</li></ol></blockquote><h3 id="5-为什么InnoDB只有一个聚簇索引，而不将所有索引都使用聚簇索引？"><a href="#5-为什么InnoDB只有一个聚簇索引，而不将所有索引都使用聚簇索引？" class="headerlink" title="5. 为什么InnoDB只有一个聚簇索引，而不将所有索引都使用聚簇索引？"></a>5. 为什么InnoDB只有一个聚簇索引，而不将所有索引都使用聚簇索引？</h3><p>因为聚簇索引是将索引和数据都存放在叶子节点中，如果所有的索引都用聚簇索引，则每一个索引都将保存一份数据，会造成数据的冗余，在数据量很大的情况下，这种数据冗余是很消耗资源的。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>排序：优化查询的根本，插入时进行排序实际上就是为了优化查询的效率。<br>页：用于减少IO次数，还可以利用程序局部性原理，来稍微提高查询效率。<br>页目录：用于规避链表的软肋，避免在查询时进行链表的扫描。<br>多页：数据量增加的情况下开辟新页来保存数据。<br>目录页：“特殊的页目录”，其中保存的数据是页的地址。查询时可以通过目录页快速定位到页，避免多页的扫描。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2020/09/09/Algorithm-10/"/>
      <url>/2020/09/09/Algorithm-10/</url>
      
        <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1. 红黑树"></a>1. 红黑树</h3><p>数组查询快，链表插入删除快 =&gt; 二叉树兼具两者优点 =&gt; 但是二叉树可能存在特殊情况，即一侧子树非常长，另一侧很短，不平衡 =&gt; 红黑树，即二叉平衡树，是一个去除二叉树顶端优势的解决方案，从而达到树的平衡。</p><p>红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:</p><ol><li>每个节点都有红色或黑色</li><li>树的根始终是黑色的</li><li>没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点）</li><li>从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点</li></ol><p>红黑树两大操作:</p><ol><li>recolor (重新标记黑色或红色)</li><li>rotation (旋转，这是树达到平衡的关键)</li></ol><p>红黑树插入节点过程:</p><ol><li>新插入的节点标记为红色</li><li>如果 X 是根结点(root)，则标记为黑色</li><li>如果 X 的 parent 不是黑色，同时 X 也不是 root:<br> 3.1 如果 X 的 uncle (叔叔) 是红色<br> 3.1.1 将 parent 和 uncle 标记为黑色<br> 3.1.2 将 grand parent (祖父) 标记为红色<br> 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3</li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-树和B+树</title>
      <link href="/2020/09/06/Algorithm-9/"/>
      <url>/2020/09/06/Algorithm-9/</url>
      
        <content type="html"><![CDATA[<h2 id="B-树和B-树"><a href="#B-树和B-树" class="headerlink" title="B-树和B+树"></a>B-树和B+树</h2><h3 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1. B-树"></a>1. B-树</h3><h4 id="1-1-B-树就是B树"><a href="#1-1-B-树就是B树" class="headerlink" title="1.1 B-树就是B树"></a>1.1 B-树就是B树</h4><p>英文名字叫做B-tree，中间的短线是英文连接符，只是翻译的时候将短线翻译成了减号。<br>全称Balance-tree(平衡多路查找树)，平衡的意思是左边和右边分布均匀。多路的意思是相对于二叉树而言的，二叉树就是二路查找树，查找时只有两条路，而B-tree有多条路，即父节点有多个子节点。</p><h4 id="1-2-B-树用途"><a href="#1-2-B-树用途" class="headerlink" title="1.2 B-树用途"></a>1.2 B-树用途</h4><p>使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。这个数据结构一般用于数据库的索引，综合效率较高。</p><h4 id="1-3-一个-m-阶的B-树的特征"><a href="#1-3-一个-m-阶的B-树的特征" class="headerlink" title="1.3 一个 m 阶的B-树的特征"></a>1.3 一个 m 阶的B-树的特征</h4><ol><li>根结点至少有两个子女。</li><li>每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m</li><li>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</li><li>所有的叶子结点都位于同一层。</li><li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</li></ol><h3 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h3><h4 id="2-1-一个-m-阶的B-树的特征"><a href="#2-1-一个-m-阶的B-树的特征" class="headerlink" title="2.1 一个 m 阶的B+树的特征"></a>2.1 一个 m 阶的B+树的特征</h4><ol><li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li></ol><blockquote><p>每一个父节点的元素都出现在子节点中，是子节点的最大或最小元素。<br>根节点的最大元素等同于整个B+树的最大元素 =&gt; 无论插入删除多少元素，始终要保持最大元素在根节点中。<br>由于父节点元素都出现在子节点中，因此所有叶子节点包含所有的元素信息。</p></blockquote><h3 id="3-B-树和B-树对比"><a href="#3-B-树和B-树对比" class="headerlink" title="3. B-树和B+树对比"></a>3. B-树和B+树对比</h3><h4 id="3-1-卫星数据"><a href="#3-1-卫星数据" class="headerlink" title="3.1 卫星数据"></a>3.1 卫星数据</h4><p>卫星数据指的是索引元素所指向的数据记录，比如数据库中的某一行。B-树所有节点都带有卫星数据。</p><p><img src="https://images.weserv.nl/?url=http://img.mp.sohu.com/upload/20170713/36efa69561dc4043a17d550133e13a6c_th.png" alt="B-树的卫星数据"></p><p>B+树只有叶子节点带有卫星数据，其他节点仅仅是索引。</p><p><img src="https://images.weserv.nl/?url=http://img.mp.sohu.com/upload/20170713/d8ae1b14e9bf4b1890146eb803ee9795_th.png" alt="B+树的卫星数据"></p><blockquote><p>在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。</p></blockquote><h4 id="3-2-查询对比"><a href="#3-2-查询对比" class="headerlink" title="3.2 查询对比"></a>3.2 查询对比</h4><ol><li>由于B+树中间节点没有卫星数据，所以同样4KB大小的磁盘页可以容纳更多的节点元素（节点存储在文件中，节点中的卫星数据是在内存中的） =&gt; 在数据量相同的情况下，B+树的结构比B-树要更加矮胖，查询IO的次数也更少</li><li>B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，所以B-树查找性能不稳定，最好情况是只查到根节点，最坏情况是查到叶子节点。而B+树每一次查找都是稳定的。</li><li>范围查询时，B-树要通过中序遍历来确定范围，但是B+树可以直接通过链表来查询范围</li></ol><p>利用平衡树的优势加快查询的稳定性和速度；<br>B+树的数据都存储在叶子结点中，分支结点均为索引，查询时只需要扫描叶子节点，常用于数据库索引；</p><p>B树其分支结点和叶子节点都存储着数据，查询时需要进行一个遍历，常用于文件索引；</p><p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p><p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程一些理解</title>
      <link href="/2020/09/03/OOP-1/"/>
      <url>/2020/09/03/OOP-1/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p><a href="https://www.zhihu.com/question/305042684" target="_blank" rel="noopener">摘自知乎</a></p><p>理解：参考Alan Kay的原话来看，对象就像是细胞，互相交流是靠消息传递。OOP对它只是消息传递，本地保留和保护，隐藏状态进程，极端的后期绑定。</p><p>原文如下：</p><p>面向对象编程（OOP），是一种设计思想或者架构风格。</p><p>OO语言之父Alan Kay，Smalltalk的发明人，在谈到OOP时是这样说的：</p><blockquote><p>I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages (so messaging came at the very beginning – it took a while to see how to do messaging in a programming language efficiently enough to be useful)<br>….<br>OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. </p></blockquote><p>简单解释一下上面的这几句话的大概意思：OOP应该体现一种网状结构，这个结构上的每个节点“Object”只能通过“消息”和其他节点通讯。每个节点会有内部隐藏的状态，状态不可以被直接修改，而应该通过消息传递的方式来间接的修改。</p><p>这个编程思想被设计能够编写庞大复杂的系统。</p><p>那么为什么OOP能够支撑庞大复杂的系统呢？用开公司举个例子。如果公司就只有几个人，那么大家总是一起干活，工作可以通过“上帝视角“完全搞清楚每一个细节，于是可以制定非常清晰的、明确的流程来完成这个任务。这个思想接近于传统的面向过程编程。而如果公司人数变多，达到几百上千，这种“上帝视角”是完全不可行的。在这样复杂的公司里，没有一个人能搞清楚一个工作的所有细节。为此，公司要分很多个部门，每个部门相对的独立，有自己的章程，办事方法和规则等。独立性就意味着“隐藏内部状态”。比如你只能说申请让某部门按照章程办一件事，却不能说命令部门里的谁谁谁，在什么时候之前一定要办成。这些内部的细节你管不着。类似的，更高一层，公司之间也存在大量的协作关系。一个汽车供应链可能包括几千个企业，组成了一个商业网络。通过这种松散的协作关系维系的系统可以无限扩展下去，形成庞大的，复杂的系统。这就是OOP想表达的思想。</p><p>第一门OOP语言是Ole-Johan Dahland和Kristen Nygaard发明的Simula（比smalltalk还要早）。从名字就可以看出来，是用来支撑“模拟系统”的。模拟这个场景非常适合体现OOP的这个思想。这个语言引入了object、class、subclass、inheritance、动态绑定虚拟进程等概念，甚至还有GC。Java很大程度上受了Simula的影响。我们在现在教书上讲解OOP类、实例和继承关系时，总会给出比如动物-猫-狗，或者形状-圆-矩形的例子，都源自于此。</p><p>但随后在施乐Palo Alto研究中心（Xerox PARC），Alan Kay、Dan Ingalls、Adele Goldberg在1970年开发了smalltalk，主要用于当时最前沿计算模型研究。在Simula的基础之上，smalltak特别强调messaging的重要性，成为了当时最有影响力的OOP语言。与smalltalk同期进行的还有比如GUI、超文本等项目。smalltalk也最早的实现了在GUI使用MVC模型来编程。</p><p>但是，并不是说OOP程序一定要用OOP语言来写。再强调一下，OOP首先是一种设计思想，非仅仅是编码方式。从这个角度推演，其实OOP最成功的例子其实是互联网。（Alan Kay也是互联网前身ARPNET的设计者之一）。另外一个OOP典型的例子是Linux内核，它充分体现了多个相对独立的组件（进程调度器、内存管理器、文件系统……）之间相互协作的思想。尽管Linux内核是用C写的，但是他比很多用所谓OOP语言写的程序更加OOP。</p><p>现在很多初学者会把使用C++，Java等语言的“OOP”语法特性后的程序称为OOP。比如封装、继承、多态等特性以及class、interface、private等管家你在会被大量提及和讨论。OOP语言不能代替人类做软件设计。既然做不了设计，就只能把一些轮子和语法糖造出来，供想编写OOP程序的人使用。但是，特别强调，是OOP设计思想在前，OOP编码在后。简单用OOP语言写代码，程序也不会自动变成OOP，也不一定能得到OOP的各种好处。</p><p>我们在以为我们在OOP时，其实很多时候都是在处理编码的细节工作，而非OOP提倡的“独立”，“通讯”。以“class”为例，实际上我们对它的用法有：</p><ul><li>表达一个类型（和父子类关系），以对应真实世界的概念，一个类型可以起到一个“模版”的作用。这个类型形成的对象会严格维护内部的状态（或者叫不变量）</li><li>表达一个Object（即单例），比如XXXService这种“Bean”</li><li>表达一个名字空间，这样就可以把一组相关的代码写到一起而不是散播的到处都是，其实这是一个“module”</li><li>表达一个数据结构，比如DTO这种</li><li>因为代码复用，硬造出来的，无法与现实概念对应，但又不得不存在的类</li><li>提供便利，让foo(a)这种代码可以写成a.foo()形式</li></ul><p>其中前两种和OOP的设计思想有关，而其他都是编写具体代码的工具，有的是为了代码得到更好的组织，有的就是为了方便。</p><p>很多地方提及OOP=封装+继承+多态。我非常反对这个提法，因为这几个术语把原本很容易理解的，直观的做事方法变的图腾化。初学者往往会觉得他们听上去很牛逼，但是使用起来又经常和现实相冲突以至于落不了地。</p><p>“封装”，是想把一段逻辑/概念抽象出来做到“相对独立”。这并不是OOP发明的，而是长久以来一直被广泛采用的方法。比如电视机就是个“封装”的好例子，几个简单的操作按钮（接口）暴露出来供使用者操作，复杂的内部电路和元器件在机器里面隐藏。再比如，Linux的文件系统接口也是非常好的“封装”的例子，它提供了open，close，read，write和seek这几个简单的接口，却封装了大量的磁盘驱动，文件系统，buffer和cache，进程的阻塞和唤醒等复杂的细节。然而它是用函数做的“封装”。好的封装设计意味着简洁的接口和复杂的被隐藏的内部细节。这并非是一个private关键字就可以表达的。一个典型的反面的例子是从数据库里读取出来的数据，几乎所有的字段都是要被处理和使用的，还有新的字段可能在处理过程中被添加进来。这时用ORM搞出一个个实体class，弄一堆private成员再加一堆getter和setter是非常愚蠢的做法。这里的数据并非是具有相对独立性的，可以进行通讯的“Object“，而仅仅是“Data Structure”。因此我非常喜欢有些语言提供“data object”的支持。</p><blockquote><p>当然，好的ORM会体现“Active Record”这种设计模式，非常有趣，本文不展开</p></blockquote><p>再说说“继承”，是希望通过类型的 is-a 关系来实现代码的复用。绝大部分OOP语言会把is-a和代码复用这两件事情合作一件事。但是我们经常会发现这二者之间并不一定总能对上。有时我们觉得A is a B，但是A并不想要B的任何代码，仅仅想表达is-a关系而已；而有时，仅仅是想把A的一段代码给B用，但是A和B之间并没有什么语义关系。这个分歧会导致严重的设计问题。比如，做类的设计时往往会希望每个类能与现实当中的实体/概念对应上；但如果从代码复用角度出发设计类，就可能会得到很多现实并不存在，但不得不存在的类。一般这种类都会有奇怪的名字和非常玄幻的意思。如果开发者换了个人，可能很难把握原来设计的微妙的思路，但又不得不改，再稳妥保守一点就绕开重新设计，造成玄幻的类越来越多…… 继承造成的问题相当多。现在人们谈论“继承”，一般都会说“Composite Over Inheritance” – 组合大于继承原则。</p><p>多态和OOP也不是必然的关系。所谓多态，是指让一组Object表达同一概念，并展现不同的行为。入门级的OOP的书一般会这么举例子，比如有一个基类Animal，定义了run方法。然后其子类Cat，Dog，Cow等都可以override掉run，实现自己的逻辑，因为Cat，Dog，Cow等都是Animal。例子说得挺有道理。但现实的复杂性往往会要求实现一个不是Animal的子类也能“run”，比如汽车可以run，一个程序也可以“run”等。总之只要是run就可以，并不太在意其类型表达出的包含关系。这里想表达的意思是，如果想进行极致的“多态”，is-a与否就不那么重要了。在动态语言里，一般采用duck typing来实现这种“多态”——不关是什么东西，只要觉得他可以run，就给他写个叫“run”的函数即可；而对于静态语言，一般会设计一个“IRun”的接口，然后mixin到期望得到run能力的类上。简单来说，要实现多态可以不用继承、甚至不用class。</p><p>OOP一定好吗？显然是否定的。回到OOP的本心是要<strong>处理大型复杂系统</strong>的设计和实现。OOP的优势一定要到了根本就不可能有一个“上帝视角”的存在，不得不把系统拆成很多Object时才会体现出来。</p><p>举个例子，smalltalk中，1 + 2 的理解方式是：向“1”这个Object发送一给消息“+”，消息的参数是“2”。的确是非常存粹的OOP思想。但是放在工程上，1 + 2理解为一般人常见的表达式可能更容易理解。对于1 + 2这样简单的逻辑，人很容易从上帝视角出发得到最直接的理解，也就有了最简单直接的代码而无用考虑“Object”。</p><p>如果是那种“第一步”、“第二步“……的程序，面向数据的程序，极致为性能做优化的程序，是不应该用OOP去实现的。但很无奈如果某些“纯OOP语言”，就不得不造一些本来就不需要的class，再绕回到这个领域适合的编码模式上。比如普通的Web系统就是典型的“面向”数据库这个中心进行数据处理（处理完了展示给用户，或者响应用户的操作）。这个用FP的思路去理解更加简单，直观。也有MVC，MVVM这样的模式被广泛应用。</p><p>还有一些领域尽管用OOP最为基础很适合，但是根据场景，已经诞生出了“领域化的OOP”，比如GUI是一个典型的例子。GUI里用OOP也是比较适合的，但是GUI里有很多细节OOP不管或者处理不好，因此好的GUI库会在OOP基础之上扩展很多。早期的MFC，.Net GUI Framework, React等都是这样。另外一个领域是游戏，用OOP也很合适，但也是有些性能和领域细节需要特殊处理，因此ECS会得到广泛的采用。</p><p>总结一下，OOP是众多设计思想中的一种。很多OOP语言把这种思想的不重要的细节工具化，但直接无脑应用这些工具不会直接得到OOP的设计。即便是OOP思想本身也有其适合的场景和不适合的场景。即便是适合的场景，也可能针对这个场景在OOP之上做更针对这个场景需求的定制的架构/框架。如果简单把OOP作为某种教条就大大的违反了这个思想的初衷，也只能得到拧巴的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> OOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 中的哈希值计算问题</title>
      <link href="/2020/08/21/HashMap-2/"/>
      <url>/2020/08/21/HashMap-2/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap-中的哈希值计算问题"><a href="#HashMap-中的哈希值计算问题" class="headerlink" title="HashMap 中的哈希值计算问题"></a>HashMap 中的哈希值计算问题</h2><h3 id="1-hash-计算"><a href="#1-hash-计算" class="headerlink" title="1. hash 计算"></a>1. hash 计算</h3><p>JDK1.8<br>HashMap源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images.weserv.nl/?url=https://img2018.cnblogs.com/blog/984423/201907/984423-20190718113737330-625791541.png" alt></p><p>右移16位相当于将高16位移入到低16位，再与原hashcode做异或计算（位相同为0，不同为1）可以将高低位二进制特征混合起来 =&gt; 高16位没有发生变化，但是低16位改变了</p><p>拿到的hash值会参与hashmap中数组槽位的计算，计算公式：(n - 1) &amp; hash，假设数组初始槽位16个，那么槽位计算如下：</p><p><img src="https://images.weserv.nl/?url=https://img2018.cnblogs.com/blog/984423/201907/984423-20190718114255570-1053064897.png" alt></p><p>高区的16位很有可能会被数组槽位数的二进制码锁屏蔽，<strong>如果我们不做刚才移位异或运算，那么在计算槽位时将丢失高区特征</strong></p><p>虽然丢失了高区特征，不同hashcode也可以计算出不同的槽位来，但是如果两个hashcode很接近时，高区的特征差异可能会导致一次哈希碰撞。</p><h3 id="2-使用异或运算的原因"><a href="#2-使用异或运算的原因" class="headerlink" title="2. 使用异或运算的原因"></a>2. 使用异或运算的原因</h3><p>异或运算能更好的保留各部分的特征，如果采用 &amp; 运算计算出来的值会向0靠拢，采用 | 运算计算出来的值会向1靠拢</p><h3 id="3-为什么槽位数必须使用2-n-为什么要-amp-length-1"><a href="#3-为什么槽位数必须使用2-n-为什么要-amp-length-1" class="headerlink" title="3. 为什么槽位数必须使用2^n / 为什么要 &amp;length-1"></a>3. 为什么槽位数必须使用2^n / 为什么要 &amp;length-1</h3><p>为了让哈希后的结果更加均匀，减少hash碰撞</p><h3 id="4-扩容后Hash值计算"><a href="#4-扩容后Hash值计算" class="headerlink" title="4. 扩容后Hash值计算"></a>4. 扩容后Hash值计算</h3><p>length * 2，即新增的bit位是1，在 (n - 1) &amp; hash 时，只需要判断新增加的这一个bit位，如果是0的话，说明索引不变，如果变成1了，索引变成 原索引+扩容前的容量大小</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 面试问题</title>
      <link href="/2020/08/20/JS/"/>
      <url>/2020/08/20/JS/</url>
      
        <content type="html"><![CDATA[<p><img src="coverPage.png" alt></p><h1 id="123-JavaScript-Interview-Questions"><a href="#123-JavaScript-Interview-Questions" class="headerlink" title="123-JavaScript-Interview-Questions"></a>123-JavaScript-Interview-Questions</h1><p>It’s a book about frontend interview question. We hope that it will help all javascript developers to prepare for a technical job interview. </p><h2 id="Want-to-buy-a-book-in-paper-form-Want-some-badass-flashcards"><a href="#Want-to-buy-a-book-in-paper-form-Want-some-badass-flashcards" class="headerlink" title="Want to buy a book in paper form? Want some badass flashcards?"></a>Want to buy a book in paper form? Want some badass flashcards?</h2><ul><li>This Book will be soon completed and then it will be available to buy in a paper form. If you want me to sent an early copy of this book, please add your name and email address in google form here <a href="https://goo.gl/forms/c8ubV1tWBBdz6fJP2" target="_blank" rel="noopener">Google Form</a>.</li><li>If you don’t want to wait, you can buy <a href="http://flashcardsjs.com" target="_blank" rel="noopener">Yuri’s JavaScript Flashcards</a>, a set of frontend interview questions sorted by popularity among the interviewers printed on beautiful poker-size flashcards.</li></ul><h2 id="Question-1-What’s-the-difference-between-undefined-and-not-defined-in-JavaScript"><a href="#Question-1-What’s-the-difference-between-undefined-and-not-defined-in-JavaScript" class="headerlink" title="Question 1. What’s the difference between undefined and not defined in JavaScript"></a>Question 1. What’s the difference between <code>undefined</code> and <code>not defined</code> in JavaScript</h2><details><summary><b>Answer</b></summary><p>In JavaScript if you try to use a variable that doesn’t exist and has not been declared, then JavaScript will throw an error <code>var name is not defined</code> and the script will stop executing thereafter. But If you use <code>typeof undeclared_variable</code> then it will return <code>undefined</code>.</p><p>Before starting further discussion let’s understand the difference between declaration and definition.</p><p><code>var x</code> is a declaration because you are not defining what value it holds yet, but you are declaring its existence and the need for memory allocation.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">// declaring x</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// output: undefined</span></span><br></pre></td></tr></table></figure><p><code>var x = 1</code> is both declaration and definition (what we are doing is called “initialisation”), Here declaration and assignment of value happen inline for variable x, In JavaScript both variable declarations and function declarations go to the top of the scope in which they are declared, then assignment happens—this series of events is called <code>hoisting</code>.</p><p>A variable can be declared but not defined. When we try to access it, It will result <code>undefined</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">// Declaration</span></span><br><span class="line"><span class="keyword">typeof</span> x === <span class="string">'undefined'</span>; <span class="comment">// Will return true</span></span><br></pre></td></tr></table></figure><p>A variable can be neither declared nor defined. When we try to reference such variable then the result will be <code>not defined</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(y);  <span class="comment">// Output: ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><h3 id="Ref-Link"><a href="#Ref-Link" class="headerlink" title="Ref Link:"></a>Ref Link:</h3><p><a href="http://stackoverflow.com/questions/20822022/javascript-variable-definition-declaration" target="_blank" rel="noopener">http://stackoverflow.com/questions/20822022/javascript-variable-definition-declaration</a></p></details><h2 id="Question-2-For-which-value-of-x-the-results-of-the-following-statements-are-not-the-same"><a href="#Question-2-For-which-value-of-x-the-results-of-the-following-statements-are-not-the-same" class="headerlink" title="Question 2. For which value of x the results of the following statements are not the same?"></a>Question 2. For which value of <code>x</code> the results of the following statements are not the same?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  if( x &lt;= 100 ) &#123;...&#125;</span></span><br><span class="line"><span class="keyword">if</span>( !(x &gt; <span class="number">100</span>) ) &#123;...&#125;</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p><code>NaN &lt;= 100</code> is <code>false</code> and <code>NaN &gt; 100</code> is also <code>false</code>, so if the<br>value of <code>x</code> is <code>NaN</code>, the statements are not the same.</p><p>The same holds true for any value of x that being converted to Number, returns NaN, e.g.: <code>undefined</code>, <code>[1,2,5]</code>, <code>{a:22}</code> , etc.</p><p>This is why you need to pay attention when you deal with numeric variables. <code>NaN</code> can’t be equal, less than or more than any other numeric value, so the only reliable way to check if the value is <code>NaN</code>, is to use <code>isNaN()</code> function.</p></details><h2 id="Question-3-What-is-the-drawback-of-declaring-methods-directly-in-JavaScript-objects"><a href="#Question-3-What-is-the-drawback-of-declaring-methods-directly-in-JavaScript-objects" class="headerlink" title="Question 3. What is the drawback of declaring methods directly in JavaScript objects?"></a>Question 3. What is the drawback of declaring methods directly in JavaScript objects?</h2><details><summary><b>Answer</b></summary><p>One of the drawback of declaring methods directly in JavaScript objects is that they are very memory inefficient.  When you do that, a new copy of the method is created for each instance of an object. Let’s see it on example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Employee = <span class="function"><span class="keyword">function</span> (<span class="params">name, company, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">""</span>;       </span><br><span class="line">  <span class="keyword">this</span>.company = company || <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">this</span>.salary = salary || <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We can create a method like this:</span></span><br><span class="line">  <span class="keyword">this</span>.formatSalary = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"$ "</span> + <span class="keyword">this</span>.salary;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we can also create method in Employee's prototype:</span></span><br><span class="line">Employee.prototype.formatSalary2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"$ "</span> + <span class="keyword">this</span>.salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//creating objects</span></span><br><span class="line"><span class="keyword">var</span> emp1 = <span class="keyword">new</span> Employee(<span class="string">'Yuri Garagin'</span>, <span class="string">'Company 1'</span>, <span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">var</span> emp2 = <span class="keyword">new</span> Employee(<span class="string">'Dinesh Gupta'</span>, <span class="string">'Company 2'</span>, <span class="number">1039999</span>);</span><br><span class="line"><span class="keyword">var</span> emp3 = <span class="keyword">new</span> Employee(<span class="string">'Erich Fromm'</span>, <span class="string">'Company 3'</span>, <span class="number">1299483</span>);</span><br></pre></td></tr></table></figure><p>Here each instance variable <code>emp1</code>, <code>emp2</code>, <code>emp3</code> has own copy of <code>formatSalary</code> method. However the <code>formatSalary2</code> will only be added once to an object <code>Employee.prototype</code>.</p></details><h2 id="Question-4-What-is-“closure”-in-javascript-Can-you-provide-an-example"><a href="#Question-4-What-is-“closure”-in-javascript-Can-you-provide-an-example" class="headerlink" title="Question 4. What is “closure” in javascript? Can you provide an example?"></a>Question 4. What is “closure” in javascript? Can you provide an example?</h2><details><summary><b>Answer</b></summary><p>A closure is a function defined inside another function (called parent function) and has access to the variable which is declared and defined in parent function scope.</p><p>The closure has access to the variable in three scopes:</p><ul><li>Variable declared in his own scope</li><li>Variable declared in parent function scope</li><li>Variable declared in the global namespace</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVar = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parent self invoking function</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span> (<span class="params">outerArg</span>) </span>&#123; <span class="comment">// begin of scope outerFunction</span></span><br><span class="line">  <span class="comment">// Variable declared in outerFunction function scope</span></span><br><span class="line">  <span class="keyword">var</span> outerFuncVar = <span class="string">'x'</span>;    </span><br><span class="line">  <span class="comment">// Closure self-invoking function</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span> (<span class="params">innerArg</span>) </span>&#123; <span class="comment">// begin of scope innerFunction</span></span><br><span class="line">    <span class="comment">// variable declared in innerFunction function scope</span></span><br><span class="line">    <span class="keyword">var</span> innerFuncVar = <span class="string">"y"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(         </span><br><span class="line">      <span class="string">"outerArg = "</span> + outerArg + <span class="string">"\n"</span> +</span><br><span class="line">      <span class="string">"outerFuncVar = "</span> + outerFuncVar + <span class="string">"\n"</span> +</span><br><span class="line">      <span class="string">"innerArg = "</span> + innerArg + <span class="string">"\n"</span> +</span><br><span class="line">      <span class="string">"innerFuncVar = "</span> + innerFuncVar + <span class="string">"\n"</span> +</span><br><span class="line">      <span class="string">"globalVar = "</span> + globalVar);</span><br><span class="line">  <span class="comment">// end of scope innerFunction</span></span><br><span class="line">  &#125;)(<span class="number">5</span>); <span class="comment">// Pass 5 as parameter</span></span><br><span class="line"><span class="comment">// end of scope outerFunction</span></span><br><span class="line">&#125;)(<span class="number">7</span>); <span class="comment">// Pass 7 as parameter</span></span><br></pre></td></tr></table></figure><p><code>innerFunction</code> is closure which is defined inside <code>outerFunction</code> and has access to all variable which is declared and defined in outerFunction scope. In addition to this function defined inside the function as closure has access to the variable which is declared in <code>global namespace</code>.</p><p>Output of above code would be:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outerArg = <span class="number">7</span></span><br><span class="line">outerFuncVar = x</span><br><span class="line">innerArg = <span class="number">5</span></span><br><span class="line">innerFuncVar = y</span><br><span class="line">globalVar = abc</span><br></pre></td></tr></table></figure></details><h2 id="Question-5-Write-a-mul-function-which-will-work-properly-when-invoked-with-following-syntax"><a href="#Question-5-Write-a-mul-function-which-will-work-properly-when-invoked-with-following-syntax" class="headerlink" title="Question 5. Write a mul function which will work properly when invoked with following syntax."></a>Question 5. Write a mul function which will work properly when invoked with following syntax.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)); <span class="comment">// output : 24</span></span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">4</span>)(<span class="number">3</span>)(<span class="number">4</span>)); <span class="comment">// output : 48</span></span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>Below is the code followed by the explanation of how it works:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123; <span class="comment">// anonymous function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123; <span class="comment">// anonymous function</span></span><br><span class="line">      <span class="keyword">return</span> x * y * z;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here the <code>mul</code> function accepts the first argument and returns the anonymous function which takes the second parameter and returns the anonymous function which takes the third parameter and returns the multiplication of arguments which is being passed in successive</p><p>In Javascript function defined inside has access to outer function variable and function is the first class object so it can be returned by the function as well and passed as an argument in another function.</p><ul><li>A function is an instance of the Object type</li><li>A function can have properties and has a link back to its constructor method</li><li>A function can be stored as variable</li><li>A function can be pass as a parameter to another function</li><li>A function can be returned from another function</li></ul></details><h2 id="Question-6-How-to-empty-an-array-in-JavaScript"><a href="#Question-6-How-to-empty-an-array-in-JavaScript" class="headerlink" title="Question 6. How to empty an array in JavaScript?"></a>Question 6. How to empty an array in JavaScript?</h2><p>For instance:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList =  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br></pre></td></tr></table></figure><p>How can we empty the array above?</p><details><summary><b>Answer</b></summary><p>There are a couple of ways by which we can empty an array, So let’s discuss all the possible way by which we can empty an array.</p><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayList = [];</span><br></pre></td></tr></table></figure><p>The code above will set the variable <code>arrayList</code> to a new empty array. This is recommended if you don’t have <strong>references to the original array</strong> <code>arrayList</code> anywhere else because It will actually create a new empty array. You should be careful with this way of empty the array, because if you have referenced this array from another variable, then the original reference array will remain unchanged, Only use this way if you have only referenced the array by its original variable <code>arrayList</code>.</p><p>For instance:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]; <span class="comment">// Created array</span></span><br><span class="line"><span class="keyword">var</span> anotherArrayList = arrayList;  <span class="comment">// Referenced arrayList by another variable</span></span><br><span class="line">arrayList = []; <span class="comment">// Empty the array</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherArrayList); <span class="comment">// Output ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br></pre></td></tr></table></figure><h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayList.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>The code above will clear the existing array by setting its length to 0. This way of emptying an array will also update all the reference variables that point to the original array. </p><p>For instance:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]; <span class="comment">// Created array</span></span><br><span class="line"><span class="keyword">var</span> anotherArrayList = arrayList;  <span class="comment">// Referenced arrayList by another variable</span></span><br><span class="line">arrayList.length = <span class="number">0</span>; <span class="comment">// Empty the array by setting length to 0</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherArrayList); <span class="comment">// Output []</span></span><br></pre></td></tr></table></figure><h4 id="Method-3"><a href="#Method-3" class="headerlink" title="Method 3"></a>Method 3</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayList.splice(<span class="number">0</span>, arrayList.length);</span><br></pre></td></tr></table></figure><p>Above implementation will also work perfectly. This way of empty the array will also update all the references of the original array.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]; <span class="comment">// Created array</span></span><br><span class="line"><span class="keyword">var</span> anotherArrayList = arrayList;  <span class="comment">// Referenced arrayList by another variable</span></span><br><span class="line">arrayList.splice(<span class="number">0</span>, arrayList.length); <span class="comment">// Empty the array by setting length to 0</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherArrayList); <span class="comment">// Output []</span></span><br></pre></td></tr></table></figure><h4 id="Method-4"><a href="#Method-4" class="headerlink" title="Method 4"></a>Method 4</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(arrayList.length) &#123;</span><br><span class="line">  arrayList.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Above implementation can also empty the array. But not recommended to use often.</p></details><h2 id="Question-7-How-to-check-if-an-object-is-an-array-or-not"><a href="#Question-7-How-to-check-if-an-object-is-an-array-or-not" class="headerlink" title="Question 7. How to check if an object is an array or not?"></a>Question 7. How to check if an object is an array or not?</h2><details><summary><b>Answer</b></summary><p>The best way to find whether an object is instance of a particular class or not using <code>toString</code> method from <code>Object.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList = [<span class="number">1</span> , <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>One of the best use cases of type checking of an object is when we do method overloading in JavaScript. To understand this, let’s say we have a method called <code>greet</code> which can take a single string and also a list of strings. To make our <code>greet</code> method workable in both situation we need to know what kind of parameter is being passed: is it single value or list of values?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>() &#123;</span><br><span class="line">    <span class="comment">// here have to check whether param is array or not</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, in the above implementation it might not necessary to check the type of the array, we can check for single value string and put array logic code in else block, let see below code for the same.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> param === <span class="string">'string'</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If param is of type array then this block of code would execute</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now it’s fine we can go with the previous two implementations, but when we have a situation like a parameter can be <code>single value</code>, <code>array</code>, and <code>object</code> type then we will be in trouble.</p><p>Coming back to checking the type of an object, As we mentioned that we can use <code>Object.prototype.toString</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(arrayList) === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Array!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you are using <code>jQuery</code> then you can also used jQuery <code>isArray</code> method:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($.isArray(arrayList)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Array'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Not an array'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FYI jQuery uses <code>Object.prototype.toString.call</code> internally to check whether an object is an array or not.</p><p>In modern browser, you can also use:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(arrayList);</span><br></pre></td></tr></table></figure><p><code>Array.isArray</code> is supported by Chrome 5, Firefox 4.0, IE 9, Opera 10.5 and Safari 5</p></details><h2 id="Question-8-What-will-be-the-output-of-the-following-code"><a href="#Question-8-What-will-be-the-output-of-the-following-code" class="headerlink" title="Question 8. What will be the output of the following code?"></a>Question 8. What will be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> output = (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> x;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;)(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The code above will output <code>0</code> as output. <code>delete</code> operator is used to delete a property from an object. Here <code>x</code> is not an object it’s <strong>local variable</strong>. <code>delete</code> operator doesn’t affect local variables.</p></details><h2 id="Question-9-What-will-be-the-output-of-the-following-code"><a href="#Question-9-What-will-be-the-output-of-the-following-code" class="headerlink" title="Question 9. What will be the output of the following code?"></a>Question 9. What will be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> output = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> x;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The code above will output <code>1</code> as output. <code>delete</code> operator is used to delete a property from an object. Here <code>x</code> is not an object it’s <strong>global variable</strong> of type <code>number</code>.</p></details><h2 id="Question-10-What-will-be-the-output-of-the-following-code"><a href="#Question-10-What-will-be-the-output-of-the-following-code" class="headerlink" title="Question 10. What will be the output of the following code?"></a>Question 10. What will be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = &#123; <span class="attr">foo</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> output = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> x.foo;</span><br><span class="line">  <span class="keyword">return</span> x.foo;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The code above will output <code>undefined</code> as output. <code>delete</code> operator is used to delete a property from an object. Here <code>x</code> is an object which has foo as a property and from a self-invoking function, we are deleting the <code>foo</code> property of object <code>x</code> and after deletion, we are trying to reference deleted property <code>foo</code> which result <code>undefined</code>.</p></details><h2 id="Question-11-What-will-be-the-output-of-the-following-code"><a href="#Question-11-What-will-be-the-output-of-the-following-code" class="headerlink" title="Question 11. What will be the output of the following code?"></a>Question 11. What will be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Employee = &#123;</span><br><span class="line">  company: <span class="string">'xyz'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> emp1 = <span class="built_in">Object</span>.create(Employee);</span><br><span class="line"><span class="keyword">delete</span> emp1.company</span><br><span class="line"><span class="built_in">console</span>.log(emp1.company);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary>The code above will output `xyz` as output. Here `emp1` object got company as **prototype** property. delete operator doesn't delete prototype property.<p><code>emp1</code> object doesn’t have <strong>company</strong> as its own property. you can test it <code>console.log(emp1.hasOwnProperty(&#39;company&#39;)); //output : false</code> However, we can delete company property directly from <code>Employee</code> object using <code>delete Employee.company</code> or we can also delete from <code>emp1</code> object using <code>__proto__</code> property <code>delete emp1.__proto__.company</code>.</p></details><h2 id="Question-12-What-is-undefined-x-1-in-JavaScript"><a href="#Question-12-What-is-undefined-x-1-in-JavaScript" class="headerlink" title="Question 12. What is undefined x 1 in JavaScript"></a>Question 12. What is <code>undefined x 1</code> in JavaScript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trees = [<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>];</span><br><span class="line"><span class="keyword">delete</span> trees[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary> - When you run the code above and do `console.log(trees);` in chrome developer console then you will get `["redwood", "bay", "cedar", undefined × 1, "maple"]`. - In the recent versions of Chrome you will see the word `empty` of `undefined x 1`. - When you run the same code in Firefox browser console then you will get `["redwood", "bay", "cedar", undefined, "maple"]`<p>Clearly we can see that Chrome has its own way of displaying uninitialized index in arrays. However when you check <code>trees[3] === undefined</code> in any browser you will get similar output as <code>true</code>.</p><p><strong>Note:</strong> Please remember that you need not check for the uninitialized index of the array in  <code>trees[3] === &#39;undefined × 1&#39;</code> it will give an error because <code>&#39;undefined × 1&#39;</code> this is just way of displaying an uninitialized index of an array in chrome.</p></details><h2 id="Question-13-What-will-be-the-output-of-the-following-code"><a href="#Question-13-What-will-be-the-output-of-the-following-code" class="headerlink" title="Question 13. What will be the output of the following code?"></a>Question 13. What will be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trees = [<span class="string">"xyz"</span>, <span class="string">"xxxx"</span>, <span class="string">"test"</span>, <span class="string">"ryan"</span>, <span class="string">"apple"</span>];</span><br><span class="line"><span class="keyword">delete</span> trees[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(trees.length);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary>The code above will output `5` as output. When we used `delete` operator for deleting an array element then, the array length is not affected by this. This holds even if you deleted all elements of an array using `delete` operator.<p>So when delete operator removes an array element that deleted element is no longer present in the array. In place of value at deleted index <code>undefined x 1</code> in <strong>chrome</strong> and <code>undefined</code> is placed at the index. If you do <code>console.log(trees)</code> output <code>[&quot;xyz&quot;, &quot;xxxx&quot;, &quot;test&quot;, undefined × 1, &quot;apple&quot;]</code> in Chrome and in Firefox <code>[&quot;xyz&quot;, &quot;xxxx&quot;, &quot;test&quot;, undefined, &quot;apple&quot;]</code>.</p></details><h2 id="Question-14-What-will-be-the-output-of-the-following-code"><a href="#Question-14-What-will-be-the-output-of-the-following-code" class="headerlink" title="Question 14. What will be the output of the following code?"></a>Question 14. What will be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar + <span class="number">0</span>);   </span><br><span class="line"><span class="built_in">console</span>.log(bar + <span class="string">"xyz"</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(bar + <span class="literal">true</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(bar + <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The code above will output <code>1, &quot;truexyz&quot;, 2, 1</code> as output. Here’s a general guideline  for the plus operator:</p><ul><li>Number + Number  -&gt; Addition</li><li>Boolean + Number -&gt; Addition</li><li>Boolean + Boolean -&gt; Addition</li><li>Number + String  -&gt; Concatenation</li><li>String + Boolean -&gt; Concatenation</li><li>String + String  -&gt; Concatenation</li></ul></details><h2 id="Question-15-What-will-be-the-output-of-the-following-code"><a href="#Question-15-What-will-be-the-output-of-the-following-code" class="headerlink" title="Question 15. What will be the output of the following code?"></a>Question 15. What will be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z = <span class="number">1</span>, y = z = <span class="keyword">typeof</span> y;</span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The code above will print string <code>&quot;undefined&quot;</code> as output. According to associativity rule operator with the same precedence are processed based on their associativity property of operator. Here associativity of the assignment operator is <code>Right to Left</code> so first <code>typeof y</code> will evaluate first which is string <code>&quot;undefined&quot;</code> and assigned to <code>z</code> and then <code>y</code> would be assigned the value of z. The overall sequence will look like that: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z;</span><br><span class="line">z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y;</span><br><span class="line">z = <span class="keyword">typeof</span> y;</span><br><span class="line">y = z;</span><br></pre></td></tr></table></figure></details><h2 id="Question-16-What-will-be-the-output-of-the-following-code"><a href="#Question-16-What-will-be-the-output-of-the-following-code" class="headerlink" title="Question 16. What will be the output of the following code?"></a>Question 16. What will be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NFE (Named Function Expression)</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">12</span>; &#125;;</span><br><span class="line"><span class="keyword">typeof</span> bar();</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output will be <code>Reference Error</code>. To fix the bug we can try to rewrite the code a little bit: </p><p><strong>Sample 1</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">12</span>; &#125;;</span><br><span class="line"><span class="keyword">typeof</span> bar();</span><br></pre></td></tr></table></figure><p>or</p><p><strong>Sample 2</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">12</span>; &#125;;</span><br><span class="line"><span class="keyword">typeof</span> bar();</span><br></pre></td></tr></table></figure><p>The function definition can have only one reference variable as a function name, In <strong>sample 1</strong> <code>bar</code> is reference variable which is pointing to <code>anonymous function</code> and in <strong>sample 2</strong> we have function statement and <code>bar</code> is the function name.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// foo is visible here</span></span><br><span class="line">  <span class="comment">// bar is visible here</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar()); <span class="comment">// Works here :)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// foo is visible here</span></span><br><span class="line"><span class="comment">// bar is undefined here</span></span><br></pre></td></tr></table></figure></details><h2 id="Question-17a-What-is-the-difference-between-declaring-a-function-in-the-formats-listed-below"><a href="#Question-17a-What-is-the-difference-between-declaring-a-function-in-the-formats-listed-below" class="headerlink" title="Question 17a. What is the difference between declaring a function in the formats listed below?"></a>Question 17a. What is the difference between declaring a function in the formats listed below?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The main difference is that function <code>foo</code> is defined at <code>run-time</code> and is called a function expression, whereas function <code>bar</code> is defined at <code>parse time</code> and is called a function statement. To understand it better, let’s take a look at the code below :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run-Time function declaration</span></span><br><span class="line">  foo(); <span class="comment">// Call foo function here, It will give an error</span></span><br><span class="line">  <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi I am inside Foo"</span>);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse-Time function declaration</span></span><br><span class="line">bar(); <span class="comment">// Call bar function here, It will not give an Error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hi I am inside Foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Question-17b-What-is-the-output-of-the-following"><a href="#Question-17b-What-is-the-output-of-the-following" class="headerlink" title="Question 17b. What is the output of the following?"></a>Question 17b. What is the output of the following?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar();</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'something'</span>)&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'bar got called'</span>)&#125;;</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output will be :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar got called</span><br><span class="line">something</span><br></pre></td></tr></table></figure><p>Since the function is called first and defined during parse time the JS engine will try to find any possible parse time definitions and start the execution loop which will mean function is called first even if the definition is post another function.</p></details><h2 id="Question-18-In-which-case-the-function-definition-is-not-hoisted-in-JavaScript"><a href="#Question-18-In-which-case-the-function-definition-is-not-hoisted-in-JavaScript" class="headerlink" title="Question 18. In which case the function definition is not hoisted in JavaScript?"></a>Question 18. In which case the function definition is not hoisted in JavaScript?</h2><details><summary><b>Answer</b></summary><p>Let’s take the following <strong>function expression</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In JavaScript <code>var</code>-declared variables and functions are <code>hoisted</code>. Let’s take function <code>hoisting</code> first. Basically, the JavaScript interpreter looks ahead to find all the variable declaration and hoists them to the top of the function where it’s declared. For example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// Here foo is still undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The code above behind the scene look something like this:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">undefined</span>;</span><br><span class="line">foo(); <span class="comment">// Here foo is undefined</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Some code stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">undefined</span>;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Some code stuff</span></span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// Now foo is defined here</span></span><br></pre></td></tr></table></figure></details><h2 id="Question-19-What-will-be-the-output-of-the-following-code"><a href="#Question-19-What-will-be-the-output-of-the-following-code" class="headerlink" title="Question 19. What will be the output of the following code?"></a>Question 19. What will be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> salary = <span class="string">"1000$"</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Original salary was "</span> + salary);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> salary = <span class="string">"5000$"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My New Salary "</span> + salary);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The code above will output: <code>undefined, 5000$</code> because of hoisting. In the code presented above, you might be expecting <code>salary</code> to retain it values from outer scope until the point that <code>salary</code> was re-declared in the inner scope. But due to <code>hoisting</code> salary value was <code>undefined</code> instead. To understand it better have a look of the following code, here <code>salary</code> variable is hoisted and declared at the top in function scope. When we print its value using <code>console.log</code> the result is <code>undefined</code>. Afterwards the variable is redeclared and the new value <code>&quot;5000$&quot;</code> is assigned to it.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> salary = <span class="string">"1000$"</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> salary = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Original salary was "</span> + salary);</span><br><span class="line"></span><br><span class="line">  salary = <span class="string">"5000$"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My New Salary "</span> + salary);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></details><h2 id="Question-20-What’s-the-difference-between-typeof-and-instanceof"><a href="#Question-20-What’s-the-difference-between-typeof-and-instanceof" class="headerlink" title="Question 20. What’s the difference between typeof and instanceof?"></a>Question 20. What’s the difference between <code>typeof</code> and <code>instanceof</code>?</h2><details><summary><b>Answer</b></summary><p><code>typeof</code> is an operator that returns a string with the type of whatever you pass.</p><p>The <code>typeof</code> operator checks if a value belongs to one of the seven basic types: <code>number</code>, <code>string</code>, <code>boolean</code>, <code>object</code>, <code>function</code>, <code>undefined</code> or <code>Symbol</code>.</p><p><code>typeof(null)</code> will return <code>object</code>.</p><p><code>instanceof</code> is much more intelligent: it works on the level of prototypes. In particular, it tests to see if the right operand appears anywhere in the prototype chain of the left. <code>instanceof</code> doesn’t work with primitive types. The <code>instanceof</code> operator checks the current object and returns true if the object is of the specified type, for example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal();</span><br><span class="line">dog <span class="keyword">instanceof</span> Animal; <span class="comment">// Output : true</span></span><br></pre></td></tr></table></figure><p>Here <code>dog instanceof Animal</code> is true since <code>dog</code> inherits from <code>Animal.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"xyz"</span>);</span><br><span class="line">name <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// Output : true</span></span><br></pre></td></tr></table></figure><p>Ref Link: <a href="http://stackoverflow.com/questions/2449254/what-is-the-instanceof-operator-in-javascript" target="_blank" rel="noopener">http://stackoverflow.com/questions/2449254/what-is-the-instanceof-operator-in-javascript</a></p></details><h2 id="Question-21-Calculate-the-length-of-the-associative-array"><a href="#Question-21-Calculate-the-length-of-the-associative-array" class="headerlink" title="Question 21. Calculate the length of the associative array"></a>Question 21. Calculate the length of the associative array</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counterArray = &#123;</span><br><span class="line">  A : <span class="number">3</span>,</span><br><span class="line">  B : <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line">counterArray[<span class="string">"C"</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>First of all, in the case of JavaScript an associative array is the same as an object. Secondly, even though there is no built-in function or property available to calculate the length/size an object, we can write such function ourselves.</p><h4 id="Method-1-1"><a href="#Method-1-1" class="headerlink" title="Method 1"></a>Method 1</h4><p><code>Object</code> has <code>keys</code> method which can be used to calculate the length of object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(counterArray).length; <span class="comment">// Output 3</span></span><br></pre></td></tr></table></figure><h4 id="Method-2-1"><a href="#Method-2-1" class="headerlink" title="Method 2"></a>Method 2</h4><p>We can also calculate the length of object by iterating through the object and by doing a count of own property of object. This way we will ignoge the properties that came from the object’s prototype chain:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="comment">// hasOwnProperty method check own property of object</span></span><br><span class="line">    <span class="keyword">if</span>(object.hasOwnProperty(key)) count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-3-1"><a href="#Method-3-1" class="headerlink" title="Method 3"></a>Method 3</h4><p>All modern browsers (including IE9+) support the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" target="_blank" rel="noopener"><code>getOwnPropertyNames</code></a> method, so we can calculate the length using the following code: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(counterArray).length; <span class="comment">// Output 3</span></span><br></pre></td></tr></table></figure><h4 id="Method-4-1"><a href="#Method-4-1" class="headerlink" title="Method 4"></a>Method 4</h4><p><a href="https://underscorejs.org/#size" target="_blank" rel="noopener">Underscore</a> and <a href="https://lodash.com/docs/4.17.10#size" target="_blank" rel="noopener">lodash</a> libraries have the method <code>size</code> dedicated to calculate the object length. We don’t recommend to include one of these libraries just to use the <code>size</code> method, but if it’s already used in your project - why not? </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.size(&#123;<span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span>, <span class="attr">three</span>: <span class="number">3</span>&#125;);</span><br><span class="line">=&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure></details><h2 id="Question-22-Difference-between-Function-Method-and-Constructor-calls-in-JavaScript"><a href="#Question-22-Difference-between-Function-Method-and-Constructor-calls-in-JavaScript" class="headerlink" title="Question 22. Difference between Function, Method and Constructor calls in JavaScript."></a>Question 22. Difference between <code>Function</code>, <code>Method</code> and <code>Constructor</code> calls in JavaScript.</h2><details><summary><b>Answer</b></summary><p>If your are familiar with Object-oriented programming, More likely familiar to thinking of functions, methods, and class constructors as three separate things. But In JavaScript, these are just three different usage patterns of one single construct.</p><p>functions : The simplest usages of function call:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello world, "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">helloWorld(<span class="string">"JS Geeks"</span>); <span class="comment">// "hello world JS Geeks"</span></span><br></pre></td></tr></table></figure><p>Methods in JavaScript are nothing more than object properties that are functions.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  helloWorld : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world, "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  name: <span class="string">'John Carter'</span></span><br><span class="line">&#125;</span><br><span class="line">obj.helloWorld(); <span class="comment">// // "hello world John Carter"</span></span><br></pre></td></tr></table></figure><p>Notice how <code>helloWorld</code> refer to <code>this</code> properties of obj. Here it’s clear or you might have already understood that <code>this</code> gets bound to <code>obj</code>. But the interesting point that we can copy a reference to the same function <code>helloWorld</code> in another object and get a difference answer. Let see:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  helloWorld : obj.helloWorld,</span><br><span class="line">  name: <span class="string">'John Doe'</span></span><br><span class="line">&#125;</span><br><span class="line">obj2.helloWorld(); <span class="comment">// "hello world John Doe"</span></span><br></pre></td></tr></table></figure><p>You might be wonder what exactly happens in a method call here. Here we call the expression itself determine the binding of this <code>this</code>, The expression <code>obj2.helloWorld()</code> looks up the <code>helloWorld</code> property of obj and calls it with receiver object <code>obj2</code>.</p><p>The third use of functions is as constructors. Like function and method, <code>constructors</code> are defined with function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emp1 = <span class="keyword">new</span> Employee(<span class="string">'John Doe'</span>, <span class="number">28</span>);</span><br><span class="line">emp1.name; <span class="comment">// "John Doe"</span></span><br><span class="line">emp1.age; <span class="comment">// 28</span></span><br></pre></td></tr></table></figure><p>Unlike function calls and method calls, a constructor call <code>new Employee(&#39;John Doe&#39;, 28)</code> creates a brand new object and passes it as the value of <code>this</code>, and implicitly returns the new object as its result.</p><p>The primary role of the constructor function is to initialize the object.</p></details><h2 id="Question-23-What-would-be-the-output-of-the-following-code"><a href="#Question-23-What-would-be-the-output-of-the-following-code" class="headerlink" title="Question 23. What would be the output of the following code?"></a>Question 23. What would be the output of the following code?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">"JsGeeks"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> User(<span class="string">"xyz"</span>)[<span class="string">"location"</span>] = <span class="string">"USA"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output of above code would be <code>&quot;USA&quot;</code>. Here <code>new User(&quot;xyz&quot;)</code> creates a brand new object and created property <code>location</code> on that and <code>USA</code> has been assigned to object property location and that has been referenced by the person.</p><p>Let say <code>new User(&quot;xyz&quot;)</code> created a object called <code>foo</code>. The value <code>&quot;USA&quot;</code> will be assigned to <code>foo[&quot;location&quot;]</code>, but according to <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-assignment-operators-runtime-semantics-evaluation" target="_blank" rel="noopener">ECMAScript Specification</a> , pt 12.14.4 the assignment will itself return the rightmost value: in our case it’s <code>&quot;USA&quot;</code>. Then it will be assigned to person. </p><p> To better understand what’s going on here, try to execute this code in console, line by line:<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">"JsGeeks"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> User(<span class="string">"xyz"</span>);</span><br><span class="line">foo[<span class="string">"location"</span>] = <span class="string">"USA"</span>;</span><br><span class="line"><span class="comment">// the console will show you that the result of this is "USA"</span></span><br></pre></td></tr></table></figure></p></details><h2 id="Question-24-What-are-Service-Workers-and-when-can-you-use-them"><a href="#Question-24-What-are-Service-Workers-and-when-can-you-use-them" class="headerlink" title="Question 24. What are Service Workers and when can you use them?"></a>Question 24. What are Service Workers and when can you use them?</h2><details><summary><b>Answer</b></summary><p>It’s a technology that allows your web application to use cached resources first, and provide default experience offline, before getting more data from the network later. This principle is commonly known as Offline First.</p><p>Service Workers actively use promises. A Service Worker has to be installed,activated and then it can react on fetch, push and sync events.</p><p>As of 2017, Service Workers are not supported in IE and Safari.</p></details><h2 id="Question-25-What-is-the-difference-between-a-method-and-a-function-in-javascript"><a href="#Question-25-What-is-the-difference-between-a-method-and-a-function-in-javascript" class="headerlink" title="Question 25. What is the difference between a method and a function in javascript?"></a>Question 25. What is the difference between a method and a function in javascript?</h2><details><summary><b>Answer</b></summary><p>In JS, that difference is quite subtle. A function is a piece of code that is called by name and function itself not associated with any object and not defined inside any object. It can be passed data to operate on (i.e. parameter) and can optionally return data (the return value).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function statement</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do some stuff;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calling the function</span></span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure><p>Here myFunc() function call is not associated with object hence not invoked through any object.</p><p>A function can take a form of immediately invoked function expression (IIFE):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Anonymous Self-invoking Function</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do some stuff;</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>Finally there are also arrow functions: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunc = <span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A method is a piece of code that is called by its name and that is associated with the object. Methods are functions. When you call a method like this <code>obj1.myMethod()</code>, the reference to <code>obj1</code> gets assigned (bound) to <code>this</code> variable. In other words, the value of <code>this</code> will be <code>obj1</code> inside <code>myMethod</code>. </p><p>Here are some examples of methods: </p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  attribute: <span class="string">"xyz"</span>,</span><br><span class="line">  myMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// Method</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.attribute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the method</span></span><br><span class="line">obj1.myMethod();</span><br></pre></td></tr></table></figure><p>Here <code>obj1</code> is an object and <code>myMethod</code> is a method which is associated with <code>obj1</code>.</p><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h5><p>In ES6 we have classes. There the methods will look like this:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAwesomeClass</span> </span>&#123;</span><br><span class="line">  myMethod() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi there"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> MyAwesomeClass();</span><br><span class="line">obj1.myMethod();</span><br></pre></td></tr></table></figure><p>Understand: the method is not some kind of special type of a function, and it’s not about how you declare a function. It’s the way we <strong>call</strong> a function. Look at that: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  prop1: <span class="string">"buddy"</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hi there"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// let's call myFunc as a function: </span></span><br><span class="line">myFunc(); <span class="comment">// will output "Hi there undefined" or "Hi there Window"</span></span><br><span class="line"> </span><br><span class="line">obj1.myMethod = myFunc;</span><br><span class="line"><span class="comment">//now we're calling myFunc as a method of obj1, so this will point to obj1</span></span><br><span class="line">obj1.myMethod(); <span class="comment">// will print "Hi there" following with obj1.</span></span><br></pre></td></tr></table></figure></details><h2 id="Question-26-What-is-IIFE-Immediately-Invoked-Function-Expression-and-how-it-can-be-useful"><a href="#Question-26-What-is-IIFE-Immediately-Invoked-Function-Expression-and-how-it-can-be-useful" class="headerlink" title="Question 26. What is IIFE (Immediately Invoked Function Expression) and how it can be useful?"></a>Question 26. What is IIFE (Immediately Invoked Function Expression) and how it can be useful?</h2><details><summary><b>Answer</b></summary><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>IIFE a function that runs as soon as it’s defined. Usually it’s anonymous (doesn’t have a function name), but it also can be named. Here’s an example of IIFE:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hi, I'm IIFE!"</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// outputs "Hi, I'm IIFE!"</span></span><br></pre></td></tr></table></figure><h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h4><p>So, here’s how it works. Remember the difference between function statements (<code>function a () {}</code>) and function expressions (<code>var a = function() {}</code>)? So, IIFE is a function expression. To make it an expression we surround our function declaration into the parens. We do it to explicitly tell the parser that it’s an expression, not a statement (JS doesn’t allow statements in parens).</p><p>After the function you can see the two <code>()</code> braces, this is how we run the function we just declared. </p><p>That’s it. The rest is details.  </p><ul><li><p>The function inside IIFE doesn’t have to be anonymous. This one will work perfectly fine and will help to detect your function in a stacktrace during debugging: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">myIIFEFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hi, I'm IIFE!"</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// outputs "Hi, I'm IIFE!"</span></span><br></pre></td></tr></table></figure></li><li><p>It can take some parameters:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">myIIFEFunc</span>(<span class="params">param1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hi, I'm IIFE, "</span> + param1);</span><br><span class="line">&#125;)(<span class="string">"Yuri"</span>);</span><br><span class="line"><span class="comment">// outputs "Hi, I'm IIFE, Yuri!"</span></span><br></pre></td></tr></table></figure><p>Here there value <code>&quot;Yuri&quot;</code> is passed to the <code>param1</code> of the function.</p></li><li><p>It can return a value: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> <span class="title">myIIFEFunc</span>(<span class="params">param1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hi, I'm IIFE, "</span> + param1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;)(<span class="string">"Yuri"</span>);</span><br><span class="line"><span class="comment">// outputs "Hi, I'm IIFE, Yuri!"</span></span><br><span class="line"><span class="comment">// result variable will contain 1</span></span><br></pre></td></tr></table></figure></li><li><p>You don’t have to surround the function declaration into parens, although it’s the most common way to define IIFE. Instead you can use any of the following forms: </p><ul><li><code>~function(){console.log(&quot;hi I&#39;m IIFE&quot;)}()</code></li><li><code>!function(){console.log(&quot;hi I&#39;m IIFE&quot;)}()</code></li><li><code>+function(){console.log(&quot;hi I&#39;m IIFE&quot;)}()</code></li><li><code>-function(){console.log(&quot;hi I&#39;m IIFE&quot;)}()</code></li><li><code>(function(){console.log(&quot;hi I&#39;m IIFE&quot;)}());</code></li><li><code>var i = function(){console.log(&quot;hi I&#39;m IIFE&quot;)}();</code></li><li><code>true &amp;&amp; function(){ console.log(&quot;hi I&#39;m IIFE&quot;) }();</code></li><li><code>0, function(){ console.log(&quot;hi I&#39;m IIFE&quot;) }();</code></li><li><code>new function(){ console.log(&quot;hi I&#39;m IIFE&quot;) }</code></li><li><code>new function(){ console.log(&quot;hi I&#39;m IIFE&quot;) }()</code></li></ul><p>Please don’t use all these forms to impress colleagues, but be prepared that you can encounter them in someone’s code. </p></li></ul><h4 id="Applications-and-usefulness"><a href="#Applications-and-usefulness" class="headerlink" title="Applications and usefulness"></a>Applications and usefulness</h4><p>Variables and functions that you declare inside an IIFE are not visible to the outside world, so you can:</p><ul><li>Use the IIFE for isolating parts of the code to hide details of implementation.</li><li>Specify the input interface of your code by passing commonly used global objects (window, document, jQuery, etc.) IIFE’s parameters, and then reference these global objects within the IIFE via a local scope.</li><li>Use it in closures, when you use closures in loops.</li><li>IIFE is the basis of in the module pattern in ES5<br>code, it helps to prevent polluting the global scope and provide the module interface to the outside.</li></ul></details><h2 id="Question-27-Describe-Singleton-Pattern-In-JavaScript"><a href="#Question-27-Describe-Singleton-Pattern-In-JavaScript" class="headerlink" title="Question 27. Describe Singleton Pattern In JavaScript"></a>Question 27. Describe Singleton Pattern In JavaScript</h2><details><summary><b>Answer</b></summary><p>The singleton pattern is an often used JavaScript design pattern. It provides a way to wrap the code into a logical unit that can be accessed through a single variable. The Singleton design pattern is used when only one instance of an object is needed throughout the lifetime of an application. In JavaScript, Singleton pattern have many uses, they can be used for NameSpacing, which reduce the number of global variables in your page (prevent from polluting global space), organizing the code in a consistent manner, which increase the readability and maintainability of your pages.</p><p>There are two important points in the traditional definition of Singleton pattern:</p><ul><li>There should be only one instance allowed for a class and</li><li>We should allow global point of access to that single instance</li></ul><p>Let me define singleton pattern in JavaScript context:</p><blockquote><p>It is an object that is used to create namespace and group together a related set of methods and attributes (encapsulation) and if we allow to initiate then it can be initiated only once.</p></blockquote><p>In JavaScript, we can create singleton though object literal. However, there is some another way but that I will cover in next post.</p><p>A singleton object consists of two parts: The object itself, containing the members (Both methods and attributes) within it, and global variable used to access it. The variable is global so that object can be accessed anywhere in the page, this is a key feature of the singleton pattern.</p><p><strong>JavaScript: A Singleton as a Namespace</strong></p><p>As I have already stated above that singleton can be used to declare Namespace in JavaScript. NameSpacing is a large part of responsible programming in JavaScript. Because everything can be overwritten, and it is very easy to wipe out variable by mistake or a function, or even a class without even knowing it. A common example which happens frequently when you are working with another team member parallel,  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findUserName</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Later in the page another programmer</span></span><br><span class="line"><span class="comment">added code */</span></span><br><span class="line"><span class="keyword">var</span> findUserName = $(<span class="string">'#user_list'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* You are trying to call :( */</span></span><br><span class="line"><span class="built_in">console</span>.log(findUserName())</span><br></pre></td></tr></table></figure><p>One of the best ways to prevent accidentally overwriting variable is to namespace your code within a singleton object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  Using Namespace */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MyNameSpace = &#123;</span><br><span class="line">  findUserName : <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// Other methods and attribute go here as well</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Later in the page another programmer</span></span><br><span class="line"><span class="comment">added code */</span></span><br><span class="line"><span class="keyword">var</span> findUserName = $(<span class="string">'#user_list'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* You are trying to call and you make this time workable */</span></span><br><span class="line"><span class="built_in">console</span>.log(MyNameSpace.findUserName());</span><br></pre></td></tr></table></figure><h3 id="Singleton-Design-Pattern-Implementation"><a href="#Singleton-Design-Pattern-Implementation" class="headerlink" title="Singleton Design Pattern Implementation"></a>Singleton Design Pattern Implementation</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lazy Instantiation skeleton for a singleton pattern */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MyNameSpace = &#123;&#125;;</span><br><span class="line">MyNameSpace.Singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Private attribute that holds the single instance</span></span><br><span class="line">  <span class="keyword">var</span> singletonInstance;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// All of the normal code goes here</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">constructor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Private members</span></span><br><span class="line">    <span class="keyword">var</span> privateVar1 = <span class="string">"Nishant"</span>;</span><br><span class="line">    <span class="keyword">var</span> privateVar2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// code stuff</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// code stuff</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      attribute1 : <span class="string">"Nishant"</span>,</span><br><span class="line">      publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"Nishant"</span>);<span class="comment">// some code logic</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// public method (Global access point to Singleton object)</span></span><br><span class="line">    getInstance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//instance already exist then return  </span></span><br><span class="line">      <span class="keyword">if</span>(!singletonInstance) &#123;</span><br><span class="line">        singletonInstance = <span class="keyword">constructor</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      return singletonInstance;           </span><br><span class="line">    &#125;           </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)();   </span><br><span class="line"></span><br><span class="line">// getting access of publicMethod</span><br><span class="line">console.log(MyNamespace.Singleton.getInstance().publicMethod());</span><br></pre></td></tr></table></figure><p>The singleton implemented above is easy to understand. The singleton class maintains a static reference to the lone singleton instance and return that reference from the static getInstance() method.</p></details><h2 id="Question-28-What-are-the-ways-of-creating-objects-in-JavaScript"><a href="#Question-28-What-are-the-ways-of-creating-objects-in-JavaScript" class="headerlink" title="Question 28. What are the ways of creating objects in JavaScript ?"></a>Question 28. What are the ways of creating objects in JavaScript ?</h2><details><summary><b>Answer</b></summary><h4 id="Method-1-Function-based"><a href="#Method-1-Function-based" class="headerlink" title="Method 1: Function based"></a>Method 1: Function based</h4><p>This method is useful if we want to create several similar objects. In the code sample below, we wrote the function <code>Employee</code> and used it as a constructor by calling it with the <code>new</code> operator. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">fName, lName, age, salary</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.firstName = fName;</span><br><span class="line"><span class="keyword">this</span>.lastName = lName;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating multiple object which have similar property but diff value assigned to object property.</span></span><br><span class="line"><span class="keyword">var</span> employee1 = <span class="keyword">new</span> Employee(<span class="string">'John'</span>, <span class="string">'Moto'</span>, <span class="number">24</span>, <span class="string">'5000$'</span>);</span><br><span class="line"><span class="keyword">var</span> employee2 = <span class="keyword">new</span> Employee(<span class="string">'Ryan'</span>, <span class="string">'Jor'</span>, <span class="number">26</span>, <span class="string">'3000$'</span>);</span><br><span class="line"><span class="keyword">var</span> employee3 = <span class="keyword">new</span> Employee(<span class="string">'Andre'</span>, <span class="string">'Salt'</span>, <span class="number">26</span>, <span class="string">'4000$'</span>);</span><br></pre></td></tr></table></figure><h4 id="Method-2-Object-Literal"><a href="#Method-2-Object-Literal" class="headerlink" title="Method 2: Object Literal"></a>Method 2: Object Literal</h4><p>Object Literal is best way to create an object and this is used frequently. Below is code sample for create employee object which contains property as well as method.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee = &#123;</span><br><span class="line">name : <span class="string">'Nishant'</span>,</span><br><span class="line">salary : <span class="number">245678</span>,</span><br><span class="line">getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code sample below is Nested Object Literal, Here address is an object inside employee object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee = &#123;</span><br><span class="line">name : <span class="string">'Nishant'</span>,</span><br><span class="line">salary : <span class="number">245678</span>,</span><br><span class="line">address : &#123;</span><br><span class="line">addressLine1 : <span class="string">'BITS Pilani'</span>,</span><br><span class="line">addressLine2 : <span class="string">'Vidya Vihar'</span>.</span><br><span class="line">phoneNumber: &#123;</span><br><span class="line">  workPhone: <span class="number">7098889765</span>,</span><br><span class="line">  homePhone: <span class="number">1234567898</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-3-From-Object-using-new-keyword"><a href="#Method-3-From-Object-using-new-keyword" class="headerlink" title="Method 3: From Object using new keyword"></a>Method 3: From <code>Object</code> using <code>new</code> keyword</h4><p>In the code below, a sample object has been created using <code>Object</code>‘s constructor function.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// Created employee object using new keywords and Object()</span></span><br><span class="line">employee.name = <span class="string">'Nishant'</span>;</span><br><span class="line">employee.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-4-Using-Object-create"><a href="#Method-4-Using-Object-create" class="headerlink" title="Method 4:** Using Object.create"></a>Method 4:** Using <code>Object.create</code></h4><p><code>Object.create(obj)</code> will create a new object and set the <code>obj</code> as its prototype. It’s a modern way to create objects that inherit properties from other objects. <code>Object.create</code> function doesn’t run the constructor. You can use <code>Object.create(null)</code> when you don’t want your object to inherit the properties of <code>Object</code>.</p></details><h2 id="Question-29-Write-a-function-called-deepClone-which-takes-an-object-and-creates-a-object-copy-of-it"><a href="#Question-29-Write-a-function-called-deepClone-which-takes-an-object-and-creates-a-object-copy-of-it" class="headerlink" title="Question 29. Write a function called deepClone which takes an object and creates a object copy of it."></a>Question 29. Write a function called deepClone which takes an object and creates a object copy of it.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObject = deepClone(obj);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> newObject = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> object)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> object[key] === <span class="string">'object'</span>  &amp;&amp; object[key] !== <span class="literal">null</span> )&#123;</span><br><span class="line"> newObject[key] = deepClone(object[key]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> newObject[key] = object[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Explanation:</strong> We have been asked to do deep copy of object so What’s basically it’s mean ??. Let’s understand in this way you have been given an object <code>personalDetail</code> this object contains some property which again a type of object here as you can see <code>address</code> is an object and <code>phoneNumber</code> in side an <code>address</code> is also an object. In simple term <code>personalDetail</code> is nested object(object inside object). So Here deep copy means we have to copy all the property of <code>personalDetail</code> object including nested object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> personalDetail = &#123;</span><br><span class="line">name : <span class="string">'Nishant'</span>,</span><br><span class="line">address : &#123;</span><br><span class="line">  location: <span class="string">'xyz'</span>,</span><br><span class="line">  zip : <span class="string">'123456'</span>,</span><br><span class="line">  phoneNumber : &#123;</span><br><span class="line">    homePhone: <span class="number">8797912345</span>,</span><br><span class="line">    workPhone : <span class="number">1234509876</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So when we do deep clone then we should copy every property (including the nested object).</p></details><h2 id="Question-30-Best-way-to-detect-undefined-object-property-in-JavaScript"><a href="#Question-30-Best-way-to-detect-undefined-object-property-in-JavaScript" class="headerlink" title="Question 30. Best way to detect undefined object property in JavaScript."></a>Question 30. Best way to detect <code>undefined</code> object property in JavaScript.</h2><details><summary><b>Answer</b></summary><blockquote><p>Suppose we have given an object <code>person</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'Nishant'</span>,</span><br><span class="line">age : <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here the <code>person</code> object has a <code>name</code> and <code>age</code> property. Now we are trying to access the <strong>salary</strong> property which we haven’t declared on the person object so while accessing it will return undefined. So how we will ensure whether property is undefined or not before performing some operation over it?</p><p><strong>Explanation:</strong></p><p>We can use <code>typeof</code> operator to check undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> someProperty === <span class="string">'undefined'</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'something is undefined here'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we are trying to access salary property of person object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> person.salary === <span class="string">'undefined'</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"salary is undefined here because we haven't declared"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Question-31-Write-a-function-called-Clone-which-takes-an-object-and-creates-a-object-copy-of-it-but-not-copy-deep-property-of-object"><a href="#Question-31-Write-a-function-called-Clone-which-takes-an-object-and-creates-a-object-copy-of-it-but-not-copy-deep-property-of-object" class="headerlink" title="Question 31. Write a function called Clone which takes an object and creates a object copy of it but not copy deep property of object."></a>Question 31. Write a function called <code>Clone</code> which takes an object and creates a object copy of it but not copy deep property of object.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> objectLit = &#123;<span class="attr">foo</span> : <span class="string">'Bar'</span>&#125;; </span><br><span class="line"><span class="keyword">var</span> cloneObj = Clone(obj); <span class="comment">// Clone is the function which you have to write </span></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj === Clone(objectLit)); <span class="comment">// this should return false</span></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj == Clone(objectLit)); <span class="comment">// this should return true</span></span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clone</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newObject = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> object)&#123;</span><br><span class="line">  newObject[key] = object[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Question-32-What-are-promises-and-how-they-are-useful"><a href="#Question-32-What-are-promises-and-how-they-are-useful" class="headerlink" title="Question 32. What are promises and how they are useful?"></a>Question 32. What are promises and how they are useful?</h2><details><summary><b>Answer</b></summary><p>We use promises for handling asynchronous interactions in a sequential manner. They are especially useful when we need to do an async operation and THEN do another async operation based on the results of the first one. For example, if you want to request the list of all flights and then for each flight you want to request some details about it. The promise represents the future value. It has an internal state (<code>pending</code>, <code>fulfilled</code> and <code>rejected</code>) and works like a state machine.</p><p>A promise object has <code>then</code> method, where you can specify what to do when the promise is fulfilled or rejected.</p><p>You can chain <code>then()</code> blocks, thus avoiding the callback hell. You can handle errors in the <code>catch()</code> block.  After a promise is set to fulfilled or rejected state, it becomes immutable.</p><p>Also mention that you know about more sophisticated concepts: </p><ul><li><code>async/await</code> which makes the code appear even more linear</li><li>RxJS observables can be viewed as the recyclable promises</li></ul><p>Be sure that you can implement the promise, read <a href="https://opensourceconnections.com/blog/2014/02/16/a-simple-promise-implementation-in-about-20-lines-of-javascript/" target="_blank" rel="noopener">one of the articles on a topic</a>, and learn the source code of the <a href="https://gist.github.com/softwaredoug/9044640" target="_blank" rel="noopener">simplest promise implementation</a>. </p></details><h2 id="Question-33-How-to-check-whether-a-key-exist-in-a-JavaScript-object-or-not"><a href="#Question-33-How-to-check-whether-a-key-exist-in-a-JavaScript-object-or-not" class="headerlink" title="Question 33. How to check whether a key exist in a JavaScript object or not."></a>Question 33. How to check whether a key exist in a JavaScript object or not.</h2><details><summary><b>Answer</b></summary><p>Let say we have <code>person</code> object with property <strong>name</strong> and <strong>age</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'Nishant'</span>,</span><br><span class="line">age: <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we want to check whether <code>name</code> property exist in <code>person</code> object or not ?</p><p>In JavaScript object can have own property, in above example name and age is own property of person object. Object also have some of inherited property of base object like toString is inherited property of person object.</p><p>So how we will check whether property is own property or inherited property. </p><p>Method 1: We can use <code>in</code> operator on objet to check own property or inherited property. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> person); <span class="comment">// checking own property print true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'salary'</span> <span class="keyword">in</span> person); <span class="comment">// checking undefined property print false</span></span><br></pre></td></tr></table></figure><p><code>in</code> operator also look into inherited property if it doesn’t find property defined as own property. For instance If I check existence of toString property as we know that we haven’t declared this property on person object so <code>in</code> operator look into there base property.</p><p>Here </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> person); <span class="comment">// Will print true</span></span><br></pre></td></tr></table></figure><p>If we want to test property of object instance not inherited properties then we will use <code>hasOwnProperty</code> method of object instance.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">'toString'</span>)); <span class="comment">// print false</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">// print true</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">'salary'</span>)); <span class="comment">// print false</span></span><br></pre></td></tr></table></figure></details><h2 id="Question-34-What-is-NaN-why-do-we-need-it-and-when-can-it-break-the-page"><a href="#Question-34-What-is-NaN-why-do-we-need-it-and-when-can-it-break-the-page" class="headerlink" title="Question 34. What is NaN, why do we need it, and when can it break the page?"></a>Question 34. What is NaN, why do we need it, and when can it break the page?</h2><details><summary><b>Answer</b></summary><p><code>NaN</code> stands for “not a number.” and it can break your table of numbers when it has an arithmetic operation that is not allowed. Here are some examples of how you can get <code>NaN</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">-5</span>);</span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"foo"</span>); <span class="comment">/* this is common: you get JSON from the server, convert some strings from JSON to a number and end up with NaN in your UI. */</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> is not equal to any number, it’s not less or more than any number, also it’s not equal to itself: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> !== <span class="literal">NaN</span></span><br><span class="line"><span class="literal">NaN</span> &lt; <span class="number">2</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> &gt; <span class="number">2</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="number">2</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>To check if the current value of the variable is NaN, you have to use the <code>isNaN</code> function. This is why we can often see NaN in the webpages: it requires special check which a lot of developers forget to do. </p><p>Further reading: <a href="https://ariya.io/2014/05/the-curious-case-of-javascript-nan" target="_blank" rel="noopener">great blogpost on ariya.io</a></p></details><h2 id="Question-35-Fix-the-bug-using-ES5-only"><a href="#Question-35-Fix-the-bug-using-ES5-only" class="headerlink" title="Question 35. Fix the bug using ES5 only"></a>Question 35. Fix the bug using ES5 only</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">32</span>, <span class="number">65</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The index of this number is: '</span> + i);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>For ES6, you can just replace <code>var i</code> with <code>let i</code>. </p><p>For ES5, you need to create a function scope like here:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">32</span>, <span class="number">65</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'The index of this number is: '</span> + j)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;(i), <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This can also achieve by forEach (allows you to keep that variable within the forEach’s scope)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">32</span>, <span class="number">65</span>, <span class="number">2</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ele, i</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The index of this number is: '</span> + i);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></details><h2 id="Question-36-How-to-check-if-the-value-of-a-variable-in-an-array"><a href="#Question-36-How-to-check-if-the-value-of-a-variable-in-an-array" class="headerlink" title="Question 36. How to check if the value of a variable in an array?"></a>Question 36. How to check if the value of a variable in an array?</h2><details><summary><b>Answer</b></summary><p>We always encounter in such situation where we need to know whether value is type of array or not.</p><p>For instance : the code below perform some operation based value type</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"value is an array"</span>)&#123;</span><br><span class="line"><span class="comment">// Then perform some operation</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// otherwise</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s discuss some way to detect an array in JavaScript.</p><p><strong>Method 1:</strong></p><p>Juriy Zaytsev (Also known as kangax) proposed an elegant solution to this.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This approach is most popular way to detecting a value of type array in JavaScript and recommended to use. This approach relies on the fact that, native toString() method on a given value produce a standard string in all browser. </p><p><strong>Method 2:</strong> </p><p>Duck typing test for array type detection</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Duck typing arrays</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> value.sort === <span class="string">'function'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As we can see above isArray method will return true if value object have <code>sort</code> method of type <code>function</code>. Now assume you have created a object with sort method</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">sort: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// Some code </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now when you check <code>isArray(bar)</code> then it will return true because bar object has sort method, But the fact is bar is not an array.</p><p>So this method is not a best way to detect an array as you can see it’s not handle the case when some object has sort method.</p><p><strong>Method 3:</strong> </p><p>ECMAScript 5 has introduced <strong>Array.isArray()</strong> method to detect an array type value. The sole purpose of this method is accurately detecting whether a value is an array or not.</p><p>In many JavaScript libraries you may see the code below for detecting an value of type array.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// ECMAScript 5 feature</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Array</span>.isArray === <span class="string">'function'</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.isArray(value);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Method 4:</strong></p><p>You can query the constructor name:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.constructor.name === <span class="string">"Array"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Method 5:</strong></p><p>You check  if a given value is an <code>instanceof Array</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Question-37-Best-way-to-detect-reference-values-of-any-type-in-JavaScript"><a href="#Question-37-Best-way-to-detect-reference-values-of-any-type-in-JavaScript" class="headerlink" title="Question 37. Best way to detect reference values of any type in JavaScript ?"></a>Question 37. Best way to detect reference values of any type in JavaScript ?</h2><details><summary><b>Answer</b></summary><p> In Javascript Object are called as reference type, Any value other then primitive is definitely a reference type. There are several built-in reference type such as <strong>Object</strong>, <strong>Array</strong>, <strong>Function</strong>, <strong>Date</strong>, <strong>null</strong> and <strong>Error</strong>.</p><p>Detecting object using <code>typeof</code> operator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);           <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);           <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Array</span>());  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);         <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>()); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>());   <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>But the downside of using typeof operator to detect an object is that typeof returns <code>object</code> for <code>null</code> (However this is fact that null is an object in JavaScript).</p><p>The best way to detect an object of specific reference type using <code>instanceof</code> operator.</p><blockquote><p>Syntax : <strong>value</strong> instanceof <strong>constructor</strong>   </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Detecting an array</span></span><br><span class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value is type of array"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Employee constructor function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name; <span class="comment">// Public property</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emp1 = <span class="keyword">new</span> Employee(<span class="string">'John'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(emp1 <span class="keyword">instanceof</span> Employee); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code> not only check the constructor which is used to create an object but also check it’s prototype chain see below example.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(emp1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></details><h2 id="Question-38-How-does-Object-create-method-works-JavaScript"><a href="#Question-38-How-does-Object-create-method-works-JavaScript" class="headerlink" title="Question 38. How does Object.create method works JavaScript?"></a>Question 38. How does Object.create method works JavaScript?</h2><details><summary><b>Answer</b></summary><p>The ECMAScript 5 <strong>Object.create()</strong> method is the easiest way for one object to inherit from another, without invoking a constructor function. </p><p><strong>For instance:</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee = &#123;</span><br><span class="line">  name: <span class="string">'Nishant'</span>,</span><br><span class="line">  displayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emp1 = <span class="built_in">Object</span>.create(employee);</span><br><span class="line"><span class="built_in">console</span>.log(emp1.displayName());  <span class="comment">// output "Nishant"</span></span><br></pre></td></tr></table></figure><p>In the example above, we create a new object <code>emp1</code> that inherits from <code>employee</code>. In other words <code>emp1</code>‘s prototype is set to <code>employee</code>. After this emp1 is able to access the same properties and method on employee until new properties or method with the same name are defined.</p><p><strong>For instance:</strong> Defining <code>displayName()</code> method on <code>emp1</code> will not automatically override the employee <code>displayName</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">emp1.displayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'xyz-Anonymous'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">employee.displayName(); <span class="comment">//Nishant</span></span><br><span class="line">emp1.displayName();<span class="comment">//xyz-Anonymous</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In addition to this **`</span><span class="built_in">Object</span>.create(<span class="string">`)** method also allows to specify a second argument which is an object containing additional properties and methods to add to the new object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**For example**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> emp1 = <span class="built_in">Object</span>.create(employee, &#123;</span><br><span class="line">name: &#123;</span><br><span class="line">value: <span class="string">"John"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emp1.displayName(); <span class="comment">// "John"</span></span><br><span class="line">employee.displayName(); <span class="comment">// "Nishant"</span></span><br></pre></td></tr></table></figure><p>In the example above, <code>emp1</code> is created with it’s own value for name, so calling <strong>displayName()</strong> method will display <code>&quot;John&quot;</code> instead of <code>&quot;Nishant&quot;</code>.</p><p>Object created in this manner give you full control over newly created object. You are free to add, remove any properties and method you want.</p></details><h2 id="Question-39-How-to-use-constructor-functions-for-inheritance-in-JavaScript"><a href="#Question-39-How-to-use-constructor-functions-for-inheritance-in-JavaScript" class="headerlink" title="Question 39. How to use constructor functions for inheritance in JavaScript?"></a>Question 39. How to use constructor functions for inheritance in JavaScript?</h2><details><summary><b>Answer</b></summary><p>Let say we have <code>Person</code> class which has name, age, salary properties and <strong>incrementSalary()</strong> method.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  <span class="keyword">this</span>.incrementSalary = <span class="function"><span class="keyword">function</span> (<span class="params">byValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = <span class="keyword">this</span>.salary + byValue;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we wish to create Employee class which contains all the properties of Person class and wanted to add some additional properties into Employee class.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">company</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.company = company;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Prototypal Inheritance </span></span><br><span class="line">Employee.prototype = <span class="keyword">new</span> Person(<span class="string">"Nishant"</span>, <span class="number">24</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>In the example above, <strong>Employee</strong> type inherits from <strong>Person</strong>. It does so by assigning a new instance of <code>Person</code> to <code>Employee</code> prototype. After that, every instance of <code>Employee</code> inherits its properties and methods from <code>Person</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Prototypal Inheritance </span></span><br><span class="line">Employee.prototype = <span class="keyword">new</span> Person(<span class="string">"Nishant"</span>, <span class="number">24</span>,<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emp1 = <span class="keyword">new</span> Employee(<span class="string">"Google"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(emp1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(emp1 <span class="keyword">instanceof</span> Employee); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Let’s understand Constructor inheritance </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Defined Person class</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">"Nishant"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj inherit Person class properties and method </span></span><br><span class="line">Person.call(obj); <span class="comment">// constructor inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Object &#123;name: "Nishant"&#125;</span></span><br></pre></td></tr></table></figure><p>Here we saw calling <strong>Person.call(obj)</strong> define the name properties from <code>Person</code> to <code>obj</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name <span class="keyword">in</span> obj); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Type-based inheritance is best used with developer defined constructor function rather than natively in JavaScript. In addition to this also allows flexibility in how we create similar type of object.</p></details><h2 id="Question-40-How-we-can-prevent-modification-of-object-in-JavaScript"><a href="#Question-40-How-we-can-prevent-modification-of-object-in-JavaScript" class="headerlink" title="Question 40. How we can prevent modification of object in JavaScript ?."></a>Question 40. How we can prevent modification of object in JavaScript ?.</h2><details><summary><b>Answer</b></summary><p> ECMAScript 5 introduce several methods to prevent modification of object which lock down object to ensure that no one, accidentally or otherwise, change functionality of Object.</p><p>There are three levels of preventing modification: </p><p><strong>1: Prevent extensions :</strong> </p><p>No new properties or methods can be added to the object, but one can change the existing properties and method.</p><p>For example: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee = &#123;</span><br><span class="line">name: <span class="string">"Nishant"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock the object </span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(employee);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now try to change the employee object property name</span></span><br><span class="line">employee.name = <span class="string">"John"</span>; <span class="comment">// work fine </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Now try to add some new property to the object</span></span><br><span class="line">employee.age = <span class="number">24</span>; <span class="comment">// fails silently unless it's inside the strict mode</span></span><br></pre></td></tr></table></figure><p><strong>2: Seal :</strong></p><p>It is same as prevent extension, in addition to this also prevent existing properties and methods from being deleted.</p><p>To seal an object, we use <strong>Object.seal()</strong> method. you can check whether an object is sealed or not using <strong>Object.isSealed();</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee = &#123;</span><br><span class="line">name: <span class="string">"Nishant"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Seal the object </span></span><br><span class="line"><span class="built_in">Object</span>.seal(employee);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(employee)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(employee)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> employee.name <span class="comment">// fails silently unless it's in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trying to add new property will give an error</span></span><br><span class="line">employee.age = <span class="number">30</span>; <span class="comment">// fails silently unless in strict mode</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">when an object is sealed, its existing properties and methods can't be removed. Sealed object are also non-extensible.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**3: Freeze :**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Same as seal, In addition to this prevent existing properties methods from being modified (All properties and methods are read only).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To freeze an object, use Object.freeze() method. We can also determine whether an object is frozen using Object.isFrozen();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> employee = &#123;</span><br><span class="line">name: <span class="string">"Nishant"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Freeze the object</span></span><br><span class="line"><span class="built_in">Object</span>.freeze(employee); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Seal the object </span></span><br><span class="line"><span class="built_in">Object</span>.seal(employee);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(employee)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(employee));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(employee));     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">employee.name = <span class="string">"xyz"</span>; <span class="comment">// fails silently unless in strict mode</span></span><br><span class="line">employee.age = <span class="number">30</span>;     <span class="comment">// fails silently unless in strict mode</span></span><br><span class="line"><span class="keyword">delete</span> employee.name   <span class="comment">// fails silently unless it's in strict mode</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Frozen objects are considered both non-extensible and sealed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**Recommended:**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you are decided to prevent modification, sealed, freeze the object then use in strict mode so that you can catch the error.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For example: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> employee = &#123;</span><br><span class="line">name: <span class="string">"Nishant"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Freeze the object</span></span><br><span class="line"><span class="built_in">Object</span>.freeze(employee); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Seal the object </span></span><br><span class="line"><span class="built_in">Object</span>.seal(employee);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(employee)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(employee));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(employee));     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">employee.name = <span class="string">"xyz"</span>; <span class="comment">// fails silently unless in strict mode</span></span><br><span class="line">employee.age = <span class="number">30</span>;     <span class="comment">// fails silently unless in strict mode</span></span><br><span class="line"><span class="keyword">delete</span> employee.name;  <span class="comment">// fails silently unless it's in strict mode</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/details&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Question 41. Write a log function which will add prefix `</span>(your message)<span class="string">` to every message you log using console.log ? </span></span><br><span class="line"><span class="string"> For example, If you log `</span><span class="built_in">console</span>.log(<span class="string">"Some message"</span>)<span class="string">` then output should be **(your message) Some message**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &lt;details&gt;&lt;summary&gt;&lt;b&gt;Answer&lt;/b&gt;&lt;/summary&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Logging error message or some informative message is always required when you dealing with client side JavaScript using console.log method. Some time you want to add some prefix to identify message generated log from your application hence you would like to prefix your app name in every console.log. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A general way to do this keep adding your app name in every console.log message like </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'your app name'</span> + <span class="string">'some error message'</span>);</span><br></pre></td></tr></table></figure><p>But doing in this way you have to write your app name everytime when you log message using console.</p><p>There are some best way we can achieve this </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appLog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  args.unshift(<span class="string">'your app name'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">appLog(<span class="string">"Some error message"</span>); </span><br><span class="line"><span class="comment">//output of above console: 'your app name Some error message'</span></span><br></pre></td></tr></table></figure></details><h2 id="Question-42-Write-a-function-which-will-test-string-as-a-literal-and-as-an-object"><a href="#Question-42-Write-a-function-which-will-test-string-as-a-literal-and-as-an-object" class="headerlink" title="Question 42 . Write a function which will test string as a literal and as an object ?"></a>Question 42 . Write a function which will test string as a literal and as an object ?</h2><p>For example: We can create string using string literal and using String constructor function. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using string literal</span></span><br><span class="line"><span class="keyword">var</span> ltrlStr = <span class="string">"Hi I am string literal"</span>;</span><br><span class="line"><span class="comment">// using String constructor function </span></span><br><span class="line"><span class="keyword">var</span> objStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Hi I am string object"</span>);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p> We can use typeof operator to test string literal and instanceof operator to test String object.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">typeof</span>(str) == <span class="string">'string'</span> || str <span class="keyword">instanceof</span> <span class="built_in">String</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> ltrlStr = <span class="string">"Hi I am string literal"</span>;</span><br><span class="line"> <span class="keyword">var</span> objStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Hi I am string object"</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(isString(ltrlStr)); <span class="comment">// true</span></span><br><span class="line"> <span class="built_in">console</span>.log(isString(objStr)); <span class="comment">// true</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">&lt;/details&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Question 43 . What is typical use case for anonymous function in JavaScript ?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;details&gt;&lt;summary&gt;&lt;b&gt;Answer&lt;/b&gt;&lt;/summary&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Anonymous functions basically used in following scenario.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. No name is needed if function is only used in one place, then there is no need to add a name to function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Let's take the example of setTimeout function </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><pre><code>Here there is no need of using named function when we are sure     that function which will alert `hello` would use only once in     application.</code></pre><ol start="2"><li><p>Anonymous functions are declared inline and inline functions have advantages in the case that they can access variable in the parent scopes.</p><p> Let’s take a example of event handler. Notify event of particular     type (such as click) for a given object. </p><p> Let say we have HTML element (button) on which we want to add click event and when user do click on button we would like to execute some logic.</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"myBtn"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p> Add Event Listener </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'button clicked'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><pre><code>Above example shows used of anonymous function as a callback function in event handler.</code></pre><ol start="3"><li><p>Passing anonymous function as a parameter to calling function.</p><p> Example: </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function which will execute callback function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processCallback</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">'function'</span>)&#123;</span><br><span class="line">callback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call function and pass anonymous function as callback </span></span><br><span class="line">processCallback(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Hi I am anonymous callback function"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>The best way to make a decision for using anonymous function is to ask the following question:</p><p> Will the function which I am going to define, be used anywhere else?</p><p>If your answer is yes then go and create named function rather anonymous function.</p><p><strong>Advantage of using anonymous function:</strong></p><ol><li>It can reduce a bit of code, particularly in recursive function and in callback function.</li><li>Avoid needless global namespace pollutions.</li></ol></details><h2 id="Question-44-How-to-set-a-default-parameter-value"><a href="#Question-44-How-to-set-a-default-parameter-value" class="headerlink" title="Question 44 . How to set a default parameter value ?"></a>Question 44 . How to set a default parameter value ?</h2><details><summary><b>Answer</b></summary><p> If you are coming from python/c# you might be using default value for function parameter incase value(formal parameter) has not been passed. For instance : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Define sentEmail function </span><br><span class="line">// configuration : Configuration object</span><br><span class="line">// provider : Email Service provider, Default would be gmail</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sentEmail</span><span class="params">(configuration, provider = <span class="string">'Gmail'</span>)</span>:</span></span><br><span class="line"><span class="comment"># Your code logic</span></span><br></pre></td></tr></table></figure><p><strong>In Pre ES6/ES2015</strong></p><p>There are a lot of ways by which you can achieve this in pre ES2015.</p><p>Let’s understand the code below by which we achieved setting default parameter value.</p><p><strong>Method 1: Setting default parameter value</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sentEmail</span>(<span class="params">configuration, provider</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Set default value if user has not passed value for provider</span></span><br><span class="line">  provider = <span class="keyword">typeof</span> provider !== <span class="string">'undefined'</span> ? provider : <span class="string">'Gmail'</span>  </span><br><span class="line">  <span class="comment">// Your code logic</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In this call we are not passing provider parameter value</span></span><br><span class="line">sentEmail(&#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="string">'xyz@gmail.com'</span>,</span><br><span class="line">  subject: <span class="string">'Test Email'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Here we are passing Yahoo Mail as a provider value</span></span><br><span class="line">sentEmail(&#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="string">'xyz@gmail.com'</span>,</span><br><span class="line">  subject: <span class="string">'Test Email'</span></span><br><span class="line">&#125;, <span class="string">'Yahoo Mail'</span>);</span><br></pre></td></tr></table></figure><p><strong>Method 2: Setting default parameter value</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sentEmail</span>(<span class="params">configuration, provider</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Set default value if user has not passed value for provider</span></span><br><span class="line">  provider = provider || <span class="string">'Gmail'</span>  </span><br><span class="line">  <span class="comment">// Your code logic</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In this call we are not passing provider parameter value</span></span><br><span class="line">sentEmail(&#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="string">'xyz@gmail.com'</span>,</span><br><span class="line">  subject: <span class="string">'Test Email'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Here we are passing Yahoo Mail as a provider value</span></span><br><span class="line">sentEmail(&#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="string">'xyz@gmail.com'</span>,</span><br><span class="line">  subject: <span class="string">'Test Email'</span></span><br><span class="line">&#125;, <span class="string">'Yahoo Mail'</span>);</span><br></pre></td></tr></table></figure><p><strong>Method 3: Setting default parameter value in ES6</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendEmail</span>(<span class="params">configuration, provider = <span class="string">"Gmail"</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Set default value if user has not passed value for provider</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Value of provider can be accessed directly</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Provider: <span class="subst">$&#123;provider&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In this call we are not passing provider parameter value</span></span><br><span class="line">sentEmail(&#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="string">'xyz@gmail.com'</span>,</span><br><span class="line">  subject: <span class="string">'Test Email'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Here we are passing Yahoo Mail as a provider value</span></span><br><span class="line">sentEmail(&#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="string">'xyz@gmail.com'</span>,</span><br><span class="line">  subject: <span class="string">'Test Email'</span></span><br><span class="line">&#125;, <span class="string">'Yahoo Mail'</span>);</span><br></pre></td></tr></table></figure></details><h2 id="Question-45-Write-code-for-merge-two-JavaScript-Object-dynamically"><a href="#Question-45-Write-code-for-merge-two-JavaScript-Object-dynamically" class="headerlink" title="Question 45. Write code for merge two JavaScript Object dynamically."></a>Question 45. Write code for merge two JavaScript Object dynamically.</h2><p>Let say you have two objects </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">'John'</span>,</span><br><span class="line">age  : <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> address = &#123;</span><br><span class="line">addressLine1 : <span class="string">'Some Location x'</span>,</span><br><span class="line">addressLine2 : <span class="string">'Some Location y'</span>,</span><br><span class="line">city : <span class="string">'NewYork'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Write merge function which will take two object and add all the own property of second object into first object.</p><details><summary><b>Answer</b></summary><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">merge(person , address); </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Now person should have 5 properties </span></span><br><span class="line"><span class="comment">name , age , addressLine1 , addressLine2 , city */</span></span><br></pre></td></tr></table></figure><p><strong>Method 1: Using ES6, Object.assign method</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">toObj, fromObj</span>) =&gt;</span> <span class="built_in">Object</span>.assign(toObj, fromObj);</span><br></pre></td></tr></table></figure><p><strong>Method 2: Without using built-in function</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">toObj, fromObj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure both of the parameter is an object</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> toObj === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> fromObj === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> pro <span class="keyword">in</span> fromObj) &#123;</span><br><span class="line">      <span class="comment">// Assign only own properties not inherited properties</span></span><br><span class="line">      <span class="keyword">if</span> (fromObj.hasOwnProperty(pro)) &#123;</span><br><span class="line">        <span class="comment">// Assign property and value</span></span><br><span class="line">        toObj[pro] = fromObj[pro];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"Merge function can apply only on object"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Question-46-What-is-non-enumerable-property-in-JavaScript-and-how-you-can-create-one"><a href="#Question-46-What-is-non-enumerable-property-in-JavaScript-and-how-you-can-create-one" class="headerlink" title="Question 46. What is non-enumerable property in JavaScript and how you can create one?"></a>Question 46. What is non-enumerable property in JavaScript and how you can create one?</h2><details><summary><b>Answer</b></summary><p>Object can have properties that don’t show up when you iterate through object using for…in loop or using Object.keys() to get an array of property names. This properties is know as non-enumerable properties.</p><p>Let say we have following object</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'John'</span></span><br><span class="line">&#125;;</span><br><span class="line">person.salary = <span class="string">'10000$'</span>;</span><br><span class="line">person[<span class="string">'country'</span>] = <span class="string">'USA'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); <span class="comment">// ['name', 'salary', 'country']</span></span><br></pre></td></tr></table></figure><p>As we know that person object properties <code>name</code>, <code>salary</code> ,<code>country</code> are enumerable hence it’s shown up when we called Object.keys(person).</p><p>To create a non-enumerable property we have to use <strong>Object.defineProperty()</strong>. This is a special method for creating non-enumerable property in JavaScript.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'John'</span></span><br><span class="line">&#125;;</span><br><span class="line">person.salary = <span class="string">'10000$'</span>;</span><br><span class="line">person[<span class="string">'country'</span>] = <span class="string">'USA'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create non-enumerable property</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'phoneNo'</span>,&#123;</span><br><span class="line">value : <span class="string">'8888888888'</span>,</span><br><span class="line">enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(person); <span class="comment">// ['name', 'salary', 'country']</span></span><br></pre></td></tr></table></figure><p>In the example above <code>phoneNo</code> property didn’t show up because we made it non-enumerable by setting <strong>enumerable:false</strong></p><p><strong>Bonus</strong></p><p>Now let’s try to change value of <code>phoneNo</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.phoneNo = <span class="string">'7777777777'</span>;</span><br></pre></td></tr></table></figure><p><strong>Object.defineProperty()</strong> also lets you create read-only properties as we saw above, we are not able to modify phoneNo value of a person object. This is because descriptor has <strong>writable</strong> property, which is <code>false</code> by default. Changing non-writable property value will return error in strict mode. In non-strict mode it won’t through any error but it won’t change the value of phoneNo.</p></details><h2 id="Question-47-What-is-Function-binding"><a href="#Question-47-What-is-Function-binding" class="headerlink" title="Question 47. What is Function binding ?"></a>Question 47. What is Function binding ?</h2><details><summary><b>Answer</b></summary><p> Function binding falls in advance JavaScript category and this is very popular technique to use in conjunction with event handler and callback function to preserve code execution context while passing function as a parameter.</p><p>Let’s consider the following example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clickHandler = &#123;</span><br><span class="line">message: <span class="string">'click event handler'</span>,</span><br><span class="line">handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line"><span class="comment">// Add click event to btn</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, clickHandler.handleClick);</span><br></pre></td></tr></table></figure><p>Here in this example clickHandler object is created which contain message properties and handleClick method.</p><p>We have assigned handleClick method to a DOM button, which will be executed in response of click. When the button is clicked, then handleClick method is being called and console message. Here console.log should log the <code>click event handler</code> message but it actually log <code>undefined</code>.</p><p>The problem of displaying <code>undefined</code> is because of the execution context of clickHandler.handleClick method is not being saved hence <code>this</code> pointing to button <code>btn</code> object. We can fix this issue using bind method.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clickHandler = &#123;</span><br><span class="line">message: <span class="string">'click event handler'</span>,</span><br><span class="line">handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line"><span class="comment">// Add click event to btn and bind the clickHandler object</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, clickHandler.handleClick.bind(clickHandler));</span><br></pre></td></tr></table></figure><p><code>bind</code> method is available to all the function similar to call and apply method which take argument value of <code>this</code>.</p></details><h1 id="Coding-Questions"><a href="#Coding-Questions" class="headerlink" title="Coding Questions"></a>Coding Questions</h1><h2 id="Passing-values-by-reference-vs-by-value"><a href="#Passing-values-by-reference-vs-by-value" class="headerlink" title="Passing values by reference vs by value"></a>Passing values by reference vs by value</h2><p>For a JS developer, it’s crucially important to understand which values are passed by reference,<br>and which ones are passed by value. Remember that objects, including arrays are passed by reference<br>while strings, booleans and numbers are passed by value. </p><h3 id="1-What-would-be-the-output-of-following-code"><a href="#1-What-would-be-the-output-of-following-code" class="headerlink" title="1. What would be the output of following code?"></a>1. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strA = <span class="string">"hi there"</span>;</span><br><span class="line"><span class="keyword">var</span> strB = strA;</span><br><span class="line">strB=<span class="string">"bye there!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log (strA)</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output will be <code>&#39;hi there&#39;</code> because we’re dealing with strings here. Strings are<br>passed by value, that is, copied. </p></details><h3 id="2-What-would-be-the-output-of-following-code"><a href="#2-What-would-be-the-output-of-following-code" class="headerlink" title="2. What would be the output of following code?"></a>2. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;<span class="attr">prop1</span>: <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objB = objA; </span><br><span class="line">objB.prop1 = <span class="number">90</span>;</span><br><span class="line"><span class="built_in">console</span>.log(objA)</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output will be <code>{prop1: 90}</code> because we’re dealing with objects here. Objects are<br>passed by reference, that is, <code>objA</code> and <code>objB</code> point to the same object in memory. </p></details><h3 id="3-What-would-be-the-output-of-following-code"><a href="#3-What-would-be-the-output-of-following-code" class="headerlink" title="3. What would be the output of following code?"></a>3. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;<span class="attr">prop1</span>: <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objB = objA;</span><br><span class="line">objB = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(objA)</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output will be <code>{prop1: 42}</code>. </p><p>When we assign <code>objA</code> to <code>objB</code>, the <code>objB</code> variable will point<br>to the same object as the <code>objB</code> variable.</p><p>However, when we reassign <code>objB</code> to an empty object, we simply change where <code>objB</code> variable references to.<br>This doesn’t affect where <code>objA</code> variable references to. </p></details><h3 id="4-What-would-be-the-output-of-following-code"><a href="#4-What-would-be-the-output-of-following-code" class="headerlink" title="4. What would be the output of following code?"></a>4. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrA = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arrB = arrA;</span><br><span class="line">arrB[<span class="number">0</span>]=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrA)</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output will be <code>[42,1,2,3,4,5]</code>. </p><p>Arrays are object in JavaScript and they are passed and assigned by reference. This is why<br>both <code>arrA</code> and <code>arrB</code> point to the same array <code>[0,1,2,3,4,5]</code>. That’s why changing the first<br>element of the <code>arrB</code> will also modify <code>arrA</code>: it’s the same array in the memory.</p></details><h3 id="5-What-would-be-the-output-of-following-code"><a href="#5-What-would-be-the-output-of-following-code" class="headerlink" title="5. What would be the output of following code?"></a>5. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrA = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arrB = arrA.slice();</span><br><span class="line">arrB[<span class="number">0</span>]=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrA)</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output will be <code>[0,1,2,3,4,5]</code>. </p><p>The <code>slice</code> function copies all the elements of the array returning the new array. That’s why<br><code>arrA</code> and <code>arrB</code> reference two completely different arrays. </p></details><h3 id="6-What-would-be-the-output-of-following-code"><a href="#6-What-would-be-the-output-of-following-code" class="headerlink" title="6. What would be the output of following code?"></a>6. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrA = [&#123;<span class="attr">prop1</span>: <span class="string">"value of array A!!"</span>&#125;,  &#123;<span class="attr">someProp</span>: <span class="string">"also value of array A!"</span>&#125;, <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arrB = arrA;</span><br><span class="line">arrB[<span class="number">0</span>].prop1=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrA);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output will be <code>[{prop1: 42},  {someProp: &quot;also value of array A!&quot;}, 3,4,5]</code>. </p><p>Arrays are object in JS, so both varaibles arrA and arrB point to the same array. Changing<br><code>arrB[0]</code> is the same as changing <code>arrA[0]</code></p></details><h3 id="7-What-would-be-the-output-of-following-code"><a href="#7-What-would-be-the-output-of-following-code" class="headerlink" title="7. What would be the output of following code?"></a>7. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrA = [&#123;<span class="attr">prop1</span>: <span class="string">"value of array A!!"</span>&#125;, &#123;<span class="attr">someProp</span>: <span class="string">"also value of array A!"</span>&#125;,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arrB = arrA.slice();</span><br><span class="line">arrB[<span class="number">0</span>].prop1=<span class="number">42</span>;</span><br><span class="line">arrB[<span class="number">3</span>] = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrA);</span><br></pre></td></tr></table></figure><details><summary><b>Answer</b></summary><p>The output will be <code>[{prop1: 42},  {someProp: &quot;also value of array A!&quot;}, 3,4,5]</code>. </p><p>The <code>slice</code> function copies all the elements of the array returning the new array. However,<br>it doesn’t do deep copying. Instead it does shallow copying. You can imagine slice implemented like this: </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slice</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Look at the line with <code>result.push(arr[i])</code>. If <code>arr[i]</code> happens to be a number or string,<br>it will be passed by value, in other words, copied. If <code>arr[i]</code> is an object, it will be passed by reference. </p><p>In case of our array <code>arr[0]</code> is an object <code>{prop1: &quot;value of array A!!&quot;}</code>. Only the reference<br>to this object will be copied. This effectively means that arrays arrA and arrB share first<br>two elements. </p><p>This is why changing the property of <code>arrB[0]</code> in <code>arrB</code> will also change the <code>arrA[0]</code>.</p></details><h2 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h2><h3 id="1-console-log-employeeId"><a href="#1-console-log-employeeId" class="headerlink" title="1. console.log(employeeId);"></a>1. console.log(employeeId);</h3><ol><li>Some Value</li><li>Undefined </li><li>Type Error</li><li>ReferenceError: employeeId is not defined </li></ol><details><summary><b>Answer</b></summary><p> 4) ReferenceError: employeeId is not defined </p></details><h3 id="2-What-would-be-the-output-of-following-code-1"><a href="#2-What-would-be-the-output-of-following-code-1" class="headerlink" title="2. What would be the output of following code?"></a>2. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(employeeId);</span><br><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'19000'</span>;</span><br></pre></td></tr></table></figure><ol><li>Some Value</li><li>undefined </li><li>Type Error</li><li>ReferenceError: employeeId is not defined </li></ol><details><summary><b>Answer</b></summary><p> 2) undefined </p></details><h3 id="3-What-would-be-the-output-of-following-code-1"><a href="#3-What-would-be-the-output-of-following-code-1" class="headerlink" title="3. What would be the output of following code?"></a>3. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'1234abe'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(employeeId);</span><br><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'122345'</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>‘122345’</li><li>undefined </li><li>Type Error</li><li>ReferenceError: employeeId is not defined </li></ol><details><summary><b>Answer</b></summary><p> 2) undefined </p></details><h3 id="4-What-would-be-the-output-of-following-code-1"><a href="#4-What-would-be-the-output-of-following-code-1" class="headerlink" title="4. What would be the output of following code?"></a>4. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'1234abe'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(employeeId);</span><br><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'122345'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'abc1234'</span>;</span><br><span class="line">&#125;());</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>‘122345’</li><li>undefined </li><li>‘1234abe’</li><li>ReferenceError: employeeId is not defined </li></ol><details><summary><b>Answer</b></summary><p> 2) undefined </p></details><h3 id="5-What-would-be-the-output-of-following-code-1"><a href="#5-What-would-be-the-output-of-following-code-1" class="headerlink" title="5. What would be the output of following code?"></a>5. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> displayFunc);</span><br><span class="line"><span class="keyword">var</span> displayFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hi I am inside displayFunc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>undefined</li><li>function </li><li>‘Hi I am inside displayFunc’</li><li>ReferenceError: displayFunc is not defined </li></ol><details><summary><b>Answer</b></summary><p> 1) undefined </p></details><h3 id="6-What-would-be-the-output-of-following-code-1"><a href="#6-What-would-be-the-output-of-following-code-1" class="headerlink" title="6. What would be the output of following code?"></a>6. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'abc123'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">employeeId = <span class="string">'123bcd'</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(employeeId);</span><br></pre></td></tr></table></figure><ol><li>undefined</li><li>‘123bcd’ </li><li>‘abc123’</li><li>ReferenceError: employeeId is not defined </li></ol><details><summary><b>Answer</b></summary><p> 2) ‘123bcd’ </p></details><h3 id="7-What-would-be-the-output-of-following-code-1"><a href="#7-What-would-be-the-output-of-following-code-1" class="headerlink" title="7. What would be the output of following code?"></a>7. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'abc123'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">employeeId = <span class="string">'123bcd'</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">employeeId</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(employeeId);</span><br></pre></td></tr></table></figure><ol><li>undefined</li><li>‘123bcd’ </li><li>‘abc123’</li><li>ReferenceError: employeeId is not defined </li></ol><details><summary><b>Answer</b></summary><p> 3) ‘abc123’ </p></details><h3 id="8-What-would-be-the-output-of-following-code"><a href="#8-What-would-be-the-output-of-following-code" class="headerlink" title="8. What would be the output of following code?"></a>8. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'abc123'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">employeeId();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">employeeId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> employeeId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><ol><li>undefined</li><li>function </li><li>string</li><li>ReferenceError: employeeId is not defined </li></ol><details><summary><b>Answer</b></summary><p> 2) ‘function’</p></details><h3 id="9-What-would-be-the-output-of-following-code"><a href="#9-What-would-be-the-output-of-following-code" class="headerlink" title="9. What would be the output of following code?"></a>9. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">employeeId();</span><br><span class="line"><span class="keyword">var</span> product = <span class="string">'Car'</span>; </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">employeeId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(product);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><ol><li>undefined</li><li>Type Error </li><li>‘Car’</li><li>ReferenceError: product is not defined </li></ol><details><summary><b>Answer</b></summary><p> 1) undefined</p></details><h3 id="10-What-would-be-the-output-of-following-code"><a href="#10-What-would-be-the-output-of-following-code" class="headerlink" title="10. What would be the output of following code?"></a>10. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">abc();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> abc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>undefined undefined</li><li>Type Error </li><li>function function</li><li>ReferenceError: bar is not defined </li></ol><details><summary><b>Answer</b></summary><p> 3) function function</p></details><h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><h3 id="1-What-would-be-the-output-of-following-code-1"><a href="#1-What-would-be-the-output-of-following-code-1" class="headerlink" title="1. What would be the output of following code ?"></a>1. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'John'</span></span><br><span class="line">&#125;;</span><br><span class="line">person.salary = <span class="string">'10000$'</span>;</span><br><span class="line">person[<span class="string">'country'</span>] = <span class="string">'USA'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'phoneNo'</span>, &#123;</span><br><span class="line">value: <span class="string">'8888888888'</span>,</span><br><span class="line">enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>Type Error</li><li>undefined </li><li>[“name”, “salary”, “country”, “phoneNo”]</li><li>[“name”, “salary”, “country”]</li></ol><details><summary><b>Answer</b></summary><p> 3) [“name”, “salary”, “country”, “phoneNo”]</p></details><h3 id="2-What-would-be-the-output-of-following-code-2"><a href="#2-What-would-be-the-output-of-following-code-2" class="headerlink" title="2. What would be the output of following code ?"></a>2. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'John'</span></span><br><span class="line">&#125;;</span><br><span class="line">person.salary = <span class="string">'10000$'</span>;</span><br><span class="line">person[<span class="string">'country'</span>] = <span class="string">'USA'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'phoneNo'</span>, &#123;</span><br><span class="line">value: <span class="string">'8888888888'</span>,</span><br><span class="line">enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>Type Error</li><li>undefined </li><li>[“name”, “salary”, “country”, “phoneNo”]</li><li>[“name”, “salary”, “country”]</li></ol><details><summary><b>Answer</b></summary><p> 4) [“name”, “salary”, “country”]</p></details><h3 id="3-What-would-be-the-output-of-following-code-2"><a href="#3-What-would-be-the-output-of-following-code-2" class="headerlink" title="3. What would be the output of following code ?"></a>3. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">foo: <span class="string">'foo'</span>,</span><br><span class="line">bar: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> objB = &#123;</span><br><span class="line">foo: <span class="string">'foo'</span>,</span><br><span class="line">bar: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(objA == objB);</span><br><span class="line"><span class="built_in">console</span>.log(objA === objB);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>false true</li><li>false false </li><li>true false</li><li>true true</li></ol><details><summary><b>Answer</b></summary><p> 2) false false</p></details><h3 id="4-What-would-be-the-output-of-following-code-2"><a href="#4-What-would-be-the-output-of-following-code-2" class="headerlink" title="4. What would be the output of following code ?"></a>4. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">foo</span>: <span class="string">"foo"</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">foo</span>: <span class="string">"foo"</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(objA == objB);</span><br><span class="line"><span class="built_in">console</span>.log(objA === objB);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>false true</li><li>false false </li><li>true false</li><li>true true</li></ol><details><summary><b>Answer</b></summary><p> 2) false false</p></details><h3 id="5-What-would-be-the-output-of-following-code-2"><a href="#5-What-would-be-the-output-of-following-code-2" class="headerlink" title="5. What would be the output of following code ?"></a>5. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> objA = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">foo: <span class="string">'foo'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">foo: <span class="string">'foo'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(objA == objB);</span><br><span class="line"><span class="built_in">console</span>.log(objA === objB);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>false true</li><li>false false </li><li>true false</li><li>true true</li></ol><details><summary><b>Answer</b></summary><p> 2) false false</p></details><h3 id="6-What-would-be-the-output-of-following-code-2"><a href="#6-What-would-be-the-output-of-following-code-2" class="headerlink" title="6. What would be the output of following code ?"></a>6. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> objA = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">foo: <span class="string">'foo'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="built_in">Object</span>.create(objA);</span><br><span class="line"><span class="built_in">console</span>.log(objA == objB);</span><br><span class="line"><span class="built_in">console</span>.log(objA === objB);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>false true</li><li>false false </li><li>true false</li><li>true true</li></ol><details><summary><b>Answer</b></summary><p> 2) false false</p></details><h3 id="7-What-would-be-the-output-of-following-code-2"><a href="#7-What-would-be-the-output-of-following-code-2" class="headerlink" title="7. What would be the output of following code ?"></a>7. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> objA = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">foo: <span class="string">'foo'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="built_in">Object</span>.create(objA);</span><br><span class="line"><span class="built_in">console</span>.log(objA.toString() == objB.toString());</span><br><span class="line"><span class="built_in">console</span>.log(objA.toString() === objB.toString());</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>false true</li><li>false false </li><li>true false</li><li>true true</li></ol><details><summary><b>Answer</b></summary><p> 4) true true</p></details><h3 id="8-What-would-be-the-output-of-following-code-1"><a href="#8-What-would-be-the-output-of-following-code-1" class="headerlink" title="8. What would be the output of following code ?"></a>8. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> objA = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">foo: <span class="string">'foo'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> objB = objA;</span><br><span class="line"><span class="built_in">console</span>.log(objA == objB);</span><br><span class="line"><span class="built_in">console</span>.log(objA === objB);</span><br><span class="line"><span class="built_in">console</span>.log(objA.toString() == objB.toString());</span><br><span class="line"><span class="built_in">console</span>.log(objA.toString() === objB.toString());</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>true true true false</li><li>true false true true </li><li>true true true true</li><li>true true false false</li></ol><details><summary><b>Answer</b></summary><p> 3) true true true true</p></details><h3 id="9-What-would-be-the-output-of-following-code-1"><a href="#9-What-would-be-the-output-of-following-code-1" class="headerlink" title="9. What would be the output of following code ?"></a>9. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> objA = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">foo: <span class="string">'foo'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> objB = objA;</span><br><span class="line">objB.foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(objA.foo);</span><br><span class="line"><span class="built_in">console</span>.log(objB.foo);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>foo bar</li><li>bar bar </li><li>foo foo</li><li>bar foo</li></ol><details><summary><b>Answer</b></summary><p> 2) bar bar</p></details><h3 id="10-What-would-be-the-output-of-following-code-1"><a href="#10-What-would-be-the-output-of-following-code-1" class="headerlink" title="10. What would be the output of following code ?"></a>10. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> objA = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">foo: <span class="string">'foo'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> objB = objA;</span><br><span class="line">objB.foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> objA.foo;</span><br><span class="line"><span class="built_in">console</span>.log(objA.foo);</span><br><span class="line"><span class="built_in">console</span>.log(objB.foo);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>foo bar</li><li>bar bar </li><li>foo foo</li><li>bar foo</li></ol><details><summary><b>Answer</b></summary><p> 3) foo foo</p></details><h3 id="11-What-would-be-the-output-of-following-code"><a href="#11-What-would-be-the-output-of-following-code" class="headerlink" title="11. What would be the output of following code ?"></a>11. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">foo: <span class="string">'foo'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> objB = objA;</span><br><span class="line">objB.foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> objA.foo;</span><br><span class="line"><span class="built_in">console</span>.log(objA.foo);</span><br><span class="line"><span class="built_in">console</span>.log(objB.foo);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>foo bar</li><li>undefined undefined </li><li>foo foo</li><li>undefined bar</li></ol><details><summary><b>Answer</b></summary><p> 2) undefined undefined</p></details><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="1-What-would-be-the-output-of-following-code-2"><a href="#1-What-would-be-the-output-of-following-code-2" class="headerlink" title="1. What would be the output of following code?"></a>1. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'100'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"><span class="built_in">console</span>.log(array.length);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>undefined undefined</li><li>[undefined × 100] 100 </li><li>[“100”] 1</li><li>ReferenceError: array is not defined </li></ol><details><summary><b>Answer</b></summary><p> 3) [“100”] 1</p></details><h3 id="2-What-would-be-the-output-of-following-code-3"><a href="#2-What-would-be-the-output-of-following-code-3" class="headerlink" title="2. What would be the output of following code?"></a>2. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> array1 = [];</span><br><span class="line"><span class="keyword">var</span> array2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> array3 = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="string">'1'</span>,<span class="number">2</span>,<span class="string">'3'</span>,<span class="number">4</span>,<span class="number">5.6</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(array1);</span><br><span class="line"><span class="built_in">console</span>.log(array2);</span><br><span class="line"><span class="built_in">console</span>.log(array3);</span><br><span class="line"><span class="built_in">console</span>.log(array3.length);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>[] [] [Array[5]] 1</li><li>[] [undefined × 100] Array[5] 1</li><li>[] [] [‘1’,2,’3’,4,5.6] 5</li><li>[] [] [Array[5]] 5 </li></ol><details><summary><b>Answer</b></summary><p> 1) [] [] [Array[5]] 1</p></details><h3 id="3-What-would-be-the-output-of-following-code-3"><a href="#3-What-would-be-the-output-of-following-code-3" class="headerlink" title="3. What would be the output of following code?"></a>3. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>);</span><br><span class="line">  array[<span class="number">10</span>] = <span class="string">'f'</span>;</span><br><span class="line">  <span class="keyword">delete</span> array[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(array.length);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>11</li><li>5</li><li>6</li><li>undefined</li></ol><details><summary><b>Answer</b></summary><p> 1) 11</p></details><h3 id="4-What-would-be-the-output-of-following-code-3"><a href="#4-What-would-be-the-output-of-following-code-3" class="headerlink" title="4. What would be the output of following code?"></a>4. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> animal = [<span class="string">'cow'</span>,<span class="string">'horse'</span>];</span><br><span class="line">animal.push(<span class="string">'cat'</span>);</span><br><span class="line">animal.push(<span class="string">'dog'</span>,<span class="string">'rat'</span>,<span class="string">'goat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.length);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>4</li><li>5</li><li>6</li><li>undefined</li></ol><details><summary><b>Answer</b></summary><p> 3) 6</p></details><h3 id="5-What-would-be-the-output-of-following-code-3"><a href="#5-What-would-be-the-output-of-following-code-3" class="headerlink" title="5. What would be the output of following code?"></a>5. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> animal = [<span class="string">'cow'</span>,<span class="string">'horse'</span>];</span><br><span class="line">animal.push(<span class="string">'cat'</span>);</span><br><span class="line">animal.unshift(<span class="string">'dog'</span>,<span class="string">'rat'</span>,<span class="string">'goat'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>[ ‘dog’, ‘rat’, ‘goat’, ‘cow’, ‘horse’, ‘cat’ ]</li><li>[ ‘cow’, ‘horse’, ‘cat’, ‘dog’, ‘rat’, ‘goat’ ]</li><li>Type Error</li><li>undefined</li></ol><details><summary><b>Answer</b></summary><p> 1) [ ‘dog’, ‘rat’, ‘goat’, ‘cow’, ‘horse’, ‘cat’ ]</p></details><h3 id="6-What-would-be-the-output-of-following-code-3"><a href="#6-What-would-be-the-output-of-following-code-3" class="headerlink" title="6. What would be the output of following code?"></a>6. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log([&#123;<span class="attr">name</span>: <span class="string">'John'</span>&#125;,&#123;<span class="attr">name</span> : <span class="string">'John'</span>&#125;].indexOf(&#123;<span class="attr">name</span>:<span class="string">'John'</span>&#125;));</span><br><span class="line"><span class="built_in">console</span>.log([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]].indexOf([<span class="number">3</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"abcdefgh"</span>.indexOf(<span class="string">'e'</span>));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>1 -1 -1 4</li><li>1 0 -1 4</li><li>1 -1 -1 -1</li><li>1 undefined -1 4</li></ol><details><summary><b>Answer</b></summary><p> 1) 1 -1 -1 4</p></details><h3 id="7-What-would-be-the-output-of-following-code-3"><a href="#7-What-would-be-the-output-of-following-code-3" class="headerlink" title="7. What would be the output of following code?"></a>7. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(array.indexOf(<span class="number">2</span>,<span class="number">10</span>));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>1 -1 -1</li><li>1 6 -1</li><li>1 1 -1 </li><li>1 undefined undefined</li></ol><details><summary><b>Answer</b></summary><p> 2) 1 6 -1</p></details><h3 id="8-What-would-be-the-output-of-following-code-2"><a href="#8-What-would-be-the-output-of-following-code-2" class="headerlink" title="8. What would be the output of following code?"></a>8. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">16</span>];</span><br><span class="line"><span class="keyword">var</span> even = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">element, index</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> element % <span class="number">2</span> === <span class="number">0</span>; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(even);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> containsDivisibleby3 = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">element, index</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> element % <span class="number">3</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(containsDivisibleby3);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>[ 2, 4, 8, 12, 16 ] [ 0, 3, 0, 0, 9, 0, 12]</li><li>[ 2, 4, 8, 12, 16 ] [ 3, 9, 12]</li><li>[ 2, 4, 8, 12, 16 ] true </li><li>[ 2, 4, 8, 12, 16 ] false</li></ol><details><summary><b>Answer</b></summary><p> 3) [ 2, 4, 8, 12, 16 ] true </p></details><h3 id="9-What-would-be-the-output-of-following-code-2"><a href="#9-What-would-be-the-output-of-following-code-2" class="headerlink" title="9. What would be the output of following code?"></a>9. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> containers = [<span class="number">2</span>,<span class="number">0</span>,<span class="literal">false</span>,<span class="string">""</span>, <span class="string">'12'</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">var</span> containers = containers.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="built_in">console</span>.log(containers);</span><br><span class="line"><span class="keyword">var</span> containers = containers.filter(<span class="built_in">Number</span>);</span><br><span class="line"><span class="built_in">console</span>.log(containers);</span><br><span class="line"><span class="keyword">var</span> containers = containers.filter(<span class="built_in">String</span>);</span><br><span class="line"><span class="built_in">console</span>.log(containers);</span><br><span class="line"><span class="keyword">var</span> containers = containers.filter(<span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(containers);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>[ 2, ‘12’, true ]<br>[ 2, ‘12’, true ]<br>[ 2, ‘12’, true ]<br>[ 2, ‘12’, true ]</li><li>[false, true]<br>[ 2 ]<br>[‘12’]<br>[ ]</li><li>[2,0,false,””, ‘12’, true]<br>[2,0,false,””, ‘12’, true]<br>[2,0,false,””, ‘12’, true]<br>[2,0,false,””, ‘12’, true]</li><li>[ 2, ‘12’, true ]<br> [ 2, ‘12’, true, false ]<br> [ 2, ‘12’, true,false ]<br> [ 2, ‘12’, true,false]</li></ol><details><summary><b>Answer</b></summary><p> 1) [ 2, ‘12’, true ]<br>             [ 2, ‘12’, true ]<br>             [ 2, ‘12’, true ]<br>             [ 2, ‘12’, true ]</p></details><h3 id="10-What-would-be-the-output-of-following-code-2"><a href="#10-What-would-be-the-output-of-following-code-2" class="headerlink" title="10. What would be the output of following code?"></a>10. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> list = [<span class="string">'foo'</span>,<span class="string">'bar'</span>,<span class="string">'john'</span>,<span class="string">'ritz'</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(list.slice(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(list.slice(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(list.slice());</span><br><span class="line">    <span class="built_in">console</span>.log(list.slice(<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(list);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>[ ‘bar’, ‘john’, ‘ritz’ ]<br>[ ‘bar’, ‘john’ ]<br>[ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]<br>[]<br>[ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]</li><li>[ ‘bar’, ‘john’, ‘ritz’ ]<br>[ ‘bar’, ‘john’,’ritz ]<br>[ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]<br>[]<br>[ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]</li><li>[ ‘john’, ‘ritz’ ]<br>[ ‘bar’, ‘john’ ]<br>[ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]<br>[]<br>[ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]</li><li>[ ‘foo’ ]<br>[ ‘bar’, ‘john’ ]<br>[ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]<br>[]<br>[ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]</li></ol><details><summary><b>Answer</b></summary><p> 1) [ ‘bar’, ‘john’, ‘ritz’ ]<br>              [ ‘bar’, ‘john’ ]<br>           [ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]<br>           []<br>           [ ‘foo’, ‘bar’, ‘john’, ‘ritz’ ]        </p></details><h3 id="11-What-would-be-the-output-of-following-code-1"><a href="#11-What-would-be-the-output-of-following-code-1" class="headerlink" title="11. What would be the output of following code?"></a>11. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> list = [<span class="string">'foo'</span>,<span class="string">'bar'</span>,<span class="string">'john'</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(list.splice(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(list.splice(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(list);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>[ ‘bar’, ‘john’ ] [] [ ‘foo’ ]</li><li>[ ‘bar’, ‘john’ ] [] [ ‘bar’, ‘john’ ]</li><li>[ ‘bar’, ‘john’ ] [ ‘bar’, ‘john’ ] [ ‘bar’, ‘john’ ]</li><li>[ ‘bar’, ‘john’ ] [] []</li></ol><details><summary><b>Answer</b></summary><ol><li>[ ‘bar’, ‘john’ ] [] [ ‘foo’ ] </li></ol></details><h3 id="12-What-would-be-the-output-of-following-code"><a href="#12-What-would-be-the-output-of-following-code" class="headerlink" title="12. What would be the output of following code?"></a>12. What would be the output of following code?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> arrayNumb = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>];</span><br><span class="line">arrayNumb.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arrayNumb);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>[2, 8, 15, 16, 23, 42]</li><li>[42, 23, 26, 15, 8, 2]</li><li>[ 15, 16, 2, 23, 42, 8 ]</li><li>[ 2, 8, 15, 16, 23, 42 ]</li></ol><details><summary><b>Answer</b></summary><ol start="3"><li>[ 15, 16, 2, 23, 42, 8 ]</li></ol></details><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="1-What-would-be-the-output-of-following-code-3"><a href="#1-What-would-be-the-output-of-following-code-3" class="headerlink" title="1. What would be the output of following code ?"></a>1. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"funcA "</span>, <span class="keyword">this</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">innerFuncA1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"innerFunc1"</span>, <span class="keyword">this</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">innerFunA11</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"innerFunA11"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;)();</span><br><span class="line">&#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(funcA());</span><br></pre></td></tr></table></figure><ol><li>funcA  Window {…}<br>innerFunc1 Window {…}<br>innerFunA11 Window {…}</li><li>undefined </li><li>Type Error</li><li>ReferenceError: this is not defined </li></ol><details><summary><b>Answer</b></summary><p> 1) </p></details><h3 id="2-What-would-be-the-output-of-following-code-4"><a href="#2-What-would-be-the-output-of-following-code-4" class="headerlink" title="2. What would be the output of following code ?"></a>2. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">message: <span class="string">"Hello"</span>,</span><br><span class="line">innerMessage: !(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</span><br><span class="line">&#125;)()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.innerMessage);</span><br></pre></td></tr></table></figure><ol><li>ReferenceError: this.message is not defined </li><li>undefined </li><li>Type Error</li><li>undefined true</li></ol><details><summary><b>Answer</b></summary><p> 4) undefined true</p></details><h3 id="3-What-would-be-the-output-of-following-code-4"><a href="#3-What-would-be-the-output-of-following-code-4" class="headerlink" title="3. What would be the output of following code ?"></a>3. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">message: <span class="string">"Hello"</span>,</span><br><span class="line">innerMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.innerMessage());</span><br></pre></td></tr></table></figure><ol><li>Hello </li><li>undefined </li><li>Type Error</li><li>ReferenceError: this.message is not defined</li></ol><details><summary><b>Answer</b></summary><p> 1) Hello</p></details><h3 id="4-What-would-be-the-output-of-following-code-4"><a href="#4-What-would-be-the-output-of-following-code-4" class="headerlink" title="4. What would be the output of following code ?"></a>4. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  message: <span class="string">'Hello'</span>,</span><br><span class="line">  innerMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</span><br><span class="line">    &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.innerMessage());</span><br></pre></td></tr></table></figure><ol><li>Type Error </li><li>Hello </li><li>undefined</li><li>ReferenceError: this.message is not defined</li></ol><details><summary><b>Answer</b></summary><p> 3) undefined</p></details><h3 id="5-What-would-be-the-output-of-following-code-4"><a href="#5-What-would-be-the-output-of-following-code-4" class="headerlink" title="5. What would be the output of following code ?"></a>5. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  message: <span class="string">'Hello'</span>,</span><br><span class="line">  innerMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(self.message);</span><br><span class="line">    &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.innerMessage());</span><br></pre></td></tr></table></figure><ol><li>Type Error </li><li>‘Hello’ </li><li>undefined</li><li>ReferenceError: self.message is not defined</li></ol><details><summary><b>Answer</b></summary><p> 2) ‘Hello’</p></details><h3 id="6-What-would-be-the-output-of-following-code-4"><a href="#6-What-would-be-the-output-of-following-code-4" class="headerlink" title="6. What would be the output of following code ?"></a>6. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</span><br><span class="line">&#125;</span><br><span class="line">myFunc.message = <span class="string">"Hi John"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myFunc());</span><br></pre></td></tr></table></figure><ol><li>Type Error </li><li>‘Hi John’ </li><li>undefined</li><li>ReferenceError: this.message is not defined</li></ol><details><summary><b>Answer</b></summary><p> 3) undefined</p></details><h3 id="7-What-would-be-the-output-of-following-code-4"><a href="#7-What-would-be-the-output-of-following-code-4" class="headerlink" title="7. What would be the output of following code ?"></a>7. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(myFunc.message);</span><br><span class="line">&#125;</span><br><span class="line">myFunc.message = <span class="string">"Hi John"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myFunc());</span><br></pre></td></tr></table></figure><ol><li>Type Error </li><li>‘Hi John’ </li><li>undefined</li><li>ReferenceError: this.message is not defined</li></ol><details><summary><b>Answer</b></summary><p> 2) ‘Hi John’</p></details><h3 id="8-What-would-be-the-output-of-following-code-3"><a href="#8-What-would-be-the-output-of-following-code-3" class="headerlink" title="8. What would be the output of following code ?"></a>8. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  myFunc.message = <span class="string">'Hi John'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(myFunc.message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFunc());</span><br></pre></td></tr></table></figure><ol><li>Type Error </li><li>‘Hi John’ </li><li>undefined</li><li>ReferenceError: this.message is not defined</li></ol><details><summary><b>Answer</b></summary><p> 2) ‘Hi John’</p></details><h3 id="9-What-would-be-the-output-of-following-code-3"><a href="#9-What-would-be-the-output-of-following-code-3" class="headerlink" title="9. What would be the output of following code ?"></a>9. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">param1,param2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myFunc.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFunc());</span><br><span class="line"><span class="built_in">console</span>.log(myFunc(<span class="string">"a"</span>,<span class="string">"b"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(myFunc(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</span><br></pre></td></tr></table></figure><ol><li>2 2 2 </li><li>0 2 4</li><li>undefined</li><li>ReferenceError</li></ol><details><summary><b>Answer</b></summary><p> a) 2 2 2 </p></details><h3 id="10-What-would-be-the-output-of-following-code-3"><a href="#10-What-would-be-the-output-of-following-code-3" class="headerlink" title="10. What would be the output of following code ?"></a>10. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFunc());</span><br><span class="line"><span class="built_in">console</span>.log(myFunc(<span class="string">"a"</span>,<span class="string">"b"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(myFunc(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</span><br></pre></td></tr></table></figure><ol><li>2 2 2 </li><li>0 2 4</li><li>undefined</li><li>ReferenceError</li></ol><details><summary><b>Answer</b></summary><p> 2) 0 2 4 </p></details><h2 id="Object-Oriented"><a href="#Object-Oriented" class="headerlink" title="Object Oriented"></a>Object Oriented</h2><h3 id="1-What-would-be-the-output-of-following-code-4"><a href="#1-What-would-be-the-output-of-following-code-4" class="headerlink" title="1. What would be the output of following code ?"></a>1. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">"John"</span>;</span><br><span class="line"><span class="keyword">this</span>.age = age || <span class="number">24</span>;</span><br><span class="line"><span class="keyword">this</span>.displayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.name = <span class="string">"John"</span>;</span><br><span class="line">Person.displayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'John'</span>);</span><br><span class="line">person1.displayName();</span><br><span class="line">Person.displayName();</span><br></pre></td></tr></table></figure><ol><li>John Person</li><li>John John</li><li>John undefined</li><li>John John</li></ol><details><summary><b>Answer</b></summary><p> 1) John Person </p></details><h2 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h2><h3 id="1-What-would-be-the-output-of-following-code-5"><a href="#1-What-would-be-the-output-of-following-code-5" class="headerlink" title="1. What would be the output of following code ?"></a>1. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passWordMngr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> password = <span class="string">'12345678'</span>;</span><br><span class="line"><span class="keyword">this</span>.userName = <span class="string">'John'</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">pwd: password</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Block End</span></span><br><span class="line"><span class="keyword">var</span> userInfo = passWordMngr();</span><br><span class="line"><span class="built_in">console</span>.log(userInfo.pwd);</span><br><span class="line"><span class="built_in">console</span>.log(userInfo.userName);</span><br></pre></td></tr></table></figure><ol><li>12345678 Window</li><li>12345678 John</li><li>12345678 undefined</li><li>undefined undefined</li></ol><details><summary><b>Answer</b></summary><p> 3) 12345678 undefined </p></details><h3 id="2-What-would-be-the-output-of-following-code-5"><a href="#2-What-would-be-the-output-of-following-code-5" class="headerlink" title="2. What would be the output of following code ?"></a>2. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'aq123'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.employeeId = <span class="string">'bq1uy'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Employee.employeeId);</span><br></pre></td></tr></table></figure><ol><li>Reference Error</li><li>aq123</li><li>bq1uy</li><li>undefined</li></ol><details><summary><b>Answer</b></summary><p> 4) undefined </p></details><h3 id="3-What-would-be-the-output-of-following-code-5"><a href="#3-What-would-be-the-output-of-following-code-5" class="headerlink" title="3. What would be the output of following code ?"></a>3. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'aq123'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.employeeId = <span class="string">'bq1uy'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Employee().employeeId);</span><br><span class="line">Employee.prototype.employeeId = <span class="string">'kj182'</span>;</span><br><span class="line">Employee.prototype.JobId = <span class="string">'1BJKSJ'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Employee().JobId);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Employee().employeeId);</span><br></pre></td></tr></table></figure><ol><li>bq1uy 1BJKSJ bq1uy undefined</li><li>bq1uy 1BJKSJ bq1uy</li><li>bq1uy 1BJKSJ kj182</li><li>undefined 1BJKSJ kj182</li></ol><details><summary><b>Answer</b></summary><p> 2) bq1uy 1BJKSJ bq1uy </p></details><h3 id="4-What-would-be-the-output-of-following-code-5"><a href="#4-What-would-be-the-output-of-following-code-5" class="headerlink" title="4. What would be the output of following code ?"></a>4. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeId = <span class="string">'aq123'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">'foo123'</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (employeeId) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(employeeId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(employeeId);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>foo123 aq123</li><li>foo123 foo123</li><li>aq123 aq123</li><li>foo123 undefined </li></ol><details><summary><b>Answer</b></summary><p> 1) foo123 aq123 </p></details><h2 id="Call-Apply-Bind"><a href="#Call-Apply-Bind" class="headerlink" title="Call, Apply, Bind"></a>Call, Apply, Bind</h2><h3 id="1-What-would-be-the-output-of-following-code-6"><a href="#1-What-would-be-the-output-of-following-code-6" class="headerlink" title="1. What would be the output of following code ?"></a>1. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> greet = <span class="string">'Hello World'</span>;</span><br><span class="line"><span class="keyword">var</span> toGreet = [].filter.call(greet, <span class="function"><span class="keyword">function</span>(<span class="params">element, index</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> index &gt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(toGreet);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>Hello World</li><li>undefined</li><li>World</li><li>[ ‘W’, ‘o’, ‘r’, ‘l’, ‘d’ ] </li></ol><details><summary><b>Answer</b></summary><p> 4) [ ‘W’, ‘o’, ‘r’, ‘l’, ‘d’ ]  </p></details><h3 id="2-What-would-be-the-output-of-following-code-6"><a href="#2-What-would-be-the-output-of-following-code-6" class="headerlink" title="2. What would be the output of following code ?"></a>2. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> fooAccount = &#123;</span><br><span class="line">name: <span class="string">'John'</span>,</span><br><span class="line">amount: <span class="number">4000</span>,</span><br><span class="line">deductAmount: <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.amount -= amount;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'Total amount left in account: '</span> + <span class="keyword">this</span>.amount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> barAccount = &#123;</span><br><span class="line">name: <span class="string">'John'</span>,</span><br><span class="line">amount: <span class="number">6000</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> withdrawAmountBy = <span class="function"><span class="keyword">function</span>(<span class="params">totalAmount</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fooAccount.deductAmount.bind(barAccount, totalAmount);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(withdrawAmountBy(<span class="number">400</span>)());</span><br><span class="line"><span class="built_in">console</span>.log(withdrawAmountBy(<span class="number">300</span>)());</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>Total amount left in account: 5600 Total amount left in account: 5300</li><li>undefined undefined</li><li>Total amount left in account: 3600 Total amount left in account: 3300</li><li>Total amount left in account: 5600 Total amount left in account: 5600</li></ol><details><summary><b>Answer</b></summary><p> 1) Total amount left in account: 5600 Total amount left in account: 5300 </p></details><h3 id="3-What-would-be-the-output-of-following-code-6"><a href="#3-What-would-be-the-output-of-following-code-6" class="headerlink" title="3. What would be the output of following code ?"></a>3. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> fooAccount = &#123;</span><br><span class="line">name: <span class="string">'John'</span>,</span><br><span class="line">amount: <span class="number">4000</span>,</span><br><span class="line">deductAmount: <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.amount -= amount;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.amount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> barAccount = &#123;</span><br><span class="line">name: <span class="string">'John'</span>,</span><br><span class="line">amount: <span class="number">6000</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> withdrawAmountBy = <span class="function"><span class="keyword">function</span>(<span class="params">totalAmount</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fooAccount.deductAmount.apply(barAccount, [totalAmount]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(withdrawAmountBy(<span class="number">400</span>));</span><br><span class="line"><span class="built_in">console</span>.log(withdrawAmountBy(<span class="number">300</span>));</span><br><span class="line"><span class="built_in">console</span>.log(withdrawAmountBy(<span class="number">200</span>));</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>5600 5300 5100</li><li>3600 3300 3100</li><li>5600 3300 5100</li><li>undefined undefined undefined</li></ol><details><summary><b>Answer</b></summary><p> 1) 5600 5300 5100</p></details><h3 id="4-What-would-be-the-output-of-following-code-6"><a href="#4-What-would-be-the-output-of-following-code-6" class="headerlink" title="4. What would be the output of following code ?"></a>4. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> fooAccount = &#123;</span><br><span class="line">name: <span class="string">'John'</span>,</span><br><span class="line">amount: <span class="number">6000</span>,</span><br><span class="line">deductAmount: <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.amount -= amount;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.amount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> barAccount = &#123;</span><br><span class="line">name: <span class="string">'John'</span>,</span><br><span class="line">amount: <span class="number">4000</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> withdrawAmountBy = <span class="function"><span class="keyword">function</span>(<span class="params">totalAmount</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fooAccount.deductAmount.call(barAccount, totalAmount);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(withdrawAmountBy(<span class="number">400</span>));</span><br><span class="line"><span class="built_in">console</span>.log(withdrawAmountBy(<span class="number">300</span>));</span><br><span class="line"><span class="built_in">console</span>.log(withdrawAmountBy(<span class="number">200</span>));</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ol><li>5600 5300 5100</li><li>3600 3300 3100</li><li>5600 3300 5100</li><li>undefined undefined undefined</li></ol><details><summary><b>Answer</b></summary><p> 2) 3600 3300 3100</p></details><h3 id="5-What-would-be-the-output-of-following-code-5"><a href="#5-What-would-be-the-output-of-following-code-5" class="headerlink" title="5. What would be the output of following code ?"></a>5. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">greetNewCustomer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;.bind(&#123;</span><br><span class="line">name: <span class="string">'John'</span></span><br><span class="line">&#125;)());</span><br></pre></td></tr></table></figure><ol><li>Hello John</li><li>Reference Error</li><li>Window</li><li>undefined</li></ol><details><summary><b>Answer</b></summary><p> 1) Hello John</p></details><h3 id="6-Suggest-your-question"><a href="#6-Suggest-your-question" class="headerlink" title="6. Suggest your question!"></a>6. Suggest your question!</h3><h2 id="Callback-Functions"><a href="#Callback-Functions" class="headerlink" title="Callback Functions"></a>Callback Functions</h2><h3 id="1-What-would-be-the-output-of-following-code-7"><a href="#1-What-would-be-the-output-of-following-code-7" class="headerlink" title="1. What would be the output of following code ?"></a>1. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataFromServer</span>(<span class="params">apiUrl</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"John"</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">then : <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">fn(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getDataFromServer(<span class="string">'www.google.com'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>John</li><li>undefined</li><li>Reference Error</li><li>fn is not defined</li></ol><details><summary><b>Answer</b></summary><p> 1) John</p></details><h3 id="2-What-would-be-the-output-of-following-code-7"><a href="#2-What-would-be-the-output-of-following-code-7" class="headerlink" title="2. What would be the output of following code ?"></a>2. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> arrayNumb = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.sort = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;;</span><br><span class="line">arrayNumb.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arrayNumb);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> numberArray = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>];</span><br><span class="line">numberArray.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(numberArray);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> numberArray = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>];</span><br><span class="line">numberArray.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(numberArray);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>[ 2, 8, 15, 16, 23, 42 ]<br>[ 2, 8, 15, 16, 23, 42 ]<br>[ 2, 8, 15, 16, 23, 42 ]</li><li>undefined undefined undefined</li><li>[42, 23, 16, 15, 8, 2]<br>[42, 23, 16, 15, 8, 2]<br>[42, 23, 16, 15, 8, 2]</li><li>Reference Error</li></ol><details><summary><b>Answer</b></summary><p> 1) [ 2, 8, 15, 16, 23, 42 ]<br>             [ 2, 8, 15, 16, 23, 42 ]<br>             [ 2, 8, 15, 16, 23, 42 ]</p></details><h2 id="Return-Statement"><a href="#Return-Statement" class="headerlink" title="Return Statement"></a>Return Statement</h2><h3 id="1-What-would-be-the-output-of-following-code-8"><a href="#1-What-would-be-the-output-of-following-code-8" class="headerlink" title="1. What would be the output of following code ?"></a>1. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Hi John"</span>;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#123;</span><br><span class="line">fullName: name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello().fullName);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>Hi John</li><li>undefined</li><li>Reference Error</li><li>Uncaught TypeError: Cannot read property ‘fullName’ of undefined</li></ol><details><summary><b>Answer</b></summary><p> 4) Uncaught TypeError: Cannot read property ‘fullName’ of undefined</p></details><h3 id="2-What-would-be-the-output-of-following-code-8"><a href="#2-What-would-be-the-output-of-following-code-8" class="headerlink" title="2. What would be the output of following code ?"></a>2. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numb = getNumber();</span><br><span class="line"><span class="built_in">console</span>.log(numb);</span><br></pre></td></tr></table></figure><ol><li>5</li><li>undefined</li><li>2</li><li>(2,4,5)</li></ol><details><summary><b>Answer</b></summary><p> 1) 5</p></details><h3 id="3-What-would-be-the-output-of-following-code-7"><a href="#3-What-would-be-the-output-of-following-code-7" class="headerlink" title="3. What would be the output of following code ?"></a>3. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numb = getNumber();</span><br><span class="line"><span class="built_in">console</span>.log(numb);</span><br></pre></td></tr></table></figure><ol><li>null</li><li>undefined</li><li>“”</li><li>0</li></ol><details><summary><b>Answer</b></summary><p> 2) undefined</p></details><h3 id="4-What-would-be-the-output-of-following-code-7"><a href="#4-What-would-be-the-output-of-following-code-7" class="headerlink" title="4**. What would be the output of following code ?"></a>4**. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> [x*y, <span class="function"><span class="keyword">function</span>(<span class="params">z</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y + z;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">2</span>)(<span class="number">3</span>)[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">2</span>)(<span class="number">3</span>)[<span class="number">1</span>](<span class="number">4</span>));</span><br></pre></td></tr></table></figure><ol><li>6, 10</li><li>undefined undefined</li><li>Reference Error</li><li>10, 6</li></ol><details><summary><b>Answer</b></summary><p> 1) 6, 10</p></details><h3 id="5-What-would-be-the-output-of-following-code-6"><a href="#5-What-would-be-the-output-of-following-code-6" class="headerlink" title="5**. What would be the output of following code ?"></a>5**. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">result: x * y,</span><br><span class="line">sum: <span class="function"><span class="keyword">function</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * y + z;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">2</span>)(<span class="number">3</span>).result);</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">2</span>)(<span class="number">3</span>).sum(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><ol><li>6, 10</li><li>undefined undefined</li><li>Reference Error</li><li>10, 6</li></ol><details><summary><b>Answer</b></summary><p> 1) 6, 10</p></details><h3 id="6-What-would-be-the-output-of-following-code-5"><a href="#6-What-would-be-the-output-of-following-code-5" class="headerlink" title="6. What would be the output of following code ?"></a>6. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * y * z * w * p;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><ol><li>720</li><li>undefined</li><li>Reference Error</li><li>Type Error</li></ol><details><summary><b>Answer</b></summary><p> 1) 720</p></details><h3 id="7-What-would-be-the-output-of-following-code-5"><a href="#7-What-would-be-the-output-of-following-code-5" class="headerlink" title="7. What would be the output of following code ?"></a>7. What would be the output of following code ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.getName2 = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personObj = &#123;</span><br><span class="line">name:<span class="string">"Tony"</span>,</span><br><span class="line">print:getName1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">personObj.print();</span><br><span class="line">personObj.getName2();</span><br></pre></td></tr></table></figure><ol><li>undefined undefined</li><li>Tony undefined</li><li>undefined Tony</li><li>Tony Tony</li></ol><details><summary><b>Answer</b></summary><p> 2) Tony undefined</p><p>Explaination: <strong>getName1()</strong> function works fine because it’s being called from <strong><em>personObj</em></strong>, so it has access to <em>this.name</em> property. But when while calling <strong>getnName2</strong> which is defined under <em>Object.prototype</em> doesn’t have any proprty named <em>this.name</em>. There should be <em>name</em> property under prototype. Following is the code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.getName2 = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personObj = &#123;</span><br><span class="line">name:<span class="string">"Tony"</span>,</span><br><span class="line">print:getName1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">personObj.print();</span><br><span class="line"><span class="built_in">Object</span>.prototype.name=<span class="string">"Steve"</span>;</span><br><span class="line">personObj.getName2();</span><br></pre></td></tr></table></figure></details><h2 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h2><p>We always appreciate your feedback on how the book can be improved, and more questions can be added. If you think you have some question then please add that and open a pull request. </p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>This book is released under a Creative Commons Attribution-Noncommercial- No Derivative Works 3.0 United States License.</p><p>What this means it that the project is free to read and use, but the license does not permit commercial use of the material (i.e you can freely print out the questions for your own use, but you can’t sell it). I’m trying to best to publish all of my books in a free + purchased (if you would like to support these projects) form so I would greatly appreciate it if you would respect these terms.</p><p>Copyright Iurii Katkov and Nishant Kumar, 2017.</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>守护线程和用户线程</title>
      <link href="/2020/08/19/Thread-4/"/>
      <url>/2020/08/19/Thread-4/</url>
      
        <content type="html"><![CDATA[<h2 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h2><p>Java分为两种线程：用户线程和守护线程</p><p>所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。</p><p>当用户进程结束后，程序终止，不管此时是否还有正在运行的守护线程。</p><p>将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。</p><ul><li>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。</li><li>任何线程都会继承负责创建它的那个线程的daemon状态，∴在主线程main方法中创建的线程都是用户线程，在守护线程内创建的线程都是守护线程</li><li>守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2020/08/19/Thread-3/"/>
      <url>/2020/08/19/Thread-3/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a href="https://mp.weixin.qq.com/s/2139B5EfyoUkbkSdz8QgYA" target="_blank" rel="noopener">参考网址</a></p><p>以数据库连接为例，如果多个线程共享一个连接，有可能一个线程在对数据库进行操作，另一个线程调用了closeConnection操作；如果在每一个线程都new一个连接对象，如果开启关闭数据库操作频繁，会影响到服务器压力，并且影响程序执行性能。<br>=&gt; ThreadLocal 内部维护一个 ThreadLocalMap 类，保存的是 Entry&lt;Thread K, Object V&gt; 数组，K是线程，V是值，这样每一个线程无论在哪里调用，都会拿到自己线程的值</p><p>每个Thread对象中都持有一个ThreadLocalMap的成员变量。每个ThreadLocalMap内部又维护了N个Entry节点，也就是Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值</p><p>ThreadLocalMap的引用是在Thread里的，所以它里面的Entry数组存放的是一个线程里new出来的多个ThreadLocal对象</p><p>Thread维护了ThreadLocalMap，而ThreadLocalMap里维护了Entry，而Entry里存的是以ThreadLocal为key，传入的值为value的键值对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// java.lang.Thread类里持有ThreadLocalMap的引用</span><br><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// java.lang.ThreadLocal有内部静态类ThreadLocalMap</span><br><span class="line">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">    static class ThreadLocalMap &#123;</span><br><span class="line">        private Entry[] table;</span><br><span class="line">        </span><br><span class="line">        // ThreadLocalMap内部有Entry类，Entry的key是ThreadLocal本身，value是泛型值</span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuf9AEW6RSVibTlHEWRFAklONOCH7Lh4ibClfBFzw1gn8LneEdcdR4jeBp85dgxyWJE4xn6ExFMOibGPw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="ThreadLocal内存结构图"></p><p>主要方法：</p><ul><li><p>initialValue：初始化。在get方法里懒加载的。</p><ul><li>通常，每个线程最多调用一次此方法。但是如果已经调用了remove()，然后再次调用get()的话，则可以再次触发initialValue。</li><li>如果要重写的话一般建议采取匿名内部类的方式重写此方法，否则默认返回的是null。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = new ThreadLocal() &#123;</span><br><span class="line">@Override</span><br><span class="line">protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">    return new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// Java8的高逼格写法</span><br><span class="line">public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span><br><span class="line">    ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>get：得到这个线程对应的value。如果调用get之前没set过，则get内部会执行initialValue方法进行初始化。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 获取当前线程下的entry里的value值。</span><br><span class="line">* 先获取当前线程下的ThreadLocalMap，</span><br><span class="line">* 然后以当前ThreadLocal为key取出map中的value</span><br><span class="line">*/</span><br><span class="line">public T get() &#123;</span><br><span class="line">    // 获取当前线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    // 获取当前线程对应的ThreadLocalMap对象。</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    // 若获取到了。则获取此ThreadLocalMap下的entry对象，若entry也获取到了，那么直接获取entry对应的value返回即可。</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        // 获取此ThreadLocalMap下的entry对象</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        // 若entry也获取到了</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            // 直接获取entry对应的value返回。</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若没获取到ThreadLocalMap或没获取到Entry，则设置初始值。 懒加载方式</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        // 如果e=null，说明出现碰撞问题，通过开放寻址方法来继续寻找</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过布长+1或-1来寻找下一个相邻的位置</span><br><span class="line">private static int nextIndex(int i, int len) &#123;</span><br><span class="line">    return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">&#125;</span><br><span class="line">private static int prevIndex(int i, int len) &#123;</span><br><span class="line">    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>set：为这个线程设置一个新值。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 设置当前线程的线程局部变量的值</span><br><span class="line">* 实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问。</span><br><span class="line">*/</span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    // 获取当前线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    // 获取当前线程对应的ThreadLocalMap实例，注意这里是将t传进去了，t是当前线程，就是说ThreadLocalMap是在线程里持有的引用。</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    // 若当前线程有对应的ThreadLocalMap实例，则将当前ThreadLocal对象作为key，value做为值存到ThreadLocalMap的entry里。</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        // 若当前线程没有对应的ThreadLocalMap实例，则创建ThreadLocalMap，并将此线程与之绑定</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove：ThreadLocalMap键为弱引用，删除这个线程对应的值，防止内存泄露的最佳手段。</p></li></ul><p>碰撞解决与神奇的 0x61c88647（十进制：1640531527)</p><p>两种碰撞类型</p><pre><code>- 只有一个ThreadLocal实例的时候(上面推荐的做法)，当向thread-local变量中设置多个值的时产生的碰撞，碰撞解决是通过开放定址法， 且是线性探测(linear-probe)- 多个ThreadLocal实例的时候，最极端的是每个线程都new一个ThreadLocal实例，此时利用特殊的哈希码0x61c88647大大降低碰撞的几率， 同时利用开放定址法处理碰撞</code></pre><p>显然ThreadLocalMap采用线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。</p><p>所以这里引出的良好建议是：每个线程只存一个变量，这样的话所有的线程存放到map中的Key都是相同的ThreadLocal，如果一个线程要保存多个变量，就需要创建多个ThreadLocal，多个ThreadLocal放入Map中时会极大的增加Hash冲突的可能。</p><p>key.threadLocalHashCode ==&gt; AtomicInteger.getAndAdd(HASH_INCREMENT) 其中 HASH_INCREMENT = 0x61c88647，这个值是 为了让哈希码能均匀的分布在2的N次方的数组里</p><p>This number represents the golden ratio (sqrt(5)-1) times two to the power of 31 ((sqrt(5)-1) * (2^31)). The result is then a golden number, either 2654435769 or -1640531527.</p><p>魔数0x61c88647的与斐波那契散列有关，0x61c88647对应的十进制为1640531527。斐波那契散列的乘数可以用(long) ((1L &lt;&lt; 31) * (Math.sqrt(5) - 1))可以得到2654435769，如果把这个值给转为带符号的int，则会得到-1640531527。换句话说(1L &lt;&lt; 32) - (long) ((1L &lt;&lt; 31) * (Math.sqrt(5) - 1))得到的结果就是1640531527也就是0x61c88647。通过理论与实践，当我们用0x61c88647作为魔数累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步队列</title>
      <link href="/2020/08/11/Thread-2/"/>
      <url>/2020/08/11/Thread-2/</url>
      
        <content type="html"><![CDATA[<h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>∵ 多线程 ∴ 需要针对一些资源进行同步 ∴ 有了同步队列<br>实现方式主要有两种：阻塞方式（队列使用一个锁，出队入队用同一把锁或者队列使用两把锁，出队和入队用不同的锁）和非阻塞方式（底层通过循环CAS的方式）</p><p>synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁<br>CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。Compare And Swap 比较并替换</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。<br>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><blockquote><p>工作线程t1、t2从主内存根据内存地址V先拷贝一份变量的值到各自的工作内存空间，这就是预期值A；CAS(A, B)，t1先更新变量的值，更新后，写到主内存中，此时t2再去传 CAS(A, B) 就会失败，因为A值已经变成了B值，所以t2需要重新拉取最新的值到工作内存空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean为例</span><br><span class="line">compareAndSet(prev,newValue)方法要拆成compare(prev)方法和Set(newValue)方法，compare(prev)是等于prev后，就马上设置共享内存为newValue。</span><br><span class="line">public final boolean getAndSet(boolean newValue) &#123;</span><br><span class="line">    boolean prev;</span><br><span class="line">    do &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">    &#125; while (!compareAndSet(prev, newValue));</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CAS的缺点：</span><br><span class="line">1.CPU开销较大</span><br><span class="line">在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。所以一般会线程sleep</span><br><span class="line">2.不能保证代码块的原子性</span><br><span class="line">CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</span><br><span class="line"></span><br><span class="line">CAS的原理：</span><br><span class="line">CAS通过调用JNI的代码实现的。JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言。而compareAndSwapInt就是借助C来调用CPU底层指令实现的</span><br></pre></td></tr></table></figure><p><img src="https://images.weserv.nl/?url=http://dl.iteye.com/upload/attachment/0083/2584/b7b2472f-6b93-3f85-9e44-29a9ff774c8e.png" alt="java.util.concurrent"></p><p>CAS 可能产生的 ABA 问题</p><ol><li>问题描述<br>如说一个线程T1从内存位置V中取出A，这时候另一个线程T2也从内存中取出A，并且T2进行了一些操作变成了B，然后T2又将V位置的数据变成A，这时候线程T1进行CAS操作发现内存中仍然是A，然后T1操作成功。尽管线程T1的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。</li><li>解决</li></ol><ul><li>AtomicMarkableReference 使用boolean变量——表示引用变量是否被更改过,不关心中间变量变化了几次</li><li>AtomicStampedReference 通过时间戳\版本进行唯一标记变量中途被更改了几次</li></ul><h3 id="1-非阻塞队列"><a href="#1-非阻塞队列" class="headerlink" title="1. 非阻塞队列"></a>1. 非阻塞队列</h3><h4 id="1-1-ConcurrentLinkedQueue"><a href="#1-1-ConcurrentLinkedQueue" class="headerlink" title="1.1 ConcurrentLinkedQueue"></a>1.1 ConcurrentLinkedQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 在队尾插入一个元素，因为队列无边界，所以不会返回false</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);//入队前，创建一个新节点</span><br><span class="line"></span><br><span class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;//除非插入成功并返回，否则反复循环</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            // p is last node</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;//利用CAS操作，将p的next指针从旧值null更新为newNode </span><br><span class="line">                if (p != t) // hop two nodes at a time</span><br><span class="line">                    casTail(t, newNode);  // Failure is OK.利用CAS操作更新tail，如果失败说明其他线程添加了元素，由其他线程负责更新tail</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // Lost CAS race to another thread; re-read next 如果添加元素失败，说明其他线程添加了元素，p后移，并继续尝试</span><br><span class="line">        &#125;</span><br><span class="line">        else if (p == q) //如果p被移除出链表，我们需要调整指针重新指向head，否则我们指向新的tail</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        else</span><br><span class="line">            //p指向tail或者q</span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">casTail(cmp,value)方法用于更新tail节点。tail被设置为volatile保证可见性</span><br></pre></td></tr></table></figure><h4 id="1-2-ConcurrentHashMap"><a href="#1-2-ConcurrentHashMap" class="headerlink" title="1.2 ConcurrentHashMap"></a>1.2 ConcurrentHashMap</h4><p>HashTable 线程安全，但是put get实现方法全是synchronized，效率太低；HashMap 线程不安全。HashTable 效率低下，是因为所有线程访问竞争的都是同一把锁，而<br>JDK 1.5<br>ConcurrentHashMap 采用锁分段技术，将数据分段，每一段数据都配有一把锁，那么多线程访问不同数据段的数据时就不需要竞争同一把锁，就可以实现线程安全。对于像 size() containsValue() 方法需要锁定整个表而不仅仅是某几个数据段，那么就需要按顺序锁定所有段，操作完毕后，再按顺序释放所有段的锁。<br><img src="https://images.weserv.nl/?url=https://images2017.cnblogs.com/blog/400827/201709/400827-20170928212457434-1134706220.png" alt="pic1"></p><p>JDK 1.8<br>ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。<br>synchronized只锁定当前链表或红黑二叉树的head节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><blockquote><p>如果是key对应的是null，通过cas来设置当前值；如果key对应的不是null（即链表表头或树的根元素），就是用synchronized</p></blockquote><p><img src="https://images.weserv.nl/?url=https://upload-images.jianshu.io/upload_images/2843224-59ca97f3ae25b043.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/681/format/webp" alt="pic2"></p><p>TreeBin: 红黑二叉树节点 Node: 链表节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">hash表初始化或扩容时的一个控制位标识量。</span><br><span class="line">负数代表正在进行初始化或扩容操作</span><br><span class="line">-1 代表正在初始化</span><br><span class="line">-N 表示有 N-1 个线程正在进行扩容操作</span><br><span class="line">正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小 */</span><br><span class="line">private transient volatile int sizeCtl;</span><br><span class="line">static final int MOVED     = -1; // hash值是-1，表示这是一个forwardNode节点</span><br><span class="line">static final int TREEBIN   = -2; // hash值是-2  表示这时一个TreeBin节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    //ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    //计算key的hash值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    //for循环的作用：因为更新元素是使用CAS机制更新，需要不断的失败重试，直到成功为止。</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        // f：链表或红黑二叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        //判断Node[]数组是否初始化，没有则进行初始化操作</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //检查到内部正在移动元素（Node[] 数组扩容）</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            //帮助它扩容</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //锁住链表或红黑二叉树的头结点</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                //判断f是否是链表的头结点</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //如果fh&gt;=0 是链表节点</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        //遍历链表所有节点</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //如果节点存在，则更新value</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            //不存在则在链表尾部添加新节点。</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //TreeBin是红黑二叉树节点</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        //添加树节点</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                      value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                //如果链表长度已经达到临界值8 就需要把链表转换为树结构</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将当前ConcurrentHashMap的size数量+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断Node[]数组是否初始化，没有则进行初始化操作<br>通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。<br>检查到内部正在扩容，如果正在扩容，就帮助它一块扩容。<br>如果f!=null，则使用synchronized锁住f元素（链表/红黑二叉树的头元素）<br>4.1 如果是Node(链表结构)则执行链表的添加操作。<br>4.2 如果是TreeNode(树型结果)则执行树添加操作。<br>判断链表长度已经达到临界值8 就需要把链表转换为树结构。<br>总结：<br>    JDK8中的实现也是锁分离的思想，它把锁分的比segment（JDK1.5）更细一些，只要hash不冲突，就不会出现并发获得锁的情况。它首先使用无锁操作CAS插入头结点，如果插入失败，说明已经有别的线程插入头结点了，再次循环进行操作。如果头结点已经存在，则通过synchronized获得头结点锁，进行后续的操作。性能比segment分段锁又再次提升。</p><h3 id="2-阻塞队列"><a href="#2-阻塞队列" class="headerlink" title="2. 阻塞队列"></a>2. 阻塞队列</h3><p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。</p><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><p><a href="https://www.cnblogs.com/tjudzj/p/4454490.html" target="_blank" rel="noopener">参考</a></p><table><thead><tr><th></th><th>抛出异常</th><th>特殊值（通常是true、false）</th><th>阻塞</th><th>超时（在规定时间内进行操作，如果操作还不成功，就返回false）</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><h4 id="2-1-SynchronousQueue"><a href="#2-1-SynchronousQueue" class="headerlink" title="2.1 SynchronousQueue"></a>2.1 SynchronousQueue</h4><p>无界的，无缓冲的等待队列。无缓冲指的是，一个put必须需要一个take，不会保存put的数据。</p><p>生产者 put() 一个对象时，会等消费者来 take()，如果没有的话就一直等，直到消费者消费；反之，如果消费者 take() 时，会等生产者 put()。</p><p>isEmpty()方法永远返回是true，remainingCapacity() 方法永远返回是0，remove()和removeAll() 方法永远返回是false，iterator()方法永远返回空，peek()方法永远返回null。</p><p>它一种阻塞队列，其中每个 put 必须等待一个 take，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。<br>它是线程安全的，是阻塞的。<br>不允许使用 null 元素。<br>公平排序策略是指调用put的线程之间，或take的线程之间。</p><p>为什么 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); newCachedThreadPool() 方法里使用的是 SynchronousQueue。</p><p>SynchronousQueue队列，一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作。所以，当我们提交第一个任务的时候，是加入不了队列的，这就满足了一个线程池条件“当无法加入队列的时候，且任务没有达到maxsize时，我们将新开启一个线程任务”。所以我们的maxsize是int的最大值。时间是60s，当一个线程没有任务执行会暂时保存60s超时时间，如果没有的新的任务的话，会从cache中remove掉。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p><h4 id="2-2-LinkedBlockingQueue"><a href="#2-2-LinkedBlockingQueue" class="headerlink" title="2.2 LinkedBlockingQueue"></a>2.2 LinkedBlockingQueue</h4><p>是一个无界缓存的等待队列。</p><p>基于链表的阻塞队列，内部维持着一个数据缓冲队列（该队列由链表构成）。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p>在构造 LinkedBlockingQueue 对象时如果没有指定其容量大小，默认会设置为int最大值，一旦生产者的速度远远大于消费者的速度，会导致内存溢出。</p><h4 id="2-3-ArrayBlockingQueue"><a href="#2-3-ArrayBlockingQueue" class="headerlink" title="2.3 ArrayBlockingQueue"></a>2.3 ArrayBlockingQueue</h4><p>是一个有界缓存的等待队列。在创建时必须指定队列长度，一旦指定，不能修改，不支持扩容。还可以指定是否采用公平锁。</p><p>内部维持着一个定长数据缓冲队列（该队列由数组构成）。ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。</p><h4 id="2-4-DelayQueue"><a href="#2-4-DelayQueue" class="headerlink" title="2.4 DelayQueue"></a>2.4 DelayQueue</h4><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><p>DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p><h4 id="2-5-PriorityBlockingQueue"><a href="#2-5-PriorityBlockingQueue" class="headerlink" title="2.5 PriorityBlockingQueue"></a>2.5 PriorityBlockingQueue</h4><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>血缘分析</title>
      <link href="/2020/07/29/Hive-7/"/>
      <url>/2020/07/29/Hive-7/</url>
      
        <content type="html"><![CDATA[<h2 id="血缘分析"><a href="#血缘分析" class="headerlink" title="血缘分析"></a>血缘分析</h2><h3 id="1-LineageLogger"><a href="#1-LineageLogger" class="headerlink" title="1. LineageLogger"></a>1. LineageLogger</h3><p>首先需要对 org.apache.hadoop.hive.ql.hooks.LineageLogger 这个类进行改写，原类会把 lineage 字段依赖信息打印到日志里去，但是现在我们需要把 lineage 信息直接 return 回来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String lineage = out.toString();</span><br><span class="line">if (testMode) &#123;</span><br><span class="line">    log(lineage);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    LOG.info(lineage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=&gt; </span><br><span class="line">String lineage = out.toString();</span><br><span class="line">return lineage;</span><br></pre></td></tr></table></figure><h3 id="2-添加-hook"><a href="#2-添加-hook" class="headerlink" title="2. 添加 hook"></a>2. 添加 hook</h3><p>Hive 提供了多个 hook 给开发者调用，对于字段分析来说，需要在 conf 里添加 <code>hConf.set(&quot;hive.exec.post.hooks&quot;, &quot;org.apache.hadoop.hive.ql.hooks.LineageLogger&quot;)</code></p><h3 id="3-LineageInfo"><a href="#3-LineageInfo" class="headerlink" title="3. LineageInfo"></a>3. LineageInfo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">package cn.edata.StageTest;</span><br><span class="line"></span><br><span class="line">import cn.edata.Lineage.LineageLogger;</span><br><span class="line">import org.apache.hadoop.hive.conf.HiveConf;</span><br><span class="line">import org.apache.hadoop.hive.conf.HiveVariableSource;</span><br><span class="line">import org.apache.hadoop.hive.conf.VariableSubstitution;</span><br><span class="line">import org.apache.hadoop.hive.metastore.MetaStoreUtils;</span><br><span class="line">import org.apache.hadoop.hive.metastore.api.FieldSchema;</span><br><span class="line">import org.apache.hadoop.hive.metastore.api.Schema;</span><br><span class="line">import org.apache.hadoop.hive.ql.Context;</span><br><span class="line">import org.apache.hadoop.hive.ql.QueryDisplay;</span><br><span class="line">import org.apache.hadoop.hive.ql.QueryPlan;</span><br><span class="line">import org.apache.hadoop.hive.ql.exec.FetchTask;</span><br><span class="line">import org.apache.hadoop.hive.ql.hooks.WriteEntity;</span><br><span class="line">import org.apache.hadoop.hive.ql.lockmgr.LockException;</span><br><span class="line">import org.apache.hadoop.hive.ql.optimizer.lineage.LineageCtx;</span><br><span class="line">import org.apache.hadoop.hive.ql.parse.*;</span><br><span class="line">import org.apache.hadoop.hive.ql.plan.FetchWork;</span><br><span class="line">import org.apache.hadoop.hive.ql.plan.PartitionDesc;</span><br><span class="line">import org.apache.hadoop.hive.ql.plan.TableDesc;</span><br><span class="line">import org.apache.hadoop.hive.ql.processors.SetProcessor;</span><br><span class="line">import org.apache.hadoop.hive.ql.session.SessionState;</span><br><span class="line">import org.apache.hadoop.util.StringUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import javax.sql.CommonDataSource;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 改写hive本身编译过程，获取字段依赖关系</span><br><span class="line"> */</span><br><span class="line">public class LineageInfo &#123;</span><br><span class="line">    private static final String KEY_ADD = &quot;add &quot;;</span><br><span class="line">    private static final String KEY_DROP = &quot;drop &quot;;</span><br><span class="line">    private static final String KEY_SET = &quot;set &quot;;</span><br><span class="line">    private static final String KEY_FUNCTION = &quot;create temporary function &quot;;</span><br><span class="line">    private static final SetProcessor setProcessor = new SetProcessor();</span><br><span class="line">    static Logger LOG = LoggerFactory.getLogger(&quot;LineageInfo&quot;);</span><br><span class="line"></span><br><span class="line">    private static final LineageLogger lineageLogger = new LineageLogger();</span><br><span class="line"></span><br><span class="line">    public void getLineageInfo(HiveConf conf, String filePath, boolean testTableDenpendency) throws LockException, IOException, ParseException, SemanticException &#123;</span><br><span class="line">        SessionState ss = SessionState.start(conf);</span><br><span class="line">        ss.initTxnMgr(conf);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;filePath: &quot; + filePath);</span><br><span class="line">        // TODO: 2020/8/3 后续添加对直接读取文件的支持 </span><br><span class="line">        String command2 = &quot;select * from model_ennenergy_ccs.a_md_ccs_common_h limit 2&quot;;</span><br><span class="line">        List&lt;String&gt; commandList = new LinkedList&lt;&gt;();</span><br><span class="line">        commandList.add(&quot;use model_ennenergy_ccs&quot;);</span><br><span class="line">        commandList.add(&quot;select * from a_md_ccs_common_h limit 2&quot;);</span><br><span class="line">        </span><br><span class="line">        for(String command : commandList)&#123;</span><br><span class="line">            String lowerSql = command.toLowerCase();</span><br><span class="line">            // add / drop 无需解析</span><br><span class="line">            if (lowerSql.startsWith(KEY_ADD) || lowerSql.startsWith(KEY_DROP)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 设置参数</span><br><span class="line">            if (lowerSql.startsWith(KEY_SET)) &#123;</span><br><span class="line">                setProcessor.run(command.substring(KEY_SET.length()));</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            command = new VariableSubstitution(new HiveVariableSource() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Map&lt;String, String&gt; getHiveVariable() &#123;</span><br><span class="line">                    return ss.getHiveVariables();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).substitute(conf, command);</span><br><span class="line">            Context ctx = new Context(conf);</span><br><span class="line">            ctx.setCmd(command);</span><br><span class="line">            System.out.println(&quot;ctx: &quot; + ctx);</span><br><span class="line">            ASTNode tree;</span><br><span class="line">            try &#123;</span><br><span class="line">                ParseDriver pd = new ParseDriver();</span><br><span class="line">                tree = pd.parse(command, ctx);</span><br><span class="line">                tree = ParseUtils.findRootNonNullToken(tree);</span><br><span class="line">            &#125; catch (ParseException e) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tree: &quot; + tree);</span><br><span class="line"></span><br><span class="line">            // 切换数据库</span><br><span class="line">            if (tree.getToken().getType() == HiveParser.TOK_SWITCHDATABASE) &#123;</span><br><span class="line">                ss.setCurrentDatabase(tree.getChild(0).getText());</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ss.setupQueryCurrentTimestamp();</span><br><span class="line">            System.out.println(&quot;ss: &quot; + ss);</span><br><span class="line">            // 6.2.0 版本</span><br><span class="line">            // QueryState queryState = new QueryState(conf);</span><br><span class="line">            // System.out.println(&quot;queryState: &quot; + queryState);</span><br><span class="line">            // BaseSemanticAnalyzer sem = SemanticAnalyzerFactory.get(queryState, tree);</span><br><span class="line">            BaseSemanticAnalyzer sem = SemanticAnalyzerFactory.get(conf, tree);</span><br><span class="line">            sem.analyze(tree, ctx);</span><br><span class="line">            sem.validate();</span><br><span class="line">            System.out.println(&quot;sem: &quot; + sem);</span><br><span class="line"></span><br><span class="line">            Schema schema = getSchame(sem, conf);</span><br><span class="line">            // System.out.println(&quot;schema: &quot; + schema);</span><br><span class="line">            </span><br><span class="line">            // 查询计划</span><br><span class="line">            // QueryDisplay queryDisplay = new QueryDisplay();</span><br><span class="line">            // queryDisplay.setQueryStr(command);</span><br><span class="line">            // queryDisplay.setQueryId(QueryPlan.makeQueryId());</span><br><span class="line">            // QueryPlan queryPlan = new QueryPlan(command, sem, 0L, QueryPlan.makeQueryId(), SessionState.get().getHiveOperation(), schema, queryDisplay);</span><br><span class="line">            // System.out.println(&quot;queryPlan: &quot; + queryPlan);</span><br><span class="line">            </span><br><span class="line">            List&lt;FieldSchema&gt; fieldSchemas = schema.getFieldSchemas();</span><br><span class="line">            // System.out.println(&quot;fieldSchemas: &quot; + fieldSchemas);</span><br><span class="line"></span><br><span class="line">            // 部分语句不能完整的分析出schema</span><br><span class="line">            // 例：ALTER TABLE model_icome_cheme.cheme_icome_kpi_month_h SET</span><br><span class="line">            // TBLPROPERTIES(&apos;comment&apos; = &apos;化工月指标&apos;)</span><br><span class="line">            // 可以针对 alter 开头的语句进行过滤，无需解析</span><br><span class="line">            if (fieldSchemas == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            HashSet&lt;WriteEntity&gt; outputs = sem.getOutputs();</span><br><span class="line">            System.out.println(&quot;outputs: &quot; + outputs);</span><br><span class="line"></span><br><span class="line">            // 字段血缘分析信息输出</span><br><span class="line">            LineageCtx.Index index = ss.getLineageState().getIndex();</span><br><span class="line">            // 6.2.0 版本</span><br><span class="line">            // LineageCtx.Index index = queryState.getLineageState().getIndex();</span><br><span class="line">            System.out.println(&quot;index: &quot; + index);</span><br><span class="line"></span><br><span class="line">            String result = lineageLogger.getJsonString(command, fieldSchemas, outputs, index);</span><br><span class="line">            System.out.println(&quot;result: &quot; + result);</span><br><span class="line"></span><br><span class="line">            if(testTableDenpendency)&#123;</span><br><span class="line">                DependencyInfo dependencyInfo = new DependencyInfo();</span><br><span class="line">                dependencyInfo.getDependencyInfo(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拿过来Driver类下的方法</span><br><span class="line">    private Schema getSchame(BaseSemanticAnalyzer sem, HiveConf conf) &#123;</span><br><span class="line">        Schema schema = null;</span><br><span class="line">        if (sem != null) &#123;</span><br><span class="line">            if (sem.getResultSchema() != null) &#123;</span><br><span class="line">                List&lt;FieldSchema&gt; lst = sem.getResultSchema();</span><br><span class="line">                schema = new Schema(lst, (Map) null);</span><br><span class="line">            &#125; else if (sem.getFetchTask() != null) &#123;</span><br><span class="line">                FetchTask ft = sem.getFetchTask();</span><br><span class="line">                TableDesc td = ft.getTblDesc();</span><br><span class="line">                if (td == null &amp;&amp; ft.getWork() != null &amp;&amp; ((FetchWork) ft.getWork()).getPartDesc() != null &amp;&amp; ((FetchWork) ft.getWork()).getPartDesc().size() &gt; 0) &#123;</span><br><span class="line">                    td = ((PartitionDesc) ((FetchWork) ft.getWork()).getPartDesc().get(0)).getTableDesc();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (td != null) &#123;</span><br><span class="line">                    String tableName = &quot;result&quot;;</span><br><span class="line">                    List lst = null;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        lst = MetaStoreUtils.getFieldsFromDeserializer(tableName, td.getDeserializer(conf));</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(&quot;Error getting schema: &quot; + StringUtils.stringifyException(e));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (lst != null) &#123;</span><br><span class="line">                        schema = new Schema(lst, (Map) null);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (schema == null) &#123;</span><br><span class="line">            schema = new Schema();</span><br><span class="line">        &#125;</span><br><span class="line">        // System.out.println(&quot;Returning Hive schema: &quot; + schema);</span><br><span class="line">        return schema;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-TableDependency"><a href="#4-TableDependency" class="headerlink" title="4. TableDependency"></a>4. TableDependency</h3><p>除了字段的血缘分析，还可以进一步去获取表之间的依赖关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package cn.edata.StageTest;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 拿到返回的字段依赖信息，解析数据，获取表之间的依赖关系</span><br><span class="line"> */</span><br><span class="line">public class DependencyInfo &#123;</span><br><span class="line">    public void getDependencyInfo(String lineageInfo)&#123;</span><br><span class="line">        JSONObject result = JSONObject.parseObject(lineageInfo);</span><br><span class="line">        System.out.println(&quot;#########&quot;);</span><br><span class="line"></span><br><span class="line">        JSONArray verticesArray = JSONArray.parseArray(result.getString(&quot;vertices&quot;));</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; modelTables = new HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; originTables = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        verticesArray.forEach(data-&gt;&#123;</span><br><span class="line">            JSONObject tmp = JSONObject.parseObject(data.toString());</span><br><span class="line">            String vertextId = tmp.getString(&quot;vertexId&quot;);</span><br><span class="line">            if(vertextId.startsWith(&quot;model&quot;))</span><br><span class="line">                modelTables.add(vertextId.split(&quot;\\.&quot;)[0]+&quot;.&quot;+vertextId.split(&quot;\\.&quot;)[1]);</span><br><span class="line">            if(vertextId.startsWith(&quot;origin&quot;))</span><br><span class="line">                originTables.add(vertextId);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;####&quot;);</span><br><span class="line">        System.out.println(&quot;modelTables: &quot; + modelTables.toString());</span><br><span class="line">        System.out.println(&quot;originTables: &quot; + originTables.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-pom-xml"><a href="#5-pom-xml" class="headerlink" title="5. pom.xml"></a>5. pom.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;!--        查询--&gt;</span><br><span class="line">    &lt;!--        &lt;cdh.hadoop.version&gt;3.0.0-cdh6.2.0&lt;/cdh.hadoop.version&gt;--&gt;</span><br><span class="line">    &lt;!--        &lt;cdh.hive.version&gt;2.1.1-cdh6.2.0&lt;/cdh.hive.version&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;cdh.hadoop.version&gt;2.6.0-cdh5.14.4&lt;/cdh.hadoop.version&gt;</span><br><span class="line">    &lt;cdh.hive.version&gt;1.1.0-cdh5.14.4&lt;/cdh.hive.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;cdh.hadoop.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;hadoop-mapreduce-client-common&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;cdh.hadoop.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;hive-exec&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;cdh.hive.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;</span><br><span class="line">                    hadoop-yarn-server-resourcemanager</span><br><span class="line">                &lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">&lt;!--                &lt;exclusion&gt;--&gt;</span><br><span class="line">&lt;!--                    &lt;artifactId&gt;gson&lt;/artifactId&gt;--&gt;</span><br><span class="line">&lt;!--                    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;--&gt;</span><br><span class="line">&lt;!--                &lt;/exclusion&gt;--&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;hive-shims&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;cdh.hive.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;hbase-server&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;jasper-compiler&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;tomcat&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;jasper-runtime&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;tomcat&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-rewrite&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-server&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-runner&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;hadoop-yarn-registry&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;hbase-hadoop2-compat&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;hive-shims-0.23&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.hive.shims&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;artifactId&gt;hive-common&lt;/artifactId&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;cdh.hadoop.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parquet 源码解析</title>
      <link href="/2020/07/20/Parquet/"/>
      <url>/2020/07/20/Parquet/</url>
      
        <content type="html"><![CDATA[<h2 id="Parquet-源码解析"><a href="#Parquet-源码解析" class="headerlink" title="Parquet 源码解析"></a>Parquet 源码解析</h2><p>Parquet文件是以二进制方式存储的，所以是不可以直接读取的，文件中包括该文件的数据和元数据，因此Parquet格式文件是自解析的。在HDFS文件系统和Parquet文件中存在如下几个概念。</p><ul><li>HDFS块(Block)：它是HDFS上的最小的副本单位，HDFS会把一个Block存储在本地的一个文件并且维护分散在不同的机器上的多个副本，通常情况下一个Block的大小为256M、512M等。</li><li>HDFS文件(File)：一个HDFS的文件，包括数据和元数据，数据分散存储在多个Block中。</li><li>行组(Row Group)：按照行将数据物理上划分为多个单元，每一个行组包含一定的行数，在一个HDFS文件中至少存储一个行组，Parquet读写的时候会将整个行组缓存在内存中，所以如果每一个行组的大小是由内存大的小决定的，例如记录占用空间比较小的Schema可以在每一个行组中存储更多的行。</li><li>列块(Column Chunk)：在一个行组中每一列保存在一个列块中，行组中的所有列连续的存储在这个行组文件中。一个列块中的值都是相同类型的，不同的列块可能使用不同的算法进行压缩。</li><li>页(Page)：每一个列块划分为多个页，一个页是最小的编码的单位，在同一个列块的不同页可能使用不同的编码方式。</li></ul><blockquote><p>一般按照 Block 大小来设置行组的大小，每一个mapper处理数据的最小单位是一个 block，这样就可以把每一个行组由一个mapper处理，提高任务执行并行度</p></blockquote><p><img src="https://images2017.cnblogs.com/blog/400827/201710/400827-20171017112835787-354192287.png" alt></p><blockquote><p>MapredParquetOutputFormat.getHiveRecordWriter()<br>-&gt; DataWritableWriteSupport.setSchema(HiveSchemaConverter.convert((List)columnNames, columnTypes), jobConf) 根据列名和类型，生成schema<br>-&gt; ParquetRecordWriterWrapper.ParquetRecordWriterWrapper() 生成一个 ParquetOutputFormat 对象<br>-&gt; ParquetFileWriter<br>    创建一个文件写入对象，<br>    ParquetFileWriter(Configuration configuration, MessageType schema, Path file, ParquetFileWriter.Mode mode, long rowGroupSize, int maxPaddingSize)<br>    参数包括：conf配置，schema表结构，file文件路径，mode文件写入的模式（新建或覆写），blockSizeHDFS块大小，也就是一个行组的大小<br>    之后会先在这个文件的最开始的位置写入四个字节的 “PAR1” 表示该文件为 parquet 格式，”parquet.writer.max-padding”, 8388608<br>    根据这个文件写入对象，去创建一个<br>-&gt; InternalParquetRecordWriter<br>    创建一个 InternalParquetRecordWriter(fileWriter, writeSupport, schema, writeContext.getExtraMetaData(), (long)blockSize, compressor, validating, encodingProps); 对象，每读取一条数据，调用该对象的 write() 方法写入，底层实现是调用 DataWritableWriter.write(T value)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">InternalParquetRecordWriter 类</span><br><span class="line">public void write(T value) throws IOException, InterruptedException &#123;</span><br><span class="line">    this.writeSupport.write(value);</span><br><span class="line">    ++this.recordCount; // 每写入一条数据，记录数+1</span><br><span class="line">    this.checkBlockSizeReached();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void checkBlockSizeReached() throws IOException &#123;</span><br><span class="line">    if (this.recordCount &gt;= this.recordCountForNextMemCheck) &#123; // 默认值 this.recordCountForNextMemCheck = 100L，每调用一次修改为新值</span><br><span class="line">        // this.pageStore = new ColumnChunkPageWriteStore(this.compressor, this.schema, this.props.getAllocator());</span><br><span class="line">        // this.columnStore = this.props.newColumnWriteStore(this.schema, this.pageStore);</span><br><span class="line">        // props 就是 ParquetProperties</span><br><span class="line">        // 已写入到内存中的记录的总大小，除以记录数，得到平均一条记录的大小</span><br><span class="line">        long memSize = this.columnStore.getBufferedSize();</span><br><span class="line">        long recordSize = memSize / this.recordCount; </span><br><span class="line">        if (memSize &gt; this.nextRowGroupSize - 2L * recordSize) &#123;</span><br><span class="line">            // 如果内存中的记录总大小 &gt; 行组大小 - 2*平均一条记录大小 ？？？</span><br><span class="line">            // 当 memSize &gt; GroupSize(约等于blocksize)，就可以刷到磁盘</span><br><span class="line">            LOG.debug(&quot;mem size &#123;&#125; &gt; &#123;&#125;: flushing &#123;&#125; records to disk.&quot;, new Object[]&#123;memSize, this.nextRowGroupSize, this.recordCount&#125;);</span><br><span class="line">            // 刷写内存的记录</span><br><span class="line">            this.flushRowGroupToStore();</span><br><span class="line">            this.initStore(); // 重置 pageStore、columnStore 等信息</span><br><span class="line">            this.recordCountForNextMemCheck = Math.min(Math.max(100L, this.recordCount / 2L), 10000L);</span><br><span class="line">            this.lastRowGroupEndPos = this.parquetFileWriter.getPos();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 当目前内存中的记录的总大小还不够大时，修改 recordCountForNextMemCheck 的值，每次会增大一点，差不多相当于之前增量的一半，如果recordsize变化不大的话</span><br><span class="line">            this.recordCountForNextMemCheck = Math.min(Math.max(100L, (this.recordCount + (long)((float)this.nextRowGroupSize / (float)recordSize)) / 2L), this.recordCount + 10000L);</span><br><span class="line">            LOG.debug(&quot;Checked mem at &#123;&#125; will check again at: &#123;&#125;&quot;, this.recordCount, this.recordCountForNextMemCheck);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void flushRowGroupToStore() throws IOException &#123;</span><br><span class="line">    // 先将null值刷写出去？？？</span><br><span class="line">    this.recordConsumer.flush();</span><br><span class="line">    LOG.debug(&quot;Flushing mem columnStore to file. allocated memory: &#123;&#125;&quot;, this.columnStore.getAllocatedSize());</span><br><span class="line">    if (this.columnStore.getAllocatedSize() &gt; 3L * this.rowGroupSizeThreshold) &#123;</span><br><span class="line">        LOG.warn(&quot;Too much memory used: &#123;&#125;&quot;, this.columnStore.memUsageString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.recordCount &gt; 0L) &#123;</span><br><span class="line">        // 获取block的元数据信息</span><br><span class="line">        this.parquetFileWriter.startBlock(this.recordCount);</span><br><span class="line">        // 把每一列的值写到文件</span><br><span class="line">        this.columnStore.flush();</span><br><span class="line">        this.pageStore.flushToFileWriter(this.parquetFileWriter);</span><br><span class="line">        this.recordCount = 0L;</span><br><span class="line">        this.parquetFileWriter.endBlock();</span><br><span class="line">        this.nextRowGroupSize = Math.min(this.parquetFileWriter.getNextRowGroupSize(), this.rowGroupSizeThreshold);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.columnStore = null;</span><br><span class="line">    this.pageStore = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ColumnWriteStoreV1 类</span><br><span class="line">this.columnStore = ColumnWriteStoreV1 时，执行的方法</span><br><span class="line">public void flush() &#123;</span><br><span class="line">    // private final Map&lt;ColumnDescriptor, ColumnWriterV1&gt; columns = new TreeMap();</span><br><span class="line">    Collection&lt;ColumnWriterV1&gt; values = this.columns.values();</span><br><span class="line">    Iterator var2 = values.iterator();</span><br><span class="line"></span><br><span class="line">    while(var2.hasNext()) &#123;</span><br><span class="line">        ColumnWriterV1 memColumn = (ColumnWriterV1)var2.next();</span><br><span class="line">        memColumn.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ColumnWriterV1 类</span><br><span class="line">public void flush() &#123;</span><br><span class="line">    if (this.valueCount &gt; 0) &#123;</span><br><span class="line">        this.writePage(); </span><br><span class="line">        // 将所有数据都转换成了Bytes</span><br><span class="line">        // this.pageWriter.writePage(BytesInput.concat(new BytesInput[]&#123;this.repetitionLevelColumn.getBytes(), this.definitionLevelColumn.getBytes(), this.dataColumn.getBytes()&#125;), this.valueCount, this.statistics, this.repetitionLevelColumn.getEncoding(), this.definitionLevelColumn.getEncoding(), this.dataColumn.getEncoding());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DictionaryPage dictionaryPage = this.dataColumn.toDictPageAndClose();</span><br><span class="line">    if (dictionaryPage != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.pageWriter.writeDictionaryPage(dictionaryPage);</span><br><span class="line">        &#125; catch (IOException var3) &#123;</span><br><span class="line">            throw new ParquetEncodingException(&quot;could not write dictionary page for &quot; + this.path, var3);</span><br><span class="line">        &#125;</span><br><span class="line">        this.dataColumn.resetDictionary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ParquetProperties 默认变量信息</span><br><span class="line">private Builder() &#123;</span><br><span class="line">    this.pageSize = 1048576;</span><br><span class="line">    this.dictPageSize = 1048576;</span><br><span class="line">    this.enableDict = true;</span><br><span class="line">    this.writerVersion = ParquetProperties.DEFAULT_WRITER_VERSION =&gt; &quot;v1&quot;;</span><br><span class="line">    this.minRowCountForPageSizeCheck = 100;</span><br><span class="line">    this.maxRowCountForPageSizeCheck = 10000;</span><br><span class="line">    this.estimateNextSizeCheck = true;</span><br><span class="line">    this.allocator = new HeapByteBufferAllocator();</span><br><span class="line">    this.valuesWriterFactory = ParquetProperties.DEFAULT_VALUES_WRITER_FACTORY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.apache.parquet.hadoop.api 包下 </p><ul><li>ReadSupport<ul><li>GroupReadSupport</li><li>DataWritableReadSupport</li></ul></li><li>WriteSupport<ul><li>GroupWriteSupport</li><li>DataWritableWriteSupport</li></ul></li></ul><p>映射下推(Project PushDown)<br>说到列式存储的优势，映射下推是最突出的，它意味着在获取表中原始数据时只需要扫描查询中需要的列，由于每一列的所有值都是连续存储的，所以分区取出每一列的所有值就可以实现TableScan算子，而避免扫描整个表文件内容。</p><p>在Parquet中原生就支持映射下推，执行查询的时候可以通过Configuration传递需要读取的列的信息，这些列必须是Schema的子集，映射每次会扫描一个Row Group的数据，然后一次性得将该Row Group里所有需要的列的Cloumn Chunk都读取到内存中，每次读取一个Row Group的数据能够大大降低随机读的次数，除此之外，Parquet在读取的时候会考虑列是否连续，如果某些需要的列是存储位置是连续的，那么一次读操作就可以把多个列的数据读取到内存。</p><p>谓词下推(Predicate PushDown)<br>在数据库之类的查询系统中最常用的优化手段就是谓词下推了，通过将一些过滤条件尽可能的在最底层执行可以减少每一层交互的数据量，从而提升性能，例如”select count(1) from A Join B on A.id = B.id where A.a &gt;数据 10 and B.b &lt; 100”SQL查询中，在处理Join操作之前需要首先对A和B执行TableScan操作，然后再进行Join，再执行过滤，最后计算聚合函数返回，但是如果把过滤条件A.a &gt; 10和B.b &lt; 100分别移到A表的TableScan和B表的TableScan的时候执行，可以大大降低Join操作的输入数据。</p><p>无论是行式存储还是列式存储，都可以在将过滤条件在读取一条记录之后执行以判断该记录是否需要返回给调用者，在Parquet做了更进一步的优化，优化的方法时对每一个Row Group的每一个Column Chunk在存储的时候都计算对应的统计信息，包括该Column Chunk的最大值、最小值和空值个数。通过这些统计值和该列的过滤条件可以判断该Row Group是否需要扫描。另外Parquet未来还会增加诸如Bloom Filter和Index等优化数据，更加有效的完成谓词下推。</p><p>在使用Parquet的时候可以通过如下两种策略提升查询性能：1、类似于关系数据库的主键，对需要频繁过滤的列设置为有序的，这样在导入数据的时候会根据该列的顺序存储数据，这样可以最大化的利用最大值、最小值实现谓词下推。2、减小行组大小和页大小，这样增加跳过整个行组的可能性，但是此时需要权衡由于压缩和编码效率下降带来的I/O负载。</p><p><a href="https://www.cnblogs.com/windliu/p/10942252.html" target="_blank" rel="noopener">参考地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">4-byte magic number &quot;PAR1&quot;</span><br><span class="line">&lt;Column 1 Chunk 1 + Column Metadata&gt;</span><br><span class="line">&lt;Column 2 Chunk 1 + Column Metadata&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Column N Chunk 1 + Column Metadata&gt;</span><br><span class="line">&lt;Column 1 Chunk 2 + Column Metadata&gt;</span><br><span class="line">&lt;Column 2 Chunk 2 + Column Metadata&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Column N Chunk 2 + Column Metadata&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Column 1 Chunk M + Column Metadata&gt;</span><br><span class="line">&lt;Column 2 Chunk M + Column Metadata&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Column N Chunk M + Column Metadata&gt;</span><br><span class="line">File Metadata</span><br><span class="line">4-byte length in bytes of file metadata</span><br><span class="line">4-byte magic number &quot;PAR1&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Parquet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Parquet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/07/20/Thread-1/"/>
      <url>/2020/07/20/Thread-1/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程的目的不是提升执行速度等，而是提高资源利用效率，当有的线程不占用cpu时让出来资源，从而有可能达到提高效率的结果（线程太多有可能会变慢）。</p><p>JVM虚拟机的启动是多线程的，至少有两个线程：main 和垃圾回收机制。</p><p>线程状态<br>创建状态(new一个线程) – Thread.State.NEW<br>就绪状态(调用 start() 方法，等cpu调度) – Thread.State.RUNNABLE<br>运行状态(cpu开始调度)<br>阻塞状态(调用sleep、wait或同步锁定时，阻塞状态解除后，重新进入就绪状态)<br>死亡状态(线程中断或结束)</p><p>反映到jstack中的状态<br>RUNNABLE,在虚拟机内执行的。运行中状态，可能里面还能看到locked字样，表明它获得了某把锁。<br>BLOCKED,受阻塞并等待监视器锁。被某个锁(synchronizers)給block住了。<br>WATING,无限期等待另一个线程执行特定操作。等待某个condition或monitor发生，一般停留在park(), wait(), sleep(),join() 等语句里。<br>TIMED_WATING,有时限的等待另一个线程的特定操作。和WAITING的区别是wait() 等语句加上了时间限制 wait(timeout)。<br>TERMINATED,已退出的。</p><p>每个对象都有一个锁，sleep不会释放锁</p><p>yield 线程礼让 – 暂停当前线程，从运行状态回到就绪状态，不会造成阻塞，让cpu重新调度，但不一定礼让成功<br>join 线程合并 – 待此线程执行完成后，再执行其他线程，会造成其他线程阻塞，类似于插队</p><p>线程分为用户线程(main线程以及创建的线程)和守护线程(gc线程等)<br>thread.setDaemon(true);// 默认为false即用户线程，虚拟机不会等待守护线程执行完毕，只需要保证用户线程执行结束，程序就结束了</p><h3 id="1-实现方法"><a href="#1-实现方法" class="headerlink" title="1. 实现方法"></a>1. 实现方法</h3><p>1.1 通过 extends Thread类，重写Thread的run()方法，将线程运行的逻辑放在其中。</p><p>1.2 通过 implement Runnable接口，实例化Thread类，如果要有返回值的话，就 implement Callable接口，通过 Future 来接收所有的返回值</p><p>1.3 通过线程池</p><p><img src="https://images.weserv.nl/?url=https://img-blog.csdn.net/20151027094316987" alt="ExecutorService继承树"></p><p>接口 Executor 只有一个方法 <code>void execute(Runnable command);</code><br>在这个接口的基础上，提供一个更有拓展性的接口 ExecutorService，里面的方法有 <code>submit(Callable&lt;T&gt; task)</code> <code>submit(Runnable task);</code> <code>shutdown()</code> 等等<br>ThreadPoolExecutor 类是提供了一个更有拓展性的线程池实现类。在ThreadPoolExecutor的execute方法中会判断线程池是否可用，如果可用，就会获取线程池的锁(ReentrantLock)，然后将任务加入任务队列。<br>Executors 类提供了方便的工厂方法</p><p>submit 和 exexute 区别</p><ul><li>submit 可以接受 Callable 或 Runnable，但是execute 只接受 Runnable，所以如果需要调用返回结果的话，就用 submit，通过 future.get() 来获取</li><li>execute中的是Runnable接口的实现，所以只能使用try、catch来捕获CheckedException，通过实现UncaughtExceptionHande接口处理UncheckedException；而submit通过 future.get() 可以拿到任何一种异常</li></ul><h3 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h3><p>2.1 将需要多次调用的方法封装成一个类，实现 Runnable 或 Callable 接口。每调用一次相当于多一个线程。比如读取多个文件，for循环遍历目录，对文件的处理就封装成一个类，不断调用，相当于多个不同的线程同时在处理不同的文件。</p><p>2.2 创建线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">    int maximumPoolSize,</span><br><span class="line">    long keepAliveTime,</span><br><span class="line">    TimeUnit unit,</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">    RejectedExecutionHandler handler) &#123;</span><br><span class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">        Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">corePoolSize:核心线程数 =&gt; 线程池能维护的最小线程数</span><br><span class="line">maxPoolSize:最大线程数 =&gt; 线程池能维护的最大线程数 = 核心线程数+非核心线程数</span><br><span class="line">keepAliveTime:线程池维护线程所允许的空闲时间 =&gt; 非核心线程闲置超时时长</span><br><span class="line">unit:线程池维护线程所允许的空闲时间的单位</span><br><span class="line">workQueue:线程池所使用的缓冲队列</span><br><span class="line">handler:线程池对拒绝任务的处理策略</span><br><span class="line"></span><br><span class="line">private ThreadPoolExecutor executor;</span><br><span class="line">executor = new ThreadPoolExecutor(corePoolSize, maxPoolSize, 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">    new ArrayBlockingQueue&lt;Runnable&gt;(1000), new ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure><ul><li>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li><li>如果此时线程池中的数量等于corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。</li><li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li><li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。</li><li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。</li></ul><blockquote><p>shutdown(): 线程池不会立即关闭，只是不再接收新的任务（不再添加新的线程），直到所有已提交的线程都执行完成才会关闭。<br>shutdownnow(): 跳过所有正在执行的任务和已提交还没有执行的任务，正在执行的任务可能会停止也可能执行完成。</p></blockquote><h3 id="3-线程安全和线程同步"><a href="#3-线程安全和线程同步" class="headerlink" title="3. 线程安全和线程同步"></a>3. 线程安全和线程同步</h3><p>为了提高资源利用效率 -&gt; 多线程会对同一个资源同时进行操作（线程异步）-&gt; 这样的线程在运行时是不安全的，所以引入同步 —&gt; 当线程A对某一个资源进行操作时，其他线程必须等待。</p><p>多线程访问一个类，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步，这个类的行为仍然是正确的，那么称这个类是线程安全的。</p><p>线程同步的实现条件：队列(线程排队来获取一个对象进行操作)+锁(每一个对象都有一个锁)</p><h4 id="3-1-synchronized"><a href="#3-1-synchronized" class="headerlink" title="3.1 synchronized"></a>3.1 synchronized</h4><p><a href="https://www.cnblogs.com/codebj/p/10994748.html" target="_blank" rel="noopener">关于锁的用法1</a><br><a href="https://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">关于锁的用法2</a><br><a href="https://blog.csdn.net/gentlezuo/article/details/91410716" target="_blank" rel="noopener">synchronized和对象头</a></p><blockquote><p>方法锁、类锁，能确保同步的前提是，锁的那部分代码指向的应该是内存中的同一个地址</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">synchronized(需要加锁的共享变量)&#123;</span><br><span class="line">    // 同步代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void xxx()&#123;</span><br><span class="line">    // 同步方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以某一个线程进入synchronized代码块前后，执行过程入如下：<br>a.线程获得互斥锁<br>b.清空工作内存<br>c.从主内存拷贝共享变量最新的值到工作内存成为副本<br>d.执行代码<br>e.将修改后的副本的值刷新回主内存中<br>f.线程释放锁<br>随后，其他代码在进入synchronized代码块的时候，会重新从主内存拉取共享变量的值，这个值是上一个线程修改后的最新值。</p><p>synchronized 的实现依赖于对象头。对象在内存中存储的布局可以分为三块区域：</p><ul><li>对象头（Header）<ul><li>第一部分是类型指针，用于表示是哪一个类的对象</li><li>第二部分存储了关于对象运行时的数据，比如GC年龄，hashcode，锁状态标志等，这一部分也被称为Mark Word。</li></ul></li><li>实例数据（Instance Data）</li><li>对齐填充（Padding）</li></ul><p>一个对象可以是无锁状态，偏向锁状态（当前线程检查对象头没有存储其他线程，那么当前线程用CAS替换Mark Word，将对象头中的Mark Word指向当前线程自己），轻量级锁（对象头中存储了其他线程，当前线程自旋来获取锁），重量级锁（如果当前线程一直自旋却始终无法获取锁，那么锁会膨胀到重量级锁）</p><h4 id="3-2-volatile"><a href="#3-2-volatile" class="headerlink" title="3.2 volatile"></a>3.2 volatile</h4><p>当一个变量定义为 volatile 之后，它将具备两种特性：</p><ul><li>保证此变量对所有线程的可见性<br>  volatile变量每次被线程访问时，都强迫线程从主内存中重读该变量的最新值，而当该变量发生修改变化时，也会强迫线程将最新的值刷新回主内存中。这样一来，不同的线程都能及时的看到该变量的最新值。</li><li>禁止指令重排序优化<br>  指令重排序是JVM为了优化指令，提高运行效率，在不影响 单线程程序 执行结果的前提下，尽可能地提高并行度。但是在多线程情况下，指令重排序可能会影响结果。<ul><li>重排序遵守两个规则<ul><li>as-if-serial规则：指不管如何重排序（编译器与处理器为了提高并行度），单线程程序的结果不能被改变。</li><li>happens-before规则：<ul><li>程序顺序规则：一个线程中的每个操作，happens-before于线程中的任意后续操作。</li><li>监视器锁规则：一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果（A）happens-before（B），且（B）happens-before（C），那么（A）happens-before（C）。</li><li>线程start()规则：主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。也就是start() happens-before 线程B中的操作。</li><li>线程join()规则：主线程A等待子线程B完成，当子线程B执行完毕后，主线程A可以看到线程B的所有操作。也就是说，子线程B中的任意操作，happens-before join()的返回。</li><li>中断规则：一个线程调用另一个线程的interrupt，happens-before于被中断的线程发现中断。</li><li>终结规则：一个对象的构造函数的结束，happens-before于这个对象finalizer的开始。</li><li>概念：前一个操作的结果可以被后续的操作获取。讲直白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1</li></ul></li></ul></li></ul></li></ul><p>但是volatile不能保证<strong>变量操作</strong>的原子性：<br>比如number++，这个操作实际上是三个操作的集合（读取number，number加1，将新的值写回number），volatile只能保证每一步的操作对所有线程是可见的，但是假如两个线程都需要执行number++，那么这一共6个操作集合，之间是可能会交叉执行的，那么最后导致 number 的结果可能会不是所期望的。所以对于number++这种非原子性操作，推荐用synchronized</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized（this）&#123;</span><br><span class="line">     number++;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile适用情况</p><ul><li>对变量的写入操作不依赖当前值<ul><li>比如自增自减、number = number + 5等是不适用的；如果是new Date() 这样的，是可以使用的；直接对变量进行赋值比如修改布尔值，是可以使用的</li></ul></li><li>当前volatile变量不依赖于别的volatile变量<ul><li>比如 volatile_var &gt; volatile_var2这个不等式是不适用的</li></ul></li></ul><p>synchronized和volatile比较</p><ol><li>volatile不需要同步操作，所以效率更高，不会阻塞线程，但是适用情况比较窄</li><li>volatile读变量相当于加锁（即进入synchronized代码块），而写变量相当于解锁（退出synchronized代码块）</li><li>synchronized既能保证共享变量可见性，也可以保证锁内操作的原子性；volatile只能保证可见性</li></ol><p>volatile是如何防止指令重排序优化的呢？<br>答：</p><p>volatile关键字通过 “内存屏障” 的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。大多数的处理器都支持内存屏障的指令。</p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p><p>在每个volatile写操作的前面插入一个StoreStore屏障。<br>在每个volatile写操作的后面插入一个StoreLoad屏障。<br>在每个volatile读操作的后面插入一个LoadLoad屏障。<br>在每个volatile读操作的后面插入一个LoadStore屏障。</p><p>知识拓展：内存屏障：</p><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p><p>内存屏障可以被分为以下几种类型：</p><p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p><h4 id="3-3-原子类"><a href="#3-3-原子类" class="headerlink" title="3.3 原子类"></a>3.3 原子类</h4><p>如果需要用到自增等，可以使用 AtomicInteger 类，可以自动保证变量累加的原子性（设置为 static，所有线程只保留一份）<br>通过 AtomicInteger.addAndGet(int num)) 来进行增加，通过 get() 方法来获取当前的值</p><p>线程睡眠时，它所持的任何锁都不会释放</p><p>线程池是如何保证线程安全的？<br>1.线程池任务调度使用ReentrantLock保证任务不会被重复执行<br>任务队列必须是BlockQueue类型的，BlockQueue的子类保证队列的出入的线程安全。<br>2.线程池的worker节点继承了AbstractQueueSynchronizer()<br>当worker在运行任务前上锁，在任务运行结束后解锁。上锁后，不会响应中断，保证开始运行的任务不会被其他线程中断。只有任务结束，才会被中断。<br>3.worker的锁是不可重入的锁<br>防止线程池操作调整大小，获取数量等操作时，中断线程，导致任务没有完整的被执行。</p><p>同步的前提：<br>　　1、必须要有两个或者两个以上的线程。<br>　　2、必须是多个线程使用同一个锁。<br>　　3、必须保证同步中只能有一个线程在运行。<br>　　4、只能同步方法，不能同步变量和类。<br>　　5、不必同步类中所有方法，类可以拥有同步和非同步的方法。<br>　　6、如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。<br>　　7、线程睡眠时，它所持的任何锁都不会释放。</p><p>　　好处：解决了多线程的安全问题。<br>　　弊端：多个线程需要判断，消耗资源，降低效率。</p><p>　　如何找问题？<br>　　1、明确哪些代码是多线程运行代码。<br>　　2、明确共享数据。<br>　　3、明确多线程运行代码中哪些语句是操作共享数据的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashMap 实现LRU缓存</title>
      <link href="/2020/07/09/LRU/"/>
      <url>/2020/07/09/LRU/</url>
      
        <content type="html"><![CDATA[<h2 id="LinkedHashMap-实现LRU缓存"><a href="#LinkedHashMap-实现LRU缓存" class="headerlink" title="LinkedHashMap 实现LRU缓存"></a>LinkedHashMap 实现LRU缓存</h2><p><a href="https://www.cnblogs.com/lzrabbit/p/3734850.html#f1" target="_blank" rel="noopener">参考</a></p><p>LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序插入顺序 、 访问顺序</p><p>插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序<br>访问顺序：所谓访问指的是get/put操作，对一个键执行get/put操作后，其对应的键值对会移动到链表末尾，<strong>所以最末尾的是最近访问的，最开始的是最久没有被访问的</strong>，这就是访问顺序。</p><p><code>public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</code> 其中参数accessOrder就是用来指定是否按访问顺序，如果为true，就是访问顺序。</p><p>LRU(Least Recently Used): 最近最少使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private int maxEntries;</span><br><span class="line"></span><br><span class="line">    public LRUCache(int maxEntries) &#123;</span><br><span class="line">        super(16, 0.75f, true);</span><br><span class="line">        this.maxEntries = maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        return size() &gt; maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在LinkedHashMap添加元素后，会调用removeEldestEntry防范，传递的参数时最久没有被访问的键值对，如果方法返回true，这个最久的键值对就会被删除。LinkedHashMap中的实现总返回false，该子类重写后即可实现对容量的控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LRUCache&lt;String,Object&gt; cache = new LRUCache&lt;&gt;(3);</span><br><span class="line">cache.put(&quot;a&quot;,&quot;abstract&quot;);</span><br><span class="line">cache.put(&quot;b&quot;,&quot;basic&quot;);</span><br><span class="line">cache.put(&quot;c&quot;,&quot;call&quot;);</span><br><span class="line">cache.get(&quot;a&quot;);</span><br><span class="line">cache.put(&quot;d&quot;,&quot;滴滴滴&quot;);</span><br><span class="line">System.out.println(cache); // 输出为：&#123;c=call, a=abstract, d=滴滴滴&#125;</span><br></pre></td></tr></table></figure><p>相比HashMap，LinkedHashMap还实现了三个方法，当且仅当 accessOrder=True 时会被调用到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;  //访问节点之后调用的方法</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125; //插入节点之后调用的方法</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;  //删除节点之后调用的方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">在get()方法中调用afterNodeAccess()方法，具体作用是：在对节点进行访问之后，会更新链表，将节点移动到链表的尾部，表示最近被访问过。</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = null;</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a;</span><br><span class="line">        else</span><br><span class="line">            b.after = a;</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b;</span><br><span class="line">        else</span><br><span class="line">            last = b;</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap的put()是调用的父类HashMap的put()方法</span><br><span class="line">这个方法是在HashMap中的put()方法中被调用，在LinkedHashMap中被实现，具体作用是：在插入新节点后，因为缓存不够，需要删除最近最少使用的节点。要成功调用这个方法，还需要用户覆写 removeEldestEntry(first) 方法</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当LinkedHashMap成功调用removeNode()方法，删除节点之后，会调用本方法</span><br><span class="line">具体作用是：在removeNode方法中，只是删除了HashMap中的节点，并没有在链表中删除。所以在removeNode中，回调了这个方法，将该节点从链表中删除（这里是删除的头结点，因为头结点是最早进入或者最近最久未使用的）。</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = null;</span><br><span class="line">    if (b == null)</span><br><span class="line">        head = a;</span><br><span class="line">    else</span><br><span class="line">        b.after = a;</span><br><span class="line">    if (a == null)</span><br><span class="line">        tail = b;</span><br><span class="line">    else</span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190413205151890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5tZW5neXVhbkNTRE4=,size_16,color_FFFFFF,t_70" alt="左HashMap右LinkedHashMap"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> LinkedHashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LinkedHashMap </tag>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive源码解析</title>
      <link href="/2020/07/08/Hive-5/"/>
      <url>/2020/07/08/Hive-5/</url>
      
        <content type="html"><![CDATA[<h2 id="Hive源码解析"><a href="#Hive源码解析" class="headerlink" title="Hive源码解析"></a>Hive源码解析</h2><p>入口：hive-cli-1.1.0-cdh5.14.4.jar!/org/apache/hadoop/hive/cli/CliDriver.class</p><p><a href="https://blog.csdn.net/zyzzxycj/article/details/102861166" target="_blank" rel="noopener">参考文档</a></p><h3 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h3><p>命令行输入 hive 后，启动log进程，建立一个客户端Session，获取到服务器的hive conf配置文件，启动客户端</p><p>启动后 executeDriver(CliSessionState ss, HiveConf conf, OptionsProcessor oproc) 一直监听输入的 line; line 会按照 ; 来进行分割拼接成 command，对每一个 command 依次进行处理。command 一共分四种情况：① quit\exit ② source FilePath 指定执行某个文件里的语句 ③ 以 ! 开头的 shell 命令 ④ 本地客户端的各种命令(processLocalCmd(String cmd, CommandProcessor proc, CliSessionState ss))</p><p>通过读取 conf 配置，拿到 Driver 信息，然后交给对应的 Driver 来执行命令：org.apache.hadoop.hive.ql.Driver.compile(String command, boolean resetTaskIds, boolean deferClose)</p><h3 id="2-解析命令"><a href="#2-解析命令" class="headerlink" title="2. 解析命令"></a>2. 解析命令</h3><p><img src="https://img-blog.csdnimg.cn/20191205170415800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5enp4eWNq,size_46,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20191217165145562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5enp4eWNq,size_46,color_FFFFFF,t_70" alt></p><p>在 Driver 拿到命令后，<code>runInternal(command, alreadyCompiled);</code> 判断是否已经编译过，如果没有的话，首先要进行语法解析，通过 org.apache.hadoop.hive.ql.parse.parseDriver.parse(String command, Context ctx) 生成 AST(AbstractSyntaxTree) 抽象语法树</p><pre><code>在 parse 目录下存放5个文件- HiveLexer.g ：定义Hive关键字，及组成词组的合法字符    定义的规则如下：    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KW_SELECT : &apos;SELECT&apos;;</span><br><span class="line">KW_WHERE : &apos;WHERE&apos;;</span><br><span class="line">KW_FROM : &apos;FROM&apos;;</span><br><span class="line">fragment</span><br><span class="line">Letter</span><br><span class="line">    : &apos;a&apos;..&apos;z&apos; | &apos;A&apos;..&apos;Z&apos;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>- SelectClauseParser.g ：定义select语句的语法规则- FromClauseParser.g ：定义from语句的语法规则- IdentifiersParser.g ：定义函数、group等的语法规则- HiveParser.g：定义语法规则文件，引入了其他语法规则文件</code></pre><p>BaseSemanticAnalyzer sem = SemanticAnalyzerFactory.get(this.conf, tree); 对拿到的AST进行解析<br>this.schema = getSchema(sem, this.conf); 返回Hive表的字段信息<br>this.plan = new QueryPlan(queryStr, sem, perfLogger.getStartTime(“Driver.run”), queryId, SessionState.get().getHiveOperation(), this.schema, this.queryDisplay); 生成执行计划<br>this.plan.getFetchTask().initialize(this.conf, this.plan, (DriverContext)null); 对执行计划中拉取数据的任务进行初始化</p><p>针对 QueryPlan，调用 Driver.exexute() 执行job</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String queryId = this.conf.getVar(ConfVars.HIVEQUERYID);</span><br><span class="line">String queryStr = HiveConf.getVar(this.conf, ConfVars.HIVEQUERYSTRING);</span><br></pre></td></tr></table></figure><h3 id="3-Hive-可使用的函数"><a href="#3-Hive-可使用的函数" class="headerlink" title="3. Hive 可使用的函数"></a>3. Hive 可使用的函数</h3><p>hive-exec 包下  org.apache.hadoop.hive.ql.exec.FunctionRegistry.java</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解</title>
      <link href="/2020/06/18/Spring/"/>
      <url>/2020/06/18/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h3 id="1-组件类注解"><a href="#1-组件类注解" class="headerlink" title="1. 组件类注解"></a>1. 组件类注解</h3><ul><li>@Component ：标准一个普通的spring Bean类</li><li>@Repository：标注一个数据访问层DAO组件类</li><li>@Service：标注一个业务逻辑组件类</li><li>@Controller：标注一个控制器（用于和前端交互）组件类</li></ul><p>这些都是注解在平时的开发过程中出镜率极高，@Component、@Repository、@Service、@Controller实质上属于同一类注解，都在 org.springframework.stereotype 包下，用法相同，功能相同，区别在于标识组件的类型。@Component可以代替@Repository、@Service、@Controller，因为这三个注解是被@Component标注的。如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Component</span><br><span class="line">public @interface Controller &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-装配bean时常用的注解"><a href="#2-装配bean时常用的注解" class="headerlink" title="2. 装配bean时常用的注解"></a>2. 装配bean时常用的注解</h3><ul><li>@Autowired：属于Spring 的org.springframework.beans.factory.annotation包下,可用于为类的属性、构造器、方法进行注值。默认情况下，其依赖的对象必须存在（Bean可用），如果要改变这种默认方式，可以设置其 required 属性为 false</li><li>@PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, </span><br><span class="line">ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Autowired &#123;</span><br><span class="line">    boolean required() default true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HappyController &#123;</span><br><span class="line">@Autowired //默认依赖的ClubDao 对象（Bean）必须存在</span><br><span class="line">//@Autowired(required = false) 改变默认方式</span><br><span class="line">@Qualifier(&quot;goodClubService&quot;)</span><br><span class="line">    private ClubService clubService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired 注解默认按照类型装配，如果容器中包含多个同一类型的Bean，那么启动容器时会报找不到指定类型bean的异常，解决办法是结合 <strong>@Qualifier</strong> 注解进行限定，指定注入的bean名称。</p><h3 id="3-Component-vs-Configuration-and-Bean"><a href="#3-Component-vs-Configuration-and-Bean" class="headerlink" title="3. @Component vs @Configuration and @Bean"></a>3. @Component vs @Configuration and @Bean</h3><p>@Component可以替代 @Configuration注解，但是依旧有区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Component  //看这里！！！</span><br><span class="line">public @interface Configuration &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br></pre></td></tr></table></figure><p>Bean注解主要用于方法上，有点类似于工厂方法，当使用了@Bean注解，我们可以连续使用多种定义bean时用到的注解，譬如用@Qualifier注解定义工厂方法的名称，用@Scope注解定义该bean的作用域范围，譬如是singleton还是prototype等</p><p>Spring 中新的 Java 配置支持的核心就是@Configuration 注解的类。这些类主要包括 @Bean 注解的方法来为 Spring 的 IoC 容器管理的对象定义实例，配置和初始化逻辑。</p><p>使用@Configuration 来注解类表示类可以被 Spring 的 IoC 容器所使用，作为 bean 定义的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MyService myService() &#123;</span><br><span class="line">        return new MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans" target="_blank" rel="noopener">Spring IoC</a></p><h3 id="4-web模块常用到的注解"><a href="#4-web模块常用到的注解" class="headerlink" title="4. web模块常用到的注解"></a>4. web模块常用到的注解</h3><ul><li><p>@Controller ：表明该类会作为与前端作交互的控制层组件，通过服务接口定义的提供访问应用程序的一种行为，解释用户的输入，将其转换成一个模型然后将试图呈献给用户。</p><ul><li><p>@RequestMapping ： 这个注解用于将url映射到整个处理类或者特定的处理请求的方法。可以只用通配符！</p><ul><li>既可以作用在类级别，也可以作用在方法级别。当它定义在类级别时，标明该控制器处理所有的请求都被映射到 /xxx 路径下；定义在方法类型下，可以指定接收的方法类型，@RequestMapping(value=”/haha”,method=RequestMethod.GET)</li></ul></li><li><p>@RequestParam ：将请求的参数绑定到方法中的参数上，有required参数，默认情况下，required=true，也就是改参数必须要传。如果改参数可以传可不传，可以配置required=false</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String sayHappy(</span><br><span class="line">@RequestParam(value = &quot;name&quot;, required = false) String name,</span><br><span class="line">@RequestParam(value = &quot;age&quot;, required = true) String age) &#123;</span><br><span class="line">//age参数必须传 ，name可传可不传</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@PathVariable ： 该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定）。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/happy/&#123;dayid&#125;&quot;,method=RequestMethod.GET)</span><br><span class="line">public String findPet(@PathVariable String dayid, Model mode) &#123;</span><br><span class="line">//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@RequestBody ： @RequestBody是指方法参数应该被绑定到HTTP请求Body上。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)</span><br><span class="line">public void handle(@RequestBody String body，@RequestBody User user)&#123;</span><br><span class="line">//可以绑定自定义的对象类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ResponseBody ： @ResponseBody与@RequestBody类似，它的作用是将返回类型直接输入到HTTP response body中。@ResponseBody在输出JSON格式的数据时，会经常用到。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/happy&quot;, method =RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String helloWorld() &#123;    </span><br><span class="line">return &quot;Hello World&quot;;//返回String类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phoenix</title>
      <link href="/2020/06/16/Phoenix-1/"/>
      <url>/2020/06/16/Phoenix-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Phoenix"><a href="#Phoenix" class="headerlink" title="Phoenix"></a>Phoenix</h2><h3 id="1-phoenix-sqlline"><a href="#1-phoenix-sqlline" class="headerlink" title="1. phoenix-sqlline"></a>1. phoenix-sqlline</h3><p>退出 <code>!quit</code> <code>!exit</code><br>列出metadata信息 <code>!dbinfo</code><br>查看当前库中存在的表 <code>!tables</code><br>phoenix中的表信息都存在SYSTEM.CATALOG表中，也可以通过下面的sql语句查看系统的表信息 <code>select * from SYSTEM.CATALOG;</code></p><blockquote><p>主键信息保存在元数据表的 key_seq 列。可以通过 <code>!set maxWidth 10000</code> 来显示所有的列</p></blockquote><blockquote><p>如果不加双引号，会自动将小写转为大写<br>phoenix/hbase对表名、字段名都是大小写敏感，如果直接写小写字母，不加双引号，则默认会被转换成大写字母</p></blockquote><p>删除表 <code>drop table 库.表;</code><br>查看表结构 <code>!describe &quot;METRIC_AGGREGATE&quot;</code><br>创建表 <code>create table if not exists 库.表(id integer primary key,name varchar(20));</code><br>插入&amp;更新 <code>upsert into 库.表(id,name) values(1,&#39;zhangsan&#39;);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS TEST4PHOENIX.testdata (</span><br><span class="line">   tag_id char(10) NOT NULL,</span><br><span class="line">   user_id char(10) NOT NULL,</span><br><span class="line">   val char(10),</span><br><span class="line">   update_time char(30),</span><br><span class="line">   CONSTRAINT pk PRIMARY KEY (tag_id, user_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加字段 <code>alter table 库.表 add xxx 类型 (default 默认值);</code></p><p>修改字段信息 <code>upsert into SYSTEM.CATALOG (TENANT_ID,TABLE_SCHEM,TABLE_NAME,COLUMN_NAME,COLUMN_FAMILY,DATA_TYPE,COLUMN_SIZE) values(&#39;&#39;,&#39;库&#39;,&#39;表&#39;,&#39;字段&#39;,&#39;列族&#39;,12,15);</code> </p><blockquote><p>data_type 12 字符串 4 int -6 tinyint 修改为数值类型的时候就不需要column_size了<br>COLUMN_FAMILY 列族，有可能是空有可能是0，这个最好修改之前先查看一下元数据表，尤其是修改已存在的字段信息</p></blockquote><p>查看元数据表 <code>select COLUMN_FAMILY, TENANT_ID, COLUMN_NAME, DATA_TYPE, COLUMN_SIZE from SYSTEM.CATALOG where TABLE_SCHEM = &#39;库&#39; and TABLE_NAME = &#39;表&#39;;</code></p><p>设置字段默认值 <code>upsert into SYSTEM.CATALOG (TENANT_ID,TABLE_SCHEM,TABLE_NAME,COLUMN_NAME,COLUMN_FAMILY,COLUMN_DEF) values(&#39;&#39;,&#39;库&#39;,&#39;表&#39;,&#39;字段&#39;,&#39;&#39;,&#39;\&#39;xxx\&#39;&#39;);</code></p><blockquote><p>字段如果字符串类型，默认值应该填 ‘&#39;xxx&#39;‘，需要对’进行转义；如果是数值类型，可以直接写 ‘123’，默认值对应的是CATALOG表中的COLUMN_DEF字段<br>修改默认值有一个场景可以用，比如之前的主键做了修改，不想删表重建，那么就把之前的主键加默认值，这样sql里就不需要带着主键字段了<br>对元数据表的修改可能需要重启客户端甚至重启hbase才可以生效</p></blockquote><h3 id="2-预分区"><a href="#2-预分区" class="headerlink" title="2. 预分区"></a>2. 预分区</h3><p>HBase 默认分区规则<br>memstore.flush.size=128MB<br>max.store.size=10G</p><p>分区规则：Min(R^2 * “hbase.hregion.memstore.flush.size”, “hbase.hregion.max.filesize”)</p><p>第一次拆分大小为：min(10G，1<em>1</em>128M)=128M // 一开始的时候就一个region，当数据量达到128M时，会一分为二，变成2个region，然后会往第二个region里写数据，但是第一个不会写，处于半满状态 =&gt; 之前分裂的region都不会再被写入数据，处于半满状态<br>第二次拆分大小为：min(10G，3<em>3</em>128M)=1152M<br>第三次拆分大小为：min(10G，5<em>5</em>128M)=3200M<br>第四次拆分大小为：min(10G，7<em>7</em>128M)=6272M<br>第五次拆分大小为：min(10G，9<em>9</em>128M)=10G<br>第五次拆分大小为：min(10G，11<em>11</em>128M)=10G // 最大是10G</p><p>phoenix 自定义分区<br>如果指定了 SALT_BUCKETS=N，那么就会通过 hash(rowkey) % SALT_BUCKETS 划分成 N 个region。SALT_BUCKETS 取值为1到256。实现原理是会在row_key的byte数组的第一个字节位置设定一个系统生成的byte值，byte值 = hash(rowkey) % SALT_BUCKETS，这样就可以划分到不同region里。</p><p>如果指定了 SPLIT ON(“a”,”b”,”c”)，就会将rowkey划分到 空——a、a——b、b——c、c——无穷 这四个分区里。</p><p>如果同时指定了 SALT_BUCKETS=N 和 SPLIT ON(“a”,”b”,”c”)，会根据N拿到散列值，然后同散列值去SPLIT ON指定的分区规则里查询，放入到对应的分区里。</p><blockquote><p>SALT_BUCKETS + SPLIT ON 通过散列+分区的方式，在 RowKey 的前面拼接通过 hash 生成的随机字符串，可以生成范围比较随机的 RowKey，可以比较均衡分散到不同的 Region 中。<br>但是可能会存在极限情况：加盐产生的散列数，都集中到某几个分区中，导致热点问题，所以如果要用到 split_on，需要对主键对散列有一个很好的规划</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Phoenix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Phoenix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO相关使用</title>
      <link href="/2020/06/14/IO/"/>
      <url>/2020/06/14/IO/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-IO相关使用"><a href="#Java-IO相关使用" class="headerlink" title="Java IO相关使用"></a>Java IO相关使用</h2><h3 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h3><p>创建 File 对象的三种方式</p><ul><li>一个路径名：<code>File(String pathname)</code></li><li>一个父路径名和子路径名：<code>File(File parent, String child)</code> 或 <code>File(String parent, String child)</code></li><li>一个URI (统一资源标识符)：<code>File(URI uri)</code></li></ul><p>有文件时覆盖，无文件时创建。</p><p>通过 <code>f.getAbsolutePath()</code> 和 <code>f.getCanonicalPath()</code> 可获取文件的绝对路径和规范路径</p><p><code>f.delete()</code> 会立即删除文件，而 <code>f.deleteOnExit()</code> 会延迟删除，直到JVM调用该方法</p><p>File 对象不可变，始终表示文件的路径名。文件经过创建、删除后，File 对象依旧是原始的路径名，并不代表实际的文件。</p><h3 id="2-输入字节流"><a href="#2-输入字节流" class="headerlink" title="2. 输入字节流"></a>2. 输入字节流</h3><p><img src="http://img.blog.csdn.net/20160421004733383?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>抽象基类是 InputStream 类，结构关系如下：</p><p>InputStream<br>|+–FileInputStream<br>|+–ByteArrayInputStream<br>|+–PipedInputStream<br>|+–FilterInputStream<br>|+–BufferedInputStream<br>|+–PushbackInputStream<br>|+–DataInputStream<br>|+–ObjectInputStream</p><p>基类的基本方法如下：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">read()</td><td align="center">读取一个字节并将读取的字节作为int返回。当到达输入流的结尾时，它返回-1。</td></tr><tr><td align="center">read(byte[] buffer)</td><td align="center">读取最大值直到指定缓冲区的长度。它返回在缓冲区中读取的字节数。如果到达输入流的结尾，则返回-1。</td></tr><tr><td align="center">read(byte[] buffer,int offset, int length)</td><td align="center">读取最大值到指定长度字节。数据从偏移索引开始写入缓冲区。它返回读取的字节数，如果到达输入流的结束它返回-1。</td></tr><tr><td align="center">close()</td><td align="center">关闭输入流</td></tr><tr><td align="center">available()</td><td align="center">返回可以从此输入流读取但不阻塞的估计字节数。</td></tr></tbody></table><h4 id="2-1-BufferedInputStream"><a href="#2-1-BufferedInputStream" class="headerlink" title="2.1 BufferedInputStream"></a>2.1 BufferedInputStream</h4><p>通过缓冲数据向输入流添加功能。维护一个内部缓冲区以存储从底层输入流读取的字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    String filePath = &quot;/Users/mxxct/Desktop/md_meter.java&quot;;</span><br><span class="line">    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath));</span><br><span class="line">    byte[] buffer = new byte[1024]; // 长度为1024个字节的缓冲区</span><br><span class="line">    int len = -1; // 偏移量，或本次读取的字节数</span><br><span class="line">    StringBuilder content = null;</span><br><span class="line">    // 此次读取的字节数赋值给 len，如果等于 -1 说明已经读完了</span><br><span class="line">    while((len = bis.read(buffer)) != -1)&#123;</span><br><span class="line">        content.append(new String(buffer, 0, len));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">    bis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-输出字节流"><a href="#3-输出字节流" class="headerlink" title="3. 输出字节流"></a>3. 输出字节流</h3><p><img src="http://img.blog.csdn.net/20160421004936555?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p><code>FileOutputStream fos   = new FileOutputStream(destFile);</code> 创建一个 FileOutputStream 对象，如果文件不存在，会尝试创建文件，但必须处理异常 FileNotFoundException，需要放在 try-catch 里面。</p><p>如果文件包含数据，数据会被覆盖。如果要追加，需要添加一个第二个参数，true 表示追加。</p><p>fos.write(int b)<br>fos.write(byte[] b)<br>fos.write(byte[] b, int off, int len)<br>由于输出的是字节流，所以只能 write int 或 byte[]，如果是字符串的话，通过 getBytes() 方法可以返回字节数组</p><p>通过 fos.flush() 方法刷新输出流：将 write 里的字节缓存清出，写入到目标处。</p><h3 id="4-管道"><a href="#4-管道" class="headerlink" title="4. 管道"></a>4. 管道</h3><p>管道IO基于生产者–消费者模式，<code>PipedOutputStream</code> 负责把数据写入到管道里，相当于生产者， <code>PipedInputStream</code> 负责读取管道里的数据</p><p>两种连接管道的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PipedInputStream pis  = new PipedInputStream(); </span><br><span class="line">PipedOutputStream pos  = new PipedOutputStream(); </span><br><span class="line">pis.connect(pos); /* Connect  the   two  ends */</span><br><span class="line"></span><br><span class="line">PipedInputStream pis  = new PipedInputStream(); </span><br><span class="line">PipedOutputStream pos  = new PipedOutputStream(pis, 2048); // 缓冲区容量为2048字节</span><br><span class="line">当创建管道时，可以设置管道容量。 如果管道的缓冲区已满，则尝试在管道上写入将会被阻止。</span><br></pre></td></tr></table></figure><h3 id="5-字符输入流"><a href="#5-字符输入流" class="headerlink" title="5. 字符输入流"></a>5. 字符输入流</h3><p><img src="http://img.blog.csdn.net/20160421005211916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>Reader是所有的输入字符流的父类，它是一个抽象类<br>FilterReader是所有自定义具体装饰流的父类，其子类PushbackReader对Reader对象进行装饰，会增加一个行号<br>InputStreamReader是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream转变为Reader的方法。我们可以从这个类中得到一定的技巧。Reader中各个类的用途和使用方法基本和InputStream中的类使用一致。后面会有Reader与InputStream的对应关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = new BufferedReader(new FileReader(filePath));</span><br><span class="line">String str;</span><br><span class="line">while((str=reader.readLine())!=null)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-字符输出流"><a href="#6-字符输出流" class="headerlink" title="6. 字符输出流"></a>6. 字符输出流</h3><p><img src="http://img.blog.csdn.net/20160421005336445?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>问：字节流与字符流有什么区别？<br>答：计算机中的一切最终都是以二进制字节形式存在的，对于我们经常操作的字符串，在写入时其实都是先将字符转成对应的字节，然后将字节写入到输出流，在读取时其实都是先读到的是字节，然后将字节直接使用或者转换为字符给我们使用。由于对于字节和字符两种操作的需求比较广泛，所以 Java 专门提供了字符流与字节流相关IO类。</p><p>对于程序运行的底层设备来说永远都只接受字节数据，所以当我们往设备写数据时无论是字节还是字符最终都是写的字节流。字符流是字节流的包装类，所以当我们将字符流向字节流转换时要注意编码问题（因为字符串转成字节数组的实质是转成该字符串的某种字节编码）。</p><p>字符流和字节流的使用非常相似，但是实际上字节流的操作不会经过缓冲区（内存）而是直接操作文本本身的，而字符流的操作会先经过缓冲区（内存）然后通过缓冲区再操作文件。</p><p>1、字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的</p><p>2、字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容</p><p>3、Reader类的read()方法返回类型为int ：作为整数读取的字符（占两个字节共16位），范围在 0 到 65535 之间 (0x00-0xffff)，如果已到达流的末尾，则返回 -1<br>inputStream的read()虽然也返回int，但由于此类是面向字节流的，一个字节占8个位，所以返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。因此对于不能用0-255来表示的值就得用字符流来读取！比如说汉字.</p><p>4、字节流与字符流主要的区别是他们的的处理方式</p><p>字节流：处理字节和字节数组或二进制对象；</p><p>字符流：处理字符、字符数组或字符串。</p><p>问：什么是缓冲区？有什么作用？</p><p>答：缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性能。<br>对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作。</p><p>问：如何选择字节流和字符流？<br>答：如果是文本文件通常使用字符流，而像视频，图片，音频等文件都是二进制数据使用字节流。当然文本文件也可以使用字节流来操作，字节流更通用。</p><p>如果只是复制纯文本文件不做显示操作，哪个流都可以，如果要显示纯文本就用字符流。</p><p>问：为什么对于字符流中都有flush方法，但是字节流中没有？<br>字节流的操作不会经过缓冲区（内存）而是直接操作文本本身的，而字符流的操作会先经过缓冲区（内存）然后通过缓冲区再操作文件。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqoop源码解析</title>
      <link href="/2020/05/31/Sqoop/"/>
      <url>/2020/05/31/Sqoop/</url>
      
        <content type="html"><![CDATA[<h2 id="Sqoop源码解析"><a href="#Sqoop源码解析" class="headerlink" title="Sqoop源码解析"></a>Sqoop源码解析</h2><p>org.apache.sqoop 文件夹</p><blockquote><p>参考文档：</p><ol><li><a href="https://blog.csdn.net/omadesala/article/details/48368163" target="_blank" rel="noopener">https://blog.csdn.net/omadesala/article/details/48368163</a></li></ol></blockquote><h3 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h3><ul><li>Sqoop 类下的 main() 方法: 如果没有参数，返回 “sqoop help’ for usage.” 并终止。如果有参数，调用 runTool(args, new Configuration())<ul><li>runTool(args, new Configuration()): 主要任务是负责解析参数<ul><li>尝试调用 OptionsFileUtil 类下的 expandArguments(String[] args) 方法<ul><li>expandedArgs = OptionsFileUtil.expandArguments(args); 遍历所有参数，如果有 “–options-file” 这个参数，就打开指定的脚本文件（保存要执行语句的参数和值），先过滤掉 # 开头的注释部分，然后判断 \ 结尾、’ 、 “ 开头，依次过滤掉这些情况，将最后的参数加入 options[] 中；否则就将参数直接添加到 options[] 中。最终返回结果为 (String[])options.toArray(new String[options.size()]) 。</li></ul></li></ul></li><li>expandArguments() 返回的结果保存在 expandedArgs[] 中，String toolName = expandedArgs[0] 第一个位置的参数就是 sqoop 语句要使用的功能（export，import等）</li><li>通过 Configuration pluginConf = SqoopTool.loadPlugins(conf); 返回 sqoop 所有 tool 以及对应的配置信息。</li><li>调用 SqoopTool 类下的 getTool(String toolName) 方法，会从 Map&lt;String, Class&lt;? extends SqoopTool&gt;&gt; TOOLS 这个里面来读取具体使用的 tool 的类信息，创建一个实例，返回一个 SqoopTool</li><li>调用 runSqoop(sqoop, (String[])Arrays.copyOfRange(expandedArgs, 1, expandedArgs.length)); sqoop 是传入 tool 和 pluginConf 创建的一个 Sqoop 实例；将 tool 之后的所有参数传递出去。 eg: sqoop export –connect … expandedArgs=[“export”,”–connect”,…] export 就是 tool</li><li>调用 ToolRunner.run(sqoop.getConf(), sqoop, toolArgs); 方法执行。由于 Tool 是一个抽象类，run() 方法被 Sqoop 重写，所以最终调用的方法还是 Sqoop 类下的 run() 方法<ul><li>通过 Parser 类下的 parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) 方法对一些普遍的option进行解析，比如 <code>-fs &lt;local|namenode:port&gt;      specify a namenode</code> <code>-jt &lt;local|resourcemanager:port&gt;    specify a ResourceManager</code> <code>-D &lt;property=value&gt;            use value for given property</code> 等等</li></ul></li><li>调用 SqoopTool 类下的 parseArguments(String[] args, Configuration conf, SqoopOptions in, boolean useGenericOptions) 方法来解析参数。此时的 tool 指向的是具体的功能，import、export 等，调用的方法都在对应的类下: tool 包下有对应的所有的功能文件。在判断完参数是完整的情况下，最后执行的 run() 方法也是在对应功能文件下的 run() 方法。<br>— 以 ExportTool 为例，在执行 run() 方法时，会回调父类 BaseSqoopTool 类下的 init(SqoopOptions sqoopOpts) 方法，来生成一个 ConnManager 实例，用来管理连接信息。通过 this.codeGenerator.generateORM(options, tableName); 来将表结构对应的 java 类写入 jar 文件，这个 jar 文件和其他 options 会构造出一个 ExportJobContext 对象，根据 –update_mode 参数来决定更新方式<ul><li>通过调用 orm 包下的 ClassWriter 类的 ClassWriter(SqoopOptions opts, ConnManager connMgr, String table, CompilationManager compMgr) 方法，和 generate() 方法来生成一个 .java 文件，路径保存在 orm 包下的 CompilationManager 类的对象中，再经过 compile() 和 jar() 方法来打包生成 表名.jar 文件。</li><li>在 SqoopOptions 类下会保存目标表的所有字段，针对字段会做一个过滤，是否等于 java 保留关键字，如果等于就用在前面加一个 _。</li></ul></li><li>数据库的连接方法基类抽象类在 manager 包下的 ConnManager 文件里，主要包括 1.MainFrameManager——连接主机 2.SqlManager——连接各种支持JDBC连接的数据库<br>Sqlmanager 类下在获取到参数后，会先尝试连接一下数据库，执行一个 select t.* from XX as t limit 1 的语句</li><li>mysql 和 hadoop 连接的时候使用的是 SqlManager 类，如果是 import 调用的是 importTable 方法，如果是 export 调用的是 exportTable 方法。根据生成的 ExportJobContext 上下文实例，执行 runExport() 方法，调用的是 mapreduce 包下的 ExportJobBase 类的方法。</li><li>配置好 job 相关信息，执行 runJob(job) 方法。<ul><li>在 hive export to mysql 时，如果字段还有特殊字符，可能会出现因为切分数据而导致数据错位导致推数失败的情况。如果要对 hive 表中的数据进行处理的话，需要在 mapreduce 包下找到对应的 mapper 类（根据 hive 表类型划分为 TextExportMapper、ParquetMapper、SequenceFileMapper 等）</li></ul></li><li>具体解析参数是在 SqoopParser 类下的 processArgs(Option opt, ListIterator iter) 方法</li></ul></li></ul><p>sqoopTool：sqoop具体的工具类</p><p>Hive 用增量<br>采集、建模需要固定的时间段，昨天9点到今天9点，限制住时间，或者要先获取到上次执行时间，再算上这次的执行时间。建模无法获取上次的执行时间，如果固定时间间隔，如果报错后续处理，比如垮天了，或者白天执行作业的时候就会很麻烦。<br>Hive不支持删除数据，对于不要的数据只能全量执行，不管是采集还是建模。<br>如果业务那边有一个base_table，每天的一个增量表，可以做成拉链表。燃气设备是做成了拉链表，是在源头做的，不是在hive</p><p>kpi 是增量插入一天一条，但是如果存在回补历史数据或者修正历史数据，比如某一天的数据就很麻烦</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Sqoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Sqoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive 建模</title>
      <link href="/2020/05/24/Hive-6/"/>
      <url>/2020/05/24/Hive-6/</url>
      
        <content type="html"><![CDATA[<h2 id="Hive-建模"><a href="#Hive-建模" class="headerlink" title="Hive 建模"></a>Hive 建模</h2><h3 id="1-存储格式"><a href="#1-存储格式" class="headerlink" title="1. 存储格式"></a>1. 存储格式</h3><ul><li>textFile</li><li>sequenceFile：一种Hadoop API提供的二进制文件，使用方便、可分割、可压缩。将数据以&lt;key,value&gt;的形式序列化到文件中。序列化和反序列化使用Hadoop 的标准的Writable 接口实现。key为空，用value 存放实际的值， 这样可以避免map 阶段的排序过程。</li><li>rcFile：一种行列存储相结合的存储方式。首先，其将数据按行分块，保证同一个record在一个块上，避免读一个记录需要读取多个block。其次，块数据列式存储，有利于数据压缩和快速的列存取。但是不好用。</li><li>orc：ecFile升级版。常用于Hive、Presto。</li><li>parquet：Parquet和ORC都以列的形式存储数据。面向列的数据存储针对读取繁重的分析工作负载进行了优化。常用于Impala、Drill、Spark、Arrow。</li><li>avro：基于行的格式存储数据。基于行的数据库最适合于大量写入的事务性工作负载。常用于Kafka、Druid。</li></ul><p>数据压缩比例上ORC最优，相比textfile节省了50倍磁盘空间，parquet压缩性能也较好<br>SQL查询速度而言，ORC与parquet性能较好，远超其余存储格式</p><h3 id="2-表的类型"><a href="#2-表的类型" class="headerlink" title="2. 表的类型"></a>2. 表的类型</h3><ul><li>全量表：保存用户所有的数据（包括新增与历史数据）</li><li>增量表：只保留当前新增的数据</li><li>快照表：按日分区，记录截止数据日期的全量数据</li><li>切片表：切片表根据基础表，往往只反映某一个维度的相应数据。其表结构与基础表结构相同，但数据往往只有某一维度，或者某一个事实条件的数据</li><li>拉链表：记录一个事物从开始，一直到当前状态的所有变化的信息</li></ul><h3 id="3-数据仓库、数据建模"><a href="#3-数据仓库、数据建模" class="headerlink" title="3. 数据仓库、数据建模"></a>3. 数据仓库、数据建模</h3><h4 id="3-1-数据仓库目标"><a href="#3-1-数据仓库目标" class="headerlink" title="3.1 数据仓库目标"></a>3.1 数据仓库目标</h4><ol><li>访问性能：能够快速查询所需的数据，减少数据I/O。</li><li>数据成本：减少不必要的数据冗余，实现计算结果数据复用，降低大数据系统中的存储成本和计算成本。</li><li>使用效率：改善用户应用体验，提高使用数据的效率。</li><li>数据质量：改善数据统计口径的不一致性，减少数据计算错误的可能性，提供高质量的、一致的数据访问平台。</li></ol><p>比如hive的优点：</p><ul><li>容量大 hdfs</li><li>运算能力强 mapreduce</li></ul><h4 id="3-2-建模方式"><a href="#3-2-建模方式" class="headerlink" title="3.2 建模方式"></a>3.2 建模方式</h4><h5 id="3-2-1-ER实体模型"><a href="#3-2-1-ER实体模型" class="headerlink" title="3.2.1 ER实体模型"></a>3.2.1 ER实体模型</h5><p>实体Entity（矩形）、属性Property（椭圆形）、关系Relationship（菱形）</p><h5 id="3-2-2-维度建模"><a href="#3-2-2-维度建模" class="headerlink" title="3.2.2 维度建模"></a>3.2.2 维度建模</h5><p><a href="https://www.cnblogs.com/muchen/p/5310732.html" target="_blank" rel="noopener">参考地址</a></p><p>维度建模源自数据集市，主要面向分析场景。Ralph Kimball推崇数据集市的集合为数据仓库，同时也提出了对数据集市的维度建模，将数据仓库中的表划分为事实表、维度表两种类型</p><ol><li>事实表</li></ol><p>在ER模型中抽象出了有实体、关系、属性三种类别，在现实世界中，每一个操作型事件，基本都是发生在实体之间的，伴随着这种操作事件的发生，会产生可度量的值，而这个过程就产生了一个事实表，存储了每一个可度量的事件。通常是数值类型，且记录数会不断增加，表规模迅速增长。</p><blockquote><p>业务里每一个提交的表单都可以作为一个事实表（一次业务处理流程），表单相关的一些信息作为维度表</p></blockquote><ol start="2"><li>维度表</li></ol><p>维度表一般为单一主键，在ER模型中，实体为客观存在的事务，会带有自己的描述性属性，属性一般为文本性、描述性的，这些描述被称为维度。</p><p>比如商品，单一主键：商品ID，属性包括产地、颜色、材质、尺寸、单价等，但并非属性一定是文本，比如单价、尺寸，均为数值型描述性的，日常主要的维度抽象包括：时间维度表、地理区域维度表等。</p><p>维度建模通常又分为星型模型和雪花模型。</p><p>星型模型：<br><img src="https://images2015.cnblogs.com/blog/903014/201603/903014-20160324180338683-1916113766.jpg" alt="星型模型"></p><p>可以看出，星形模式的维度建模由一个事实表和一组维表成，且具有以下特点：</p><p>a. 维表只和事实表关联，维表之间没有关联；<br>b. 每个维表的主码为单列，且该主码放置在事实表中，作为两边连接的外码；<br>c. 以事实表为核心，维表围绕核心呈星形分布；</p><p>雪花模型：<br><img src="https://images2015.cnblogs.com/blog/903014/201603/903014-20160324180236104-1134926519.jpg" alt="雪花模型"></p><p>星型模型和雪花模型的主要区别在于对维度表的拆分，对于雪花模型，维度表的设计更加规范，一般符合3NF；而星型模型，一般采用降维的操作，利用冗余来避免模型过于复杂，提高易用性和分析效率。</p><blockquote><p>然而这种模式在实际应用中很少见，因为这样做会导致开发难度增大</p></blockquote><p>雪花、星型模型对比：</p><p>1、冗余：雪花模型符合业务逻辑设计，采用3NF设计，有效降低数据冗余；星型模型的维度表设计不符合3NF，反规范化，维度表之间不会直接相关，牺牲部分存储空间。</p><p>2、性能：雪花模型由于存在维度间的关联，采用3NF降低冗余，通常在使用过程中，需要连接更多的维度表，导致性能偏低；星型模型反三范式，采用降维的操作将维度整合，以存储空间为代价有效降低维度表连接数，性能较雪花模型高。</p><p>3、ETL：雪花模型符合业务ER模型设计原则，在ETL过程中相对简单，但是由于附属模型的限制，ETL任务并行化较低；星型模型在设计维度表时反范式设计，所以在ETL过程中整合业务数据到维度表有一定难度，但由于避免附属维度，可并行化处理。</p><p>大数据和传统关系型数据库的计算框架不一样，例如对比mapreduce和oracle，在mapreduce里面，每多一个表的关联，就多一个job。mapreduce的每个任务进来，要申请资源，分配容器，各节点通信等。有可能YARN调度时长大于任务运行时间，例如调度需要5秒才能申请到资源，而表之间的join只需要2秒。hive优化里面，要尽可能减少job任务数，也就是减少表之间的关联，可以用适当的冗余来避免低效的查询方式，这是和oracle等其他关系型数据库不同的地方。</p><p>星座模型（星行模型的拓展）：</p><p><img src="https://images2015.cnblogs.com/blog/903014/201603/903014-20160324175828948-2089267269.jpg" alt></p><p>前面介绍的两种维度建模方法都是多维表对应单事实表，但在很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到。在业务发展后期，绝大部分维度建模都采用的是星座模式。</p><h5 id="3-2-3-Data-Vault模型"><a href="#3-2-3-Data-Vault模型" class="headerlink" title="3.2.3 Data Vault模型"></a>3.2.3 Data Vault模型</h5><h5 id="3-2-4-Anchor"><a href="#3-2-4-Anchor" class="headerlink" title="3.2.4 Anchor"></a>3.2.4 Anchor</h5>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark</title>
      <link href="/2020/04/23/Spark/"/>
      <url>/2020/04/23/Spark/</url>
      
        <content type="html"><![CDATA[<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>VM options: -Dspark.master=local 还可以是 cluster，local[*], Standalone(只支持简单的固定资源分配策略)</p><p>Spark Streaming 用来获取不同的源数据流DStream，为了初始化Spark Streaming就需要先创建一个StreamingContext对象，一个StreamingContext对象可以用SparkConf对象创建。</p><p>流程：</p><p>createStreamingContext() 通过sparkConf来<br>    createKafkaStream() 先先从zk拿到topic的分区情况，再从zk拿到每个分区的offset，从kafka创建一个DStream返回一个rdds<br>        process() 操作rdds</p><p>两种方式创建StreamingContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf().setAppName(appName).setMaster(master);</span><br><span class="line">val ssc = new StreamingContext(conf, Seconds(1)); // 第二个参数是spark从kafka每隔多少秒一个批次</span><br><span class="line"></span><br><span class="line">StreamingContext，还可以使用已有的SparkContext来创建</span><br><span class="line">val sc = new SparkContext(conf)</span><br><span class="line">val ssc = new StreamingContext(sc, Seconds(1));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dstream.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">    rdd.foreach(record =&gt; &#123;</span><br><span class="line">        val connection = createNewConnection()</span><br><span class="line">        connection.send(record)</span><br><span class="line">        connection.close()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">上面的方法也可以实现读取数据，但是为每个记录创建和销毁连接对象会导致非常高的开支。</span><br><span class="line"></span><br><span class="line">下面的方法将连接对象的创建开销分摊到了partition的所有记录上，并且池中的连接对象应该根据需要延迟创建，并且在空闲一段时间后自动超时</span><br><span class="line">dstream.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">    rdd.foreachPartition(partitionOfRecords =&gt; &#123;</span><br><span class="line">        // ConnectionPool is a static, lazily initialized pool of connections</span><br><span class="line">        val connection = ConnectionPool.getConnection()</span><br><span class="line">        partitionOfRecords.foreach(record =&gt; connection.send(record))</span><br><span class="line">        ConnectionPool.returnConnection(connection)  // return to the pool for future reuse</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>内存调优：减少Spark Streaming应用程序垃圾回收的相关暂停，获得更稳定的批处理时间。</p><ul><li>默认的持久化级别是序列化数据到内存中，默认的持久化级别是序列化数据到内存中</li><li>spark.streaming.unpersist = true 使系统找出那些不需要经常保有的RDD，然后去持久化它们。这可以减少Spark RDD的内存使用，也可能改善垃圾回收的行为。</li><li>Concurrent garbage collector：使用并发的标记-清除垃圾回收可以进一步减少垃圾回收的暂停时间。尽管并发的垃圾回收会减少系统的整体吞吐量，但是仍然推荐使用它以获得更稳定的批处理时间。</li></ul><ol><li>RDD 弹性分布式数据集 (Resilient Distributed DataSet)</li></ol><p>特性：分区，不可变，并行操作</p><p>RDD 只是抽象意义的数据集合，分区内部并不会存储具体的数据，只会存储它在该 RDD 中的 index，通过该 RDD 的 ID 和分区的 index 可以唯一确定对应数据块的编号，然后通过底层存储层的接口提取到数据进行处理。</p><p>不可变性是指每个 RDD 都是只读的，它所包含的分区信息是不可变的。由于已有的 RDD 是不可变的，所以我们只有对现有的 RDD 进行转化 (Transformation) 操作，才能得到新的 RDD ，一步一步的计算出我们想要的结果。不需要立刻去存储计算出的数据本身，我们只要记录每个 RDD 是经过哪些转化操作得来的</p><p>因为有分区，所以不同节点上的数据可以分别被处理，然后生成一个新的 RDD</p><p><img src="https://upload-images.jianshu.io/upload_images/1503160-75ddac9bb2922589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="RDD结构"></p><p>a，Partitions<br>Partitions 就是上面所说的，代表着 RDD 中数据的逻辑结构，每个 Partion 会映射到某个节点内存或者硬盘的一个数据块。</p><p>b，SparkContext<br>SparkContext 是所有 Spark 功能的入口，代表了与 Spark 节点的连接，可以用来创建 RDD 对象以及在节点中的广播变量等等。一个线程只有一个 SparkContext。</p><p>c，SparkConf<br>SparkConf 是一些配置信息。</p><p>d，Partitioner<br>Partitioner 决定了 RDD 的分区方式，目前两种主流的分区方式：Hash partioner 和 Range partitioner。Hash 就是对数据的 Key 进行散列分布，Range 是按照 Key 的排序进行的分区。也可以自定义 Partitioner。</p><p>e，Dependencies<br>Dependencies 也就是依赖关系，记录了该 RDD 的计算过程，也就是说这个 RDD 是通过哪个 RDD 经过怎么样的转化操作得到的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@DeveloperApi</span><br><span class="line">abstract class Dependency[T] extends Serializable&#123;</span><br><span class="line">    def rdd: RDD[T]</span><br><span class="line">&#125;</span><br><span class="line">这是RDD指的是父RDD，所以依赖是对父RDD的包装，并且通过Dependency的类型说明当前这个transformation对应的数据处理方式。子类实现主要有两种：</span><br><span class="line"></span><br><span class="line">@DeveloperApi</span><br><span class="line">abstract class NarrowDependency[T](_rdd: RDD[T]) extends Dependency[T] &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Get the parent partitions for a child partition.</span><br><span class="line">   * @param partitionId a partition of the child RDD</span><br><span class="line">   * @return the partitions of the parent RDD that the child partition depends upon</span><br><span class="line">   */</span><br><span class="line">  def getParents(partitionId: Int): Seq[Int]</span><br><span class="line"></span><br><span class="line">  override def rdd: RDD[T] = _rdd</span><br><span class="line">&#125;</span><br><span class="line">窄依赖是抽象类，具体的实现类有2种</span><br><span class="line"></span><br><span class="line">子RDD和父RDD的Partition之间的关系是一对一</span><br><span class="line">@DeveloperApi</span><br><span class="line">class OneToOneDependency[T](rdd: RDD[T]) extends NarrowDependency[T](rdd) &#123;</span><br><span class="line">  override def getParents(partitionId: Int): List[Int] = List(partitionId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子RDD和父RDD的Partition之间的关系是一个区间内的1对1对应关系</span><br><span class="line">子的partitionID 3 4 5 6</span><br><span class="line">父的partitionID 8 9 10 11</span><br><span class="line">求子partitionID=5的父partitionID，5-3+8=10</span><br><span class="line">@DeveloperApi</span><br><span class="line">class RangeDependency[T](rdd: RDD[T], inStart: Int, outStart: Int, length: Int)</span><br><span class="line">  extends NarrowDependency[T](rdd) &#123;</span><br><span class="line"></span><br><span class="line">  override def getParents(partitionId: Int): List[Int] = &#123;</span><br><span class="line">    if (partitionId &gt;= outStart &amp;&amp; partitionId &lt; outStart + length) &#123;</span><br><span class="line">      List(partitionId - outStart + inStart)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Nil</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">宽依赖</span><br><span class="line">@DeveloperApi</span><br><span class="line">class ShuffleDependency[K: ClassTag, V: ClassTag, C: ClassTag](</span><br><span class="line">    @transient private val _rdd: RDD[_ &lt;: Product2[K, V]],</span><br><span class="line">    val partitioner: Partitioner,</span><br><span class="line">    val serializer: Serializer = SparkEnv.get.serializer,</span><br><span class="line">    val keyOrdering: Option[Ordering[K]] = None,</span><br><span class="line">    val aggregator: Option[Aggregator[K, V, C]] = None,</span><br><span class="line">    val mapSideCombine: Boolean = false)</span><br><span class="line">  extends Dependency[Product2[K, V]] &#123;</span><br><span class="line"></span><br><span class="line">  if (mapSideCombine) &#123;</span><br><span class="line">    require(aggregator.isDefined, &quot;Map-side combine without Aggregator specified!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  override def rdd: RDD[Product2[K, V]] = _rdd.asInstanceOf[RDD[Product2[K, V]]]</span><br><span class="line"></span><br><span class="line">  private[spark] val keyClassName: String = reflect.classTag[K].runtimeClass.getName</span><br><span class="line">  private[spark] val valueClassName: String = reflect.classTag[V].runtimeClass.getName</span><br><span class="line">  // Note: It&apos;s possible that the combiner class tag is null, if the combineByKey</span><br><span class="line">  // methods in PairRDDFunctions are used instead of combineByKeyWithClassTag.</span><br><span class="line">  private[spark] val combinerClassName: Option[String] =</span><br><span class="line">    Option(reflect.classTag[C]).map(_.runtimeClass.getName)</span><br><span class="line"></span><br><span class="line">  val shuffleId: Int = _rdd.context.newShuffleId()</span><br><span class="line"></span><br><span class="line">  val shuffleHandle: ShuffleHandle = _rdd.context.env.shuffleManager.registerShuffle(</span><br><span class="line">    shuffleId, _rdd.partitions.length, this)</span><br><span class="line"></span><br><span class="line">  _rdd.sparkContext.cleaner.foreach(_.registerShuffleForCleanup(this))</span><br><span class="line">&#125;</span><br><span class="line">因为shuffle设计到网络传输，所以要有序列化serializer，为了减少网络传输，可以加map端聚合，通过mapSideCombine和aggregator控制，还有key排序相关的keyOrdering，以及重输出的数据如何分区的partitioner。宽依赖(即shuffle操作)是stage划分的依据</span><br></pre></td></tr></table></figure><p>这里有个概念，根据每个 RDD 的分区计算后生成的新的 RDD 的分区的对应关系，可以分成窄依赖和宽依赖。</p><p>窄依赖就是父 RDD 的分区可以一一对应到子 RDD 的分区，宽依赖是说父 RDD 的每个分区可以被多个子 RDD 分区使用。如图：<br><img src="https://upload-images.jianshu.io/upload_images/1503160-0356b95069a88b37.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt></p><p>由于窄依赖的特性，窄依赖允许子 RDD 的每个分区可以被并行处理产生，而且支持在同一个节点上链式执行多条指令，无需等待其它父 RDD 的分区操作。</p><p><img src="https://upload-images.jianshu.io/upload_images/1503160-c8554d7f7f93885f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt><br>Spark 区分宽窄依赖的原因主要有两点：</p><p>窄依赖支持在同一节点上进行链式操作，比如在执行了 map 后，紧接着执行 filter 操作。相反，宽依赖需要所有父分区都是可用的，可能还需要调用类似 MapReduce 之类的操作进行跨节点传递。<br>从失败恢复的角度考虑，窄依赖失败恢复更有效，因为只要重新计算丢失的父分区即可，而宽依赖涉及到 RDD 的各级多个父分区。</p><p>f，Checkpoint<br>检查点机制，在计算过程中有一些比较耗时的 RDD，我们可以将它缓存到硬盘或者 HDFS 中，标记这个 RDD 有被检查点处理过，并且清空它的所有依赖关系。同时，给它新建一个依赖于 CheckpointRDD 的依赖关系，CheckpintRDD 可以用来从 硬盘中读取 RDD 和生成新的分区信息。</p><p>这么做之后，当某个 RDD 需要错误恢复时，回溯到该 RDD，发现它被检查点记录过，就可以直接去硬盘读取该 RDD，无需重新计算。</p><p>g，Preferred Location<br>针对每一个分片，都会选择一个最优的位置来计算，数据不动，代码动。</p><p>h，Storage Level<br>用来记录 RDD 持久化时存储的级别，常用的有：</p><p>MEMORY_ONLY：只存在缓存中，如果内存不够，则不缓存剩余的部分。这是 RDD 默认的存储级别。<br>MEMORY_AND_DISK：缓存在内存中，不够则缓存至内存。<br>DISK_ONLY：只存硬盘。<br>MEMORY_ONLY_2 和 MEMORY_AND_DISK_2等：与上面的级别和功能相同，只不过每个分区在集群两个节点上建立副本。<br>i，Iterator<br>迭代函数和计算函数是用来表示 RDD 怎样通过父 RDD 计算得到的。</p><p>迭代函数首先会判断缓存中是否有想要计算的 RDD，如果有就直接读取，如果没有就查找想要计算的 RDD 是否被检查点处理过。如果有，就直接读取，如果没有，就调用计算函数向上递归，查找父 RDD 进行计算。</p><ol start="2"><li>map 和 flatMap</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">都是对 rdd 中的每一个元素进行操作，原先也有几个元素，map就返回含有几个元素的rdd，flatMap = map + flattern 操作，先做map操作，如果元素中含有迭代器，那就把迭代器里的元素循环取出来</span><br><span class="line">val arr2 = sc.parallelize(Array(&quot;hello world&quot;, &quot;java&quot;))</span><br><span class="line">val t1 = arr2.flatMap(x=&gt;x.split(&quot; &quot;))</span><br><span class="line">t1.foreach(println)</span><br><span class="line">val t2 = arr2.map(x=&gt;x.split(&quot; &quot;))</span><br><span class="line">t2.foreach(x=&gt;&#123;</span><br><span class="line">    x.foreach(println)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>collect 和 filter</li></ol><p>var a = List(1, 2, 3, 4, 5)<br>a.collect({case i if i % 2 == 0 =&gt; i + 10})<br>a.filter(x=&gt;x%2==0) // filter 只是过滤元素，并不做元素上的改变</p><ol start="4"><li>offset</li></ol><p>一般都会 <code>enable.auto.commit = false</code> 禁止自动提交，自己来管理offset</p><ul><li>交给 zk 管理</li></ul><p>zkClientUrl 下 zkOffsetPath = “/kafka/consumers/“+ consumer_group_id + “/offsets/“ + topic + “/“ + partitionId 保存 offsetNum</p><ul><li>存储到hbase<br>行键 topic:customer_group_id:batch_milliSeconds 通过batch的时间戳可以更好的展示历史的每批次的offsets<br>列族 offsets<br>列 分区id<br>value 偏移量的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def saveOffsets(TOPIC_NAME:String,GROUP_ID:String,offsetRanges:Array[OffsetRange],</span><br><span class="line">                hbaseTableName:String,batchTime: org.apache.spark.streaming.Time) =&#123;</span><br><span class="line">  val hbaseConf = HBaseConfiguration.create()</span><br><span class="line">  hbaseConf.addResource(&quot;src/main/resources/hbase-site.xml&quot;)</span><br><span class="line">  val conn = ConnectionFactory.createConnection(hbaseConf)</span><br><span class="line">  val table = conn.getTable(TableName.valueOf(hbaseTableName))</span><br><span class="line">  val rowKey = TOPIC_NAME + &quot;:&quot; + GROUP_ID + &quot;:&quot; +String.valueOf(batchTime.milliseconds)</span><br><span class="line">  val put = new Put(rowKey.getBytes)</span><br><span class="line">  for(offset &lt;- offsetRanges)&#123;</span><br><span class="line">    put.addColumn(Bytes.toBytes(&quot;offsets&quot;),Bytes.toBytes(offset.partition.toString),</span><br><span class="line">          Bytes.toBytes(offset.untilOffset.toString))</span><br><span class="line">  &#125;</span><br><span class="line">  table.put(put)</span><br><span class="line">  conn.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>foreachRDD作用于DStream中每一个时间间隔的RDD<br>foreachPartition作用于每一个时间间隔的RDD中的每一个partition<br>foreach作用于每一个时间间隔的RDD中的每一个元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">从 foreachRDD 的源码上来看，并没有任何的Iterator，而 foreach 和 foreachPartition 都用到了迭代器，说明这两个是会遍历RDD的。</span><br><span class="line">private def foreachRDD(</span><br><span class="line">    foreachFunc: (RDD[T], Time) =&gt; Unit,</span><br><span class="line">    displayInnerRDDOps: Boolean): Unit = &#123;</span><br><span class="line">    new ForEachDStream(this,</span><br><span class="line">    context.sparkContext.clean(foreachFunc, false), displayInnerRDDOps).register()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def foreach(f: T =&gt; Unit): Unit = withScope &#123;</span><br><span class="line">  val cleanF = sc.clean(f)</span><br><span class="line">  sc.runJob(this, (iter: Iterator[T]) =&gt; iter.foreach(cleanF))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def foreachPartition(f: Iterator[T] =&gt; Unit): Unit = withScope &#123;</span><br><span class="line">  val cleanF = sc.clean(f)</span><br><span class="line">  sc.runJob(this, (iter: Iterator[T]) =&gt; cleanF(iter))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>DAG 有向无环图</li></ol><p>通过DAG来对RDD的关系进行建模，描述RDD之间的依赖关系，这个关系叫 lineage</p><table><thead><tr><th align="center">名词</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">Job</td><td align="center">调用RDD的一个action，如count，即触发一个Job，spark中对应实现为ActiveJob，DAGScheduler中使用集合activeJobs和jobIdToActiveJob维护Job</td></tr><tr><td align="center">Stage</td><td align="center">代表一个Job的DAG，会在发生shuffle处被切分，切分后每一个部分即为一个Stage，Stage实现分为ShuffleMapStage和ResultStage，一个Job切分的结果是0个或多个ShuffleMapStage加一个ResultStage</td></tr><tr><td align="center">Task</td><td align="center">最终被发送到Executor执行的任务，和stage的ShuffleMapStage和ResultStage对应，其实现分为ShuffleMapTask和ResultTask</td></tr></tbody></table><blockquote><p>mr 只有一个job，分为map和reduce两个阶段；spark每执行一次action算子就会产生一个job</p></blockquote><p><img src="https://img-blog.csdn.net/20170418145256538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTU2NDE3Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><blockquote><p>spark划分stage的整体思路是：从后往前推，遇到宽依赖就断开，划分为一个stage；遇到窄依赖就将这个RDD加入该stage中</p></blockquote><p>RDD RDD 是 Spark 的灵魂，也称为弹性分布式数据集。一个 RDD 代表一个可以被分区的只读数据集。RDD 内部可以有许多分区(partitions)，每个分区又拥有大量的记录(records)。</p><p>DAG Spark 中使用 DAG 对 RDD 的关系进行建模，描述了 RDD 的依赖关系，这种关系也被称之为 lineage（血缘），RDD 的依赖关系使用 Dependency 维护。</p><p>Stage 在 DAG 中又进行 Stage 的划分，划分的依据是依赖是否是 shuffle 的，每个 Stage 又可以划分成若干 Task。接下来的事情就是 Driver 发送 Task 到 Executor，Executor 线程池去执行这些 task，完成之后将结果返回给 Driver。</p><p>Job 每一次action动作都会产生一个job。</p><p>Task 一个 Stage 内，最终的 RDD 有多少个 partition，就会产生多少个 task。repartition 会减少小文件，减少 task 的个数，但是会增加 task 处理的数据量，可能会延长处理时间。</p><ol start="7"><li>算子</li></ol><ul><li><p>Value数据类型的Transformation算子，这种变换并不触发提交作业，针对处理的数据项是Value型的数据</p><ul><li><p>输入分区与输出分区一对一型</p><ul><li>map</li><li>flatMap<ul><li>map 操作后再把所有元素拍扁</li></ul></li><li>mapPartitions<ul><li>对每个分区里的所有数据进行批处理</li><li>如果有2个分区，每个分区2条数，通过map做批处理的话需要修改4次，使用mapPartitions其实只运算了2次</li><li><code>listRDD.mapPartitions(datas =&gt;{ datas.map(x =&gt; x * 2) })</code> datas 这里指的是 Scala 的 迭代器，对于里面的 *2 计算是scala的计算，不是spark的计算（spark的计算需要发送到Executor），所以相当于是向 N个 Executor（个数等于分区个数）直接发送了结果，不牵扯计算，提高了效率。但是因为是一次性发送最终的结果，有可能存在处理完后数据的容量大于 Executor 的最大容量，产生内存溢出OOM</li></ul></li><li>glom<ul><li>将同一个分区里的元素合并到一个array里</li></ul></li></ul></li><li><p>输入分区与输出分区多对一型</p><ul><li>union</li><li>cartesian<ul><li>笛卡尔</li></ul></li></ul></li><li><p>输入分区与输出分区多对多型</p><ul><li><p>groupBy</p><ul><li><p>生成相应的key，相同的放在一起</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        val a = sc.parallelize(1 to 9, 3)</span><br><span class="line">        a.groupBy(x =&gt; &#123; if (x % 2 == 0) &quot;even&quot; else &quot;odd&quot; &#125;).collect</span><br><span class="line">        res42: Array[(String, Seq[Int])] = Array((even,ArrayBuffer(2, 4, 6, 8)), (odd,ArrayBuffer(1, 3, 5, 7, 9)))</span><br><span class="line">        ``` </span><br><span class="line">        返回值是 [String, Seq] String 相当于一个序列的昵称</span><br><span class="line">- 输出分区为输入分区子集型</span><br><span class="line">    - filter</span><br><span class="line">    - distinct</span><br><span class="line">    - subtract</span><br><span class="line">        - 去掉含有重复的项</span><br><span class="line">        -</span><br></pre></td></tr></table></figure><p>val a = sc.parallelize(1 to 9, 3)<br>val b = sc.parallelize(1 to 3, 3)<br>val c = a.subtract(b)<br>c.collect<br>res3: Array[Int] = Array(6, 9, 4, 7, 5, 8)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- sample</span><br><span class="line">    - 随机抽样</span><br><span class="line">    -</span><br></pre></td></tr></table></figure><p>val a = sc.parallelize(1 to 10000, 3)<br>a.sample(false, 0.1, 0).count<br>res24: Long = 960</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    - takeSample</span><br><span class="line">- Cache型</span><br><span class="line">    - cache</span><br><span class="line">        - cache调用了persist()方法，无参，cache只有一个默认的缓存级别MEMORY_ONLY</span><br><span class="line">    - persist</span><br><span class="line">        - persist(StorageLevel)可以根据情况设置其它的缓存级别，比如缓存到硬盘disk_only，内存和硬盘都缓存memory_and_disk。每个StorageLevel都包含了五个参数</span><br></pre></td></tr></table></figure><p>  object StorageLevel {<br>  val NONE = new StorageLevel(false, false, false, false)<br>  val DISK_ONLY = new StorageLevel(true, false, false, false)<br>  val DISK_ONLY_2 = new StorageLevel(true, false, false, false, 2)<br>  val MEMORY_ONLY = new StorageLevel(false, true, false, true)<br>  val MEMORY_ONLY_2 = new StorageLevel(false, true, false, true, 2)<br>  val MEMORY_ONLY_SER = new StorageLevel(false, true, false, false)<br>  val MEMORY_ONLY_SER_2 = new StorageLevel(false, true, false, false, 2)<br>  val MEMORY_AND_DISK = new StorageLevel(true, true, false, true)<br>  val MEMORY_AND_DISK_2 = new StorageLevel(true, true, false, true, 2)<br>  val MEMORY_AND_DISK_SER = new StorageLevel(true, true, false, false)<br>  val MEMORY_AND_DISK_SER_2 = new StorageLevel(true, true, false, false, 2)<br>  val OFF_HEAP = new StorageLevel(false, false, true, false)<br>  ……<br>  }</p><p>  class StorageLevel private(</p><pre><code>private var _useDisk: Boolean,private var _useMemory: Boolean,private var _useOffHeap: Boolean,private var _deserialized: Boolean,private var _replication: Int = 1)</code></pre><p>  extends Externalizable {<br>  ……<br>  def useDisk: Boolean = _useDisk // 使用硬盘<br>  def useMemory: Boolean = _useMemory // 使用内存<br>  def useOffHeap: Boolean = _useOffHeap // 使用堆外内存，这是Java虚拟机里面的概念，堆外内存意味着把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。<br>  def deserialized: Boolean = _deserialized // 反序列化，其逆过程序列化（Serialization）是java提供的一种机制，将对象表示成一连串的字节；而反序列化就表示将字节恢复为对象的过程。序列化是对象永久化的一种机制，可以将对象及其属性保存起来，并能在反序列化后直接恢复这个对象<br>  def replication: Int = _replication // 备份数（在多个节点上备份）<br>  ……<br>  }</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Key-Value数据类型的Transfromation算子，这种变换并不触发提交作业，针对处理的数据项是Key-Value型的数据对</span><br><span class="line"></span><br><span class="line">    - 输入分区与输出分区一对一</span><br><span class="line">        - mapValues</span><br><span class="line">            - 针对(key,value)型数据中的Value进行操作，而不对Key进行处理</span><br><span class="line">    - 对单个RDD或两个RDD聚集</span><br><span class="line">        - 单个RDD聚集</span><br><span class="line">            - combineByKey</span><br><span class="line">            - reduceByKey</span><br><span class="line">                - 会先在局部聚合再shuffle，比起groupbykey（先shuffle再聚合）在大量数据时可以减轻网络压力</span><br><span class="line">            - partitionBy</span><br><span class="line">        - 两个RDD聚集</span><br><span class="line">            - cogroup</span><br><span class="line">    - 连接</span><br><span class="line">        - join</span><br><span class="line">        - leftOutJoin和 rightOutJoin</span><br><span class="line"></span><br><span class="line">- Action算子，这类算子会调用 `sc.runjob()` 方法触发SparkContext提交Job作业</span><br><span class="line"></span><br><span class="line">    - 无输出</span><br><span class="line">        - foreach</span><br><span class="line">        - foreachPartition</span><br><span class="line">    - HDFS</span><br><span class="line">        - saveAsTextFile</span><br><span class="line">        - saveAsObjectFile</span><br><span class="line">    - Scala集合和数据类型</span><br><span class="line">        - collect</span><br><span class="line">            - 将rdd中的所有数据都从网络端下载到本地，返回结果为一个array。数据量大的时候容易引起溢出</span><br><span class="line">        - collectAsMap</span><br><span class="line">        - reduceByKeyLocally</span><br><span class="line">        - lookup</span><br><span class="line">        - count</span><br><span class="line">        - top</span><br><span class="line">        - reduce</span><br><span class="line">            - 底层实现是 reduceLeft</span><br><span class="line">        - fold</span><br><span class="line">            - 和reduce类似，不同的是fold()操作需要从一个初始值开始，并以该值作为上下文，处理集合中的每个元素</span><br><span class="line">        - aggregate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8. spark 和 mapreduce</span><br><span class="line"></span><br><span class="line">- 消除了冗余的 HDFS 读写: Hadoop 每次 shuffle 操作后，必须写到磁盘，而 Spark 在 shuffle 后不一定落盘，可以 persist 到内存中，以便迭代时使用。如果操作复杂，很多的 shufle 操作，那么 Hadoop 的读写 IO 时间会大大增加，也是 Hive 更慢的主要原因了。</span><br><span class="line">- 消除了冗余的 MapReduce 阶段: Hadoop 的 shuffle 操作一定连着完整的 MapReduce 操作，冗余繁琐。而 Spark 基于 RDD 提供了丰富的算子操作，且 reduce 操作产生 shuffle 数据，可以缓存在内存中。</span><br><span class="line">- JVM 的优化: Hadoop 每次 MapReduce 操作，启动一个 Task 便会启动一次 JVM，基于进程的操作。而 Spark 每次 MapReduce 操作是基于线程的，只在启动 Executor 是启动一次 JVM，内存的 Task 操作是在线程复用的。每次启动 JVM 的时间可能就需要几秒甚至十几秒，那么当 Task 多了，这个时间 Hadoop 不知道比 Spark 慢了多少。</span><br><span class="line"></span><br><span class="line">xx. Driver 创建spark上下文对象的应用程序就是 Driver，拆分任务，发送任务到 Executor。发送涉及到网络传输，类对象需要 extends java.io.Serializable </span><br><span class="line">Executor 执行器用于接收任务并执行任务，并可以返回执行情况给 Driver。所有算子都交给 Executor</span><br><span class="line"></span><br><span class="line">9. spark 提交流程</span><br><span class="line">spark-submit（Driver) 向Master提交任务，申请运行资源。在参数中备注上master、executor地址，运行内存等等。</span><br><span class="line"></span><br><span class="line">spark-submit --class cn.enn.realtime.business.ContractDetailStream \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--driver-memory 1g \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--executor-cores 1 \</span><br><span class="line">--num-executors 1 \</span><br><span class="line"></span><br><span class="line">Master负责资源调度，分配资源，记录Executor在哪些Worker里启动。Master和Worker进行RPC通信，让worker启动executor，将分区的参数传递过去。</span><br><span class="line">Driver里有具体的业务逻辑编写，生成执行任务，发送给executor执行，也就是executor启动会主动和driver进行通信，获取Task</span><br><span class="line"></span><br><span class="line">10. spark数据倾斜</span><br><span class="line"></span><br><span class="line">SET spark.sql.autoBroadcastJoinThreshold=104857600;</span><br><span class="line">适用于：参与Join的一边数据集足够小，可被加载进Driver并通过Broadcast方法广播到各个Executor中。</span><br><span class="line">解决方案：在Java/Scala代码中将小数据集数据拉取到Driver，然后通过Broadcast方案将小数据集的数据广播到各Executor。或者在使用SQL前，将Broadcast的阈值调整得足够大，从而使用Broadcast生效。进而将Reduce侧Join替换为Map侧Join。</span><br><span class="line">优势：避免了Shuffle，彻底消除了数据倾斜产生的条件，可极大提升性能。</span><br><span class="line">劣势：要求参与Join的一侧数据集足够小，并且主要适用于Join的场景，不适合聚合的场景，适用条件有限。</span><br><span class="line"></span><br><span class="line">11. spark-streaming连接kafka两种方式 / kafkastream 的两种形式</span><br><span class="line">Receiver模式：KafkaUtils.createDStream() kafka支持发布订阅，所以kafka把消息全部封装好，提供给spark去调用，本来kafka的消息分布在不同的partition上面，相当于做了一步数据合并，在发送给spark，故spark可以设置executor个数去消费这部分数据，效率相对慢一些</span><br><span class="line">Direct模式：KafkaUtils.createDirectStream() 每次到topic的每个partition依据偏移量进行获取数据，拉取数据以后进行处理，可以实现高可用</span><br><span class="line"></span><br><span class="line">12. RDD、DataFrame、Dataset</span><br><span class="line">共性：</span><br><span class="line">1、RDD、DataFrame、Dataset全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利</span><br><span class="line">2、三者都有惰性机制，在进行创建、转换，如map方法时，不会立即执行，只有在遇到Action如foreach时，三者才会开始遍历运算，极端情况下，如果代码里面有创建、转换，但是后面没有在Action中使用对应的结果，在执行时会被直接跳过</span><br><span class="line">3、三者都会根据spark的内存情况自动缓存运算，这样即使数据量很大，也不用担心会内存溢出</span><br><span class="line">4、三者都有partition的概念</span><br><span class="line">5、三者有许多共同的函数，如filter，排序等</span><br><span class="line">6、在对DataFrame和Dataset进行操作许多操作都需要这个包进行支持 import spark.implicits._</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">RDD不支持sparksql操作</span><br><span class="line">与RDD和Dataset不同，DataFrame每一行的类型固定为Row，只有通过解析才能获取各个字段的值，每一列的值没法直接访问</span><br><span class="line">DataFrame与Dataset均支持sparksql的操作，比如select，groupby之类</span><br><span class="line">DataFrame与Dataset支持一些特别方便的保存方式，比如保存成csv，可以带上表头，这样每一列的字段名一目了然</span><br><span class="line"></span><br><span class="line">** Dataset和DataFrame拥有完全相同的成员函数，区别只是每一行的数据类型不同 **</span><br><span class="line">DataFrame也可以叫Dataset[Row],每一行的类型是Row，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无从得知，只能用上面提到的getAS方法或者模式匹配拿出特定字段</span><br><span class="line">Dataset中，每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获得每一行的信息</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><p>case class Coltest(col1:String,col2:Int)extends Serializable //定义字段名和类型<br>/**    rdd<br>    (“a”, 1)<br>    (“b”, 1)<br>    (“a”, 1)<br>    * */<br>val test: Dataset[Coltest]=rdd.map{line=&gt;<br>    Coltest(line._1,line._2)<br>}.toDS<br>test.map{<br>    line=&gt;<br>    println(line.col1)<br>    println(line.col2)<br>}可以看出，Dataset在需要访问列中的某个字段时是非常方便的，然而，如果要写一些适配性很强的函数时，如果使用Dataset，行的类型又不确定，可能是各种case class，无法实现适配，这时候用DataFrame即Dataset[Row]就能比较好的解决问题<br>```</p><ol start="13"><li>共享变量：累加器和广播变量</li></ol><p>Spark中分布式执行的代码需要传递到各个Executor的Task上运行。对于一些只读、固定的数据(比如从DB中读出的数据),每次都需要Driver广播到各个Task上，这样效率低下。广播变量允许将变量只广播（提前广播）给各个Executor。该Executor上的各个Task再从所在节点的BlockManager获取变量，而不是从Driver获取变量，从而提升了效率。</p><p>一个Executor只需要在第一个Task启动时，获得一份Broadcast数据，之后的Task都从本节点的BlockManager中获取相关数据。</p><p>val values = List<a href="1,2,3">Int</a><br>val broadcastValues = sparkContext.broadcast(values)<br>rdd.mapPartitions(iter =&gt; {<br>  broadcastValues.getValue.foreach(println)<br>})</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 源码解析</title>
      <link href="/2020/04/23/HashMap-1/"/>
      <url>/2020/04/23/HashMap-1/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap-源码解析"><a href="#HashMap-源码解析" class="headerlink" title="HashMap 源码解析"></a>HashMap 源码解析</h2><p><a href="https://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="noopener">参考地址1</a><br><a href="https://www.cnblogs.com/duodushuduokanbao/p/9492952.html" target="_blank" rel="noopener">参考地址2</a></p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>java.lang.Object<br>   ↳     java.util.AbstractMap&lt;K, V&gt;<br>         ↳     java.util.HashMap&lt;K, V&gt;</p><p>public class HashMap&lt;K,V&gt;<br>    extends AbstractMap&lt;K,V&gt;<br>    implements Map&lt;K,V&gt;, Cloneable, Serializable { }</p><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。（多线程时可以用ConcurrentHashMap，比HashTable更高效）。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量（默认是16），初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p><p>HashMap继承于AbstractMap类，实现了Map接口。Map是”key-value键值对”接口，AbstractMap实现了”键值对”的通用函数接口。</p><p>HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。<br>table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。<br>size是HashMap的大小，它是HashMap保存的键值对的数量。<br>threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”当前最大容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。<br>loadFactor就是加载因子。<br>modCount是记录发生内部结构变化的次数，如果是put但是put的值是覆盖原有的值，这样不算是内部结构变化；是用来实现fail-fast机制的。如果在 Iterator 过程中，并发的对集合进行修改，此时会报ConcurrentModificationException异常 =&gt; 即线程不安全</p><p><img src="https://images.weserv.nl/?url=https://images2018.cnblogs.com/blog/1373220/201808/1373220-20180817111003861-1536817344.png" alt="HashMap数据结构"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class HashMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 默认的初始容量是16，必须是2的幂。</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）</span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">    // 默认加载因子</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">    // 存储数据的Entry数组，长度是2的幂。</span><br><span class="line">    // HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表</span><br><span class="line">    transient Entry[] table;</span><br><span class="line"></span><br><span class="line">    // HashMap的大小，它是HashMap保存的键值对的数量</span><br><span class="line">    transient int size;</span><br><span class="line"></span><br><span class="line">    // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）</span><br><span class="line">    int threshold;</span><br><span class="line"></span><br><span class="line">    // 加载因子实际大小</span><br><span class="line">    final float loadFactor;</span><br><span class="line"></span><br><span class="line">    // HashMap被改变的次数</span><br><span class="line">    transient volatile int modCount;</span><br><span class="line"></span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Put-方法实现"><a href="#2-Put-方法实现" class="headerlink" title="2. Put 方法实现"></a>2. Put 方法实现</h3><p><img src="https://images.weserv.nl/?url=https://img2018.cnblogs.com/blog/1684605/201905/1684605-20190522150831073-641494049.png" alt="HashMap之put过程"></p><ol><li>table[] 是否为空</li><li>判断 table[i] 位置是否插入过值</li><li>判断链表长度是否大于8，如果大于就转换为红黑二叉树，并插入树中</li><li>判断key是否和原有key相同，如果相同就覆盖原有key的value，并返回原有value</li><li>如果key不相同，就插入一个key，记录结构变化一次</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">//判断table是否为空，如果是空的就创建一个table，并获取他的长度</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">//如果计算出来的索引位置之前没有放过数据，就直接放入</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">//进入这里说明索引位置已经放入过数据了</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">//判断put的数据和之前的数据是否重复</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))   //key的地址或key的equals()只要有一个相等就认为key重复了，就直接覆盖原来key的value</span><br><span class="line">                e = p;</span><br><span class="line">//判断是否是红黑树，如果是红黑树就直接插入树中</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">//如果不是红黑树，就遍历每个节点，判断链表长度是否大于8，如果大于就转换为红黑树</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">//判断索引每个元素的key是否可要插入的key相同，如果相同就直接覆盖</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">//如果e不是null，说明没有迭代到最后就跳出了循环，说明链表中有相同的key，因此只需要将value覆盖，并将oldValue返回即可</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//说明没有key相同，因此要插入一个key-value，并记录内部结构变化次数</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Get-方法实现"><a href="#3-Get-方法实现" class="headerlink" title="3. Get 方法实现"></a>3. Get 方法实现</h3><ol><li>判断表或key是否是null，如果是直接返回null key对应的value</li><li>判断索引处第一个key与传入key是否相等，如果相等直接返回</li><li>如果不相等，判断链表是否是红黑二叉树，如果是，直接从树中取值</li><li>如果不是树，就遍历链表查找</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">//如果表不是空的，并且要查找索引处有值，就判断位于第一个的key是否是要查找的key</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">//如果是，就直接返回</span><br><span class="line">                return first;</span><br><span class="line">//如果不是就判断链表是否是红黑二叉树，如果是，就从树中取值</span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">//如果不是树，就遍历链表</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-table-的初始化时机是什么时候"><a href="#4-table-的初始化时机是什么时候" class="headerlink" title="4. table 的初始化时机是什么时候"></a>4. table 的初始化时机是什么时候</h3><ul><li>一般情况下，在第一次 put 的时候，调用 resize 方法进行 table 的初始化（懒初始化，懒加载思想在很多框架中都有应用！）</li></ul><h3 id="5-初始化的-table-length-是多少、阀值（threshold）是多少，实际能容下多少元素"><a href="#5-初始化的-table-length-是多少、阀值（threshold）是多少，实际能容下多少元素" class="headerlink" title="5. 初始化的 table.length 是多少、阀值（threshold）是多少，实际能容下多少元素"></a>5. 初始化的 table.length 是多少、阀值（threshold）是多少，实际能容下多少元素</h3><ul><li>默认情况下，table.length = 16; 指定了 initialCapacity 的情况放到问题 5 中分析</li><li>默认情况下，threshold = 12; 指定了 initialCapacity 的情况放到问题 5 中分析</li><li>默认情况下，能存放 12 个元素，当存放第 13 个元素后进行扩容</li></ul><h3 id="6-什么时候触发扩容，扩容之后的-table-length、阀值各是多少"><a href="#6-什么时候触发扩容，扩容之后的-table-length、阀值各是多少" class="headerlink" title="6. 什么时候触发扩容，扩容之后的 table.length、阀值各是多少"></a>6. 什么时候触发扩容，扩容之后的 table.length、阀值各是多少</h3><ul><li>当 size &gt; threshold 的时候进行扩容</li><li>扩容之后的 table.length = 旧 table.length * 2,</li><li>扩容之后的 threshold = 旧 threshold * 2</li></ul><h3 id="7-JDK7-和-JDK8-的区别"><a href="#7-JDK7-和-JDK8-的区别" class="headerlink" title="7. JDK7 和 JDK8 的区别"></a>7. JDK7 和 JDK8 的区别</h3><p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/20190122151826171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmV6aGFvaGFpbWln,size_16,color_FFFFFF,t_70" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce</title>
      <link href="/2020/04/22/MapReduce/"/>
      <url>/2020/04/22/MapReduce/</url>
      
        <content type="html"><![CDATA[<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><h3 id="1-1-输入输出"><a href="#1-1-输入输出" class="headerlink" title="1.1 输入输出"></a>1.1 输入输出</h3><p><img src="https://images.weserv.nl/?url=https://upload-images.jianshu.io/upload_images/12652505-0716b5d505b94bc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/577/format/webp" alt="pic1"></p><p>首先都是 k, v 的形式</p><p>map 到 reduce 端是通过网络来传输，所以 k, v 都需要序列化和反序列化，Java 基本数据类型不支持序列化，所以需要用 MR 自己封装的类型，比如 LongWritable, Text, IntWritable 等等</p><p>reduce 的输入顺序默认是按照 key 的大小顺序（字符串的字典顺序）来进行处理，如果 map 输出的 key 是一个对象，可以 implements WritableComparable 接口，自定义 key 的顺序来交给 reduce</p><p>map 输出的内容会被序列化，所以如果是输出一个对象的话，也不会有影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;OrderBean&gt; beans = new ArrayList&lt;&gt;();</span><br><span class="line">OrderBean bean = new OrderBean();</span><br><span class="line">bean.set(1);</span><br><span class="line">beans.add(bean); // 此时保存的只是bean对象的一个地址引用</span><br><span class="line">bean.set(2);</span><br><span class="line">beans.add(bean); // 由于是地址引用，在原先地址上修改了bean对象的值，那么beans最后呈现出来的值也是最新的值，打印出来都是 2</span><br><span class="line"></span><br><span class="line">class xxMapper extends Mapper&lt;&gt;&#123;</span><br><span class="line">    OrderBean bean = new OrderBean();</span><br><span class="line">    Text k = new Text();</span><br><span class="line">    @Override</span><br><span class="line">    protected void map()&#123;</span><br><span class="line">        // 每一个 maptask 都会调用 map 方法，如果在 map 方法里创建对象，就会占用大量资源，由于对象写入到上下文的时候要经过序列化，所以并不需要担心多个maptask 在频繁赋值造成前后影响</span><br><span class="line">        context.write(k, bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reduce 里虽然只有一个key，但是迭代器values每迭代一次，key也会跟着变</p><p>运行机制：<br>map task(其实是叫 yarn child)，拿到的是内容是 TextInputFormat，读取每一行用的是 LineRecordReader，返回一对kv，k是偏移量，v是行的内容。频繁的IO会降低效率，所以context(k, v) 会把结果写入到一个 MapOutputCollector 的环形内存缓冲区，当内容写到一定程度之后（缓冲区默认大小100M，spill的阈值是0.8，可以通过<code>mapreduce.map.io.sort.spill.percent</code>来设置），有一个 Spiller 溢出监控的线程，去把缓冲区的内容通过轮询的方式写入到<code>mapreduce.cluster.local.dir</code>属性指定的目录中，在写入的同时会根据key排序和合并（也就是combiner执行的地方），整个map输出完毕之后，会对所有临时文件终会执行一个合并任务，将生产的小文件全部合并为一个文件，相同分区的会拼接在一起，并且分区内保证key有序（map过程的输出是写入本地磁盘而不是HDFS，但是一开始数据并不是直接写入磁盘而是缓冲在内存中，缓存的好处就是减少磁盘I/O的开销，提高合并和排序的速度。在编写map函数的时候要尽量减少内存的使用，为shuffle过程预留更多的内存，这个过程最耗时）。文件路径会保存在NodeManager里，reduceTask 通过网络下载，文件可能存放在多个服务器，每个文件只能保证在本服务器内是分区且有序的，所以 reduceTask 在拿到文件分区后还需要再执行一次合并使key有序。reduce 里的迭代器 values 每迭代一次都会调用 groupingComparator 来判断下一次和上一次的key是不是一个。reduce 里的 context 会通过TextOutputFormat 类下的 LineRecordWriter 写入文件。map的输出到reduce的输入的过程叫 shuffle。</p><blockquote><p>写磁盘时压缩map端的输出，因为这样会让写磁盘的速度更快，节约磁盘空间，并减少传给reducer的数据量。默认情况下，输出是不压缩的(将mapreduce.map.output.compress设置为true即可启动）</p></blockquote><p>sequenceFile 里面保存的是kv形式，这样就不需要split文本内容了。 job.setOutputFormatClass(xx); 默认是 TextOutputFormat.class（同理输入），改成 SequenceFileOutputFormat.class 就可以修改输出文件的类型，直接将内容转换成二进制</p><h3 id="1-2-combiner"><a href="#1-2-combiner" class="headerlink" title="1.2 combiner"></a>1.2 combiner</h3><p>combiner 是先在 map 端做一次合并，减少传输到 reduce 端的数据量，因为 combiner 的输出是 reduce 的输入，所以 combiner 是不能对 map 的输出进行修改，所以适用的场景比如累加、求最大值等，但是求平均数就不行了。</p><p>combiner 操作发生在 map 端的，处理一个任务所接收的文件中的数据，做局部聚合，不能跨 map 任务执行；只有 reduce 可以接收多个 map 任务处理的数据（也就是通过 key 的 hash 值取模分配到对应的 reduce上）</p><p>继承的也是 reduce 父类，实现的是对 reduce 方法的覆写，然后在启动类添加 job.setCombinerClass();</p><p>可以用来解决一定的数据倾斜问题</p><h3 id="1-3-启动类配置"><a href="#1-3-启动类配置" class="headerlink" title="1.3 启动类配置"></a>1.3 启动类配置</h3><p>设置 hadoop 用户<br>System.setProperty(“HADOOP_USER_NAME”, “root”); // 这样写可以在本地运行程序的时候以 root 用户去执行 jar，从而拥有对输入输出路径下文件的读写权限</p><p>job 执行时提交请求给 resource manager，分配一定的 node manager 的资源来运行 job</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = new Configuration();</span><br><span class="line">conf.set(&quot;fs.defaultFS&quot;, &quot;hdfs://9000&quot;); // 对应linux下hadoop安装目录下 core-site.xml 里面的配置项</span><br><span class="line">conf.set(&quot;mapreduce.framework.name&quot;, &quot;yarn&quot;); // 对应linux下hadoop安装目录下 mapred-site.xml 里面的配置项，不写的话默认值是 local</span><br><span class="line">conf.set(&quot;yarn.resourcemanager.hostname&quot;, &quot;yarn-01&quot;);</span><br><span class="line">// 如果从 windows 运行的话，需要跨平台提交</span><br><span class="line">conf.set(&quot;mapreduce.app-submission.cross-platform&quot;, true);</span><br><span class="line"></span><br><span class="line">Job job = Job.getInstance(conf);</span><br><span class="line">job.setJarByClass(类名.class) | (&quot;d:/xxx.jar&quot;);</span><br><span class="line">// 还需要设置 map reduce 的 key value 的类型，以及 map reduce 对应的类，还有输入输出路径，输出路径必须不存在</span><br><span class="line">// 设置 reduceTask 个数</span><br><span class="line">job.setNumReduceTasks(2);</span><br><span class="line">// 提交到 yarn 并保持通信，打印 resource manager 返回的日志信息</span><br><span class="line">job.waitForCompletion(true);</span><br></pre></td></tr></table></figure><p>以上是在 windows 下启动运行，以下是在 linux 下运行</p><p>hadoop jar xx.jar 启动类 // hadoop jar 会把本机器上 hadoop 安装目录下的所有jar包和配置文件（core-site.xml)加载到执行语句的classpath下，这样jvm就可以读取到想要的配置</p><h3 id="1-4-yarn"><a href="#1-4-yarn" class="headerlink" title="1.4 yarn"></a>1.4 yarn</h3><p>客户端提交一个job，在yarn的resourcemanager中请求一个容器来运行，在启动 mapreduce 的时候会首先启动一个 MRAppMaster 类，用来管理所有的 mapreduce，需要1.5G的一个启动内存，所以内存至少要2G以上，而 maptask 和 reducetask 都需要至少1G内存。并不是说会全部吃满内存，但是需要这样的一个上限值才能启动。</p><p>会依次启动yarnchild（maptask）和yarnchild(reducetask)，提交到job的客户端</p><p>第一代hadoop，只有一个hdfs文件系统和mr计算调度平台<br>第二代hadoop，将调度交给yarn统一管理资源<br>Hdfs namenode datanode 第一代 client提交job，jobtracker先从namenode里拿到所需文件的数据块信息，发送到datanode中运行，tasktracker监督datanode状态，反馈给jobtracker，并一直反馈给client。客户端包括ide运行或者shell里 hadoop jar x.jar</p><p>Yarn 分为resourcemanager nodemanager 主从结构</p><p>1.用户向YARN中提交应用程序，其中包括AM程序、启动AM的命令、用户程序等。<br>2.RM为该应用程序分配一个container，并向对应的NM通信，要求他在这个container中启动ApplicationMaster。<br>3.AM向RM注册，这样用户可以直接通过RM查看应用程序的运行状态，然后它将为任务申请资源，并监控其运行状态，直到运行结束（重复4-7）<br>4.AM采用轮询的方式通过RPC协议向RM申请和领取资源。<br>5.AM申请到资源后，便于NM通信，要求其启动任务。<br>6.NM为任务设置好运行环境（包括环境变量、JAR包、二进制程序等）后，将任务启动命令写到一个脚本中，并通过运行改脚本启动任务。<br>7.各个任务通过RPC协议向AM汇报自己的进度和状态，让AM随时掌握各个任务的运行状态，从而可以在任务失败是重启任务。在应用程序运行过程中，用户可随时通过RPC向AM查询应用程序的当前运行状态。<br>8.应用程序运行完成后，AM注销并关闭自己。</p><h3 id="1-5-自定义类型"><a href="#1-5-自定义类型" class="headerlink" title="1.5 自定义类型"></a>1.5 自定义类型</h3><p>输入输出都是 k,v 的形式，k 是唯一的，但是 v 如果有很多个，那就使用一个类来封装，但是这个类需要实现 hadoop 的序列化接口：implements Writable，重写 write(DataOutput out) 和 readFields(DataInput in) 方法。</p><p>out.writeInt(字段); // 一定是4个字节<br>out.writeUTF(“我”); // 一共是5个字节，按照utf-8编码，一个汉字3个字节，然后最前面有2个字节来声明后面有几个字节是属于这个字符串的，所以可以通过这个方式来截取字节长度，然后反序列化字符串<br>out,write(“我”.getBytes()); // 3个字节，单纯的utf-8编码，一个汉字3个字节，在传输时并不知道具体字符串会有多长，不方便截取，所以更推荐使用上面的方式</p><blockquote><p>unicode 一个英文2个字节，一个汉字2个字节，中英文标点都是2个字节<br>utf-8 一个英文1个字节，一个汉字3个字节，中文标点3个字节，英文标点1个字节<br>gbk 英文1个字节，汉字2个字节</p></blockquote><p>字段 = in.readInt();<br>字段 = in.readUTF();</p><h3 id="1-6-以求最大值为例，在reduce之后还要进行最终结果的筛选"><a href="#1-6-以求最大值为例，在reduce之后还要进行最终结果的筛选" class="headerlink" title="1.6 以求最大值为例，在reduce之后还要进行最终结果的筛选"></a>1.6 以求最大值为例，在reduce之后还要进行最终结果的筛选</h3><p>首先在 reduce() 方法里就不能直接用 <code>context.write()</code>，这是直接写结果的。可以创建一个类，来保存 reduce 后的所有结果，然后在 reduceTask 处理完所有数据之后，会调用 cleanUp(Context context) 方法，重写这个方法，获取到这个类，然后进行数据筛选，把最终结果写到 context.write() 里</p><p>但是如果是大数据量的话，通过构建最小堆来获取最大的几个值</p><p>Configuration conf = context.getConfiguration();<br>int topN = conf.getInt(“topN”, 5); // 会尝试从 conf 中获取这个 name 对应的值，如果没有配置的话，默认值就是5；可以在启动类那里用过传参来设置这个topN是多少；或者自己写一个xml配置文件，通过 conf.addResource(“xx.xml”)，就可以识别出来</p><p>在 map 和 reduce 里都存在 setup()、map()/reduce()、cleanup() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">eg: </span><br><span class="line">父类 Mapper()&#123;</span><br><span class="line">    run()&#123;</span><br><span class="line">        setup();</span><br><span class="line">        try&#123;</span><br><span class="line">            while()&#123;</span><br><span class="line">                mapper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-Partitioner-修改分发规则"><a href="#1-7-Partitioner-修改分发规则" class="headerlink" title="1.7 Partitioner 修改分发规则"></a>1.7 Partitioner 修改分发规则</h3><blockquote><p>分发的动作由 maptask 来执行，由 maptask 来执行 getPartitioner() 方法，然后分发到对应的 reduce 中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">源码：</span><br><span class="line">默认是按照 map 输出的 key.hashcode() % reduceTask的数量</span><br><span class="line">public class HashPartitioner&lt;K2, V2&gt; implements Partitioner&lt;K2, V2&gt;&#123;</span><br><span class="line">    public void configure(JobConf job)&#123;&#125;</span><br><span class="line">    public int getPartitioner(K2 key, V2 value, int numReduceTasks)&#123;</span><br><span class="line">        return (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个类，extends Partitioner 覆写 getPartitioner() 方法，在启动类中设置 job.setPartitionerClass(xxx.class);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static class WordcountHashPartitioner extends Partitioner&lt;Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getPartition(Text key, IntWritable value, int numPartitions) &#123;</span><br><span class="line">        String location = key.toString().split(&quot;:&quot;)[0];</span><br><span class="line">        return Math.abs(location.hashCode() * 127) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的几个分发方法：BinaryPartitioner, HashPartitioner, KeyFieldBasedPartitioner, TotalOrderPartitioner。这些分发方法只能保证大体有序</p><p>全局排序：确保Partition之间是有序<br>对数据进行抽样分层，为了保证partition分布均匀，在相同区间的数据返回到同一个reduce，map输出的key默认是按照字典顺序实现了升序排序，如果需要降序或者输出的key是一个对象的话，要覆写comparable，那么到一个reduce中的数据都是有序的。<br>取样：<br>1) 对Math.min(10, splits.length)个split（输入分片）进行随机取样，对每个split取10000个样，总共10万个样<br>2) 10万个样排序，根据reducer的数量(n)，取出间隔平均的n-1个样<br>3) 将这个n-1个样写入partitionFile(_partition.list，是一个SequenceFile)，key是取的样，值是nullValue<br>4) 将partitionFile写入DistributedCache </p><p>全局排序在key是相对稳定的时候，可以随机采样元数据，重写partitioner方法，将数据分到reduce上，来保证数据的连续性；还有一个方式是实现TotalOrderPartitioner类的方法，一共有三种采样方式，动态生成一个partition file，在查找具体key应该分到哪个reduce时底层是通过一个Tire tree来实现，使用二分法继续查找找到返回key在划分数组中的索引，找不到会返回一个和它最接近的划分的索引。<br>类名称 | 采样方式 | 构造方法 | 效率 | 特点<br>:-: | :-: | :-: | :-: | :-:|<br>SplitSampler&lt;K,V&gt; | 对前n个记录进行采样 | 采样总数，划分数 | 最高<br>RandomSampler&lt;K,V&gt; | 遍历所有数据，随机采样 | 采样频率，采样总数，划分数 |最低<br>IntervalSampler&lt;K,V&gt; | 固定间隔采样 | 采样频率，划分数 |中 | 对有序的数据十分适用<br><a href="https://www.cnblogs.com/wuyudong/p/hadoop-partitioner.html" target="_blank" rel="noopener">参考文档</a></p><h3 id="1-8-map端输入的分区切片原理"><a href="#1-8-map端输入的分区切片原理" class="headerlink" title="1.8 map端输入的分区切片原理"></a>1.8 map端输入的分区切片原理</h3><p>在 map 方法中，有一个变量是 context，存储了作业运行时的上下文信息，可以通过 <code>InputSplit inputSplit = context.getInputSplit();</code> 方法来获取切片信息</p><p>在 Hadoop 读取文件时，会通过 <code>getPartitions()</code> 方法来获取分区，在这个方法里会调用 InputFormat 这个抽象类的 <code>getSplits()</code> 方法，这个方法的具体实现是在 FileInputFormat 类中对 <code>getSplits()</code> 方法进行覆写。如何去切分文件数据的思路是：</p><ol><li>inputPath 如果是一个文件夹的话，遍历里面的所有文件，累加所有文件的size作为totalSize</li><li>求一个平均文件大小 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3. `while(fileSize / goalSize &gt; 1.1L)&#123;fileSize -= goalSize&#125;` 如果当前文件的大小超过平均大小的1.1倍，那么就从平均大小对应的offset那里进行切分文件</span><br><span class="line">4. 综上，如果文件不可切分，那么一个分区就是那一整个不可切分文件；如果文件可切分，计算出一个理想文件大小，然后依次判断文件大小和这个理想文件大小的关系，幅度在1.1倍之内的都可以接受，否则就需要切割。</span><br><span class="line"></span><br><span class="line">&gt; 切片是在 data manager 拿到 mr 后，创建容器来运行 maptask，创建几个要根据切片后的结果来确定。通过 getSplits() 方法，获取所有输入文件（也可能是连接数据库，那就保存的是库名表名偏移量信息），然后按照128M开始切片，不到128M的也会是一个maptask，不允许被切片的文件比如二进制文件，会单独一个切片，空文件也会是一个切片，一个切片可以跨大文件的多个block</span><br><span class="line">&gt; 当一个分片包含的多个block的时候，总会从其他节点读取数据，也就是做不到所有的计算都是本地化。为了发挥计算本地化性能，应该尽量使InputSplit大小与块大小相当</span><br></pre></td></tr></table></figure></li></ol><p>由于 InputSplit 是一个抽象类，用的时候，需要用它的实现方法<br>FileSplit inputSplit = (FileSplit)context.getInputSplit(); // 强制转换，从大的类转到小的子类<br>String fileName = inputSplit.getPath().getName(); </p><p>可以用于倒排索引，获取文件的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 1.9 分组排序 WritableComparator</span><br><span class="line"></span><br><span class="line">比如两个 key 是否一样，会调用 GroupComparator 类下的 compare(o1, o2) 方法</span><br><span class="line"></span><br><span class="line">用bean来做key，包括orderid，amounfee两个属性，相同的orderid排在一起，id小的在前面</span><br><span class="line">重写分发规则 partitioner，让orderid相同的分到同一个reduce</span><br><span class="line">重写 groupComparator，由于传递的key是对象，所以要指出来只要orderid相同，就会被看成同一组进行一次reduce聚合（跟上一步不一样的地方在于，有可能存在不同的key取hashcode再取模后分发到同一个reduce上，这时候需要通过groupComparator类下的compare()方法来保证同一类orderid进行聚合）</span><br></pre></td></tr></table></figure><p>class OrderIdGroupingComparator extends WritableComparator {<br>    public OrderIdGroupingComparator(){<br>        super(OrderBean.class, true); // 调用父类的构造函数，将 OrderBean.class 序列化，要不然下面的方法无法识别 OrderBean，true代表是执行序列化<br>    }<br>    @Overwrite<br>    public int compare(WritableComparable a, WritableComparable b){<br>        OrderBean o1 = (OrderBean)a;<br>        OrderBean o2 = (OrderBean)b;<br>        return o1.getOrderId().compareTo(o2.getOrderId());<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![pic2](https://images.weserv.nl/?url=https://img-blog.csdn.net/20180722005722553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lneWJsdWUy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line">### 1.10 合合</span><br><span class="line"></span><br><span class="line">配置类读取所有的库表以及字段关系</span><br></pre></td></tr></table></figure><p>final HiveConf hiveconf = new HiveConf(conf, HHDriver.class);<br>HiveMetaStoreClient client = new HiveMetaStoreClient(hiveconf);</p><pre><code>通过HiveMetaStoreClient连接Hive，先要拿到库表的分区信息，client.listPartitionNames，如果存在就添加，如果没有就新建优化：map 中 context(库.表，kafka中的data)extends Partitioner 库.表+rand() 重写 int getPartition()extends WritableComparator 重写 int compare()reduce 中 保证是同一类库.表，输出 mosMultipleOutputs mos 结果输出到多个文件或多个文件夹，用 `mos.write(String nameOutput, Key key,Value value,String baseOutputPath)代替context.write(key, value) // nameOutput 用来指定是哪一种输出，通过别称，可以设置输出的不同地址、数据格式等`增量表是 text，最终表是 parquet。基于列式存储，由于每一列的数据类型都是一样的，因此可以针对每一列的数据类型使用更高效的压缩算法；在查询时只要扫描需要查询的列数据，不用进行全表扫描String newStr = new String(str.getBytes(&quot;UTF-8&quot;),&quot;UTF-8&quot;); 将字符串按照 UTF-8 放入到bytes[]数组里，再按照 UTF-8 的方式读取</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> MapReduce </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> MapReduce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataSkew 数据倾斜</title>
      <link href="/2020/04/21/DataSkew/"/>
      <url>/2020/04/21/DataSkew/</url>
      
        <content type="html"><![CDATA[<h2 id="DataSkew-数据倾斜"><a href="#DataSkew-数据倾斜" class="headerlink" title="DataSkew 数据倾斜"></a>DataSkew 数据倾斜</h2><h3 id="1-Hive-里的数据倾斜"><a href="#1-Hive-里的数据倾斜" class="headerlink" title="1. Hive 里的数据倾斜"></a>1. Hive 里的数据倾斜</h3><h4 id="1-1-null值-空值"><a href="#1-1-null值-空值" class="headerlink" title="1.1 null值 空值"></a>1.1 null值 空值</h4><p>尽量提前过滤，或者把无效值替换成随机字符串，比如 <code>if(a is null or trim(a) = &quot;&quot; or trim(a) = &quot;NULL&quot;, rand(1)+&quot;&quot;)</code>，由于是无效值所以不影响最终的取数，但是因为把关联字段打散了，所以就不会把所有的key发送到同一个reduce上，但是需要控制rand(1)的数据范围，小数点位数过多会导致分配的reduce太多，也会影响最终效率。</p><blockquote><p>打散key的方式同样适用于MapReduce和Spark。</p></blockquote><h4 id="1-2-小文件倾斜"><a href="#1-2-小文件倾斜" class="headerlink" title="1.2 小文件倾斜"></a>1.2 小文件倾斜</h4><p>这一点在 Hive 里主要表现在模型汇总程度越高，数据量越小，如果再带有分区，那么在HDFS里就会有很多小文件。HDFS的文件元信息，包括位置、大小、分块信息都保存在NameNode的内存中，文件越多占的内存越大，所以读取小文件就会消耗时间。还有一种产生的可能是MapReduce的reduce数量增加，也会增加输出结果文件的数量，从而导致小文件过多。</p><blockquote><p>最后这种情况主要针对的是 MapReduce。当然Hive也可以通过配置项来尽可能减少reduce输出的小文件。</p></blockquote><p>解决方法有两种：</p><ol><li><p>map输入端的小文件合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 每个Map最大输入大小，决定合并后的文件数</span><br><span class="line">set mapred.max.split.size=256000000; **常见**</span><br><span class="line">-- 一个节点上split的至少的大小 ，决定了多个data node上的文件是否需要合并</span><br><span class="line">set mapred.min.split.size.per.node=100000000;</span><br><span class="line">-- 一个交换机下split的至少的大小，决定了多个交换机上的文件是否需要合并</span><br><span class="line">set mapred.min.split.size.per.rack=100000000;</span><br><span class="line">-- 执行Map前进行小文件合并</span><br><span class="line">set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat; **常见**</span><br></pre></td></tr></table></figure></li><li><p>reduce输出端的小文件合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hive.merge.mapfiles=True True时在map输出后合并文件，默认true</span><br><span class="line">hive.merge.mapredfiles=True True时在reduce输出后合并文件，默认false</span><br><span class="line">hive.merge.size.per.task 合并后每个文件的大小，默认256000000</span><br><span class="line">hive.merge.smallfiles.avgsize 当输出文件平均大小小于设定值时，并且前两个参数得有一个为true，才会启动合并操作，默认16000000</span><br><span class="line"></span><br><span class="line">Hive在对结果文件进行合并时会执行一个额外的map-only脚本，mapper的数量是文件总大小除以size.per.task参数所得的值，触发合并的条件是：</span><br><span class="line">根据查询类型不同，相应的mapfiles/mapredfiles参数需要打开；</span><br><span class="line">结果文件的平均大小需要大于avgsize参数的值。</span><br><span class="line"></span><br><span class="line">hive.map.aggr=true; Map 端部分聚合，相当于Combiner</span><br><span class="line">hive.groupby.mapaggr.checkinterval =100000 在 Map 端进行聚合操作的条目数目</span><br><span class="line">hive.groupby.skewindata=true; 这个是给groupby优化的。会生成2个mr job，其中第一个相当于是combiner的作用，会先做一部分聚合再给reduce传过去</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-3-mapjoin-和-streamtable"><a href="#1-3-mapjoin-和-streamtable" class="headerlink" title="1.3 mapjoin 和 streamtable"></a>1.3 mapjoin 和 streamtable</h4><p>这两个类似于注解一样，放在 select 的后面即可</p><h5 id="1-3-1-mapjoin"><a href="#1-3-1-mapjoin" class="headerlink" title="1.3.1 mapjoin"></a>1.3.1 mapjoin</h5><p>适合于：N个较大的表，一个较小的表</p><p>mapjoin 会把指定的小表在客户端打成一个哈希表序列化文件的压缩包，通过分布式缓存均匀分发到作业执行的每一个结点上。然后在结点上进行解压，在内存中完成关联，有一个超级小表的情况下，目前hive能做到自动判断并转为map join。Map Join全过程不会使用Reduce，非常均匀，不会存在数据倾斜问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set hive.auto.convert.join = true; # 默认为false</span><br><span class="line">该参数为true时，Hive自动对左边的表统计量，如果是小表就加入内存，即对 小表使用Map join</span><br><span class="line"></span><br><span class="line">set hive.mapjoin.smalltable.filesize;</span><br><span class="line">hive.mapjoin.smalltable.filesize=25000000</span><br><span class="line">大表小表的阈值默认值是25mb</span><br></pre></td></tr></table></figure><h5 id="1-3-2-streamtable"><a href="#1-3-2-streamtable" class="headerlink" title="1.3.2 streamtable"></a>1.3.2 streamtable</h5><p>适合于：N个较小的表，一个超大的表</p><p>join一般都是在reduce阶段完成的，因为在map阶段无法使同样key值的分在一个map上。<br>而在reduce阶段的join，hive默认把左表数据（小表）放在缓存中，右表数据（大表）放入到磁盘中，然后把内存中的表的数据逐条与硬盘上user表的数据做Join。<br>通过<code>/*+ streamtable(大表表名) */</code>来指定大表。<br>最好每次写join时，小表放左边，大表放右边。</p><h4 id="1-4-单纯的多对多"><a href="#1-4-单纯的多对多" class="headerlink" title="1.4 单纯的多对多"></a>1.4 单纯的多对多</h4><p>主键拼接一个rand(1)，放入不同的reduce，group by 的时候把真正的主键做一个截取即可</p><h3 id="2-MapReduce-中的数据倾斜"><a href="#2-MapReduce-中的数据倾斜" class="headerlink" title="2. MapReduce 中的数据倾斜"></a>2. MapReduce 中的数据倾斜</h3><h4 id="2-1-小文件倾斜"><a href="#2-1-小文件倾斜" class="headerlink" title="2.1 小文件倾斜"></a>2.1 小文件倾斜</h4><p>原理和Hive是一样的，太多的小文件，导致在ApplicationMaster在向ResourceManager去申请资源时，要频繁访问HDFS的NameNode，再去DataNode拿数据，准备数据时间太长。</p><p>所以可以在 map 端开始之前先把小文件进行合并，再传递给MapReduce。比如客户端产生数据文件时进行合并，或者文件数据进入map之前通过继承CombineFileInputFormat类实现小文件的合并。job.setInputFormatClass(CombineTextInputFormat.class)，然后在代码里的Configuration中设置切分的块的最小值最大值等等，在同一节点上的数据块会合并，超过最大值就生产新的分片。<br>hadoopConf.set(“mapreduce.input.fileinputformat.split.maxsize”, “512000000”)<br>hadoopConf.set(“mapreduce.input.fileinputformat.split.minsize”, “268435456”)</p><h4 id="2-2-key-值倾斜"><a href="#2-2-key-值倾斜" class="headerlink" title="2.2 key 值倾斜"></a>2.2 key 值倾斜</h4><p>同一个key的数据太多，导致全部传递到一个reduce上，导致其中一个reduce运行时间过长。</p><p>可以先创建一个类，通过 extends Partitioner 来重写 <code>int getPartition()</code> 方法，将key先都拼接一个rand()随机数，但是这个随机数应该和最多能启动起来的reduceNum个数是一样的（感觉是这样，随机数不能太多不一样的值，不然会传递到太多的reduce上，虽然每个reduceTask上的数据相对少了，但是启动过多的reduceTask也会增加时间），然后再创建一个类，通过 extends WritableComparator 来重写 <code>public int compare(WritableComparable a, WritableComparable b)</code> 方法，reduce 会自动调用 WritableComparator 类中的 <code>int compare</code> 方法，来判断循环的key是否和前一个是同一个来做累加，所以如果修改了partition分区方法，一般都是需要再覆写 WritableComparator 类的。</p><h3 id="3-Spark-中的数据倾斜"><a href="#3-Spark-中的数据倾斜" class="headerlink" title="3. Spark 中的数据倾斜"></a>3. Spark 中的数据倾斜</h3><ol><li><p>数据源数据文件不均匀</p><p> SparkContext.textFile(“”) 读取文件数据的时候底层实现是通过Hadoop读取文件的方式</p><p> 在 Hadoop 读取文件时，会通过 <code>getPartitions()</code> 方法来获取分区，在这个方法里会调用 InputFormat 这个抽象类的 <code>getSplits()</code> 方法，这个方法的具体实现是在 FileInputFormat 类中对 <code>getSplits()</code> 方法进行覆写。如何去切分文件数据的思路是：</p><ol><li><p>inputPath 如果是一个文件夹的话，遍历里面的所有文件，累加所有文件的size作为totalSize</p></li><li><p>求一个平均文件大小 <code>goalSize = totalSize / numSplits;  // numSplits 指的是 min(想要的分区个数，默认分区个数2个) 在spark里面是这样的，mr可能是读的配置</code></p></li><li><p><code>while(fileSize / goalSize &gt; 1.1L){fileSize -= goalSize}</code> 如果当前文件的大小超过平均大小的1.1倍，那么就从平均大小对应的offset那里进行切分文件</p></li><li><p>综上，如果文件不可切分，那么一个分区就是那一整个不可切分文件；如果文件可切分，计算出一个理想文件大小，然后依次判断文件大小和这个理想文件大小的关系，幅度在1.1倍之内的都可以接受，否则就需要切割。</p><p>每一个partition都会是一个task，所以如果文件不可分割，那么就会input一个特别大的文件，造成倾斜<br>适用场景：对于数据源单个spark input read数据量过大，或者单个task 相对于其他task spark input read较大的情况，读取数据源明显不均匀<br>解决方式：尽量使用可切割的文本存储，生成尽量多的task进行并行计算<br>优点：从数据源避免倾斜，并且从源头增大并行度，避免倾斜<br>缺点：需要改造数据源，支持可切割</p></li></ol></li><li><p>计算过程中key的分布不均（Shuffle导致的数据不均，在进行shuffle的时候，必须将各个节点上相同的key拉取到某个节点上的一个task来进行处理，此时如果某个key对应的数据量特别大的话，就会发生数据倾斜）</p><ul><li>单个rdd中进行groupby的时候key分布不均<br>  groupby(customerPart)<br>  map(key+rand()).reducebykey().reducebykey() 执行两次</li><li>多个rdd进行join过程中key的不均匀<ul><li>一个大表和一个小表的时候，将较小的RDD中的数据存到一个Broadcast变量（即广播变量）中，先广播到各个节点中，即在每个节点的内存中缓存一份，然后对大表RDD进行map算子，从Broadcast变量中获取较小RDD的全量数据，与当前RDD的每一条数据按照连接key进行比对，如果连接key相同的话，那么就将两个RDD的数据用你需要的方式连接起来。需要调整一下广播的阈值。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
            <tag> DataSkew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka</title>
      <link href="/2020/04/21/Kafka-2/"/>
      <url>/2020/04/21/Kafka-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><ol><li>Kafka不能保证消息的全局有序，只能保证消息在partition内有序</li><li>每个partition对应于一个log文件，该log文件中存储的就是生产者生成的数据，生产者生成的数据会不断的追加到该log的文件末端，且每条数据都有自己的offset</li><li>由于生产者生产的消息会不断追加到log文件的末尾，为防止log文件过大导致数据定位效率低下，Kafka采用分片和索引的机制，将每个partition分为多个segment，每个segment对应2个文件—-index文件和log文件，这2个文件位于一个相同的文件夹下，文件夹的命名规则为topic名称+分区序号。也就是partition下有多个segment文件夹，里面都有两个文件–index和log文件。Index文件中存储的数据的索引信息，第一列是offset，第二列是这个数据所对应的log文件中的偏移量。如果要去消费offset为3的数据，首先通过二分法找到数据在哪个index文件中，然后在通过index中offset找到数据在log文件中的offset；这样就可以快速的定位到数据并消费。所以kakfa虽然把数据存储在磁盘中，但是他的读取速度还是非常快的（类似于hbase对于行键来划分region，然后做的索引一样）</li><li>kafka如何保证数据可靠性呢？通过ack来保证。</li></ol><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhrm8TXCvosZOiccDGNicKmuQNY7luoaibgofCT7I03m40Ed4fVh0oQsGAJAYiaKERTkDOEVlibxc7LwW5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt><br>为保证生产者发送的数据，能可靠的发送到指定的topic，topic的每个partition收到生产者发送的数据后，都需要向生产者发送ack（确认收到），如果生产者收到ack，就会进行下一轮的发送，否则重新发送数据。</p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhrm8TXCvosZOiccDGNicKmuQNDQeh5h2rA2hfY6mF9DVXxrjXvicSw7lRsRg5ZatpYoT9YH4hF3FT14g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt><br>那么kafka什么时候向生产者发送ack？<br>确保follower（就相当于是partition的leader的副本，避免partition的leader挂了，导致无法获取数据）和leader同步完成，leader再发送ack给生产者，这样才能确保leader挂掉之后，能在follower中选举出新的leader后，数据不会丢失。kafka采用的是全部follower都返回ack后由leader发送给生产者。为了避免其中一个follower因为某种故障一直无法同步，leader会维护一个动态的节点列表，对于那些超过一定时间（时间可以自定义）还未返回ack的follower就移除列表。leader故障后，也会从这个列表中来选举新的leader。节点的选择主要是满足两点，一是与leader的网络通信时间应该低时延，二是与leader数据差距，消息条数默认是10000条</p><ol start="5"><li>Kafka如何保证消费数据的一致性？通过HW来保证。</li></ol><p>LEO：指每个follower的最大的offset。HW（高水位）：指消费者能见到的最大的offset，LSR队列中最小的LEO，也就是说消费者只能看到1~6的数据，后面的数据看不到，也消费不了。避免leader挂掉后，比如当前消费者消费8这条数据后，leader挂了，此时比如f2成为leader，f2根本就没有9这条数据，那么消费者就会报错，所以设计了HW这个参数，只暴露最少的数据给消费者，避免上面的问题。</p><ol start="6"><li><p>zookeeper在kafka中的作用。Kafka集群中有一个broker会被选举为controller，负责管理集群broker的上下线，所有的topic的分区副本分配和leader选举等工作。</p></li><li><p>增加分区</p></li></ol><p><code>./bin/kafka-topics.sh --alter  --zookeeper localhost:2181  --topic 主题名称  --partitions 分区数量 --replication-factor 2</code></p><ol start="8"><li>kafka分布式的情况下，如何保证消息的顺序?</li></ol><p>Kafka 中发送1条消息的时候，可以指定(topic, partition, key) 3个参数。partiton 和 key 是可选的。如果你指定了 partition，那就是所有消息发往同1个 partition，就是有序的。并且在消费端，Kafka 保证，1个 partition 只能被1个 consumer 消费。或者你指定 key（比如 order id），具有同1个 key 的所有消息，会发往同1个 partition。也是有序的。</p><ol start="9"><li>kafka 增加分区后，spark 怎么办<br>总的解决方案如下：</li></ol><ul><li>MTDirectKafkaInputDStream继承DirectKafkaInputDStream，override compute方法，在每次生成KafkaRDD时，更新currentOffsets中的分区信息。</li><li>在org.apache.spark.streaming.kafka路径下,新建一个KafkaUtils.scala文件，里面的代码直接将spark源码中的KafkaUtils源码复制过来。 修改新建的KafkaUtils.scala，将createDirectStream中new DirectKafkaInputDStream，替换为 new MTDirectKafkaInputDStream.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper</title>
      <link href="/2020/04/21/Zookeeper/"/>
      <url>/2020/04/21/Zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>ZooKeeper 集群中包含 Leader、Follower 以及 Observer 三个角色：</p><p>Leader：负责进行投票的发起和决议，更新系统状态，Leader 是由选举产生;<br>Follower： 用于接受客户端请求并向客户端返回结果，在选主过程中参与投票;<br>Observer：可以接受客户端连接，接受读写请求，写请求转发给 Leader，但 Observer 不参加投票过程，只同步 Leader 的状态，Observer 的目的是为了扩展系统，提高读取速度。</p><p><img src="https://images.weserv.nl/?url=https://upload-images.jianshu.io/upload_images/3017145-45ad27489478b2ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="pic1"></p><blockquote><p>Zookeeper 系统中只要集群中存在超过一半的节点（这里指的是投票节点即非 Observer 节点）能够正常工作，那么整个集群就能够正常对外服务。基于此，如果想搭建一个能够允许 N 台机器 down 掉的集群，那么就要部署一个由 2*N+1 台服务器构成的 ZooKeeper 集群。</p></blockquote><p>多增加节点对性能和写可用性有影响。节点数越多意味着 Leader 发出的提案需要更多的节点（半数以上）来接受提案，这必然增加提案 commit 的耗时，也就意味着对写请求的性能以及可用性影响比较大。还要考虑机房容灾情况，所以一般会跨机房部署，比如三机房部署，221分配节点，任意一个机房故障都不影响正常使用。把leader和follwer放在一起，都设有observer，由 client -&gt; observer -&gt; leader 的方式通信，可以降低投票节点的工作负载，降低 Leader 和 Follower 的不稳定性，从而提高整个集群的稳定性和可用性。</p><p>原子广播zab协议ZooKeeper Atomic Broadcast。仿照kafka保证数据可靠性那种方式</p><p><a href="https://blog.csdn.net/chouya7686/article/details/100661853?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">参考</a></p><p>Zab 协议实现的作用<br>1）使用一个单一的主进程（Leader）来接收并处理客户端的事务请求（也就是写请求），并采用了Zab的原子广播协议，将服务器数据的状态变更以 事务proposal （事务提议）的形式广播到所有的副本（Follower）进程上去。</p><p>2）保证一个全局的变更序列被顺序引用。<br>Zookeeper是一个树形结构，很多操作都要先检查才能确定是否可以执行，比如P1的事务t1可能是创建节点”/a”，t2可能是创建节点”/a/bb”，只有先创建了父节点”/a”，才能创建子节点”/a/b”。</p><p>为了保证这一点，Zab要保证同一个Leader发起的事务要按顺序被apply，同时还要保证只有先前Leader的事务被apply之后，新选举出来的Leader才能再次发起事务。</p><p>3）当主进程出现异常的时候，整个zk集群依旧能正常工作。</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器 Bloom Filter 2</title>
      <link href="/2020/04/01/Algorithm-8/"/>
      <url>/2020/04/01/Algorithm-8/</url>
      
        <content type="html"><![CDATA[<h2 id="Bloom-Filter-布隆过滤器"><a href="#Bloom-Filter-布隆过滤器" class="headerlink" title="Bloom Filter 布隆过滤器"></a>Bloom Filter 布隆过滤器</h2><p>之前的一版笔记 <a href="https://mxxt.github.io/2018/12/14/Algorithm-5/" target="_blank" rel="noopener">点此跳转</a></p><h3 id="1-什么是布隆过滤器"><a href="#1-什么是布隆过滤器" class="headerlink" title="1. 什么是布隆过滤器"></a>1. 什么是布隆过滤器</h3><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><p>解决目标：在海量数据的场景当中用来快速地判断某个元素在不在一个庞大的集合当中。</p><h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h3><p>比如在爬虫场景当中，我们需要记录下之前爬过的网站。我们要将之前的网址全部都存储在容器里，然后在遇到新网站的时候去判断是否已经爬过了。在这个问题当中，我们并不关心之前爬过的网站有哪些，我们只关心现在的网站有没有在之前出现过。也就是说之前出现过什么不重要，现在的有没有出现过才重要。</p><p>我们利用平衡树或者是Trie或者是AC自动机等数据结构和算法可以实现高效的查找，但是都离不开存储下所有的字符串。想象一下，一个网址大概上百个字符，大约0.1KB，如果是一亿个网址，就需要10GB了，如果是一百亿一千亿呢？显然这么大的规模就很麻烦了，今天要介绍的布隆过滤器就可以解决这个问题，而且不需要存储下原值，这是一个非常巧妙的做法，让我们一起来看下它的原理。</p><h3 id="3-算法"><a href="#3-算法" class="headerlink" title="3. 算法"></a>3. 算法</h3><ol><li>需要 k 个 hash 函数，依次传入关键字，返回值对应了 k 个不同的 hash 值</li><li>初始化一个长度为 m 的比特 bit 数组，所有值都置为0</li><li>通过 k 个不同的 hash 值对长度 m 取模，可以得到 n 个不同的下标值（n &lt;= k 有可能存在hash值不同，但是取模最后相同的情况），将数组中对应下标的值都由0置为1</li><li>拿到一个新的关键字，计算出它的 k 个 hash 值，得到 n 个下标，查询数组中对应下标的值是否是1，分两种情况<ul><li>如果有一个不是1，那么可以认为这个关键字一定没有存在过，并将其对应的下标都置为1</li><li>如果都是1，只能认为可能存在。因为可能存在两个关键字不同，但是hash值取模后的下标是一样的情况</li></ul></li></ol><h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h3><ul><li><p>优点</p><ul><li>不需要存储key，节省空间</li></ul></li><li><p>缺点</p><ul><li>可能存在，导致命中失败</li><li>无法删除，会导致结果越来越大，最终需要重建数组</li></ul></li></ul><h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 插入元素</span><br><span class="line">def BloomFilter(filter, value, hash_functions):</span><br><span class="line">    m = len(filter)</span><br><span class="line">    for func in hash_functions:</span><br><span class="line">        idx = func(value) % m</span><br><span class="line">        filter[idx] = True</span><br><span class="line">    return filter</span><br><span class="line">    </span><br><span class="line"># 判断元素</span><br><span class="line">def MemberInFilter(filter, value, hash_functions):</span><br><span class="line">    m = len(filter)</span><br><span class="line">    for func in hash_functions:</span><br><span class="line">        idx = func(value) % m</span><br><span class="line">        if not filter[idx]:</span><br><span class="line">            return False</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure><h3 id="6-应用"><a href="#6-应用" class="headerlink" title="6. 应用"></a>6. 应用</h3><p>利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，就可以不用进行后续昂贵的查询请求，比如</p><ol><li>Google 著名的分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的IO次数</li><li>Squid 网页代理缓存服务器在 cache digests 中使用了也布隆过滤器</li><li>Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据</li><li>SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间</li><li>Google Chrome浏览器使用了布隆过滤器加速安全浏览服务</li></ol><h3 id="7-改进后的布隆过滤器"><a href="#7-改进后的布隆过滤器" class="headerlink" title="7. 改进后的布隆过滤器"></a>7. 改进后的布隆过滤器</h3><p>由于传统布隆过滤器的每一位都只有0和1两个状态，并不支持删除操作，原因如下：</p><blockquote><p>假设 A 和 B 两个关键字对应的下标分别为 1、5 和 2、5，删除 A 后将下标 1、5 都置为0，那么查询 B 的时候由于 5 被置为0，其实是存在的，也会返回不存在。</p></blockquote><p>于是有了一个改进版布隆过滤器——Counting Bloom Filter。改进的地方是：数组每一位变成了计数器，插入时就让计数器 +1，删除时 -1。但是容易引起很大的资源浪费，同时有可能某一位多次删除操作后变成负数。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Bloom Filter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Bloom Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的Python运行时错误</title>
      <link href="/2020/04/01/Python-4/"/>
      <url>/2020/04/01/Python-4/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的Python运行时错误"><a href="#常见的Python运行时错误" class="headerlink" title="常见的Python运行时错误"></a>常见的Python运行时错误</h2><p>摘自 <a href="https://mp.weixin.qq.com/s/dx6bneAcR-PDWkQRY6JMBA" target="_blank" rel="noopener">菜鸟学Python 公众号</a></p><h3 id="1-SyntaxError：invalid-syntax"><a href="#1-SyntaxError：invalid-syntax" class="headerlink" title="1. SyntaxError：invalid syntax"></a>1. SyntaxError：invalid syntax</h3><ol><li>忘记在 if，for，def，elif，else，class 等声明末尾加冒号 <code>:</code></li><li>使用= 而不是 == <blockquote><p>= 是赋值操作符而 == 是等于比较操作</p></blockquote></li><li>尝试使用Python关键字作为变量名</li><li>不存在 ++ 或者 – 自增自减操作符</li></ol><h3 id="2-IndentationError：unexpected-indent-或-IndentationError：unindent-does-not-match-any-outer-indetation-level-或-IndentationError：expected-an-indented-block"><a href="#2-IndentationError：unexpected-indent-或-IndentationError：unindent-does-not-match-any-outer-indetation-level-或-IndentationError：expected-an-indented-block" class="headerlink" title="2. IndentationError：unexpected indent 或 IndentationError：unindent does not match any outer indetation level 或 IndentationError：expected an indented block"></a>2. IndentationError：unexpected indent 或 IndentationError：unindent does not match any outer indetation level 或 IndentationError：expected an indented block</h3><ol><li>错误的使用缩进量<blockquote><p>记住缩进增加只用在以<code>：</code>结束的语句之后，而之后必须恢复到之前的缩进格式。</p></blockquote></li></ol><h3 id="3-TypeError-‘list’-object-cannot-be-interpreted-as-an-integer"><a href="#3-TypeError-‘list’-object-cannot-be-interpreted-as-an-integer" class="headerlink" title="3. TypeError: ‘list’ object cannot be interpreted as an integer"></a>3. TypeError: ‘list’ object cannot be interpreted as an integer</h3><ol><li>在 for 循环语句中忘记调用 <code>len()</code><blockquote><p>通常你想要通过索引来迭代一个list或者string的元素，这需要调用 range() 函数。要记得返回len 值而不是返回这个列表。</p></blockquote></li></ol><h3 id="4-TypeError-‘str’-object-does-not-support-item-assignment"><a href="#4-TypeError-‘str’-object-does-not-support-item-assignment" class="headerlink" title="4. TypeError: ‘str’ object does not support item assignment"></a>4. TypeError: ‘str’ object does not support item assignment</h3><ol><li>尝试修改 string 的值，而 string 是一种不可变的数据类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">错误：</span><br><span class="line">spam = &apos;I have a pet cat.&apos;</span><br><span class="line">spam[13] = &apos;r&apos;</span><br><span class="line">print(spam)</span><br><span class="line"></span><br><span class="line">正确：</span><br><span class="line">spam = &apos;I have a pet cat.&apos;</span><br><span class="line">spam = spam[:13] + &apos;r&apos; + spam[14:]</span><br><span class="line">print(spam)</span><br></pre></td></tr></table></figure><h3 id="5-TypeError-Can’t-convert-‘int’-object-to-str-implicitly"><a href="#5-TypeError-Can’t-convert-‘int’-object-to-str-implicitly" class="headerlink" title="5. TypeError: Can’t convert ‘int’ object to str implicitly"></a>5. TypeError: Can’t convert ‘int’ object to str implicitly</h3><ol><li>尝试连接非字符串值与字符串，需通过 str(int) 来转化</li></ol><h3 id="6-SyntaxError-EOL-while-scanning-string-literal"><a href="#6-SyntaxError-EOL-while-scanning-string-literal" class="headerlink" title="6. SyntaxError: EOL while scanning string literal"></a>6. SyntaxError: EOL while scanning string literal</h3><ol><li>在字符串首尾忘记加引号</li></ol><h3 id="7-NameError-name-‘fooba’-is-not-defined"><a href="#7-NameError-name-‘fooba’-is-not-defined" class="headerlink" title="7. NameError: name ‘fooba’ is not defined"></a>7. NameError: name ‘fooba’ is not defined</h3><ol><li>变量或者函数名拼写错误</li><li>使用变量之前为声明改变量<blockquote><p>spam += 1等于spam = spam + 1，意味着 spam 需要有一个初始值</p></blockquote></li></ol><h3 id="8-AttributeError-‘str’-object-has-no-attribute-‘lowerr’"><a href="#8-AttributeError-‘str’-object-has-no-attribute-‘lowerr’" class="headerlink" title="8. AttributeError: ‘str’ object has no attribute ‘lowerr’"></a>8. AttributeError: ‘str’ object has no attribute ‘lowerr’</h3><ol><li>方法名拼写错误</li></ol><h3 id="9-IndexError-list-index-out-of-range"><a href="#9-IndexError-list-index-out-of-range" class="headerlink" title="9. IndexError: list index out of range"></a>9. IndexError: list index out of range</h3><ol><li>引用超过list最大索引</li></ol><h3 id="10-KeyError：’id’"><a href="#10-KeyError：’id’" class="headerlink" title="10. KeyError：’id’"></a>10. KeyError：’id’</h3><ol><li>使用不存在的字典键值<blockquote><p>在尝试获取字典键值的时候，先判断是否存在该键<br>id = data[“id”] if “id” in data.keys() else “” </p></blockquote></li></ol><h3 id="11-UnboundLocalError-local-variable-‘foobar’-referenced-before-assignment"><a href="#11-UnboundLocalError-local-variable-‘foobar’-referenced-before-assignment" class="headerlink" title="11. UnboundLocalError: local variable ‘foobar’ referenced before assignment"></a>11. UnboundLocalError: local variable ‘foobar’ referenced before assignment</h3><ol><li>在定义局部变量前在函数中使用局部变量（此时有与局部变量同名的全局变量存在）</li></ol><h3 id="12-TypeError-‘range’-object-does-not-support-item-assignment"><a href="#12-TypeError-‘range’-object-does-not-support-item-assignment" class="headerlink" title="12. TypeError: ‘range’ object does not support item assignment"></a>12. TypeError: ‘range’ object does not support item assignment</h3><ol><li>尝试使用 range()创建整数列表</li></ol><blockquote><p>range() 返回的是 “range object”，而不是实际的 list 值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">错误：</span><br><span class="line">spam = range(10)</span><br><span class="line">spam[4] = -1</span><br><span class="line"></span><br><span class="line">正确：</span><br><span class="line">spam = list(range(10))</span><br><span class="line">spam[4] = -1</span><br></pre></td></tr></table></figure><h3 id="13-TypeError-myMethod-takes-no-arguments-1-given"><a href="#13-TypeError-myMethod-takes-no-arguments-1-given" class="headerlink" title="13. TypeError: myMethod() takes no arguments (1 given)"></a>13. TypeError: myMethod() takes no arguments (1 given)</h3><ol><li>忘记为方法的第一个参数添加self参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo():</span><br><span class="line">  def myMethod():</span><br><span class="line">      print(&apos;Hello!&apos;)</span><br><span class="line">a = Foo()</span><br><span class="line">a.myMethod()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flume</title>
      <link href="/2020/03/31/Flume/"/>
      <url>/2020/03/31/Flume/</url>
      
        <content type="html"><![CDATA[<h2 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h2><h3 id="1-Flume"><a href="#1-Flume" class="headerlink" title="1. Flume"></a>1. Flume</h3><p>日志采集</p><ol><li>读数据 组件是 resource</li><li>缓存数据 channel 原因是读写速度的不一致，可以缓存在内存或本地文件，临时储存。看做一个数据的缓冲区（数据队列），它可以将事件暂存到内存中也可以持久化到本地磁盘上， 直到Sink处理完该事件</li><li>写数据 组件是 sink</li></ol><ul><li>source<ul><li>Exec Source：实时搜集一个文件中新增的数据，不支持断点续传</li><li>Spooling Directory Source：监控目录，新的文件，不支持断点续传</li><li>TailDir Source：flume1.7 新加入的组件，支持断点续传</li></ul></li><li>channel<ul><li>memory channel：保存在内存，速度快，可能丢数据</li><li>file channel：保存在磁盘的文件中，不会丢数据，速度慢</li><li>kafka channel：省去sink，下一级必须是kafka，即直接传给kafka</li></ul></li><li>sink</li></ul><p>拦截器</p><ul><li>ETL拦截器：清洗</li><li>类型拦截器：分类</li></ul><p>flume 把内部的格式统一封装为 event，保存一些描述信息和具体数据</p><p>拦截器的位置在Source和Channel之间，当我们为Source指定拦截器后，我们在拦截器中会得到event，根据需求我们可以对event进行保留还是抛弃，抛弃的数据不会进入Channel中。</p><p><img src="https://images.weserv.nl/?url=https://images2017.cnblogs.com/blog/999804/201711/999804-20171108132026106-567951153.png" alt></p><p>Flume可靠性在于Sink 必须在Event 被存入 Channel 后，或者，已经被传达到下一站agent里，又或者已经被存入外部数据目的地之后，才能把 Event 从 Channel 中 remove 掉。而Flume支持在本地保存一份文件 channel 作为备份，而memory channel 将event存在内存 queue 里，速度快，但丢失的话无法恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">配置写到HDFS</span><br><span class="line">hdfs.rollCount = 10 // 相当于event采集到10条数据就写一次</span><br><span class="line">hdfs.batchSize = 100 // 相当于event在写数据的时候一批的数量</span><br><span class="line">hdfs.fileType = SequenceFile // 默认是SequenceFile，还有 DataStream（原始数据是什么，写完也是什么）</span><br><span class="line"></span><br><span class="line">tier1.sinks.hdfsSink_26.hdfs.path = hdfs://nameservice/user/flume/kafka/hehe/%&#123;topic&#125;/%Y%m%d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Flume </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Flume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase</title>
      <link href="/2020/03/31/HBase-1/"/>
      <url>/2020/03/31/HBase-1/</url>
      
        <content type="html"><![CDATA[<h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><h3 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h3><p>rowkey 行键（自定义，但是必须有，而且唯一）；列族，列族里储存的是 k,v 的形式，并且 v 可以储存多个不同的值，根据时间戳来判断版本，默认返回最近更新的版本；根据 rowkey 的范围来划分不同的 region 区域，然后由不同的 hbase 服务器（region server）来管理不同的 region，这样可以缓解服务器的压力；表在 hdfs 存储时，会按照 region 来创建不同的文件夹，然后再根据列族划分更细的文件夹，最后才是最终文件数据（如果数据量很小的话，会直接保存在 region server 下的一个 memstore 里，另外热数据也会保存在 memstore 里，保证快速查找，缓存空间满了后会写入文件）</p><p>region server 会持续向 zookeeper 汇报，如果有其中一个 region server 挂了，会有一个 master 来重启 region server，但是如果master挂了，region server没挂，不影响用户获取数据。一般会设置两个master，一个是active，一个是standby，组成一个解决单点故障的机制 HA：高可用</p><p>在 hbase 的系统表里，有一个 hbase:meta，里面保存了所有的用户表的region信息。用户去查询数据的时候，会先去zookeeper（有一个 meta-region-server）找到 meta 表所在的 region server，然后去 region 对应的 server 里查找数据 </p><p>存储的数据没有数据类型，都是二进制数组 byte[]，所以代码进行操作时要做数据转换</p><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><p>create tablename, 列族1, 列族2</p><p>put tablename, rowkey, 列族1:key, value</p><p>get tablename, rowkey</p><p>delete 只能删一个cell，也就是列族下的某一个k,v，deleteall 可以删除一行</p><h3 id="3-列族的布隆过滤器"><a href="#3-列族的布隆过滤器" class="headerlink" title="3. 列族的布隆过滤器"></a>3. 列族的布隆过滤器</h3><p>在构造一个列族定义时，可以设置列族的布隆过滤器类型。<br>HColumnDescriptor hColumnDescriptor = new HColumnDescriptor(“xxx”);<br>hColumnDescriptor.setBloomFilterType(BloomType.ROW);<br>在对表的列族的某个key进行更新的时候，可能会导致hdfs中/hbase/data/default/tablename/region0/列族/ 目录下有很多文件，通过设置 BloomType 可以在查询时，过滤出不存在查询的key的文件，只从剩余文件里返回最新版本的那个value，从而提高效率</p><h3 id="4-查询某一行到某一行"><a href="#4-查询某一行到某一行" class="headerlink" title="4. 查询某一行到某一行"></a>4. 查询某一行到某一行</h3><p>方法默认范围是左闭右开，如果要右闭的话可以在后面添加一个字节0<br>Scan scan = new Scan(“10”.toBytes(), “10000\000”.toBytes());</p><p>前面的0是阿拉伯符号0，后面\000，添加的是真正的数字0</p><p>String a = “000”;<br>String b = “000\0”;<br>byte[] bt1 = a.getBytes[]; // [48, 48, 48] ACSII<br>byte[] bt2 = b.getBytes[]; // [48, 48, 48, 0]</p><h3 id="5-大批量导入数据-bulk-load"><a href="#5-大批量导入数据-bulk-load" class="headerlink" title="5. 大批量导入数据 bulk-load"></a>5. 大批量导入数据 bulk-load</h3><h3 id="6-mapreduce-分析-hbase"><a href="#6-mapreduce-分析-hbase" class="headerlink" title="6. mapreduce 分析 hbase"></a>6. mapreduce 分析 hbase</h3><h3 id="7-创建二级索引-solr"><a href="#7-创建二级索引-solr" class="headerlink" title="7. 创建二级索引 solr"></a>7. 创建二级索引 solr</h3><h3 id="8-HBase提供了多个客户端参数设置超时"><a href="#8-HBase提供了多个客户端参数设置超时" class="headerlink" title="8. HBase提供了多个客户端参数设置超时"></a>8. HBase提供了多个客户端参数设置超时</h3><p>hbase.rpc.timeout<br>一次RPC请求的超时时间，如果某次RPC时间超过该值，客户端就会主动关闭socket。这个配置超时异常经常发生在大量高并发读写业务或者服务器端发生了比较严重的Full GC等场景下，导致某些请求无法得到及时处理，超过了时间间隔。该值默认大小为60000ms，即1min</p><p>hbase.client.operation.timeout<br>该参数表示HBase客户端发起一次数据操作直至得到响应之间总的超时时间，数据操作类型包括get、append、increment、delete、put等。很显然，hbase.rpc.timeout表示一次RPC的超时时间，而hbase.client.operation.timeout则表示一次操作的超时时间，有可能包含多个RPC请求。举个例子说明，比如一次Put请求，客户端首先会将请求封装为一个caller对象，该对象发送RPC请求到服务器，假如此时因为服务器端正好发生了严重的Full GC，导致这次RPC时间超时引起SocketTimeoutException，对应的就是hbase.rpc.timeout。那假如caller对象发送RPC请求之后刚好发生网络抖动，进而抛出网络异常，HBase客户端就会进行重试，重试多次之后如果总操作时间超时引起SocketTimeoutException，对应的就是hbase.client.operation.timeout。</p><p>hbase.client.scanner.timeout.period<br>默认为60000ms<br>在scan过程中RegionServer端偶尔抛出leaseException，是怎么回事？<br>看到leaseException就会想到租约机制，的确，HBase内部在一次完整的scan操作中引入了租约机制。为什么需要租约机制？这和整个scan操作流程有莫大的关系，上文讲到，一次完整的scan通常会被拆分为多个RPC请求，实际实现中，RegionServer接收到第一次RPC请求之后，会为该scan操作生成一个全局唯一的id，称为scanId。除此之外，RegionServer还会进行大量的准备工作，构建整个scan体系，构造需要用到的所有对象，后续的RPC请求只需要携带相同的scanId作为标示就可以直接利用这些已经构建好的资源进行检索。也就是说，在整个scan过程中，客户端其实都占用着服务器端的资源，此时如果此客户端意外宕机，是否就意味着这些资源永远都不能得到释放呢？租约机制就是为了解决这个问题。RegionServer接收到第一次RPC之后，除了生成全局唯一的scanId之外还会生成一个携带有超时时间的lease，超时时间可以通过参数hbase.regionserver.lease.period配置，一旦在超时时间内后续RPC请求没有到来（比如客户端处理太慢），RegionServer就认为客户端出现异常，此时会将该lease销毁并将整个scan所持有的资源全部释放，客户端在处理完成之后再发后续的RPC过来，检查到对应的lease已经不存在</p><p>To make sure the timeout period is not too short, you can configure hbase.cells.scanned.per.heartbeat.check to a minimum number of cells that must be scanned before a timeout check occurs. The default value is 10000. A smaller value causes timeout checks to occur more often. 为确保超时时间(hbase.client.scanner.timeout.period)不会太短，可以将hbase.cells.scanned.per.heartbeat.check配置为发生超时检查前必须扫描的最小数量的单元。 默认值为10000.较小的值会导致更频繁地进行超时检查。</p><p>Confiuration conf = HBaseConfiguration.create();<br>conf.setInt(“hbase.rpc.timeout”,20000);<br>conf.setInt(“hbase.client.operation.timeout”,30000);<br>conf.setInt(“hbase.client.scanner.timeout.period”,20000);<br>HTable table = new HTable(conf,”tableName”);</p><p>重试机制<br>客户端参数优化实践</p><ol><li>hbase.client.pause:默认为100，可以减少为50</li><li>hbase.client.retries.number:默认为31，可以减少为21</li></ol><p>［100，200，300，500，1000，2000，4000，10000，10000，10000，10000，20000，20000，…,20000］<br>默认情况下，客户端将在448s内重试30次，然后放弃连接到集群</p><p>［50，100，150，250，500，1000，2000，5000，5000，5000，5000，10000，10000，…，10000］<br>客户端将会在2min内重试20次，然后放弃连接到集群</p><p>在构造线程时，有一个默认关闭的特性：当hbase.client.backpressure.enabled(默认值为false，ServerStatisticTracker:63，AsyncProcess:629)为ture时，客户端会根据服务端压力和客户端配置的策略，生成带延时的Runnable对象，用以动态缓解服务端压力</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker启动Mysql镜像</title>
      <link href="/2020/03/14/Docker-4/"/>
      <url>/2020/03/14/Docker-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker启动Mysql镜像"><a href="#Docker启动Mysql镜像" class="headerlink" title="Docker启动Mysql镜像"></a>Docker启动Mysql镜像</h2><p><strong>管理员权限！！！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">-p 进行端口映射</span><br><span class="line">-e 设置mysql root密码，否则会启动报错</span><br></pre></td></tr></table></figure><p>其他几个高级操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-v /my/custom:/etc/mysql/conf.d</span><br><span class="line">把主机 /my/custom 文件夹映射到 mysqlDocker 容器中的 /etc/mysql/conf.d 文件夹下，这样如果之后要修改 mysql 的配置文件，只需把文件放在 /my/custom 目录下即可，会自动进行合并</span><br><span class="line"></span><br><span class="line">--character-set-server=utf8mb4 --collection-server=utf8mb4_unicode_ci</span><br><span class="line">设置编码格式</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Flask框架</title>
      <link href="/2020/02/10/Flask-1/"/>
      <url>/2020/02/10/Flask-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Python之Flask框架"><a href="#Python之Flask框架" class="headerlink" title="Python之Flask框架"></a>Python之Flask框架</h2><h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h3><ul><li>DemandSys<ul><li>blueprints  </li><li>config</li><li>models</li><li>static</li><li>templates</li><li><code>app.py</code></li></ul></li></ul><p>blueprints – “蓝图”文件夹下存放各个功能模块的实现文件，每一个功能“蓝图”都需要在 <code>app.py</code> 文件中进行注册 </p><p>config – 存放各种配置文件。需要注意的是，启动项目时的位置在<code>app.py</code>同级，所以打开配置文件时，路径填写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;./config/dbconf.json&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f</span><br></pre></td></tr></table></figure><p>models – 存放各种模型（类）文件</p><p>static – 存放所有的js、css文件</p><p>templates – 存放所有的页面</p><h3 id="2-开发思路"><a href="#2-开发思路" class="headerlink" title="2. 开发思路"></a>2. 开发思路</h3><h4 id="2-1-关于蓝图的使用"><a href="#2-1-关于蓝图的使用" class="headerlink" title="2.1 关于蓝图的使用"></a>2.1 关于蓝图的使用</h4><p>Auth.py文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 第一个auth_bp是在url_for中调用使用的，第二个auth_bp是在网页地址栏中呈现的</span><br><span class="line"># action=&quot;&#123;&#123; url_for(&quot;auth_bp.login&quot;) &#125;&#125;&quot; 此处的login指的是方法名</span><br><span class="line"># http://127.0.0.1:5000/auth_bp/login 此处的login指的是route后面填写的名称</span><br><span class="line">auth_bp = Blueprint(&quot;auth_bp&quot;, __name__, url_prefix=&quot;/auth_bp&quot;)</span><br><span class="line"></span><br><span class="line">@auth_bp.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def login():</span><br><span class="line">    。。。</span><br></pre></td></tr></table></figure><p>app.py文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注册认证类模块蓝图，包括登录、注册功能</span><br><span class="line">app.register_blueprint(auth_bp)</span><br></pre></td></tr></table></figure><h4 id="2-2-全局变量"><a href="#2-2-全局变量" class="headerlink" title="2.2 全局变量"></a>2.2 全局变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from flask import current_app</span><br><span class="line"></span><br><span class="line"># 直接在current_app中创建一个全局变量，并且对其赋值即可</span><br><span class="line">current_app.curUser = curUser</span><br></pre></td></tr></table></figure><h4 id="2-3-页面跳转的通用方法"><a href="#2-3-页面跳转的通用方法" class="headerlink" title="2.3 页面跳转的通用方法"></a>2.3 页面跳转的通用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 针对iframe方式来跳转</span><br><span class="line"># 根据传递的参数不同，跳转到对应的页面</span><br><span class="line">@app.route(&apos;/iframe/&lt;name&gt;&apos;, methods=[&apos;GET&apos;])</span><br><span class="line">def iframeRouter(name):</span><br><span class="line">    return render_template(name, curUser=current_app.curUser, curDomainRole=current_app.curDomainRole)</span><br></pre></td></tr></table></figure><blockquote><p>这个方法有一个问题是，它是整个项目的路由，会拦截前端页面中所有的 <figure class="highlight plain"><figcaption><span>onclick </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例子： 点击编辑按钮的时候要传递用户id，后台获取用户id对应的所有的用户信息后，跳转到编辑页面，并初始化文本框信息。在加了路由之后，a标签的点击跳转事件就不会跳到后台对应的方法，而是被 `iframeRouter` 方法拦截，会报错。折中的解决方法就是点击按钮之后，跳转到js方法，通过ajax将用户信息保存到全局变量，返回成功后，打开编辑页面，写一个 `window.onload` 方法，获取到全局变量，返回成功后，初始化文本框</span><br><span class="line"></span><br><span class="line">#### 2.4 redirect 和 render_template</span><br><span class="line"></span><br><span class="line">- redirect：方法之间的调用</span><br><span class="line">- render_template：跳转到对应的页面，并可以在后面添加传递的参数</span><br><span class="line"></span><br><span class="line">#### 2.5 flask 获取前端传过来的数据</span><br><span class="line"></span><br><span class="line">首先需要在方法名上添加注解，比如</span><br></pre></td></tr></table></figure></p></blockquote><p>@auth_bp.route(‘/login’, methods=[‘POST’])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">之后通过`request.form[&quot;xxx&quot;]`即可获取到对应的值</span><br><span class="line"></span><br><span class="line">### 3. 异常</span><br><span class="line"></span><br><span class="line">#### 3.1 启动异常</span><br></pre></td></tr></table></figure><p>[Errno 48] Address already in use<br>解决端口占用：<br>sudo lsof -i:5000<br>kill -9 端口号</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之SqlAlchemy</title>
      <link href="/2020/02/10/SqlAlchemy-1/"/>
      <url>/2020/02/10/SqlAlchemy-1/</url>
      
        <content type="html"><![CDATA[<h2 id="SqlAlchemy"><a href="#SqlAlchemy" class="headerlink" title="SqlAlchemy"></a>SqlAlchemy</h2><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><p>之前使用的是 pymysql 插件，类似于 JDBC 的连接方式，通过写大量的 sql 语句来进行关联表、筛选字段等功能。SqlAlchemy 和 Flask-SqlAlchemy（后者是针对于 Flask 框架做了进一步的优化）则是通过类似于 Mybatis 的方式，将模型与表进行匹配，将 sql 中的关键字提取成方法，以此来获取数据。使用下来的话，官方文档给的例子或者说明并不是很清楚，需要多去网上找例子。</p><blockquote><p>Flask-SqlAlchemy 通过配置可以自动管理多个数据源，比如默认数据源和数据源2，数据源3，在model里添加<code>__bind_key__=&quot;数据源别名&quot;</code>来自动在query执行时切换数据源</p></blockquote><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><h4 id="2-1-数据库连接"><a href="#2-1-数据库连接" class="headerlink" title="2.1 数据库连接"></a>2.1 数据库连接</h4><p>通过读取配置文件获取参数，然后创建一个连接引擎，这个引擎会返回一个session对话，通过这个对话来对数据库进行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># max_overflow: # 超过连接池大小外最多创建的连接</span><br><span class="line"># pool_size: # 连接池大小</span><br><span class="line">def getSession():</span><br><span class="line">    host, port, user, password, db = Conf.getDbConf()</span><br><span class="line">    linkStr = &quot;mysql+pymysql://&quot; + user + &quot;:&quot; + password + &quot;@&quot; + host + &quot;:&quot; + str(port) + &quot;/&quot; + db</span><br><span class="line">    engine = create_engine(linkStr, max_overflow=6, pool_size=6)</span><br><span class="line">    DBSession = sessionmaker(bind=engine)</span><br><span class="line">    session = DBSession()</span><br><span class="line">    return session</span><br></pre></td></tr></table></figure><h4 id="2-2-模型与表的关联"><a href="#2-2-模型与表的关联" class="headerlink" title="2.2 模型与表的关联"></a>2.2 模型与表的关联</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import Column, Integer, String</span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line"></span><br><span class="line">user_base = declarative_base()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对应 t_user 表的定义</span><br><span class="line">class User(user_base):</span><br><span class="line">    __tablename__ = &apos;t_user&apos; # 这里是数据库中对应表名</span><br><span class="line">    id = Column(Integer, primary_key=True)</span><br><span class="line">    itcode = Column(String(50))</span><br><span class="line">    username = Column(String(50))</span><br><span class="line">    password = Column(String(50))</span><br><span class="line">    truename = Column(String(50))</span><br><span class="line">    email = Column(String(50))</span><br><span class="line">    is_active = Column(String(10))</span><br></pre></td></tr></table></figure><h4 id="2-3-增"><a href="#2-3-增" class="headerlink" title="2.3 增"></a>2.3 增</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 如果表里存在自增字段，那么可以通过下面方式插入：创建一个类的实例，并显式写出每个字段的赋值，之后获取到session会话实例，将类的实例将入到会话中，并提交，最后将会话关闭</span><br><span class="line"># 除查询外，其他三种都需要执行 session.commit() 来提交操作</span><br><span class="line">new_user = User(itcode=itcode, username=username, password=password, truename=truename, email=email, is_active=is_active)</span><br><span class="line">session = db.getSession()</span><br><span class="line">session.add(new_user)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h4 id="2-4-删"><a href="#2-4-删" class="headerlink" title="2.4 删"></a>2.4 删</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 简单来看这也算是一种查询：查询 User 类对应的数据表，过滤出 id 等于 del_id 的数据，调用 delete() 方法进行删除</span><br><span class="line"># 这里的 del_res 返回的是受影响的总行数</span><br><span class="line">del_res = session.query(User).filter(User.id == del_id).delete()</span><br></pre></td></tr></table></figure><h4 id="2-5-query"><a href="#2-5-query" class="headerlink" title="2.5 query"></a>2.5 query</h4><p><code>session.query()</code> 括号内可以是某个类，比如 <code>session.query(User)</code> 返回的结果就是 User 这个类对应的表的所有字段；也可以是类的字段，比如 <code>session.query(User.id, User.username)</code> 返回的结果就是 id 和 username 两个字段</p><h4 id="2-6-join"><a href="#2-6-join" class="headerlink" title="2.6 join"></a>2.6 join</h4><p>目前用到的表和表之间关联有两种方式</p><ul><li>直接在类中添加外键定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import Column, Integer, String, ForeignKey</span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from model.User import User</span><br><span class="line"></span><br><span class="line">domain_base = declarative_base()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对应 t_domain 表的定义</span><br><span class="line">class Domain(domain_base):</span><br><span class="line">    __tablename__ = &apos;t_domain&apos;</span><br><span class="line">    id = Column(Integer, primary_key=True)</span><br><span class="line">    name = Column(String(50))</span><br><span class="line">    region = Column(String(50))</span><br><span class="line">    responser_id = Column(Integer, ForeignKey(User.id)) # 业务域负责人</span><br><span class="line">    responser_truename = Column(String(50))</span><br><span class="line">    is_active = Column(String(10))</span><br></pre></td></tr></table></figure><p>这种定义方式存在找不到或者不全的情况，更倾向于第二种</p><ul><li>在 join 时显示写出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res = session \</span><br><span class="line">.query(UserDomainRole.id, UserDomainRole.user_id, User.truename,</span><br><span class="line">UserDomainRole.domain_id, Domain.name.label(&quot;domain_name&quot;),</span><br><span class="line">UserDomainRole.role_id, Role.name.label(&quot;role_name&quot;),</span><br><span class="line">UserDomainRole.create_time, UserDomainRole.update_time,</span><br><span class="line">UserDomainRole.is_active) \</span><br><span class="line">.join(UserDomainRole, User.id == UserDomainRole.user_id) \</span><br><span class="line">.join(Domain, Domain.id == UserDomainRole.domain_id) \</span><br><span class="line">.join(Role, Role.id == UserDomainRole.role_id) \</span><br><span class="line">.filter(UserDomainRole.id == query_id).all()</span><br></pre></td></tr></table></figure><h4 id="2-7-别名"><a href="#2-7-别名" class="headerlink" title="2.7 别名"></a>2.7 别名</h4><p>如果 query 中存在多个重复字段，那么可以在后面添加 <code>label(&quot;别名&quot;)</code> 的方式来进行区分</p><h4 id="2-8-filter"><a href="#2-8-filter" class="headerlink" title="2.8 filter"></a>2.8 filter</h4><p>如果是已确定的条件，那么通过 <code>session.query().filter(User.id == query_id)</code> 这样显式写出来没问题，但是多数情况下，类似于 Mybatis 中 <code>where 1 = 1</code> 后跟着 if 判断语句，并不清楚会有几个查询条件需要放到 filter 中，这时候需要换成下面的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 需要 filter 中遍历的参数</span><br><span class="line">params = list()</span><br><span class="line">if user_id != &quot;&quot;:</span><br><span class="line">params.append(类.user_id == user_id)</span><br><span class="line">if domain_id != &quot;&quot;:</span><br><span class="line">params.append(类.domain_id == domain_id)</span><br><span class="line">if role_id != &quot;&quot;:</span><br><span class="line">params.append(类.role_id == role_id)</span><br><span class="line">if is_active != &quot;&quot;:</span><br><span class="line">params.append(类.is_active == is_active)</span><br><span class="line"></span><br><span class="line">session = db.getSession()</span><br><span class="line">res = session.query(字段).join().join().filter(*params).filter().all()</span><br><span class="line"># 可以同时写多个 filter 条件来过滤</span><br><span class="line"># 将params传到 filter 中，会自动进行赋值，注意要用 *params</span><br><span class="line"># 最后调用 all() 方法返回所有数据，first() 返回第一条数据， one() 返回一条数据</span><br></pre></td></tr></table></figure><h4 id="2-9-分页"><a href="#2-9-分页" class="headerlink" title="2.9 分页"></a>2.9 分页</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 通过 limit 和 offset 来实现分页</span><br><span class="line"># limit(10) 表示返回10条数据</span><br><span class="line"># offset(lower) 表示把下标移动到 lower 的位置，然后从下一个位置开始返回</span><br><span class="line">res = session.query().join().filter().limit(10).offset(lower).all()</span><br></pre></td></tr></table></figure><h4 id="2-10-排序"><a href="#2-10-排序" class="headerlink" title="2.10 排序"></a>2.10 排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 order_by() 方法来进行数据排序，可以添加多个字段排序规则</span><br><span class="line">order_by(类1.字段1, 类2.字段2.desc())</span><br></pre></td></tr></table></figure><h4 id="2-11-改"><a href="#2-11-改" class="headerlink" title="2.11 改"></a>2.11 改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 和 filter 中查询条件一样，多数情况下不知道更新哪几个字段，需要动态赋值</span><br><span class="line"># 和 filter 不一样的是，filter(*params) 和 update(params)</span><br><span class="line">params = &#123;&#125;</span><br><span class="line">if user_id != &quot;&quot;:</span><br><span class="line">params[&quot;user_id&quot;] = user_id</span><br><span class="line">if domain_id != &quot;&quot;:</span><br><span class="line">params[&quot;domain_id&quot;] = domain_id</span><br><span class="line">if role_id != &quot;&quot;:</span><br><span class="line">params[&quot;role_id&quot;] = role_id</span><br><span class="line">if is_active != &quot;&quot;:</span><br><span class="line">params[&quot;is_active&quot;] = is_active</span><br><span class="line">update_res = session.query(类).filter(类.id == query_id).update(params)</span><br></pre></td></tr></table></figure><h4 id="2-12-聚合函数使用"><a href="#2-12-聚合函数使用" class="headerlink" title="2.12 聚合函数使用"></a>2.12 聚合函数使用</h4><h5 id="2-12-1-group-concat"><a href="#2-12-1-group-concat" class="headerlink" title="2.12.1 group_concat"></a>2.12.1 group_concat</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 对于分组来说，可以直接调用 group_by() 方法来指定按照哪些字段来分组</span><br><span class="line"># 对于像 group_concat() 这样的函数使用，需要引用 func</span><br><span class="line">from sqlalchemy.sql import func</span><br><span class="line"></span><br><span class="line">res = session \</span><br><span class="line">.query(User.id, User.itcode, User.username, User.password, User.truename, User.email,</span><br><span class="line">func.group_concat(UserDomainRole.domain_id), func.group_concat(Domain.name),</span><br><span class="line">func.group_concat(Domain.responser_id), func.group_concat(Domain.responser_truename),</span><br><span class="line">func.group_concat(UserDomainRole.role_id), func.group_concat(Role.name)) \</span><br><span class="line">.join(UserDomainRole, User.id == UserDomainRole.user_id) \</span><br><span class="line">.join(Domain, Domain.id == UserDomainRole.domain_id) \</span><br><span class="line">.join(Role, Role.id == UserDomainRole.role_id) \</span><br><span class="line">.filter(User.id == query_id, UserDomainRole.is_active == &apos;Y&apos;, Domain.is_active == &apos;Y&apos;,</span><br><span class="line">Role.is_active == &apos;Y&apos;) \</span><br><span class="line">.group_by(User.id, User.itcode, User.username, User.password, User.truename, User.email).all()</span><br></pre></td></tr></table></figure><h5 id="2-12-2-count"><a href="#2-12-2-count" class="headerlink" title="2.12.2 count"></a>2.12.2 count</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 虽然有直接的 count() 方法，但是在数据量大的时候，会很慢，所以需要换一种方式</span><br><span class="line">first = session.query(UserDomainRole.id, User.id, Domain.id, Role.id) \</span><br><span class="line">.join(UserDomainRole, User.id == UserDomainRole.user_id)\</span><br><span class="line">.join(Domain, Domain.id == UserDomainRole.domain_id)\</span><br><span class="line">.join(Role, Role.id == UserDomainRole.role_id)\</span><br><span class="line">.filter(*params)\</span><br><span class="line">.filter(Domain.is_active == &apos;Y&apos;, Role.is_active == &apos;Y&apos;)</span><br><span class="line">totalCount = first.with_entities(func.count(UserDomainRole.id)).scalar()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习摘要--关于日志框架</title>
      <link href="/2020/01/05/SpringBoot-10/"/>
      <url>/2020/01/05/SpringBoot-10/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-学习摘要–关于日志框架"><a href="#Spring-Boot-学习摘要–关于日志框架" class="headerlink" title="Spring Boot 学习摘要–关于日志框架"></a>Spring Boot 学习摘要–关于日志框架</h2><p>学习教程来自：B站 尚硅谷</p><h3 id="1-关于日志框架"><a href="#1-关于日志框架" class="headerlink" title="1. 关于日志框架"></a>1. 关于日志框架</h3><p>市面上有 N 多个日志工具包，为了能通用，会有专门的抽象类，所以需要用的时候，要先选择一个抽象类的包，然后选择对应的一个实现类的包</p><p>抽象类：JCL 、 SLF4J</p><p>实现类：Log4J 、 JUL 、 Log4J2 、 Logback</p><p>Spring Boot 选择是的 SLF4J 和 Logback</p><blockquote><p>抽象类也就是门面，只是在.java文件中调用的类（包），底层实现还是用的 Logback</p></blockquote><h4 id="1-SLF4J-的使用"><a href="#1-SLF4J-的使用" class="headerlink" title="1. SLF4J 的使用"></a>1. SLF4J 的使用</h4><p>在开发的时候，应该调用日志抽象层中的方法，会自动适配到实现层的方法</p><p>在系统里导入 slf4j 和 logback 的 jar 包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class); // 参数为当前类</span><br><span class="line">    logger.info(&quot;Hello World&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.slf4j.org/images/concrete-bindings.png" alt></p><p>PS：如果 slf4j 要调用 log4j 的实现方法，因为 slf4j 出现的早，没有做 log4j 的适配，所以需要再导入一个 slf4j-log412.jar，来自动匹配到 log4j 的方法</p><p>每一个日志框架都有自己的配置文件。如果要是用slf4j的话，<strong>配置文件还是需要用日志实现框架自己本身的配置文件</strong>。</p><h4 id="2-如果有多个系统，每个系统用的日志框架都不一致，如何统一修改为-slf4j-？"><a href="#2-如果有多个系统，每个系统用的日志框架都不一致，如何统一修改为-slf4j-？" class="headerlink" title="2. 如果有多个系统，每个系统用的日志框架都不一致，如何统一修改为 slf4j ？"></a>2. 如果有多个系统，每个系统用的日志框架都不一致，如何统一修改为 slf4j ？</h4><p>将系统中不同的日志框架包按照下图来替换</p><p><img src="http://www.slf4j.org/images/legacy.png" alt></p><h4 id="3-slf4j-的使用"><a href="#3-slf4j-的使用" class="headerlink" title="3. slf4j 的使用"></a>3. slf4j 的使用</h4><ol><li>日志的级别 由低到高<br>可以调整日志的级别，只打印大于等于该级别的日志</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger.trace(&quot;...&quot;)</span><br><span class="line">logger.debug(&quot;...&quot;)</span><br><span class="line">logger.info(&quot;...&quot;)</span><br><span class="line">logger.warn(&quot;...&quot;)</span><br><span class="line">logger.error(&quot;...&quot;)</span><br></pre></td></tr></table></figure><p>Springboot 默认输出的是 info 级别的日志，即只输出 info、warn、error 这三个级别的日志。可以在 <code>application.properties</code> 文件里修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.具体的某一个包或类=trace/debug/info/warn/error</span><br></pre></td></tr></table></figure><ol start="2"><li>指定输出日志文件 在 application.properties 文件中配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.file=</span><br><span class="line">logging.path=</span><br></pre></td></tr></table></figure><ul><li>如果没有配置这两项，日志只在控制台输出</li><li>只配置 <code>logging.file</code>：会在当前项目下生成日志文件</li><li>只配置 <code>logging.path</code>：会在磁盘根路径下创建文件夹，并且使用 <code>spring.log</code> 作为默认文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在控制台输出的日志的格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logging&#123;50&#125; - %msg%n</span><br><span class="line"># 指定文件中日志的输出的格式</span><br><span class="line">logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss&#125; -- [%thread] -- %-5level -- %logging&#123;50&#125; -- %msg%n</span><br></pre></td></tr></table></figure><ol start="3"><li>其他配置 添加新的配置文件</li></ol><p>如果是使用 <code>Logback</code> 日志框架，添加 <code>logback.xml</code> 来指定配置，但是更推荐使用 <code>logback-spring.xml</code> 文件来指定配置，这时候日志框架不会直接加载配置文件，而是由 SpringBoot 解析日志配置，这样就可以使用 springProfile 功能，通过指定运行环境（dev/prod）来实现切换输出日志形式。</p><p>如何切换运行环境：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># application.properties 文件中添加</span><br><span class="line">spring.profile.active=dev/prod</span><br></pre></td></tr></table></figure><p>附：logback.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- %m输出的信息,%p日志级别,%t线程名,%d日期,%c类的全名,%i索引【从数字0开始递增】,,, --&gt;</span><br><span class="line">    &lt;!-- appender是configuration的子节点，是负责写日志的组件。 --&gt;</span><br><span class="line">    &lt;!-- ConsoleAppender：把日志输出到控制台 --&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;TRACE&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d %p (%file:%line\)- %m%n&lt;/pattern&gt;</span><br><span class="line">            &lt;!-- 控制台也要使用UTF-8，不要使用GBK，否则会中文乱码 --&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;!-- RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt;</span><br><span class="line">    &lt;!-- 以下的大概意思是：1.先按日期存日志，日期变了，将前一天的日志文件名重命名为XXX%日期%索引，新的日志仍然是sys.log --&gt;</span><br><span class="line">    &lt;!--             2.如果日期没有发生变化，但是当前日志的文件大小超过1KB时，对当前日志进行分割 重命名--&gt;</span><br><span class="line">    &lt;appender name=&quot;syslogInfo&quot;</span><br><span class="line">              class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;info&lt;/level&gt;</span><br><span class="line">            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;File&gt;/Users/mxxct/Desktop/log/info/info.log&lt;/File&gt;</span><br><span class="line">        &lt;!-- rollingPolicy:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 --&gt;</span><br><span class="line">        &lt;!-- TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动 --&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!-- 活动文件的名字会根据fileNamePattern的值，每隔一段时间改变一次 --&gt;</span><br><span class="line">            &lt;!-- 文件名：log/sys.2017-12-05.0.log --&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;/Users/mxxct/Desktop/log/info/%d/credit.%d.%i.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;!-- 每产生一个日志文件，该日志文件的保存期限为30天 --&gt;</span><br><span class="line">            &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;</span><br><span class="line">                &lt;!-- maxFileSize:用于判断日志切割的文件大小，默认值是10MB --&gt;</span><br><span class="line">                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;!-- pattern节点，用来设置日志的输入格式 --&gt;</span><br><span class="line">            &lt;pattern&gt;</span><br><span class="line">                %d %p (%file:%line\)- %m%n</span><br><span class="line">            &lt;/pattern&gt;</span><br><span class="line">            &lt;!-- 记录日志的编码 --&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;appender name=&quot;syslogError&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;error&lt;/level&gt;</span><br><span class="line">            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;File&gt;/Users/mxxct/Desktop/log/error/error.log&lt;/File&gt;</span><br><span class="line">        &lt;!-- rollingPolicy:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 --&gt;</span><br><span class="line">        &lt;!-- TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动 --&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!-- 活动文件的名字会根据fileNamePattern的值，每隔一段时间改变一次 --&gt;</span><br><span class="line">            &lt;!-- 文件名：log/sys.2017-12-05.0.log --&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;/Users/mxxct/Desktop/log/error/%d/error.%d.%i.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;!-- 每产生一个日志文件，该日志文件的保存期限为30天 --&gt;</span><br><span class="line">            &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;</span><br><span class="line">                &lt;!-- maxFileSize:用于判断日志切割的文件大小，默认值是10MB --&gt;</span><br><span class="line">                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;!-- pattern节点，用来设置日志的输入格式 --&gt;</span><br><span class="line">            &lt;pattern&gt;</span><br><span class="line">                %d %p (%file:%line\)- %m%n</span><br><span class="line">            &lt;/pattern&gt;</span><br><span class="line">            &lt;!-- 记录日志的编码 --&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;!-- 控制台输出日志级别 --&gt;</span><br><span class="line">    &lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">    &lt;!-- 指定项目中某个包，当有日志操作行为时的日志记录级别 --&gt;</span><br><span class="line">    &lt;!-- shop.bangke.credit为根包，也就是只要是发生在这个根包下面的所有日志操作行为的权限都是DEBUG --&gt;</span><br><span class="line">    &lt;!-- 级别依次为【从高到低】：FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE  --&gt;</span><br><span class="line">    &lt;logger name=&quot;com.bigdata&quot; level=&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;syslogInfo&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;syslogError&quot;/&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS</title>
      <link href="/2019/12/27/DNS/"/>
      <url>/2019/12/27/DNS/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS(Domain Name System)：将一个网站的域名转换为对应的IP</p><h3 id="1-源起"><a href="#1-源起" class="headerlink" title="1. 源起"></a>1. 源起</h3><p>方案1：访问一台计算机需要通过 IP 地址，但是访问如果 IP 发生变更，需要告诉所有人。所以这个方法不可行。</p><p>方案2：为每一台计算机起一个名字，然后建立计算机名字到 IP 地址的一个映射关系。访问计算机名字，由计算机来完成映射的转换。每台计算机保存一个 hosts 文件，里面列出所有计算机名字和对应的 IP 地址，然后定期从一个维护此文件的站点更新里面的记录。当我们访问某个计算机名字时，先在 hosts 文件找到对应的IP，然后就可以建立连接。但是计算机越来越多，让每台计算机的 hosts 文件来保存所有计算机的名字和对应的 IP 地址不现实。</p><p>方案3：域名系统（DNS, Domain Name System)，这是一种层次的、基于域的命名方案，并且用一个分布式数据库系统加以实现。当我们需要访问一个域名（计算机名字）时，应用程序会向 DNS 服务器发起一个 DNS 请求，DNS 服务器返回该域名对应的 IP 地址。通过下面三种手段解决了上面的问题：</p><pre><code>1. 用户计算机上并没有存储所有的名字到 IP 的映射，这样避免了 hosts 文件过于庞大（现在各操作系统中 hosts 文件默认都是空的）。2. 规定了域名的命名规则，保证主机名字不会重复。3. DNS 服务器不再是单一的一台机器，而是一个层次的、合理组织的服务器集群。</code></pre><h3 id="2-协议"><a href="#2-协议" class="headerlink" title="2. 协议"></a>2. 协议</h3><ol><li>命名规则，防止域名出现重复。使用层次的地址结构。</li></ol><p>DNS 设计之初是用来建立域名到 IP 地址的映射，理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作域名资源记录，它是一个五元组，可以用以下格式表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Domain_name Time_to_live Class Type Value</span><br></pre></td></tr></table></figure><pre><code>- Domain_name：指出这条记录适用于哪个域名；- Time_to_live：用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间（后面会讲到缓存机制）；- Class：一般总是IN；- Type：记录的类型；- Value：记录的值，如果是A记录，则value是一个IPv4地址。</code></pre><ol start="2"><li>划分域名资源记录</li></ol><p>域名的名字空间转化为一棵树，划分为不重叠的区域。然后将每个区域与多个域名服务器（其中一个是 master，其他 slave 服务器则用来提供数据备份、加快解析速度、保证服务可用性）关联起来，称这些域名服务器为该区域的权威域名服务器(Authoritative Name Servers)，它保存两类域名资源记录：</p><pre><code>1. 该区域内所有域名的域名资源记录。2. 父区域和子区域的域名服务器对应的域名资源记录（主要是NS记录）。</code></pre><p>引入根域名服务器，它保存了所有顶级区域的权威域名服务器记录。现在通过根域名服务器，我们可以找到所有的顶级区域的权威域名服务器，然后就可以往下一级一级找下去了。</p><h3 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h3><p>因为每当连接上网络之后，计算机会自动获得一个默认的 DNS 服务器，当然你也可以用自己信任的 DNS 服务器，比如8.8.8.8，我们把这个域名服务器也叫作本地域名服务器。接下来当我们需要知道一个域名对应的资源记录时，会向本地域名服务器发起请求，如果该域名恰好在本地域名服务器所辖属的域名区域（DNS zone）内，那么可以直接返回记录。</p><p>如果在本地域名服务器没有发现该域名的资源记录，就需要在整个域名空间搜索该域名。而整个域名空间的资源记录存储在一个分层的、树状联系的一系列域名服务器上，所以本地域名服务器首先要从根域名服务器开始往下搜索。这里有一个问题就是本地域名服务器如何找到根域名服务器在哪里呢？其实域名服务器启动的时候，就会加载一个配置文件，里面保存了根域名服务器的NS记录（要知道根域名服务器地址一般非常稳定，不会轻易改变，并且数量很少，所以这个配置文件会很小）。找到根域名服务器之后，就可以一级一级地往下查找啦。</p><pre><code>用语言简单描述如下：1：用户：喂，本地域名服务器，告诉我math.sysu.edu.cn的地址；2：本地域名服务器：哎呀，我不知道啊，不在我的辖区，容我去问问老大哥吧。root老大，能告诉我math.sysu.edu.cn的地址吗；3：根域名服务器：忙着呢，你去问B（.cn）；4：本地域名服务器：喂，B，告诉我math.sysu.edu.cn的地址；5：B：你去问D（.edu.cn）；6：本地域名服务器：喂，D，告诉我math.sysu.edu.cn的地址；7：D：你去问F（sysu.edu.cn）；8：本地域名服务器：喂，F，告诉我math.sysu.edu.cn的地址；9：F：容老衲看看，哎呀，找到了，是X.X.X.X；10：本地域名服务器：踏破铁鞋终于找到啦，喂用户，出来啊，我找到了，是X.X.X.X</code></pre><h3 id="4-缓存机制"><a href="#4-缓存机制" class="headerlink" title="4. 缓存机制"></a>4. 缓存机制</h3><pre><code>1：80%的时间我们都在看那些20%的网站，这就是大名鼎鼎的80/20 Rule；2：我们会在一个网站的不同网页之间跳转，也就是不断地访问同一个域名，类似程序访问的局部性原理。</code></pre><p>基于以上两个结论，在实际访问网站时，会将已经访问过的那些域名的解析结果缓存在自己的计算机上，那么下次访问的时候可以直接读取结果，不用再次重复 DNS 查询过程。</p><p>当然，这样做的一个前提是要缓存的解析结果不会频繁更改，也就是说我十分钟后解析一个域名的结果和现在解析的结果是一样的。对大多数域名来说，这都是一个不争的事实。但是难免有一些“善变”的域名，他们可能会频繁更改自己的解析结果。为了使缓存机制适应这两类情况，我们在域名资源记录里面添加一个 Time_ti_live 字段，表明这条记录最多可以缓存多久。对于那些稳定的域名，给一个比较大的值，而那些经常改变的域名，则可以给定一个小的值。</p><p>同理，在域名服务器上也可以利用缓存机制。域名服务器可以将那些访问过的域名资源记录缓存，用户再次发起请求时，可以直接返回缓存结果，不用去迭代或者递归解析。</p>]]></content>
      
      
      <categories>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习摘要--关于配置</title>
      <link href="/2019/12/27/SpringBoot-9/"/>
      <url>/2019/12/27/SpringBoot-9/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-学习摘要–关于配置"><a href="#Spring-Boot-学习摘要–关于配置" class="headerlink" title="Spring Boot 学习摘要–关于配置"></a>Spring Boot 学习摘要–关于配置</h2><p>学习教程来自：B站 尚硅谷</p><h3 id="1-关于配置"><a href="#1-关于配置" class="headerlink" title="1. 关于配置"></a>1. 关于配置</h3><h4 id="1-Yaml"><a href="#1-Yaml" class="headerlink" title="1. Yaml"></a>1. Yaml</h4><ol><li><p>键值对写法：必须要有空格！ <figure class="highlight plain"><figcaption><span>v```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. v 的一些写法</span><br><span class="line"></span><br><span class="line">    - v 是对象</span><br></pre></td></tr></table></figure></p><p> friends: </p><pre><code>name: zhangsanage: 20</code></pre><p> 行内写法：<br> friends: {name: zhangsan, age: 20}</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- v 是数组</span><br></pre></td></tr></table></figure><p> pets: </p><pre><code>- cat- dog</code></pre><p> 行内写法：<br> pets: [cat,dog]</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 2. properties 文件</span><br><span class="line"></span><br><span class="line">默认编码是 utf-8 编码，在获取其中的中文时可能有问题，需要修改一下设置</span><br><span class="line"></span><br><span class="line">在 settings -&gt; File Encodings 中勾选 “Transparent native-to-ascii conversion”</span><br><span class="line"></span><br><span class="line">#### 3. 获取配置中的值</span><br><span class="line"></span><br><span class="line">- `@ConfigurationProperties`  </span><br><span class="line"></span><br><span class="line">    `@ConfigurationProperties(prefix = &quot;?&quot;)` 告诉 SpringBoot 将本类中的所有属性和篇日志文件中相关的配置进行绑定</span><br><span class="line"></span><br><span class="line">    参数 prefix 指定配置文件中某一个 key 下的所有属性进行一一映射</span><br><span class="line"></span><br><span class="line">- `@Value`</span><br><span class="line"></span><br><span class="line">    `@Value` 使用 $ 来获取配置中的值，或者使用 # 来实时计算</span><br></pre></td></tr></table></figure><p> @Value(“${person.last-name}”)<br> private String name;<br> @Value(“#{11*2}”)<br> private int age;</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xxx|@ConfigurationProperties|@Value</span><br><span class="line">:-:|:-:|:-:|</span><br><span class="line">功能|批量注入配置文件中的属性|一个个指定</span><br><span class="line">松散绑定|支持|不支持</span><br><span class="line">SpEL|不支持|支持</span><br><span class="line">JSR303数据校验|支持|不支持</span><br><span class="line">复杂类型封装 eg:map|支持|不支持</span><br><span class="line"></span><br><span class="line">* 松散绑定：lastName / last-name / last_name 都可以识别成 lastName</span><br><span class="line">* SpEL：#&#123;11*2&#125; 这种方式</span><br><span class="line">* JSR303数据校验：在类上加入注解 `@Validated`，在变量前加入注解比如 `@Email`，可以自动识别是否符合邮箱格式</span><br><span class="line"></span><br><span class="line">**如果只是简单获取一下配置的值，就用@Value**</span><br><span class="line"></span><br><span class="line">#### 4. @PropertySource 和 @ImportResource </span><br><span class="line"></span><br><span class="line">- @PropertySource：加载指定的配置文件，在配置类上添加</span><br><span class="line"></span><br><span class="line">```@PropertySource(value=&#123;&quot;classpath:person.properties&quot;&#125;)</span><br></pre></td></tr></table></figure></li></ol><ul><li>@ImportResource：导入指定的配置文件，在启动类上添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 5. 配置文件占位符</span><br></pre></td></tr></table></figure><p>#name: zhangsan<br>age: ${random.int} # 随机数<br>pet: ${name:zs}_dog # 获取前面 key 为 name 的值，如果没有，用默认值 zs 代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 6. 测试、生产多配置文件指定</span><br><span class="line"></span><br><span class="line">1. 使用 properties 文件，多 profiles 的形式</span><br><span class="line">application.properties: 主配置文件</span><br><span class="line">application-dev.properties: 测试配置文件</span><br><span class="line">application-prod.properties: 生产配置文件</span><br><span class="line"></span><br><span class="line">默认启动的时候会激活主配置文件，切换配置文件时，在主配置文件中添加</span><br></pre></td></tr></table></figure><p>spring.profiles.active=dev/prod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用 yml 文件，多文档块的形式</span><br><span class="line"></span><br><span class="line">appication.yml 使用 --- 三个横线可以在一个文件中添加多个文档块，相当于编写了好几个文档</span><br></pre></td></tr></table></figure><p>server:<br>    port: 8081<br>spring:<br>    profiles:</p><pre><code>active:dev</code></pre><hr><p>server:<br>    port: 8082<br>spring:<br>    profiles: dev</p><hr><p>server:<br>    port: 8083<br>spring:<br>    profiles: prod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 7. 配置文件目录</span><br><span class="line"></span><br><span class="line">- file:/config/ -&gt; 项目根目录/config/</span><br><span class="line">- file:/ -&gt;项目根目录</span><br><span class="line">- classpath:/config/ -&gt; resources/config/</span><br><span class="line">- classpath:/ -&gt; resources</span><br><span class="line"></span><br><span class="line">优先级由高到低；相同配置项以高优先级的配置为主；互补配置（会全部加载）</span><br><span class="line"></span><br><span class="line">#### 8. 自动配置原理</span><br><span class="line"></span><br><span class="line">Spring Boot 启动时加载主配置类，开启自动配置功能 `@EnableAutoConfiguration`</span><br><span class="line"></span><br><span class="line">`@EnableAutoConfiguration` 的作用：</span><br><span class="line"></span><br><span class="line">1. 利用 `AutoConfigurationImportSelector.class` 给容器导入一些组件</span><br><span class="line"></span><br><span class="line">2. 通过 `selectImports()` 方法来确定哪一些配置被导入</span><br></pre></td></tr></table></figure><p>List<string> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</string></p><p>protected List<string> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {<br>    // 扫描所有 jar 包类路径下的 META-INF/spring.factories<br>    // 把扫描到的文件内容包装成properties对象<br>    // 从properties中获取到EnableAutoConfiguration.class类对应的值，添加到容器中<br>    List<string> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());<br>    Assert.notEmpty(configurations, “No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.”);<br>    return configurations;<br>}</string></string></p><pre><code>=&gt; 将类路径 `META-INF/spring.factories` 下配置的所有 `EnableAutoConfiguration.class` 的值加入到容器中eg: `xxxAutoConfiguration.class` 每一个这样的类都是容器中的一个组件，加入到容器后，再用他们来做自动配置能配置的属性都来源于 `xxxAutoConfiguration.class` 类对应的 `xxxProperties.class` 类在 `xxxProperties.class` 类前会有很多注解，比如 `@ConditionalOnWebApplication` 用来判断是否是一个web应用，如果是返回true，下面的内容才生效，等等注解。即自动配置类是需要在一定条件下才能生效可以通过在 `application.properties` 文件中添加 `debug=true` 来打印出自动配置报告，看到哪一类自动配置类启动了哪一些没启动总结：1. xxxAutoConfiguration：自动配置类，给容器添加组件2. xxxProperties：封装配置文件中相关属性</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot + Druid 多数据源绑定</title>
      <link href="/2019/12/19/SpringBoot-8/"/>
      <url>/2019/12/19/SpringBoot-8/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-Druid-多数据源绑定"><a href="#Spring-Boot-Druid-多数据源绑定" class="headerlink" title="Spring Boot + Druid 多数据源绑定"></a>Spring Boot + Druid 多数据源绑定</h2><p>版本环境：Spring Boot 2.0.6</p><p>参考文档地址：<br><a href="https://blog.csdn.net/cllaure/article/details/81509303" target="_blank" rel="noopener">https://blog.csdn.net/cllaure/article/details/81509303</a></p><h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h3><p>列举个几个比较重要的文件，其他的文件进行了省略</p><ul><li>analysis<ul><li>AnalysisApplication.java</li><li>SpringUtil.java</li></ul></li><li>dao<ul><li>OperateLogMapper.java</li></ul></li><li>datasource<ul><li>DynamicDataSource.java</li><li>DynamicDataSourceAspect.java</li><li>DynamicDataSourceContextHolder.java</li><li>DynamicDataSourceRegister.java</li><li>TargetDataSource.java</li></ul></li><li>entity</li><li>service<ul><li>AnalysisService.java</li></ul></li><li>utils</li></ul><h3 id="2-关于启动类-AnalysisApplication"><a href="#2-关于启动类-AnalysisApplication" class="headerlink" title="2. 关于启动类 AnalysisApplication"></a>2. 关于启动类 AnalysisApplication</h3><p>因为我想要的是在启动该项目时，不通过访问 url 的方式来激活某个接口，而是让程序自动来执行某个方法，所以需要在启动类中使用 <code>SpringUtil.getApplicationContext()</code> 来获取 Spring 上下文，从而将你需要的那个类注入进来，并执行该来的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@Import(DynamicDataSourceRegister.class) // 重点！！！用来覆写 Spring 默认创建数据库连接方法</span><br><span class="line">@ComponentScan(&quot;com.bigdata.*&quot;) // Service层的注解是@component，但是有可能会访问不到，在这里通过注解的方式直接将整个目录都引入进来</span><br><span class="line">@MapperScan(&quot;com.bigdata.dao&quot;)</span><br><span class="line">public class AnalysisApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(AnalysisApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 当 Spring 启动后会获取到 analysis 实例，并执行 appStart() 方法</span><br><span class="line">        ApplicationContext context = SpringUtil.getApplicationContext();</span><br><span class="line">        AnalysisService analysis = context.getBean(AnalysisService.class);</span><br><span class="line">        analysis.appStart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-关于-SpringUtil"><a href="#3-关于-SpringUtil" class="headerlink" title="3. 关于 SpringUtil"></a>3. 关于 SpringUtil</h3><p>需要注意的是，此类需要放到启动类同包或者子包下才能被扫描，否则失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringUtil implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        if(SpringUtil.applicationContext == null)&#123;</span><br><span class="line">            SpringUtil.applicationContext  = applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-多数据源连接初始化"><a href="#4-多数据源连接初始化" class="headerlink" title="4. 多数据源连接初始化"></a>4. 多数据源连接初始化</h3><p>首先创建一个 datasource 的文件夹，该文件夹下需要的文件有：</p><ul><li>DynamicDataSource.java</li><li>DynamicDataSourceAspect.java</li><li>DynamicDataSourceContextHolder.java</li><li>DynamicDataSourceRegister.java</li><li>TargetDataSource.java</li></ul><p>如果是想通过注解的方法来切换数据源，那么需要用到 <code>DynamicDataSourceAspect.java</code> 和 <code>TargetDataSource.java</code>，反之如果你的数据源连接特别多，要通过传参来切换数据源，那么就不需要这两个文件。</p><p>下面我会按照多数据源连接为例，改写文档上的代码。</p><h4 id="4-1-DynamicDataSource-java"><a href="#4-1-DynamicDataSource-java" class="headerlink" title="4.1 DynamicDataSource.java"></a>4.1 DynamicDataSource.java</h4><p>这个文件的目的是覆写 <code>determineCurrentLookupKey()</code> 方法，返回的值是保存在 <code>DynamicDataSourceContextHolder</code> 类中当前数据库连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDataSource extends AbstractRoutingDataSource &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object determineCurrentLookupKey() &#123;</span><br><span class="line">        return DynamicDataSourceContextHolder.getDataSourceType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-DynamicDataSourceContextHolder-java"><a href="#4-2-DynamicDataSourceContextHolder-java" class="headerlink" title="4.2 DynamicDataSourceContextHolder.java"></a>4.2 DynamicDataSourceContextHolder.java</h4><p>该文件是用来切换数据源，通过 <code>setDataSourceType(String dataSourceType)</code> 方法来切换到指定的数据库连接，其中 <code>dataSourceType</code> 其实是在初始化数据库连接时的别名。</p><p><code>dataSourceIds</code> 里保存了所有数据库连接的别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDataSourceContextHolder &#123;</span><br><span class="line">    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();</span><br><span class="line">    public static List&lt;String&gt; dataSourceIds = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void setDataSourceType(String dataSourceType) &#123;</span><br><span class="line">        contextHolder.set(dataSourceType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getDataSourceType() &#123;</span><br><span class="line">        return contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    恢复至默认的数据库</span><br><span class="line">    public static void clearDataSourceType() &#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断指定DataSrouce当前是否存在</span><br><span class="line">     */</span><br><span class="line">    public static boolean containsDataSource(String dataSourceId) &#123;</span><br><span class="line">        return dataSourceIds.contains(dataSourceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-DynamicDataSourceRegister-java"><a href="#4-3-DynamicDataSourceRegister-java" class="headerlink" title="4.3 DynamicDataSourceRegister.java"></a>4.3 DynamicDataSourceRegister.java</h4><p>该文件用来初始化数据源连接，并注入到 Bean 中。</p><p>Spring 启动前，会自动执行 <code>setEnvironment(Environment env)</code> 方法，在这个方法体通过读取配置文件，来初始化数据库连接。由于我们需要通过别名来切换数据库连接，所以如果在库名唯一的情况下，我们可以通过数据库名来作为别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  动态数据源注册</span><br><span class="line"> *  启动动态数据源请在启动类中 添加 @Import(DynamicDataSourceRegister.class)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceRegister.class);</span><br><span class="line"></span><br><span class="line">    // 如配置文件中未指定数据源类型，使用该默认值</span><br><span class="line">    private static final Object DATASOURCE_TYPE_DEFAULT = &quot;com.alibaba.druid.pool.DruidDataSource&quot;;</span><br><span class="line"></span><br><span class="line">    // 数据源</span><br><span class="line">    private DataSource defaultDataSource;</span><br><span class="line">    private Map&lt;String, DataSource&gt; customDataSources = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //加载多数据源配置</span><br><span class="line">    @Override</span><br><span class="line">    public void setEnvironment(Environment env) &#123;</span><br><span class="line">        // 读取配置文件获取更多数据源</span><br><span class="line">        PropertiesUtil props = new PropertiesUtil(&quot;relations.properties&quot;);</span><br><span class="line">        PropertiesEntity propsEntity = PropertiesEntity.newInstance();</span><br><span class="line">        ...... 解析配置文件并赋值 ......</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;开始初始化动态数据源~~~~&quot;);</span><br><span class="line">        initCustomDataSources(propsEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化更多数据源</span><br><span class="line">    private void initCustomDataSources(PropertiesEntity propsEntity) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; dsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 通过循环来实现多个数据库连接的初始化</span><br><span class="line">        dsMap.put(&quot;driver-class-name&quot;, propsEntity.getDriveClass());</span><br><span class="line">        dsMap.put(&quot;url&quot;, propsEntity.getUrl());</span><br><span class="line">        dsMap.put(&quot;username&quot;, propsEntity.getUsername());</span><br><span class="line">        dsMap.put(&quot;password&quot;, propsEntity.getPassword());</span><br><span class="line">        DataSource ds = buildDataSource(dsMap);</span><br><span class="line"></span><br><span class="line">        // 假设库名为 &quot;db1&quot;, 将其设置为默认数据库连接，当然也可以不设置，这个无所谓，在 `registerBeanDefinitions` 方法中将默认数据库连接的别名绑定为 default</span><br><span class="line">        if(dbName.equals(&quot;db1&quot;))&#123;</span><br><span class="line">            defaultDataSource = buildDataSource(dsMap);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            customDataSources.put(dbName, ds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        // 将主数据源添加到更多数据源中</span><br><span class="line">        targetDataSources.put(&quot;default&quot;, defaultDataSource);</span><br><span class="line">        DynamicDataSourceContextHolder.dataSourceIds.add(&quot;default&quot;);</span><br><span class="line">        // 添加更多数据源</span><br><span class="line">        targetDataSources.putAll(customDataSources);</span><br><span class="line">        for (String key : customDataSources.keySet()) &#123;</span><br><span class="line">            DynamicDataSourceContextHolder.dataSourceIds.add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 创建DynamicDataSource</span><br><span class="line">        GenericBeanDefinition beanDefinition = new GenericBeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClass(DynamicDataSource.class);</span><br><span class="line">        beanDefinition.setSynthetic(true);</span><br><span class="line">        MutablePropertyValues mpv = beanDefinition.getPropertyValues();</span><br><span class="line">        mpv.addPropertyValue(&quot;defaultTargetDataSource&quot;, defaultDataSource);</span><br><span class="line">        mpv.addPropertyValue(&quot;targetDataSources&quot;, targetDataSources);</span><br><span class="line">        registry.registerBeanDefinition(&quot;default&quot;, beanDefinition);</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;Dynamic DataSource Registry&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建DataSource</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public DataSource buildDataSource(Map&lt;String, Object&gt; dsMap) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object type = dsMap.get(&quot;type&quot;);</span><br><span class="line">            if (type == null)</span><br><span class="line">                type = DATASOURCE_TYPE_DEFAULT;// 默认DataSource</span><br><span class="line"></span><br><span class="line">            Class&lt;? extends DataSource&gt; dataSourceType;</span><br><span class="line">            dataSourceType = (Class&lt;? extends DataSource&gt;) Class.forName((String) type);</span><br><span class="line"></span><br><span class="line">            String driverClassName = dsMap.get(&quot;driver-class-name&quot;).toString();</span><br><span class="line">            String url = dsMap.get(&quot;url&quot;).toString();</span><br><span class="line">            String username = dsMap.get(&quot;username&quot;).toString();</span><br><span class="line">            String password = dsMap.get(&quot;password&quot;).toString();</span><br><span class="line"></span><br><span class="line">            DataSourceBuilder factory = DataSourceBuilder.create().driverClassName(driverClassName).url(url)</span><br><span class="line">                    .username(username).password(password).type(dataSourceType);</span><br><span class="line">            return factory.build();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-DynamicDataSourceAspect-java"><a href="#4-4-DynamicDataSourceAspect-java" class="headerlink" title="4.4 DynamicDataSourceAspect.java"></a>4.4 DynamicDataSourceAspect.java</h4><p>这个文件主要用来编写在引用了注解的方法执行前后所需要做的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 切换数据源Advice</span><br><span class="line"> */</span><br><span class="line">@Aspect</span><br><span class="line">@Order(-1)// 保证该AOP在@Transactional之前执行</span><br><span class="line">@Component</span><br><span class="line">public class DynamicDataSourceAspect &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class);</span><br><span class="line"></span><br><span class="line">    @Before(&quot;@annotation(ds)&quot;)</span><br><span class="line">    public void changeDataSource(JoinPoint point, TargetDataSource ds) &#123;</span><br><span class="line">        String dsId = ds.name();</span><br><span class="line">        if (!DynamicDataSourceContextHolder.containsDataSource(dsId)) &#123;</span><br><span class="line">            logger.error(&quot;数据源[&#123;&#125;]不存在，使用默认数据源 &gt; &#123;&#125;&quot;, ds.name(), point.getSignature());</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            logger.debug(&quot;Use DataSource : &#123;&#125; &gt; &#123;&#125;&quot;, dsId, point.getSignature());</span><br><span class="line">            DynamicDataSourceContextHolder.setDataSourceType(dsId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @After(&quot;@annotation(ds)&quot;)</span><br><span class="line">    public void restoreDataSource(JoinPoint point, TargetDataSource ds) &#123;</span><br><span class="line">        logger.debug(&quot;Revert DataSource : &#123;&#125; &gt; &#123;&#125;&quot;, ds.name(), point.getSignature());</span><br><span class="line">        DynamicDataSourceContextHolder.clearDataSourceType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-TargetDataSource-java"><a href="#4-5-TargetDataSource-java" class="headerlink" title="4.5 TargetDataSource.java"></a>4.5 TargetDataSource.java</h4><p>注解文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在方法上使用，用于指定使用哪个数据源</span><br><span class="line">@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface TargetDataSource &#123;</span><br><span class="line">    String name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-方法实现"><a href="#5-方法实现" class="headerlink" title="5. 方法实现"></a>5. 方法实现</h3><p>如果是通过注解实现，可以在此文件中的方法或者dao层中的方法上使用注解，并通过对 <code>name</code> 进行赋值来切换数据库，如果没有值的话使用的是默认数据库连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AnalysisService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    OperateLogMapper opLogMapper;</span><br><span class="line"></span><br><span class="line">    // @TargetDataSource(name=&quot;&quot;)</span><br><span class="line">    public void appStart() &#123;</span><br><span class="line">        // 切换到别名为 db1 的数据库连接</span><br><span class="line">        DynamicDataSourceContextHolder.setDataSourceType(&quot;db1&quot;);</span><br><span class="line">        ... 数据库操作 ...</span><br><span class="line">        // 恢复至默认连接</span><br><span class="line">        DynamicDataSourceContextHolder.clearDataSourceType();</span><br><span class="line"></span><br><span class="line">        // 通过别名切换到默认连接，如果不通过 set 方法直接进行数据库操作，也是在默认连接进行的</span><br><span class="line">        DynamicDataSourceContextHolder.setDataSourceType(&quot;default&quot;);</span><br><span class="line">        ... 数据库操作 ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-关于-MyBatis-xml"><a href="#6-关于-MyBatis-xml" class="headerlink" title="6. 关于 MyBatis.xml"></a>6. 关于 MyBatis.xml</h3><p>使用 MyBatis 来编写 sql 语句时，将表名通过变量传递。此时如果用 <code>#{0}</code>，会报错，因为 <code>#</code> 会把里面的参数自动加上单引号然后拼接到字符串上，如果是对于类似 <code>where name = &#39;张三&#39;</code> 是没有问题的，但是对于 <code>select * from &#39;tableName&#39;</code> 是有问题的。</p><p>有两个解决方法，一个是将需要传递的参数打包成 HashMap，在赋值的时候使用 <code>select * from ${_key}</code>, 这样就可以动态赋值了。第二个方法是传递N个参数，使用 <code>select * from ${param1}</code> 来进行赋值。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/2019/12/14/Python-3/"/>
      <url>/2019/12/14/Python-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h2><h3 id="1-标准数据类型"><a href="#1-标准数据类型" class="headerlink" title="1.标准数据类型"></a>1.标准数据类型</h3><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>其中</p><ul><li>不可变数据：Number（数字）、String（字符串）、Tuple（元组）</li><li>可变数据：List（列表）、Dictionary（字典）、Set（集合）</li></ul><h4 id="1-1-Number（数字）"><a href="#1-1-Number（数字）" class="headerlink" title="1.1 Number（数字）"></a>1.1 Number（数字）</h4><p>Python3 支持 int、float、bool、complex（复数）。</p><p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p><p>内置的 type() 函数可以用来查询变量所指的对象类型。</p><p>或者使用 <code>isinstance(a, int)</code> </p><p>isinstance 和 type 的区别在于：</p><ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型</li></ul><h4 id="1-2-String（字符串）"><a href="#1-2-String（字符串）" class="headerlink" title="1.2 String（字符串）"></a>1.2 String（字符串）</h4><p>Python中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \ 转义特殊字符。</p><p>变量[头下标:尾下标]    <strong>左闭合区间</strong></p><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><pre><code>str = &apos;Runoob&apos;print (str)          # 输出字符串print (str[0:-1])    # 输出第一个到倒数第二个的所有字符print (str[0])       # 输出字符串第一个字符print (str[2:5])     # 输出从第三个开始到第五个的字符print (str[2:])      # 输出从第三个开始的后的所有字符print (str * 2)      # 输出字符串两次print (str + &quot;TEST&quot;) # 连接字符串RunoobRunooRnoonoobRunoobRunoobRunoobTEST</code></pre><p>Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串</p><pre><code>&gt;&gt;&gt; print(&apos;Ru\noob&apos;)Ruoob&gt;&gt;&gt; print(r&apos;Ru\noob&apos;)Ru\noob&gt;&gt;&gt;  </code></pre><p>注意：</p><ol><li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li><li>字符串可以用+运算符连接在一起，用*运算符重复。</li><li>Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li><li>Python中的字符串不能改变。</li></ol><h4 id="1-3-List（列表）"><a href="#1-3-List（列表）" class="headerlink" title="1.3 List（列表）"></a>1.3 List（列表）</h4><p>列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号 [] 之间、用逗号分隔开的元素列表。</p><p>变量[头下标:尾下标]    <strong>左闭合区间</strong></p><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><p>注意：</p><ol><li>List写在方括号之间，元素用逗号隔开。</li><li>和字符串一样，list可以被索引和切片。</li><li>List可以使用 + 操作符进行拼接。</li><li>List中的元素是可以改变的。</li><li><strong>截取时可以接收第三个参数，作用是截取的步长</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r1 = []</span><br><span class="line">r1.append(1)</span><br></pre></td></tr></table></figure><h4 id="1-4-Tuple（元组）"><a href="#1-4-Tuple（元组）" class="headerlink" title="1.4 Tuple（元组）"></a>1.4 Tuple（元组）</h4><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p><p>其实，可以把字符串看作一种特殊的元组。</p><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p><p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p><pre><code>tup1 = ()    # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号</code></pre><p>注意：</p><ol><li>与字符串一样，元组的元素不能修改。</li><li>元组也可以被索引和切片，方法一样。</li><li>注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li><li>元组也可以使用+操作符进行拼接。</li></ol><h4 id="1-5-Dict-字典"><a href="#1-5-Dict-字典" class="headerlink" title="1.5 Dict (字典)"></a>1.5 Dict (字典)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r2 = &#123;&#125;</span><br><span class="line">r2[&quot;k1&quot;] = &quot;v1&quot;</span><br></pre></td></tr></table></figure><h4 id="1-6-Set（集合）"><a href="#1-6-Set（集合）" class="headerlink" title="1.6 Set（集合）"></a>1.6 Set（集合）</h4><h3 id="2-数字和字符串拼接"><a href="#2-数字和字符串拼接" class="headerlink" title="2.数字和字符串拼接"></a>2.数字和字符串拼接</h3><pre><code>id = 1session_key = str(id) + &apos;_user&apos;</code></pre><h3 id="3-if-条件"><a href="#3-if-条件" class="headerlink" title="3. if 条件"></a>3. if 条件</h3><h4 id="3-1-短路原则"><a href="#3-1-短路原则" class="headerlink" title="3.1 短路原则"></a>3.1 短路原则</h4><p>条件判断遵循短路原则，第一个条件判断之后如果能确定整个 if 表达式的值，那就不再判断下一个了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = 0</span><br><span class="line">b = 1</span><br><span class="line">if (a &gt; 0) and (b / a &gt; 2):</span><br><span class="line">    print(&quot;yes&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;no&quot;)</span><br><span class="line">结果：no</span><br><span class="line"></span><br><span class="line">if (a &gt; 0) or (b / a &gt; 2):</span><br><span class="line">    print(&quot;yes&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;no&quot;)</span><br><span class="line">结果：报除零错</span><br></pre></td></tr></table></figure><h4 id="3-2-三元表达式"><a href="#3-2-三元表达式" class="headerlink" title="3.2 三元表达式"></a>3.2 三元表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = true if 1 &gt; 0 else false</span><br></pre></td></tr></table></figure><h4 id="3-3-汉诺塔"><a href="#3-3-汉诺塔" class="headerlink" title="3.3 汉诺塔"></a>3.3 汉诺塔</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a b c 三个位置分别对应 开始位置、中间借助的位置、最终位置</span><br><span class="line"></span><br><span class="line">def hano(n, a, b, c):</span><br><span class="line">    if n == 1:</span><br><span class="line">        print(a, &quot;--&gt;&quot;, c)</span><br><span class="line">        return None</span><br><span class="line">    hano(n - 1, a, c, b) # 开始位置是 a，借助 c，把除了最后一个都放到 b</span><br><span class="line">    print(a, &quot;--&gt;&quot;, c)</span><br><span class="line">    hano(n - 1, b, a, c) # 开始位置是 b，借助 a，把除了最后一个都放到 c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hano(3, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure><h3 id="3-正则"><a href="#3-正则" class="headerlink" title="3. 正则"></a>3. 正则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">text = &quot;......&quot;</span><br><span class="line">pattern = r&quot;...&quot;</span><br><span class="line">regex = re.compile(pattern, re.IGNORECASE) # 忽略大小写，先进行编译，返回一个正则对象</span><br><span class="line">result = regex.function(text)</span><br></pre></td></tr></table></figure><h4 id="3-1-查找一项"><a href="#3-1-查找一项" class="headerlink" title="3.1 查找一项"></a>3.1 查找一项</h4><ol><li>search: 查找任意位置的匹配项</li><li>match: 从字符串开头匹配，如果开头第一个字符就不配，返回 None</li><li>fullmatch: 整个字符串和正则完全匹配才行，否则返回 None</li></ol><h4 id="3-2-查找多个匹配项"><a href="#3-2-查找多个匹配项" class="headerlink" title="3.2 查找多个匹配项"></a>3.2 查找多个匹配项</h4><ol><li>findall: 从字符串任意位置查找，返回一个列表</li><li>finditer: 从字符串任意位置查找，返回一个迭代器</li></ol><blockquote><p>列表是一次性生成在内存中，而迭代器是需要使用时一点一点生成出来的，内存使用更优。所以如果存在大量的匹配项，使用 finditer 更好一点。</p></blockquote><h4 id="3-3-分割"><a href="#3-3-分割" class="headerlink" title="3.3 分割"></a>3.3 分割</h4><p>re.split(pattern, string, maxsplit=0, flags=0)<br>函数：用 pattern 分开 string，maxsplit表示最多进行分割次数，flags表示模式，比如 re.IGNORECASE</p><blockquote><p>在 不需要正则支持 且 数据量和数次不多 的情况下使用 str.split 函数更合适，反之则使用 re.split 函数。</p></blockquote><h4 id="3-4-替换"><a href="#3-4-替换" class="headerlink" title="3.4 替换"></a>3.4 替换</h4><ol><li>sub: 替换掉字符串中被正则匹配到的字符，返回替换后的字符串</li><li>subn: 替换掉字符串中被正则匹配到的字符，返回替换后的字符串和替换次数</li></ol><h4 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h4><ol><li>re.escape(pattern): 如果 pattern 中存在特殊字符，通过该方法可自动转义。但是可能存在转义错误问题，所以还是手动转义更安全。</li><li>re.purge(): 清除正则缓存</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给二十年后的一封信</title>
      <link href="/2019/11/07/Novel-8/"/>
      <url>/2019/11/07/Novel-8/</url>
      
        <content type="html"><![CDATA[<h2 id="给二十年后的一封信（摘自微博）"><a href="#给二十年后的一封信（摘自微博）" class="headerlink" title="给二十年后的一封信（摘自微博）"></a>给二十年后的一封信（摘自微博）</h2><p>我偷偷观察你好几天了。</p><p>你今年37岁，看起来不太老，体型没有发胖的痕迹，化淡妆，穿球鞋，衣着朴素，包包上没有LOGO。你有一辆AI自动巡航的小车，那是这个时代的标配，你上了车，拿出了一本书来读，虽然全球阅读早已电子化，你依然坚持纸书这个略贵一点的习惯。我不知道你做什么工作，想必应该很辛苦吧，上次你进入那间大厦，20个小时之后才出来，回程车上还睡着了。我有点欣慰，你没有长成什么可怕的样子；但也有点失望，你看起来就是个普通的上班族，原来20年后，世界上最多的还是普通上班族，一点新意也没有。</p><p>于是我趁着红灯走上前，敲敲你的车窗。窗玻璃向下滑开，你看着我。</p><p>你不认识我了，就像所有37岁的大人，不再认识17岁的少年。</p><p>我问你：陈念，我值得活下去吗？</p><p>你愕然瞪大眼，大概不明白这个少年发什么神经，车窗防备地关上，车子匆匆开走。我站在原地难过，但是几分钟后，你回来了。</p><p>你问我：为什么问这个问题？你怎么知道我的名字？我没有回答，沉默是所有少年擅长的事。</p><p>于是你带我回家。你住一间小小的出租房，不华丽，布置得很整洁。你让我洗完澡，吃东西，就像另一个人曾经照料我那样。我边吃边看着你，如果此刻你还没认出我，那你真的长成了一个好人。</p><p>我挑剔：你没有很有钱。</p><p>你不好意思的笑。</p><p>我又说：你看起来也不像特别聪明，根本不够保护几个人。</p><p>你很诚实：念书时还是聪明的，但后来发现聪明也不够用，需要智慧。智慧又需要时间，我还不够老。</p><p>这个理由合乎逻辑，可以接受。我点头，环顾四周。房间里有少量男性物品，但不是那种长久生活的痕迹。</p><p>我有点不安，你有没有和那个你很喜欢他，他也喜欢你的人，在一起？</p><p>没得到回答，我重复：就是那个人，你曾许诺过，未来一定会有他的人？</p><p>你看着我。我知道你认出我了。你没说话，慢慢的似乎在琢磨着什么。我紧张得不能呼吸。</p><p>你突然微笑：就在上个月，你刚刚问过这个问题。</p><p>我呆住。</p><p>你说：每次你来，都问一样的问题。那么多年了，我常常想，为什么你就是不放心我，要反复来看我。就在刚才，我突然想明白了。</p><p>你的眼睛望向桌上的闹钟。是的，20年过去了，AI都已经可以代替司机，桌上还放着很老很老的，这个时代的闹钟。</p><p>我也明白了。我说：不是我来看你，是你来看我。</p><p>是37岁的陈念无法忘记，一次一次回来看17岁的我。</p><p>我说：所以你想得到什么答案？</p><p>你问了六个字：我可以平庸吗？</p><p>我想了半天。我还只有17岁，还没有经历足够的事，但已经足够知道，这个世界英雄最多的地方是漫威和DC电影，还有男生写的网络小说，生活本来就是平庸的。平庸才是真实。</p><p>我回答你：不可以。</p><p>我没说出来的话是：即使你成了平庸的大人，我们也都值得活下去。</p>]]></content>
      
      
      <categories>
          
          <category> Novel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Novel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗兰</title>
      <link href="/2019/10/27/Novel-7/"/>
      <url>/2019/10/27/Novel-7/</url>
      
        <content type="html"><![CDATA[<h3 id="1-新星"><a href="#1-新星" class="headerlink" title="1. 新星"></a>1. 新星</h3><p>“让我们掌声欢迎我们H国有史以来最闪耀的新星，罗兰小姐！”</p><p>主持人话音刚落，一道白光打在了舞台中央，穿着一袭白衣的罗兰此时就像是一个公主。曼妙的歌声和观众的呼喊声混合在一起，竟让她有了一种不真实感，脑中想到的都是自己从练习生到出道这几年的艰辛历程，不知不觉竟流下泪来。观众不知罗兰所想，恰是一种抒情歌，看着大屏幕上偶像流了眼泪，眼角竟也有了一些湿润。</p><p>自XXX节目成为冠军之后，罗兰在短短2个月的时间就占据了各大娱乐版块的封面，各个广告商纷纷递上橄榄枝，甚至也有富商子弟前来求婚，不过都被她拒绝了，一方面是她本身不喜欢那些纨绔子弟，另一方面她所在的社团的社长也是这样要求她的，在合同到期之前，她是不可以谈恋爱的。不过也无所谓，反正她现在也没有时间去想这些事情，毕竟每天的行程已经安排的非常满了。她现在只想在合同到期前，好好工作，多挣点钱，到时候才能更好的照顾家里人。</p><h3 id="2-噩梦"><a href="#2-噩梦" class="headerlink" title="2. 噩梦"></a>2. 噩梦</h3><p>“这周五早上十点，你自己来XXX路XX号。”罗兰打开手机，看到了这样的一条短信，不禁皱起了眉头。</p><p>这部手机是上次演出之后社长私下里交给她的，说是以后如果有紧急的事情，会单独通过这个手机来联系她，让她自己一个人保管好，甚至连她的经纪人都不能告诉。</p><p>罗兰搜了一下短信上的地址，眉头皱得更深了。这是一个别墅区啊，叫我过去干嘛，难道是有新的广告商或者投资人？真是搞不懂他们这帮企业家。</p><p>周五。</p><p>“罗兰啊，你知道我对你这段时间很照顾吧，一直帮你找赞助，给你开拓市场，让你去演出，让你赚钱，还帮你妈把看病的钱给交了。”</p><p>“是的，我知道，我一直都对社长心怀感激，所以我也一直拼命地工作，不敢懈怠。”</p><p>“那么现在我需要你帮我一个忙，这个忙只有你能做，但是我需要征求你的意见。”社长转动着手中的茶杯，缓缓地说道。</p><p>罗兰心中有了一丝疑惑，甚至有一点隐隐的不安，感觉自己今天过来或许是一个错误的决定。</p><p>“我们最近在和S集团谈下一步的合作事宜，现在只差最后一句话了，S集团的董事长提了一个要求，他说只要能满足他的要求，就没有问题了。”</p><p>“什么要求？”</p><p>“他要你。”社长放下手中的茶杯，眼睛盯着罗兰的眼睛，眼神坚定。“一起吃顿饭，喝点酒什么的，具体的我也不知道，但是大概就是大家平常日一起做的，你知道的。”</p><p>“我不去！”罗兰没有想到社长竟然会说出这种话，简直是不可理喻。</p><p>“罗兰啊，你应该知道吧，公司培养你也花了不少钱，既然能把你培养起来，自然也可以把东西都收回来。你可以回去考虑一下，想想你现在的事业，还有，”社长顿了顿，继续说，“你的家人们。”</p><h3 id="3-求助"><a href="#3-求助" class="headerlink" title="3. 求助"></a>3. 求助</h3><p>一年之后。</p><p>“何叔，我知道你和我爸是旧交，我有些事想麻烦您一下。”</p><p>老何不敢相信他眼前这个姑娘竟然是一年之前舞台上那个光鲜亮丽，看起来青春活泼的罗兰。此刻素颜的她黑眼圈很明显，整个人看起来憔悴很多，也消瘦很多。</p><p>“这件事有点难以启齿，但是……我感觉我快撑不住了。”说着说着，罗兰竟控制不住地流下眼泪。</p><p>“发生了什么事，慢慢说，我看我能帮上什么忙。”</p><p>……</p><h3 id="4-绝望"><a href="#4-绝望" class="headerlink" title="4. 绝望"></a>4. 绝望</h3><p>“根据本台最新报道，两年前出道的明星，罗兰，已于今天早上8点在家中逝世，警方在死者家中发现了大量的治疗抑郁症的药品，初步鉴定为自杀，具体原因正在进一步勘查中。”</p><h3 id="5-缅怀"><a href="#5-缅怀" class="headerlink" title="5. 缅怀"></a>5. 缅怀</h3><p>“小王，是你跟局长说的我一直在帮罗兰的吧。”</p><p>小王没有想到师傅会突然说起这个，一下子慌了，“师傅，你……你在说什么？”</p><p>“上次员工晋升会谈的时候，局长先找的你，之后找的我，还把咱们警车的出勤位置都翻了出来，除非是有人说，要不然他才不会翻这东西，而且当了这么多年的警察，你的表情我看得出来，”</p><p>“师傅，是那次谈话的时候局长跟我说，按照我的业绩如果没有什么突出的成绩出现，我可能就要被辞退了，你知道我母亲的身体，她一直希望我能当警察，我不敢失去这份工作，局长说如果能说说你一直在做什么，或许我还能……”</p><p>老何抬起手打断了他的话，“没事的没事的，原本距离我退休还有两三年的时间，如今只不过提前到了下个星期而已。”老何深深地抽了一口烟，慢慢地吐了出来，看着那团烟逐渐散成虚无。“你知道为什么他会这么针对我吗？五年前，我是老局长的接班人，至少大多数人都是这么认为的，我也是，在晋升会谈的前一周，老局长找我聊了好久，他并不是不想让我接替他，只是他发现咱们国家正在向一个不好的方向发展，水开始变深变浑浊了，他不想让我进来，不过他说他也会尊重我的决定，当与不当全看我的想法。”</p><p>“我回去想了好久，我去看了我父亲，我在墓碑前坐了3个小时，我就一直在说最近发生的事情，说着说着我发现我不是那样的人，我不喜欢现在的环境，但是我一个人却改变不了，我只能默默接受，并试图让自己离远一点，所以我回去告诉老局长，我拒绝接替他的岗位，出乎意料的是，他很开心，是一种发自肺腑的喜悦。后来就是现在的局长接替了那个位置。我家三代都是军人，祖辈有功勋，所以我才有现在的位置，局长他虽然看我不爽，却也不好直接对我怎样。这次被他逮到了把柄，自然会一直抓着不放。”</p><p>“师傅，对不起，我不知道会这样。”小王没想到事情会朝着这个方向发展，然而如今说什么都晚了。</p><p>“没事的没事的。对于我个人来说，我觉得倒是挺好的，我好久没有感觉这么轻松过了。我只是担心你。”老何顿了顿，继续说，“你是一个好孩子，心眼不坏。我知道你一直怪我不带你出任务，抓嫌犯，好不断晋升上去，就像当年的我，不知道即将趟的水的深浅。或许是我自私了，我希望你能晚点接触到人心，只不过如今我要离职了，不能继续带你了，我只是希望你能坚持你的本心，做个好警察。”老何拍了拍小王的肩膀，“我相信你可以的。”</p><p>“好好加油吧，而我，”老何伸了一个懒腰，恰好阳光滑过，“可以开始享受退休生活了。”</p><p>风轻轻吹过，罗兰碑前的百合花瓣被吹了起来，不知道飘向了哪里。</p><blockquote><p>之前微博上看到了一句话，忘了原话，大体意思是：世人说那些在不幸遭遇中幸存下来的人们是幸运的，可是如果那些逝去的人才是幸运的呢？<br>有对的部分，也有不对的部分，那么我的观点是：<br>世界并不会因此改变，同样的不幸依旧，坚守本心，砥砺前行。</p></blockquote><p>附：<br>香罗兰：困境中保持贞节<br>香水百合：死亡，一种傲然开放，凌驾于世俗之上的花</p>]]></content>
      
      
      <categories>
          
          <category> Novel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Novel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qlik Sense插件及QRS接口补充</title>
      <link href="/2019/10/18/QlikSense-5/"/>
      <url>/2019/10/18/QlikSense-5/</url>
      
        <content type="html"><![CDATA[<h2 id="Qlik-Sense插件及QRS接口补充"><a href="#Qlik-Sense插件及QRS接口补充" class="headerlink" title="Qlik Sense插件及QRS接口补充"></a>Qlik Sense插件及QRS接口补充</h2><h3 id="1-插件"><a href="#1-插件" class="headerlink" title="1.插件"></a>1.插件</h3><h4 id="1-1-获取数据方式"><a href="#1-1-获取数据方式" class="headerlink" title="1.1 获取数据方式"></a>1.1 获取数据方式</h4><p>理论上 Engine 所有的方法都应该有对应的 Capability API 方法，但是在开发者文档里的 API 有时候并不全，在获取数据的时候，可以去参考一下 Engine API 方法，在调用函数的时候使用 <code>app.model.enigmaModel.api</code> 的方式来获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前 app 下所有的字段</span><br><span class="line">// 在返回的 data 中会有字段名称以及其所属于的数据表名</span><br><span class="line">app.model.enigmaModel.getFieldList().then(function(data)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-组装数据"><a href="#1-2-组装数据" class="headerlink" title="1.2 组装数据"></a>1.2 组装数据</h4><p>如果数据是一个数组，那么可以使用 <code>map</code> 方法来返回一个结果体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fieldMap = fields.map(function(field)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        &quot;qDef&quot;: &#123;</span><br><span class="line">            &quot;qFieldDefs&quot;: [</span><br><span class="line">                field</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-3-同步和异步"><a href="#1-3-同步和异步" class="headerlink" title="1.3 同步和异步"></a>1.3 同步和异步</h4><p>在调用 API 方法来访问 Sense 获取数据时，返回的方式都是异步的，所以需要转换成同步操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">return new qlik.Promise(function(resolve, reject)&#123;</span><br><span class="line">    // 这里面处理异步函数</span><br><span class="line">    // 第一个函数是 resolve 的，第二个函数是 reject 的</span><br><span class="line">    app.model.enigmaModel.getFieldList().then(function(data)&#123;</span><br><span class="line">        // app.model.enigmaModel.getFieldList() 方法是异步的，所以用 then(function()&#123;&#125;) 来保证同步</span><br><span class="line">        ... // 此处的代码和上面的 `then` 是同步的</span><br><span class="line">        app.visualization.create(&apos;table&apos;,fieldArr).then(function(vis)&#123;</span><br><span class="line">            ... </span><br><span class="line">            resolve() // 这个函数一定要写在最后面，但是如果最后是一个异步的函数的话，就需要写在异步函数的最后面</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, function(error)&#123;</span><br><span class="line">        // 这里是失败时所做的操作</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-4-使用-Leonardo-组件"><a href="#1-4-使用-Leonardo-组件" class="headerlink" title="1.4 使用 Leonardo 组件"></a>1.4 使用 Leonardo 组件</h4><p>JavaScript：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">define( [</span><br><span class="line">&apos;text!./template.ng.html&apos;,</span><br><span class="line">&apos;text!./dialog-template.ng.html&apos;</span><br><span class="line">],</span><br><span class="line">function ( template, dialogTemplate ) &#123;</span><br><span class="line">return &#123;</span><br><span class="line">support: &#123;</span><br><span class="line">export: false,</span><br><span class="line">exportData: false,</span><br><span class="line">snapshot: false</span><br><span class="line">&#125;,</span><br><span class="line">template: template,</span><br><span class="line">controller: [&apos;$scope&apos;, &apos;luiDialog&apos;, function ( $scope, luiDialog ) &#123;</span><br><span class="line">            // 这里需要引用 luiDialog 的页面，相当于单独打开了一个页面</span><br><span class="line">$scope.openDialog = function() &#123;</span><br><span class="line">luiDialog.show(&#123;</span><br><span class="line">template: dialogTemplate,</span><br><span class="line">                    // 这里必须是 input 的形式，相当于主页面给次页面的一个输入值，输入的是主页面的变量</span><br><span class="line">input: &#123;</span><br><span class="line">name: $scope.name</span><br><span class="line">&#125;,</span><br><span class="line">controller: [&apos;$scope&apos;, function( $scope2 ) &#123;</span><br><span class="line">                        // 此处是 $scope2 是指 luiDialog 的</span><br><span class="line">$scope2.text = &apos;Use the dialog to display important messages or use it for actions requiring a lot of space, &apos; +</span><br><span class="line">&apos;like entering information into a form.&apos;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>dialog-template.ng.html：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;lui-dialog style=&quot;max-width: 450px;&quot;&gt;</span><br><span class="line">  &lt;lui-dialog-header&gt;</span><br><span class="line">    &lt;lui-dialog-title&gt;My dialog&lt;/lui-dialog-title&gt;</span><br><span class="line">  &lt;/lui-dialog-header&gt;</span><br><span class="line">  &lt;lui-dialog-body&gt;</span><br><span class="line">    Hello, &lt;i&gt;&#123;&#123;input.name || &quot;Missing name&quot;&#125;&#125;&lt;/i&gt;!</span><br><span class="line"></span><br><span class="line">    &lt;div style=&quot;margin-top: 10px&quot;&gt;</span><br><span class="line">      &lt;b&gt;Tip&lt;/b&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div style=&quot;margin-top: 5px&quot;&gt;</span><br><span class="line">      &#123;&#123;text&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/lui-dialog-body&gt;</span><br><span class="line">  &lt;lui-dialog-footer&gt;</span><br><span class="line">    &lt;button class=&quot;lui-button  lui-dialog__footer-button&quot; ng-click=&quot;close();&quot;&gt;Close&lt;/button&gt;</span><br><span class="line">  &lt;/lui-dialog-footer&gt;</span><br><span class="line">&lt;/lui-dialog&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BI </category>
          
          <category> Qlik Sense </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BI </tag>
            
            <tag> Qlik Sense </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 新特性</title>
      <link href="/2019/09/23/Java-2/"/>
      <url>/2019/09/23/Java-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h2><h3 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure><p>特征：</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号</li><li>可选的大括号：如果主体只包含一个语句，就不需要使用大括号</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Java8Tester tester = new Java8Tester();</span><br><span class="line"></span><br><span class="line">        // 类型声明</span><br><span class="line">        MathOperation addition = (int a, int b) -&gt; a + b;</span><br><span class="line"></span><br><span class="line">        // 不用类型声明</span><br><span class="line">        MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line"></span><br><span class="line">        // 大括号中的返回语句</span><br><span class="line">        MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;;</span><br><span class="line"></span><br><span class="line">        // 没有大括号及返回语句</span><br><span class="line">        MathOperation division = (int a, int b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));</span><br><span class="line">        System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));</span><br><span class="line">        System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));</span><br><span class="line">        System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));</span><br><span class="line"></span><br><span class="line">        // 不用括号</span><br><span class="line">        GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message);</span><br><span class="line"></span><br><span class="line">        // 用括号</span><br><span class="line">        GreetingService greetService2 = (message) -&gt; System.out.println(&quot;Hello &quot; + message);</span><br><span class="line"></span><br><span class="line">        greetService1.sayMessage(&quot;Runoob&quot;);</span><br><span class="line">        greetService2.sayMessage(&quot;Google&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface MathOperation &#123;</span><br><span class="line">        int operation(int a, int b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface GreetingService &#123;</span><br><span class="line">        void sayMessage(String message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">        return mathOperation.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda 表达式中访问外层的局部变量，这个局部变量可以不显式声明为 final，但是不能在后面代码修改（即隐式具有 final 含义）。但是如果外层变量是 static 声明的话，可以在 lambda 表达式内部引用，并且在后面的代码中修改。</p><blockquote><p>static变量是恒定指向内存的一个位置的，哪怕修改变量的值也是同一个位置，final 不可修改，也可以算是指向了内存中的一个位置（从创建那时候开始算的话）。变量只是引用，普通变量修改值的话会指向另一块内存位置，而 lambda 应该规定的是，只要一块不变的内存地址</p></blockquote><p>lambda 和 匿名内部类的比较：</p><p>匿名内部类的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 父类或接口() &#123;​</span><br><span class="line">    重写的方法;​ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在匿名内部类中很多是内容是冗余的。lambda 提取匿名内部类中最核心的内容（方法参数，方法体，返回值）。</p><p>Lambda 表达式的使用条件:</p><ol><li>必须有接口（不能是抽象类），接口中有且仅有一个需要被重写的抽象方法。</li><li>必须支持上下文推导，要能够推导出来 Lambda 表达式表示的是哪个接口中的内容。<br>可以使用接口当做参数，然后传递 Lambda 表达式(常用)，也可以将 Lambda 表达式赋值给一个接口类型的变量。</li></ol><h3 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2. 方法引用"></a>2. 方法引用</h3><p>语法：</p><ul><li>构造器引用：<code>Class::new</code></li><li>静态方法引用：<code>Class::static_method</code></li><li>特定类的任意对象的方法引用：<code>Class::method</code></li><li>特定对象的方法引用：<code>instance::method</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        List names = new ArrayList();</span><br><span class="line">        names.add(&quot;Google&quot;);</span><br><span class="line">        names.add(&quot;Runoob&quot;);</span><br><span class="line">        names.add(&quot;Taobao&quot;);</span><br><span class="line">        names.add(&quot;Baidu&quot;);</span><br><span class="line">        names.add(&quot;Sina&quot;);</span><br><span class="line">        names.forEach(System.out::println);</span><br><span class="line">// 对每一个 names 中的值，依次传递给 System.out 类下面的 println 这个方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3. 函数式接口"></a>3. 函数式接口</h3><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p><p>函数式接口可以被隐式转换为 lambda 表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// Predicate &lt;T&gt; 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。</span><br><span class="line">// 该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。</span><br><span class="line">// 该接口用于测试对象是 true 或 false。</span><br><span class="line"></span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line"></span><br><span class="line">        // Predicate&lt;Integer&gt; predicate = n -&gt; true</span><br><span class="line">        // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">        // n 如果存在则 test 方法返回 true</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;输出所有数据:&quot;);</span><br><span class="line"></span><br><span class="line">        // 传递参数 n</span><br><span class="line">        eval(list, n -&gt; true);</span><br><span class="line"></span><br><span class="line">        // Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span><br><span class="line">        // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">        // 如果 n%2 为 0 test 方法返回 true</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;输出所有偶数:&quot;);</span><br><span class="line">        eval(list, n -&gt; n % 2 == 0);</span><br><span class="line"></span><br><span class="line">        // Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span><br><span class="line">        // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">        // 如果 n 大于 3 test 方法返回 true</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;输出大于 3 的所有数字:&quot;);</span><br><span class="line">        eval(list, n -&gt; n &gt; 3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">        for (Integer n : list) &#123;</span><br><span class="line"></span><br><span class="line">            if (predicate.test(n)) &#123;</span><br><span class="line">                System.out.println(n + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 换成流计算的话</span><br><span class="line">private static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">    list.stream().filter(predicate).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">// 直接填写过滤条件的话</span><br><span class="line">list.stream().filter(n -&gt; n &gt; 3).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="4-接口的默认方法"><a href="#4-接口的默认方法" class="headerlink" title="4. 接口的默认方法"></a>4. 接口的默认方法</h3><p>接口可以有实现方法，并且不需要实现类来实现其方法。在方法名前面加 default 关键字即可实现默认方法。一个接口可以用多个默认方法。</p><p>目的：为了解决接口的修改与现有的实现不兼容的问题。之前需要修改接口的时候，需要修改全部实现该接口的类。</p><p>如果一个实现类实现了多个接口，并且多个接口中有相同的默认方法，可以在实现类中覆写掉这个默认方法，或者在实现类中通过 super 来指定接口的默认方法。</p><p>接口还可以声明（并且可以提供实现）静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">default void print()&#123;</span><br><span class="line">System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 静态方法</span><br><span class="line">static void blowHorn()&#123;</span><br><span class="line">System.out.println(&quot;按喇叭!!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Stream"><a href="#5-Stream" class="headerlink" title="5. Stream"></a>5. Stream</h3><p>流计算：<br>stream of elements<br>=&gt; 聚合操作：filter、map、reduce、find、match、sorted、collect etc</p><p>生成流：</p><ul><li>stream()：为集合创建串行流</li><li>parallelStream()：为集合创建并行流</li></ul><p>如果是 Random 的话，通过 <code>random.ints()</code> 来生成流</p><p>Collectors：<br>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。<br>Collectors 可用于返回列表或字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure><p>统计：<br>一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line"> </span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure><h3 id="6-Optional-类"><a href="#6-Optional-类" class="headerlink" title="6. Optional 类"></a>6. Optional 类</h3><p>目的：为了解决空指针问题</p><p>demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">Java8Tester java8Tester = new Java8Tester();</span><br><span class="line">Integer value1 = null;</span><br><span class="line">Integer value2 = new Integer(10);</span><br><span class="line"></span><br><span class="line">// Optional.ofNullable - 允许传递为 null 参数</span><br><span class="line">Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line"></span><br><span class="line">// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">System.out.println(java8Tester.sum(a,b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)&#123;</span><br><span class="line"></span><br><span class="line">// Optional.isPresent - 判断值是否存在</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());</span><br><span class="line">System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());</span><br><span class="line"></span><br><span class="line">// Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br><span class="line">Integer value1 = a.orElse(new Integer(0));</span><br><span class="line"></span><br><span class="line">//Optional.get - 获取值，值需要存在</span><br><span class="line">Integer value2 = b.get();</span><br><span class="line">return value1 + value2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Nashorn-JavaScript-引擎"><a href="#7-Nashorn-JavaScript-引擎" class="headerlink" title="7. Nashorn, JavaScript 引擎"></a>7. Nashorn, JavaScript 引擎</h3><h3 id="8-新的日期时间-API"><a href="#8-新的日期时间-API" class="headerlink" title="8. 新的日期时间 API"></a>8. 新的日期时间 API</h3><p>旧的日期 API 有诸多问题：</p><ol><li>非线程安全： java.util.Date 是非线程安全的，所有的日期类都是可变的</li><li>设计差：java.util 和 java.sql 的包中都有日期类</li><li>时区处理麻烦：没有时区支持，因此引入了 java.util.Calendar 和 java.util.TimeZone 类，但他们同样存在上述所有的问题</li></ol><p>新的日期 API：java.time</p><ol><li><p>本地化日期时间 API<br>LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.LocalTime;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.Month;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">Java8Tester java8tester = new Java8Tester();</span><br><span class="line">java8tester.testLocalDateTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void testLocalDateTime()&#123;</span><br><span class="line"></span><br><span class="line">// 获取当前的日期时间</span><br><span class="line">LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">System.out.println(&quot;当前时间: &quot; + currentTime);</span><br><span class="line"></span><br><span class="line">LocalDate date1 = currentTime.toLocalDate();</span><br><span class="line">System.out.println(&quot;date1: &quot; + date1);</span><br><span class="line"></span><br><span class="line">Month month = currentTime.getMonth();</span><br><span class="line">int day = currentTime.getDayOfMonth();</span><br><span class="line">int seconds = currentTime.getSecond();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;月: &quot; + month +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds);</span><br><span class="line"></span><br><span class="line">LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);</span><br><span class="line">System.out.println(&quot;date2: &quot; + date2);</span><br><span class="line"></span><br><span class="line">// 12 december 2014</span><br><span class="line">LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);</span><br><span class="line">System.out.println(&quot;date3: &quot; + date3);</span><br><span class="line"></span><br><span class="line">// 22 小时 15 分钟</span><br><span class="line">LocalTime date4 = LocalTime.of(22, 15);</span><br><span class="line">System.out.println(&quot;date4: &quot; + date4);</span><br><span class="line"></span><br><span class="line">// 解析字符串</span><br><span class="line">LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);</span><br><span class="line">System.out.println(&quot;date5: &quot; + date5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用时区的日期时间 API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.time.ZonedDateTime;</span><br><span class="line">import java.time.ZoneId;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">Java8Tester java8tester = new Java8Tester();</span><br><span class="line">java8tester.testZonedDateTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void testZonedDateTime()&#123;</span><br><span class="line"></span><br><span class="line">// 获取当前时间日期</span><br><span class="line">ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);</span><br><span class="line">System.out.println(&quot;date1: &quot; + date1);</span><br><span class="line"></span><br><span class="line">ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);</span><br><span class="line">System.out.println(&quot;ZoneId: &quot; + id);</span><br><span class="line"></span><br><span class="line">ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">System.out.println(&quot;当期时区: &quot; + currentZone);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="9-Base64"><a href="#9-Base64" class="headerlink" title="9. Base64"></a>9. Base64</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想 笔记</title>
      <link href="/2019/09/06/Java-1/"/>
      <url>/2019/09/06/Java-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Java编程思想-笔记"><a href="#Java编程思想-笔记" class="headerlink" title="Java编程思想 笔记"></a>Java编程思想 笔记</h2><h3 id="1-四类访问权限修饰词"><a href="#1-四类访问权限修饰词" class="headerlink" title="1. 四类访问权限修饰词"></a>1. 四类访问权限修饰词</h3><table><thead><tr><th align="center">\</th><th align="center">类内部</th><th align="center">本包</th><th align="center">子类</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">default（friendly）</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">private</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>protected：处理的是继承的概念。子类 extends 父类，如果父类希望某个特定成员，把对它的访问权限赋予派生类而不是所有类，即可以使用 protected。</p></blockquote><h3 id="2-8个基本类型"><a href="#2-8个基本类型" class="headerlink" title="2. 8个基本类型"></a>2. 8个基本类型</h3><table><thead><tr><th align="center">基本类型</th><th align="center">大小</th><th align="center">包装器类型</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">-</td><td align="center">Boolean</td><td align="center">false</td></tr><tr><td align="center">char</td><td align="center">16位</td><td align="center">Character</td><td align="center">null</td></tr><tr><td align="center">byte</td><td align="center">8位</td><td align="center">Byte</td><td align="center">(byte)0</td></tr><tr><td align="center">short</td><td align="center">16位</td><td align="center">Short</td><td align="center">(short)0</td></tr><tr><td align="center">int</td><td align="center">32位</td><td align="center">Integer</td><td align="center">0</td></tr><tr><td align="center">long</td><td align="center">64位</td><td align="center">Long</td><td align="center">0L</td></tr><tr><td align="center">float</td><td align="center">32位</td><td align="center">Float</td><td align="center">0.0f</td></tr><tr><td align="center">double</td><td align="center">64位</td><td align="center">Double</td><td align="center">0.0d</td></tr></tbody></table><blockquote><p>默认值只是当变量作为类的成员使用时，才会给默认值，以确保成员变量得到初始化，防止程序错误。并不适用于局部变量！</p></blockquote><p>int 的整数范围：-2147483648 ~ 2147483647</p><p>高精度数字的类：BigInteger 和 BigDecimal</p><p>float 创建变量的时候，后面必须要加一个 f</p><h3 id="3-static-关键字"><a href="#3-static-关键字" class="headerlink" title="3. static 关键字"></a>3. static 关键字</h3><p>由 <code>static</code> 声明的变量或方法只有一份存储空间。关于变量，不管创建多少个对象，这些对象都共享同一个 i；关于方法，可以直接调用不用创建对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class StaticTest &#123;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StaticTest st1 = new stStaticTest();</span><br><span class="line">st1.i;</span><br><span class="line"></span><br><span class="line">StaticTest.i; // 也可以直接访问</span><br><span class="line"></span><br><span class="line">A a＝ new A()</span><br><span class="line">A b ＝new A()</span><br><span class="line">如果A里面有static int x</span><br><span class="line">a.x和b.x是同一个x</span><br></pre></td></tr></table></figure><blockquote><p>即使没有显式使用 static 关键字，一个类的构造器实际上也是静态方法。</p></blockquote><blockquote><p>初始化的顺序是先静态对象（如果它们尚未因前面的对象创建过程而被初始化），其次是非静态对象。</p></blockquote><blockquote><p>一个类的初始化顺序：</p><ol start="0"><li>将分配给对象的存储空间初始化成二进制的零</li><li>基类中的 static 静态代码块</li><li>子类中的 static 静态代码块 </li><li>基类中的属性值和普通代码块，按书写顺序初始化（这些变量和方法肯定不是 static）</li><li>基类中的构造器执行</li><li>子类中的属性值和普通代码块，按书写顺序初始化（这些变量和方法肯定不是 static）</li><li>子类中的构造器执行</li></ol></blockquote><h3 id="4-final-关键字"><a href="#4-final-关键字" class="headerlink" title="4. final 关键字"></a>4. final 关键字</h3><p>如果一个类被声明为 final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract，又被声明为 final。</p><p>将变量或方法声明为 final，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final 的方法也同样只能使用，不能重载。 </p><h3 id="5"><a href="#5" class="headerlink" title="5. ++"></a>5. ++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++i 先执行运算，再生成值</span><br><span class="line">i++ 先生成值，再执行运算</span><br></pre></td></tr></table></figure><h3 id="6-和-equals"><a href="#6-和-equals" class="headerlink" title="6. == 和 equals"></a>6. == 和 equals</h3><p><code>equals</code>：不同对象判断内容是否相等用 <code>equals</code><br><code>==</code>：比较的是对象的引用；基本类型使用 <code>==</code> 来判等</p><h3 id="7-while-和-do…while"><a href="#7-while-和-do…while" class="headerlink" title="7. while 和 do…while"></a>7. while 和 do…while</h3><p><code>do...while</code> 中的语句最少会执行一次，哪怕 while 中的判断是 false </p><blockquote><p>for( ; ; ) 和 while(true) 是一样的，都表示无穷循环。</p></blockquote><h3 id="8-foreach"><a href="#8-foreach" class="headerlink" title="8. foreach"></a>8. foreach</h3><p>这里的 foreach 只是 for 循环的变形。Java8 之后可以使用 foreach + lambda 表达式来循环遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(type i : x) // x 比如是一个数组或容器</span><br><span class="line"></span><br><span class="line">for(char c : &quot;a test string&quot;.toCharArray()) // String 类通过 toCharArray() 方法来返回一个 char 数组</span><br></pre></td></tr></table></figure><p>Java8 特性：foreach + lambda 表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items.foreach((k, v) -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;key: &quot; + k + &quot;, value: &quot; + v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="9-break-和-continue"><a href="#9-break-和-continue" class="headerlink" title="9. break 和 continue"></a>9. break 和 continue</h3><p>break：用于强行退出循环，不执行循环中剩余的语句</p><p>continue：用于停止执行当前的迭代，然后退回循环起始处，开始下一次迭代</p><blockquote><p>break 和 continue 针对的都是当前迭代层。如果有内外两层迭代，break写在内层，只是退出内层迭代，外层迭代继续。</p></blockquote><h3 id="10-标签"><a href="#10-标签" class="headerlink" title="10. 标签"></a>10. 标签</h3><p>标签是后面跟有冒号的标识符，类似：<code>lable1:</code>，一般和 break、continue 一同使用，表示中断当前循环，跳到标签所在的位置。</p><h3 id="11-垃圾回收"><a href="#11-垃圾回收" class="headerlink" title="11. 垃圾回收"></a>11. 垃圾回收</h3><p>Java 垃圾回收器只知道释放那些由 new 分配内存的对象。如果一个对象并非使用 new 来获得一块内存的话，就需要在类中定义一个名为 finalize() 的方法。</p><p>关于回收的几个点：</p><ol><li>对象不一定会被回收</li><li>垃圾回收不是析构函数</li><li>垃圾回收只与内存有关</li><li>如果 JVM 还没面临内存耗尽的情况，那它就不会浪费时间去执行垃圾回收来恢复内存。</li></ol><p>几种垃圾回收技术：</p><ol><li><p>引用计数：引用连接至对象，计数器加1；引用离开作用域或被设置为 null 时，计数器减1。当计数为0时回收。缺点：如果对象之间存在循环引用，可能会出现”对象应该被回收，但引用计数不为0“</p></li><li><p>停止-复制：先暂停程序运行，把所有存活的对象从当前堆复制到另一个堆，没有被复制的对象都是垃圾。缺点：所有引用需要修正；需要2倍的空间；如果有较少或甚至没有垃圾，就很浪费。</p></li><li><p>标记-清扫：遍历所有引用，标记存活对象，当过程结束后开始回收。</p></li></ol><h3 id="12-可变参数列表"><a href="#12-可变参数列表" class="headerlink" title="12. 可变参数列表"></a>12. 可变参数列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void printArray(Object[] args)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-基类（继承）"><a href="#13-基类（继承）" class="headerlink" title="13. 基类（继承）"></a>13. 基类（继承）</h3><p>如果 A 作为基类，<code>B extends A</code>，那么当 new 一个 B 类的对象时，会隐式地自动先执行 A 类的无参构造函数，即构造过程是从基类开始向外扩散的。</p><blockquote><p>如果要调用 A 的有参构造函数，就必须显式地使用 super 来调用，并且传参。</p></blockquote><h3 id="14-代理"><a href="#14-代理" class="headerlink" title="14. 代理"></a>14. 代理</h3><p>子类 extends 基类，那么基类的所有方法都会暴露给子类。使用代理可以有选择地将基类的方法暴露给用户来使用。</p><blockquote><p>其实相当于之前是通过 extends 的方式来继承基类，现在是在一个类下面创建基类的对象的方式来实现功能。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    void func1(int i)&#123;&#125;</span><br><span class="line">    void func2(int i)&#123;&#125;</span><br><span class="line">    void func3(int i)&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B extends A &#123;</span><br><span class="line">    // 此时 A 中所有的方法都会暴露给 B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用代理</span><br><span class="line">public class C &#123;</span><br><span class="line">    private A a = new A();</span><br><span class="line">    // 代理方法</span><br><span class="line">    // 在这里可以有选择地提供基类中的方法</span><br><span class="line">    public void func1(int i)&#123;</span><br><span class="line">        a.func1(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-向上转型与向下转型"><a href="#15-向上转型与向下转型" class="headerlink" title="15. 向上转型与向下转型"></a>15. 向上转型与向下转型</h3><h4 id="15-1-向上转型"><a href="#15-1-向上转型" class="headerlink" title="15.1 向上转型"></a>15.1 向上转型</h4><p>向上转型指的是从一个转专用类型向较通用类型转换，比如子类向上转型为基类，由于基类不会有大于子类的方法数量，所以是安全的。</p><h4 id="15-2-向下转型"><a href="#15-2-向下转型" class="headerlink" title="15.2 向下转型"></a>15.2 向下转型</h4><p>向下转型则不安全，需要在转型时在前面用小括号写出具体转型的类型。</p><h3 id="16-多态"><a href="#16-多态" class="headerlink" title="16. 多态"></a>16. 多态</h3><blockquote><p>OOP(面向对象编程)三大特征：</p><ol><li>抽象：把一类事物的属性或行为提出来，形成一个模型（类）</li><li>继承：为了提高代码复用性，将共同的属性或方法提取出来作为基类，子类继承基类，获得基类所有属性和行为，并可以根据自身需求来拓展各自的功能。</li><li>多态：即同一消息可以根据发送对象的不同而采用多种不同的行为方式。</li></ol><p>另外还有 封装（把数据和对数据的操作组合起来，对外隐藏实现细节，对外只能用提供的功能来实现需求）。</p></blockquote><p>以下是还算较为简单的多态的实现，更麻烦的实现是在 Shapes 定义参数不同方法名相同的 draw 方法，然后调用的时候分别把 circle、triangle 对象传进去，通过传递对象的不同来调用各自的 draw 方法。但是这种方法的思想依旧是前期绑定，即在运行前就已经知道了对象的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">class Shape &#123;</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Cirle extends Shape &#123;</span><br><span class="line">    @Override 避免了方法重载的麻烦，但是也可以不加</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Triangle extends Shape &#123;</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类</span><br><span class="line">class Shapes &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cirle circle = new Circle();</span><br><span class="line">        Triangle triangle = new Triangle();</span><br><span class="line">        circle.draw();</span><br><span class="line">        triangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态的思想是通过后期绑定（亦或动态绑定或运行时绑定），是在向上转型的基础上来实现的：因为 Cirle 和 Triangle 继承自 Shape，那么可以在创建对象的时候写成 <code>Shape circle = new Circle();</code>，创建一个 Circle 对象，把引用赋值给 Shape。在调用 <code>circle.draw();</code> 时默认会调用基类中的 draw() 方法，但是如果子类中覆写了这个方法，那么就会调用在 Circle 类中覆写的 draw() 方法，从而实现了多态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">class Shape &#123;</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Cirle extends Shape &#123;</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Triangle extends Shape &#123;</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类</span><br><span class="line">class Shapes &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Shape circle = new Cirle();</span><br><span class="line">        Shape triangle = new Triangle();</span><br><span class="line">        circle.draw();</span><br><span class="line">        triangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态的两个注意事项：</p><ol><li><p>无法覆盖私有方法</p></li><li><p>变量和静态方法不具有多态性</p></li></ol><h3 id="17-构造器"><a href="#17-构造器" class="headerlink" title="17. 构造器"></a>17. 构造器</h3><p>准则：用尽可能简单的方法使对象进入正常状态；避免调用其他方法。</p><p>在构造器内唯一能够安全调用方法是基类中的 final 方法（也适用于 private 方法，它们自动属于 final 方法），这些方法不能被覆盖。</p><h3 id="18-抽象类和抽象方法"><a href="#18-抽象类和抽象方法" class="headerlink" title="18. 抽象类和抽象方法"></a>18. 抽象类和抽象方法</h3><p>建立抽象类的唯一目的是：不同的子类可以用不同的方式表示此接口（方法），抽象类就是把共同的部分提取了出来。像之前写的 Shape 就是一个抽象基类，或者抽象类。</p><p>如果一个类包含一个或多个抽象方法，该类就必须被限定为 abstract。同时，子类继承抽象类时，必须为基类中所有的抽象方法提供方法定义，否则，子类也必须被限定为 abstract。</p><p>基类中的抽象方法只定义方法，不具体实现。但是那些非抽象方法可以写实现体。（抽象类中的那些抽象方法类似于接口部分）</p><h3 id="19-接口"><a href="#19-接口" class="headerlink" title="19. 接口"></a>19. 接口</h3><p>接口使抽象这一概念更进一步：全是抽象方法，只定义方法，都不实现。</p><p>接口中的方法都是 public。</p><p>一个类只能继承一个基类，但是可以实现多个接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class X extends A implements B, C &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展接口：接口 extends 接口1, 接口2 … (只有接口继承是可以写多个的，除此之外，extends 只能后面跟一个类)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">    void func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时 B 就相当于有2个方法了</span><br><span class="line">interface B extends A &#123;</span><br><span class="line">    void func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C implements B &#123;</span><br><span class="line">    public void func1()&#123;&#125;;</span><br><span class="line">    public void func2()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于接口而言，如果使用了 extends，那么子类一定也是一个接口；如果使用了 implements，那么子类就是一个普通的类，并且必须实现接口中的所有方法。</p></blockquote><p>接口中的任何变量都是 final 以及 static 的。</p><h3 id="20-内部类"><a href="#20-内部类" class="headerlink" title="20. 内部类"></a>20. 内部类</h3><p>使用内部类的原因：每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。（比如想在一个类中以某种方式实现两个接口，可以使用单一类或者使用内部类，可以使用单一类的原因是因为可以继承多个接口，但是如果是抽象类或者具体类，即只能继承一个，那么就只能使用内部类来实现多重继承）</p><p>可以把一个类的定义放在另一个类的定义的内部（可以是类的内部，也可以是在某一个方法的内部），即为内部类。</p><p>内部类的好处之一是内部类拥有对其外部类的所有元素（成员变量及方法）的访问权。</p><p>在内部类里生成对外部类的引用：在外部类的名字后面加 <code>.this</code></p><p>在外部类引用的基础上创建某个内部类的对象：在外部类的名字后面加 <code>.new</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = new Outer();</span><br><span class="line">Outer.Inner ini = outer.new Inner();</span><br><span class="line"></span><br><span class="line">不过感觉最好是在外部类中添加一个返回内部类对象的方法</span><br><span class="line">public class Outer &#123;</span><br><span class="line">    public class Inner &#123;</span><br><span class="line">        public Outer getOuter() &#123;</span><br><span class="line">            return Outer.this; // .this 得到外部类的引用</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Inner inner() &#123; return new Inner(); &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        Outer.Inner inner = outer.inner();</span><br><span class="line">        // Outer.Inner inner = outer.new Inner(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类：（还不是很理解……）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    public Contents contents() &#123;</span><br><span class="line">        return new Contents() &#123;</span><br><span class="line">            private int i = 1;</span><br><span class="line">            public int value() &#123; return i; &#125;</span><br><span class="line">        &#125;; // 这里的分号必要要有</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a = new A();</span><br><span class="line">        Contents contents = a.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个匿名类的组成部分：</p><ol><li>new 操作符</li><li>new 之后可以写接口、抽象类、普通类名称。</li><li>()：这个括号表示构造函数的参数列表。由于Runnable是一个接口，没有构造函数，所以这里填一个空的括号表示没有参数。</li><li>{…}：大括号中间的代码表示这个类内部的一些结构。在这里可以定义变量名称、方法。跟普通的类一样。</li></ol><p>嵌套类：将内部类声明为 static，此时内部类对象和其外部类对象之间就没有了联系。（普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象，但是使用了 static 之后，就没有了这个引用）</p><p>使用嵌套类意味着：</p><ol><li>要创建嵌套类的对象，并不需要其外围类的对象（直接 new 一个就行）</li><li>不能从嵌套类的对象中访问非静态的外围类对象</li></ol><p>嵌套类可以作为接口的一部分。因为接口中的任何类默认都是 <code>public static</code></p><h3 id="21-容器类"><a href="#21-容器类" class="headerlink" title="21. 容器类"></a>21. 容器类</h3><p>容器类类库的用途是：保存对象。</p><p>分为两类：</p><ol><li><p>Collection：一个独立元素的序列</p><ul><li>Collection 是 List 和 Set 两个接口的基接口，List 和 Set 也是接口</li><li>List 在 Collection 之上增加了 ”有序“ 的概念，即必须按照插入的顺序保存元素<ul><li>ArrayList、LinkedList 是实现 List 接口的类。相同点：有序；不同点：ArrayList 是采用数组存放元素（索引查找快但是插入和删除慢），LinkedList 采用的则是链表（索引查找慢但是插入和删除快）</li></ul></li><li>Set 在 Collection 之上增加了 ”唯一“ 的概念，不能有重复元素<ul><li>HashSet、TreeSet 是实现 Set 接口的类。相同点：元素不能重复。不同点：HashSet 是无序的，而 TreeSet 是有序的，但是这个有序和 List 不一样，List 是按照插入顺序，而 TreeSet 是按照元素自定义顺序进行排序（可自定义排序的比较器）。因此 HashSet 允许放入 null，且效率较高，TreeSet相反。</li><li>LinkedHashSet 是另一个实现类，可以保证按照插入顺序来保存元素</li><li>SortedSet 接口保证元素处于排序状态</li></ul></li></ul></li><li><p>Map：一组”键值对“对象</p><ul><li>当 get() 方法返回 null 值时，即可以表示 Map 中没有该键，也可以表示该键所对应的值为 null。因此，在 Map 中不能由 get() 方法来判断 Map 中是否存在某个键，而应该用 containsKey() 方法来判断</li><li>实现 Map 的类有：HashMap、HashTable、TreeMap<ul><li>HashMap 允许有空键（null）与空值（null），在缺省情况下是非同步的，效率高于 HashTable，更推荐使用，在多线程环境下使用时，可以转换为同步</li><li>HashTable 缺省是线程同步的；不允许关键字或值为null；不推荐使用</li><li>TreeMap 能把其保存的记录根据key排序（类似TreeSet），默认是按照key的默认排序，但也可指定排序的比较器；不允许有空键（null）但可以有空值（null）。</li><li>TreeMap 和 HashMap 比较：<ul><li>TreeMap 适合于：元素顺序很重要；增加、快速创建的情况；HashMap 适合于：元素顺序不是很重要；查询</li></ul></li></ul></li></ul></li></ol><p><img src="https://images0.cnblogs.com/i/617995/201404/161353012916056.png" alt="简单的容器分类"></p><blockquote><p>点线框表示接口，实现框表示具体的类，带有空心箭头的点线表示一个特定的类实现了一个接口，实心箭头表示某个类可以生成箭头所指向类的对象。eg：任意的 Collection 可以生成 Iterator，而 List 即可以生成 Iterator 也可以生成 ListIterator。</p></blockquote><p><img src="https://images0.cnblogs.com/i/617995/201404/161352345105405.png" alt="完整的容器分类"></p><h3 id="22-List"><a href="#22-List" class="headerlink" title="22. List"></a>22. List</h3><p>subList(fromIndex, toIndex)：获取一个片段，fromIndex &lt;= index &lt; toIndex。需要注意的是 subList 获取的是原列表的引用，如果原列表发生改变（比如插入新的元素或者删除一个元素等等），那么在运行的时候 subList 就会报错。</p><h4 id="22-1-迭代器"><a href="#22-1-迭代器" class="headerlink" title="22.1 迭代器"></a>22.1 迭代器</h4><ol><li>Iterator<ul><li>使用 iterator() 要求容器返回一个 Iterator。Iterator 将准备好返回序列的第一个元素</li><li>使用 next() 返回当前元素，并指向序列的下一个元素</li><li>使用 hasNext() 检查序列中是否还有元素</li><li>使用 remove() 将迭代器当前返回的元素删除，所以在使用 remove() 之前必须调用 next()</li></ul></li></ol><blockquote><p>数组不是 Iterable，需要手动转换</p></blockquote><ol start="2"><li>ListIterator：是 Iterator 的子类，只能用于对各种 List 类的访问。ListIterator 支持双向移动</li></ol><h4 id="22-2-LinkedList"><a href="#22-2-LinkedList" class="headerlink" title="22.2 LinkedList"></a>22.2 LinkedList</h4><p>在插入和删除操作上，LinkedList 比 ArrayList 更高效。</p><p>LinkedList 具有实现 Stack 的所有功能的方法，所以可以直接把 LinkedList 当栈使用。</p><p>addFirst() &lt; - &gt; push()<br>getFirst() &lt; - &gt; peek()<br>removeFirst() &lt; - &gt; pop()</p><p>LinkedList 实现了 Queue 接口，所以 LinkedList 可以作为 Queue 的一种实现类 -&gt; 将 LinkedList 向上转型为 Queue 来使用。</p><p>在 Queue 的基础上，还有一个 PriorityQueue，用户可以自定义 Comparator 来定义优先级，下一个弹出的会是具有最高优先级的元素。</p><h3 id="23-Set"><a href="#23-Set" class="headerlink" title="23. Set"></a>23. Set</h3><p>查找是 Set 最重要的操作 =&gt; 通常会使用 HashSet，其对快速查找进行了优化</p><p>HashSet 和 LinkedHashSet 使用了散列函数来存储元素，LinkedHashSet 额外使用了链表来维护元素的插入顺序，TreeSet 使用了红黑树结构来存储元素</p><h3 id="24-异常处理"><a href="#24-异常处理" class="headerlink" title="24. 异常处理"></a>24. 异常处理</h3><p>try 后面可以跟好几个 catch 字句，每个 catch 字句只能接一个参数。只有匹配的 catch 语句才会执行（这点和 switch 不一样，switch 语句需要在每一个 case 后面跟一个 break，以避免执行后续的 case 字句）。</p><p>在 finally 字句中调用 return，即使抛出了异常，也不会产生任何输出。</p><p>Java的异常(包括 Exception 和 Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。</p><ul><li>可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<blockquote><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p></blockquote></li><li>不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。</li></ul><h3 id="25-字符串"><a href="#25-字符串" class="headerlink" title="25. 字符串"></a>25. 字符串</h3><p>推荐使用 StringBuilder</p><p>格式化输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Row1: [&quot; + x + &quot; &quot; + y + &quot;]&quot;);</span><br><span class="line">System.out.format(&quot;Row1: [%d %f]\n&quot;, x, y);</span><br><span class="line">System.out.printf(&quot;Row1: [%d %f]\n&quot;, x, y);</span><br></pre></td></tr></table></figure><p>String 格式化：String.format(…)</p><p>格式化说明符：%[argument_index][flags][width][.precision]conversion</p><ul><li>flags：默认情况下数据是右对齐，使用 ‘-‘ 来使数据左对齐</li><li>width：设置一个域的最小长度，过短时自动添加空格</li><li>.precision：指定最大尺寸。如果应用在 String 时，表示打印 String 时输出字符的最大数量。如果应用在浮点数时，表示小数部分要显示出来的位数（默认是6位小数），如果小数位数过多则舍入，太少则补零。但是不能应用于整数，会报错。</li></ul><h3 id="26-正则表达式"><a href="#26-正则表达式" class="headerlink" title="26. 正则表达式"></a>26. 正则表达式</h3><table><thead><tr><th align="center">code 需要多加一个斜线来转译</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>\\d</code></td><td align="center">表示一位数字 [0-9]</td></tr><tr><td align="center"><code>\\D</code></td><td align="center">表示一位非数字 [^0-9]</td></tr><tr><td align="center"><code>\\\\</code></td><td align="center">插入一个普通的反斜线，但是换行和制表符之类的东西只需要单反斜线即可：<code>\n\t</code></td></tr><tr><td align="center"><code>\\+</code></td><td align="center">表示一个加号</td></tr><tr><td align="center"><code>\\w</code></td><td align="center">表示一个单词字符 [a-zA-Z0-9]</td></tr><tr><td align="center"><code>\\W</code></td><td align="center">表示非单词字符</td></tr><tr><td align="center"><code>\\s</code></td><td align="center">空白符（空格、tab、换行、换页和回车）</td></tr><tr><td align="center"><code>\\S</code></td><td align="center">非空白符</td></tr></tbody></table><p>量词：</p><table><thead><tr><th align="center">code</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">X?</td><td align="center">零个或一个X</td></tr><tr><td align="center">X*</td><td align="center">零个或多个X</td></tr><tr><td align="center">X+</td><td align="center">一个或多个X</td></tr><tr><td align="center">X{n}</td><td align="center">n个X</td></tr><tr><td align="center">X{n,}</td><td align="center">最少n个X</td></tr><tr><td align="center">X{n,m}</td><td align="center">n &lt;= X的个数 &lt;= m</td></tr></tbody></table><h3 id="27-类型信息"><a href="#27-类型信息" class="headerlink" title="27. 类型信息"></a>27. 类型信息</h3><p>RTTI(Run-Time Type Identification): 运行时类型识别</p><h3 id="28-泛型"><a href="#28-泛型" class="headerlink" title="28. 泛型"></a>28. 泛型</h3><p>利用泛型概念，构建“元组”，来返回一组任意类型的对象，避免了使用类来返回信息，增加了复用性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 泛型指代可以用任意的大写字母，不仅仅是 T</span><br><span class="line">class TwoTuple&lt;A, B&gt;&#123;</span><br><span class="line">    public final A first;</span><br><span class="line">    public final B second;</span><br><span class="line">    public TwoTuple(A a, B b) &#123; first = a; second = b; &#125;</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;(&quot; + first + &quot;,&quot; + second + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreeTuple&lt;A, B, C&gt; extends TwoTuple&lt;A, B&gt;&#123;</span><br><span class="line">    public final C third;</span><br><span class="line">    public ThreeTuple(A a, B b, C c)&#123;</span><br><span class="line">        super(a, b);</span><br><span class="line">        third = c;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;(&quot; + first + &quot;,&quot; + second + &quot;,&quot; + third + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型与可变参数列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一个 &lt;T&gt; 很重要，相当于声明了当前这个方法是泛型方法</span><br><span class="line">// 只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; makeList(T ... args) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>使用泛型来构建复杂模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">interface Generator&lt;T&gt; &#123; T next(); &#125;</span><br><span class="line">class Generators &#123;</span><br><span class="line">    public static &lt;T&gt; Collection&lt;T&gt; fill(Collection&lt;T&gt; coll, Generator&lt;T&gt; gen, int n)&#123;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            coll.add(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">        return coll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Product&#123;</span><br><span class="line">    private final int id;</span><br><span class="line">    private String description;</span><br><span class="line">    private double price;</span><br><span class="line">    public Product(int IDnumber, String desc, double price)&#123;</span><br><span class="line">        this.id = IDnumber;</span><br><span class="line">        this.description = desc;</span><br><span class="line">        this.price = price;</span><br><span class="line">//        System.out.println(toString());</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return id + &quot;: &quot; + description + &quot;, price: ￥&quot; + price;</span><br><span class="line">    &#125;</span><br><span class="line">    public void priceChange(double change)&#123;</span><br><span class="line">        price = change;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Generator&lt;Product&gt; generator = new Generator&lt;Product&gt;() &#123;</span><br><span class="line">        private Random rand = new Random(47);</span><br><span class="line">        @Override</span><br><span class="line">        public Product next() &#123;</span><br><span class="line">            return new Product(rand.nextInt(1000), &quot;Test&quot;,</span><br><span class="line">                    Math.round(rand.nextDouble() * 1000.0) + 0.99);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shelf extends ArrayList&lt;Product&gt; &#123;</span><br><span class="line">    public Shelf(int nProducts)&#123;</span><br><span class="line">        Generators.fill(this, Product.generator, nProducts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Aisle extends ArrayList&lt;Shelf&gt; &#123;</span><br><span class="line">    public Aisle(int nShelves, int nProducts)&#123;</span><br><span class="line">        for(int i = 0; i &lt; nShelves; i++)&#123;</span><br><span class="line">            add(new Shelf(nProducts));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CheckoutStand &#123;&#125;</span><br><span class="line">class Office &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class Store extends ArrayList&lt;Aisle&gt; &#123;</span><br><span class="line">    private ArrayList&lt;CheckoutStand&gt; checkouts = new ArrayList&lt;CheckoutStand&gt;();</span><br><span class="line">    private Office office = new Office();</span><br><span class="line">    public Store(int nAisles, int nShelves, int nProducts)&#123;</span><br><span class="line">        for(int i = 0; i &lt; nAisles; i++)&#123;</span><br><span class="line">            add(new Aisle(nShelves,nProducts));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        StringBuilder result = new StringBuilder();</span><br><span class="line">        for(Aisle a : this)&#123;</span><br><span class="line">            for(Shelf s : a)&#123;</span><br><span class="line">                for(Product p : s)&#123;</span><br><span class="line">                    result.append(p);</span><br><span class="line">                    result.append(&quot;\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(new Store(3, 5, 2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p><p>由于擦除（在方法或类内部移除相关实际类型的信息）的存在，<code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 是相同的类（ getClass() 之后是判等返回 true）。</p><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口（一个泛型接口，仅实现一次即可）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Payable&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Employee implements Payable&lt;Employee&gt; &#123;&#125;</span><br><span class="line">class Hourly extends Employee implements Payable&lt;Hourly&gt; &#123;&#125;</span><br><span class="line">// Hourly 无法编译，因为擦除会将 Payable&lt;Employee&gt; 和 Payable&lt;Hourly&gt; 简化为相同的类 Payable</span><br><span class="line">// class Hourly implements Payable&lt;Hourly&gt; &#123;&#125; 这样是可以编译的，但是相当于重复两次地实现相同的接口</span><br><span class="line">// 同理可推，方法重载也会因为擦除的原因，导致产生相同的类型签名，从而无法编译，但是可以把方法名 f 改成 f1, f2</span><br><span class="line">public class useList&lt;T, W&gt; &#123;</span><br><span class="line">    void f(List&lt;T&gt; t) &#123;&#125;</span><br><span class="line">    void f(List&lt;W&gt; w) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至 15.11</p><h3 id="29-数组"><a href="#29-数组" class="headerlink" title="29. 数组"></a>29. 数组</h3><p>数组初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[][] a = &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125; &#125;</span><br><span class="line">int[][] a = new int[1][2] // 数组中构成矩阵的每个向量都可以具有任意的长度</span><br></pre></td></tr></table></figure><p>打印一维数组：<code>Arrays.toString(a)</code>; 打印多维数组：<code>Arrays.deepToString(a)</code></p><p>Arrays 类的6个基本方法：</p><ul><li>equals()：用于比较两个数组是否相等（deepEquals() 用于比较多维数组）</li><li>fill()：用同一个值来填充数组，可以指定起始下标和结束下标</li><li>sort()：用于对数组排序</li><li>binarySearch()：用于在已经排序的数组中查找元素</li><li>toSring()</li><li>hashCode()：产生数组的散列码</li></ul><p>另外 asList() 接受任意的序列和数组作为参数，并将其转换为 List 容器</p><p>复制数组：System.arraycopy() 比 for 循环复制要快很多，但是必须保证两个数组具有相同的确切类型。</p><h3 id="30-散列"><a href="#30-散列" class="headerlink" title="30. 散列"></a>30. 散列</h3><p>使用散列的数据结构：HashSet、HashMap、LinkedHashSet、LinkedHashMap</p><p>使用散列的目的：想要使用一个对象来查找另一个对象</p><h3 id="31-ref-类"><a href="#31-ref-类" class="headerlink" title="31. ref 类"></a>31. ref 类</h3><p>java.lang.ref 类库包含了一组类，这些类为垃圾回收提供了更大的灵活性。</p><p>有三个继承自抽象类 Reference 的类：</p><ul><li>SoftReference：用以实现内存敏感的高速缓存</li><li>WeakReference：是为实现“规范映射”而设计的，不妨碍垃圾回收期回收映射的键或值<ul><li>WeakHashMap：被用来保存 WeakReference。每个值只保存一份实例以节省存储空间。当程序需要那个”值“的时候，便在映射中查询现有的对象，然后使用它（而不是重新再创建）。WeakHashMap 允许垃圾回收期自动清理键和值。</li></ul></li><li>PhantomReference：用以调度回收前的清理工作，比Java终止机制更灵活</li></ul><h3 id="32-I-O"><a href="#32-I-O" class="headerlink" title="32. I/O"></a>32. I/O</h3><h3 id="33-对象序列化"><a href="#33-对象序列化" class="headerlink" title="33. 对象序列化"></a>33. 对象序列化</h3><p>Java 的对象序列化将那些实现了 Serializable 接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，从而实现轻量级持久性（持久性意味着一个对象的生存周期并不取决于程序是否正在执行，可以生存于程序的调用之间）。</p><h3 id="34-枚举"><a href="#34-枚举" class="headerlink" title="34. 枚举"></a>34. 枚举</h3><p>除了不能继承 enum 之外，基本上可以把 enum 看成一个常规的类——可以向里面添加方法，甚至 enum 可以有 main() 方法</p><p>可以为每一个 enum 的实例编写方法，从而为每一个实例赋予不同的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public enum ConstantSpecificMethod &#123;</span><br><span class="line">    DATE_TIME &#123;</span><br><span class="line">        String getInfo()&#123;</span><br><span class="line">            return DateFormat.getDateInstance().format(new Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    CLASSPATH &#123;</span><br><span class="line">        String getInfo()&#123;</span><br><span class="line">            return System.getenv(&quot;CLASSPATH&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-注解"><a href="#35-注解" class="headerlink" title="35. 注解"></a>35. 注解</h3><p>注解的使用方式几乎和修饰符的使用一模一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Testable&#123;</span><br><span class="line">    public void execute()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    @Test void testExecute() &#123; execute(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的定义像是接口的定义，也会被编译成 class 文件。定义注解时，会需要一些元注解，如 <code>@Target</code>（用来定义注解将应用于什么，比如是一个方法或者一个域） 和 <code>@Retention</code>（用来定义该注解在哪一个级别可用，在源代码中(SOURCE)、类文件中(CLASS)或者运行时(RUNTIME)）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface Test &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">元注解</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">@Target</td><td align="center">表示该注解可以用于什么地方。可能的ElementType参数包括：<br> CONSTRUCTOR：构造器的声明 <br> FIELD：域声明（包括 enum 实例）<br> LOCAL_VARIABLE：局部变量 <br> METHOD：方法 <br> PACKAGE：包 <br> PARAMETER：方法参数 <br> TYPE：类、接口（包括注解类型）或 enum 声明</td></tr><tr><td align="center">@Retention</td><td align="center">表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括：<br> SOURCE：注解将被编译器丢弃 <br> CLASS：注解在 class 文件中可用，但会被 VM 丢弃 <br> RUNTIME：VM 将在运行期也保留注释，因此可以通过反射机制读取注解的信息</td></tr><tr><td align="center">@Documented</td><td align="center">将此注解包含在 Javadoc 中</td></tr><tr><td align="center">@Inherited</td><td align="center">允许子类继承父类中的注解</td></tr></tbody></table><h3 id="36-并发"><a href="#36-并发" class="headerlink" title="36. 并发"></a>36. 并发</h3><p><code>implements Runnable</code> 必须具有 run() 方法，但是并不相当于具有了线程的能力，只是写了一个任务，需要把这个任务显式地附着到线程上。</p><p>Runnable 是执行工作的独立任务，但是并不返回任何值。如果希望任务在完成时能够返回一个值，可以换成实现 Callable 接口（需要指明类型参数，这个类型是从 call() 方法中返回的值的类型），必须具有 call() 方法，并且使用 ExecutorService.submit() 方法调用它（会自动得到 call() 方法的返回值）。</p><p>后台程序：必须要在线程调用（执行 thread.start() 方法）之前，调用 <code>thread.setDaemon(true)</code> 方法，才能将线程设置为后台程序</p><p>线程之间等待：在 A 线程下传入 B 线程，在调用 A.run() 方法时，调用 B.join()，其作用是让 A 线程等到 B 线程结束之后再执行（即当 B.isAlive() 返回为假的时候 A 线程才会执行），也可以在 B.join() 加上一个参数，如果 B 线程在目标时间内还没结束的话，join() 也会返回</p><p>在 Java 多线程程序中，所有线程都不允许抛出未捕获的 <code>checked exception</code>（比如 <code>sleep()</code> 时的 <code>InterruptedException</code>），也就是说各个线程需要自己把自己的 <code>checked exception</code> 处理掉。这一点是通过 <code>java.lang.Runnable.run()</code> 方法声明(因为此方法声明上没有 <code>throw exception</code> 部分)进行了约束。但是线程依然有可能抛出 <code>unchecked exception</code>（如运行时异常），当此类异常跑抛出时，线程就会终结，而对于主线程和其他线程完全不受影响，且完全感知不到某个线程抛出的异常(也是说完全无法 <code>catch</code> 到这个异常)。JVM 的这种设计源自于这样一种理念：”线程是独立执行的代码片断，线程的问题应该由线程自己来解决，而不要委托到外部。”基于这样的设计理念，在 Java 中，线程方法的异常（无论是 <code>checked</code> 还是 <code>unchecked exception</code>），都应该在线程代码边界之内（ <code>run()</code> 方法内）进行 <code>try catch</code> 并处理掉。换句话说，我们不能捕获从线程中逃逸的异常。</p><p>如果需要捕获线程的 <code>unchecked exception</code> 时，可以通过修改 <code>Executor</code> 产生线程的方式来解决这个问题。<code>Thread.UncaughtExceptionHandler</code> 接口允许在每一个 Thread 对象上添加一个异常处理器。<code>Thread.UncaughtExceptionHandler.uncaughtException()</code> 方法会在线程因未捕获的异常而面临死亡时被调用。</p><p>原子操作：是不能被线程调度机制中断的操作。可以利用这一点来编写无锁的代码，这些代码不需要被同步，但是也可能不安全。</p><p>临界区（同步控制块）：有时只是希望多个线程同时访问方法内部的部分代码而不是防止访问整个方法。通过这种方式分离出来的代码段称为临界区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在进入这段代码前，必须得到 syncObject 对象的锁</span><br><span class="line">// 如果其他线程已经得到这个锁，那么就得等到锁被释放以后，才能进入临界区</span><br><span class="line">synchronized(syncObject)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程四个状态：</p><ul><li>新建(new)：线程被创建后，只会短暂处于这种状态。之后调度器将把这个线程转变为可运行状态或阻塞状态</li><li>就绪(runable)：在这个状态下，只要调度器把时间片分给线程，线程就可以运行。即，在任意时刻，线程可以运行也可以不运行，去看调度器是否分配了时间片</li><li>阻塞(blocked)：当线程处于阻塞状态时，调度器会忽略线程，直到线程重新进入了就绪状态，才可能执行<ul><li>进入阻塞状态的原因<ul><li>通过调用 sleep(milliseconds) 使任务进入休眠状态</li><li>通过调用 wait() 将线程挂起，直到线程得到了 notify() 或者 notifyAll() 消息，线程才会进入就绪状态</li><li>任务在等待某个输入/输出完成</li><li>任务视图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁</li></ul></li></ul></li><li>死亡(dead)：此时线程不再是可调度的</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive Sql的窗口函数</title>
      <link href="/2019/08/30/Hive-4/"/>
      <url>/2019/08/30/Hive-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Hive-Sql的窗口函数"><a href="#Hive-Sql的窗口函数" class="headerlink" title="Hive Sql的窗口函数"></a>Hive Sql的窗口函数</h2><h3 id="1-count、sum、avg、max、min"><a href="#1-count、sum、avg、max、min" class="headerlink" title="1. count、sum、avg、max、min"></a>1. count、sum、avg、max、min</h3><p>以 <code>sum</code> 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 按照 year 来分组，统计每一年的总和</span><br><span class="line"># 结果：每个月的值都是本年的总和</span><br><span class="line">sum(val) over(partition by year)</span><br><span class="line"></span><br><span class="line"># 按照 year 来分组，按照 month 来排序</span><br><span class="line"># 结果：n 月的值是本年 1 - n 月的累计值</span><br><span class="line">sum(val) over(partition by year order by month)</span><br></pre></td></tr></table></figure><blockquote><p>通过 <code>explain select ...</code> 来查看语句解析，可以简单理解为，在每一次 <code>order by</code> 之后，会执行一次 <code>sum</code> 的 <code>reduce</code> 过程，也就导致结果计算的是 1 - n 月的累计值</p></blockquote><h3 id="2-rows-between"><a href="#2-rows-between" class="headerlink" title="2. rows between"></a>2. rows between</h3><p>以 <code>sum</code> 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 按照 year 分组，按照 month 排序，计算前3行和后1行的总和</span><br><span class="line">sum(val) over(partition by year order by month rows between 3 preceding and 1 following)</span><br></pre></td></tr></table></figure><ul><li>preceding：往前</li><li>following：往后</li><li>current row：当前行</li><li>unbounded：起点<ul><li>unbounded preceding：表示从前面的起点</li><li>unbounded following：表示到后面的终点</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 以下两种方式是等效的</span><br><span class="line">sum(val) over(partition by year)</span><br><span class="line">sum(val) over(partition by year rows between unbounded preceding and unbounded following)</span><br><span class="line"></span><br><span class="line"># 以下两种方式是等效的</span><br><span class="line">sum(val) over(partition by year order by month)</span><br><span class="line">sum(val) over(partition by year order by month rows between unbounded preceding and current row)</span><br><span class="line"></span><br><span class="line"># 以下两种方式不等效</span><br><span class="line">sum(val) over(partition by year rows between unbounded preceding and current row)</span><br><span class="line">sum(val) over(partition by year order by month rows between unbounded preceding and current row)</span><br><span class="line"># current row 应该是和 order by 同时出现，要不然会导致数据错位</span><br></pre></td></tr></table></figure><h3 id="3-ntile"><a href="#3-ntile" class="headerlink" title="3. ntile"></a>3. ntile</h3><p>切片：用于将分组数据按照顺序切分成n片，返回当前切片值；不支持 rows between；如果切片不均匀，默认增加第一个切片的分布（比如有6条数据，分4组，数量依次为2 2 1 1）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 统计一个月内，val 最多的前 1/n </span><br><span class="line">ntile(n) over(partition by month order by val desc) as rn</span><br><span class="line">rn = 1 就是最终想要的结果，前提是数据可以被均匀分片</span><br></pre></td></tr></table></figure><h3 id="4-row-number、rank、dense-rank"><a href="#4-row-number、rank、dense-rank" class="headerlink" title="4. row_number、rank、dense_rank"></a>4. row_number、rank、dense_rank</h3><ul><li>row_number：行号</li><li>rank：排名——结果中可能有空位 eg：1 2 2 4</li><li>dense_rank：排名——结果中无空位 eg：1 2 2 3</li></ul><h3 id="5-cume-dist"><a href="#5-cume-dist" class="headerlink" title="5. cume_dist"></a>5. cume_dist</h3><p>计算公式：(小于等于当前值的行数 / 分组内的总行数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 统计小于等于当前薪水的人占部门内总人数的比例</span><br><span class="line">cume_dist() over(partition by dept order by salary)</span><br></pre></td></tr></table></figure><h3 id="6-percent-rank"><a href="#6-percent-rank" class="headerlink" title="6. percent_rank"></a>6. percent_rank</h3><p>计算公式：(分组内当前行的rank值 - 1 / 分组内总行数 - 1)</p><h3 id="7-lag-col-n-DEFAULT"><a href="#7-lag-col-n-DEFAULT" class="headerlink" title="7. lag(col, n, DEFAULT)"></a>7. lag(col, n, DEFAULT)</h3><p>统计窗口内往上第 n 行值</p><p>三个参数分别是：列名；往上第 n 行（可选，默认是1）；当往上第 n 行为 NULL 的时候，取默认值，如不指定，则为 NULL</p><h3 id="8-lead-col-n-DEFAULT"><a href="#8-lead-col-n-DEFAULT" class="headerlink" title="8. lead(col, n, DEFAULT)"></a>8. lead(col, n, DEFAULT)</h3><p>统计窗口内往下第 n 行值</p><p>三个参数分别是：列名；往下第 n 行（可选，默认是1）；当往下第 n 行为 NULL 的时候，取默认值，如不指定，则为 NULL</p><h3 id="9-first-value-col"><a href="#9-first-value-col" class="headerlink" title="9. first_value(col)"></a>9. first_value(col)</h3><p>取分组内排序后，取第一个的 col </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_value(col) over(partition by ... order by ...)</span><br></pre></td></tr></table></figure><h3 id="10-last-value-col"><a href="#10-last-value-col" class="headerlink" title="10. last_value(col)"></a>10. last_value(col)</h3><p>取分组内排序后，截止到当前行，最后一个的 col =&gt; 相当于分组排序后，取当前这一行的 col</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last_value(col) over(partition by ... order by ...)</span><br></pre></td></tr></table></figure><blockquote><p>如果不指定 order by，则默认按照记录在文件中的偏移量进行排序，会出现错误的结果</p></blockquote><blockquote><p>如果要取分组内排序后最后一个 col，可以换成下面的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; first_value(col) over(partition by ... order by ... desc)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="11-grouping-sets"><a href="#11-grouping-sets" class="headerlink" title="11. grouping sets"></a>11. grouping sets</h3><p>在一个 <code>group by</code> 查询中，根据不同的维度组合进行聚合，等价于将不同维度的 <code>group by</code> 结果集进行 <code>union all</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">select year, month, count(1)a, grouping__id </span><br><span class="line">from ...</span><br><span class="line">group by year, month</span><br><span class="line">grouping sets(year, month, (year, month))</span><br><span class="line">order by grouping__id</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line">select year, &apos;null&apos; as month, count(1)a, 1 as grouping__id </span><br><span class="line">from ...</span><br><span class="line">group by year, month</span><br><span class="line">union all</span><br><span class="line">select &apos;null&apos; as year, month, count(1)a, 2 as grouping__id </span><br><span class="line">from ...</span><br><span class="line">group by month</span><br><span class="line">union all</span><br><span class="line">select year, month, count(1)a, 3 as grouping__id </span><br><span class="line">from ...</span><br><span class="line">group by year, month</span><br></pre></td></tr></table></figure><blockquote><p>grouping sets (col1, col2 …) 使用前必须要先写 group by (col1, col2 …)， grouping sets 表示在 group by 括号内出现的字段组合的情况，所以 grouping sets 出现的字段肯定是在 group by 中出现过的</p></blockquote><blockquote><p>grouping__id 表示结果属于哪一个分组集合，只能和 grouping sets 组合着用，单独使用报错。有两个下划线！！！</p></blockquote><h3 id="12-cube"><a href="#12-cube" class="headerlink" title="12. cube"></a>12. cube</h3><p>根据 group by 的维度的所有组合进行聚合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select year, month, count(1)a, grouping__id </span><br><span class="line">from ...</span><br><span class="line">group by year, month</span><br><span class="line">with cube</span><br><span class="line">order by grouping__id</span><br><span class="line"></span><br><span class="line">等价于以下四种情况 union all</span><br><span class="line">1. 相当于直接 count(1)a</span><br><span class="line">2. 按照 year 来分组</span><br><span class="line">3. 按照 month 来分组</span><br><span class="line">4. 按照 year&amp;month 来分组</span><br></pre></td></tr></table></figure><h3 id="13-rollup"><a href="#13-rollup" class="headerlink" title="13. rollup"></a>13. rollup</h3><p>是 cube 的子集，以最左侧的维度为主，从该维度进行层级聚合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select year, month, count(1)a, grouping__id </span><br><span class="line">from ...</span><br><span class="line">group by year, month</span><br><span class="line">with rollup</span><br><span class="line">order by grouping__id</span><br><span class="line"></span><br><span class="line">等价于先进行 with cube操作，即以下四种情况 union all</span><br><span class="line">1. 相当于直接 count(1)a</span><br><span class="line">2. 按照 year 来分组</span><br><span class="line">3. 按照 month 来分组</span><br><span class="line">4. 按照 year&amp;month 来分组</span><br><span class="line"></span><br><span class="line">然后 year 是最左侧的维度，则按照 year 来进行层级聚合，过滤掉 year 为 NULL 的记录（但是第1中情况对所有数据进行count(1)的这一条数据会依旧保存）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka概念</title>
      <link href="/2019/08/07/Kafka-1/"/>
      <url>/2019/08/07/Kafka-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka概念"><a href="#Kafka概念" class="headerlink" title="Kafka概念"></a>Kafka概念</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>Apache kafka是消息中间件的一种，我发现很多人不知道消息中间件是什么，在开始学习之前，我这边就先简单的解释一下什么是消息中间件，只是粗略的讲解，目前kafka已经可以做更多的事情。</p><p>举个例子，生产者消费者，生产者生产鸡蛋，消费者消费鸡蛋，生产者生产一个鸡蛋，消费者就消费一个鸡蛋，假设消费者消费鸡蛋的时候噎住了（系统宕机了），生产者还在生产鸡蛋，那新生产的鸡蛋就丢失了。再比如生产者很强劲（大交易量的情况），生产者1秒钟生产100个鸡蛋，消费者1秒钟只能吃50个鸡蛋，那要不了一会，消费者就吃不消了（消息堵塞，最终导致系统超时），消费者拒绝再吃了，”鸡蛋“又丢失了，这个时候我们放个篮子在它们中间，生产出来的鸡蛋都放到篮子里，消费者去篮子里拿鸡蛋，这样鸡蛋就不会丢失了，都在篮子里，而这个篮子就是”kafka“。</p><p>鸡蛋其实就是“数据流”，系统之间的交互都是通过“数据流”来传输的（就是tcp、https什么的），也称为报文，也叫“消息”。</p><p>消息队列满了，其实就是篮子满了，”鸡蛋“ 放不下了，那赶紧多放几个篮子，其实就是kafka的扩容。</p><p>各位现在知道kafka是干什么的了吧，它就是那个”篮子”。</p><h3 id="2-名词解释"><a href="#2-名词解释" class="headerlink" title="2. 名词解释"></a>2. 名词解释</h3><ol><li><p>从业务角度</p><ol><li><p><code>producer</code>：生产者，就是它来生产“鸡蛋”的。</p></li><li><p><code>consumer</code>：消费者，生出的“鸡蛋”它来消费。</p></li><li><p><code>topic</code>：你把它理解为标签，生产者每生产出来一个鸡蛋就贴上一个标签（topic），消费者可不是谁生产的“鸡蛋”都吃的，这样不同的生产者生产出来的“鸡蛋”，消费者就可以选择性的“吃”了。</p></li><li><p><code>broker</code>：就是篮子了。</p></li></ol></li><li><p>从技术角度</p><ol><li><p><code>producer</code>：发布消息的对象称之为主题生产者(Kafka topic producer)。</p></li><li><p><code>consumer</code>：订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)。</p></li><li><p><code>topic</code>：Kafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic)。每一类业务数据要从不同的主题下拿取。</p></li><li><p><code>broker</code>：已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p></li></ol></li></ol><h3 id="3-主要应用于以下两方面"><a href="#3-主要应用于以下两方面" class="headerlink" title="3. 主要应用于以下两方面"></a>3. 主要应用于以下两方面</h3><ol><li><p>构建实时的流数据管道，可靠地获取系统和应用程序之间的数据。</p></li><li><p>构建实时流的应用程序，对数据流进行转换或反应。</p></li></ol><h3 id="4-几个概念"><a href="#4-几个概念" class="headerlink" title="4. 几个概念"></a>4. 几个概念</h3><ol><li><p>kafka作为一个集群运行在一个或多个服务器上。</p></li><li><p>kafka集群存储的消息是以topic为类别记录的。</p></li><li><p>每个消息（也叫记录record，我习惯叫消息）是由一个key，一个value和时间戳构成。</p></li></ol><h3 id="5-四个核心-API"><a href="#5-四个核心-API" class="headerlink" title="5. 四个核心 API"></a>5. 四个核心 API</h3><p><img src="https://images.weserv.nl/?url=https://img.orchome.com/group1/M00/00/01/KmCudlf7DXiAVXBMAAFScKNS-Og538.png" alt="核心API"></p><ol><li><p>应用程序使用 <code>Producer API</code> 发布消息到1个或多个 topic（主题）。</p></li><li><p>应用程序使用 <code>Consumer API</code> 来订阅一个或多个 topic，并处理产生的消息。</p></li><li><p>应用程序使用 <code>Streams API</code> 充当一个流处理器，从1个或多个 topic 消费输入流，并生产一个输出流到1个或多个输出 topic，有效地将输入流转换到输出流。</p></li><li><p><code>Connector API</code> 允许构建或运行可重复使用的生产者或消费者，将 topic 连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala编程 笔记</title>
      <link href="/2019/08/07/Scala-2/"/>
      <url>/2019/08/07/Scala-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Scala编程-笔记"><a href="#Scala编程-笔记" class="headerlink" title="Scala编程 笔记"></a>Scala编程 笔记</h2><h3 id="1-makeRDD-和-parallelize-生成-RDD"><a href="#1-makeRDD-和-parallelize-生成-RDD" class="headerlink" title="1. makeRDD 和 parallelize 生成 RDD"></a>1. makeRDD 和 parallelize 生成 RDD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def parallelize[T: ClassTag](</span><br><span class="line">      seq: Seq[T],</span><br><span class="line">      numSlices: Int = defaultParallelism): RDD[T]</span><br><span class="line"> </span><br><span class="line">def makeRDD[T: ClassTag](</span><br><span class="line">      seq: Seq[T],</span><br><span class="line">      numSlices: Int = defaultParallelism): RDD[T]</span><br><span class="line"> </span><br><span class="line">def makeRDD[T: ClassTag](seq: Seq[(T, Seq[String])]): RDD[T]</span><br></pre></td></tr></table></figure><p>makeRDD 最底层实现还是通过 parallelize 的方式，所以两种方式没有太大的区别。numSlices 是传入的切片数。</p><blockquote><p>Scala 中的 Seq 相当于 Java 的 List，Scala 的 List 相当于 Java 的LinkedList</p></blockquote><h3 id="2-yield"><a href="#2-yield" class="headerlink" title="2. yield"></a>2. yield</h3><p>for 循环中的 yield 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。Scala 中 for 循环是有返回值的。如果被循环的是 Map，返回的就是 Map，被循环的是 List，返回的就是 List，以此类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1, 2, 3, 4, 5)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5)</span><br><span class="line"> </span><br><span class="line">scala&gt; for (e &lt;- a if e &gt; 2) yield e</span><br><span class="line">res1: Array[Int] = Array(3, 4, 5)</span><br><span class="line"></span><br><span class="line">// 可以在 for 循环中添加 if 语句，进行过滤</span><br><span class="line">def scalaFiles =</span><br><span class="line">    for &#123;</span><br><span class="line">        file &lt;- filesHere</span><br><span class="line">        if file.isFile</span><br><span class="line">        if file.getName.endsWith(&quot;.scala&quot;)</span><br><span class="line">    &#125; yield file</span><br></pre></td></tr></table></figure><h3 id="3-函数和方法"><a href="#3-函数和方法" class="headerlink" title="3.函数和方法"></a>3.函数和方法</h3><p>首先有一个比较广泛的叫法规则是：<br>面向对象的语言叫方法 eg：Java<br>面对过程的语言叫函数 eg：C<br>对于 Java 而言，函数和方法一般都是一样的。<br>对于 Python 而言，分两种情况：  </p><ol><li>与类和实例无绑定关系的 function 叫做函数</li><li>与类和实例有绑定关系的 function 叫做方法</li></ol><blockquote><p>这里的绑定，我的理解是，调用参数中包含类或实例，并在 function 中对参数进行了赋值</p></blockquote><p>对于 Scala 而言，分两种情况：</p><ol><li><p>方法是一个以 def 开头的带有参数列表（可以无参数列表）的一个逻辑操作块，这正如 object 或者 class 中的成员方法一样</p></li><li><p>函数是赋值给一个变量（或者常量）的匿名方法（带或者不带参数列表），并且通过 =&gt; 转换符号跟上逻辑代码块的一个表达式。=&gt; 转换符号后面的逻辑代码块的写法与 method 的 body 部分相同</p></li></ol><h3 id="4-List-的一些方法"><a href="#4-List-的一些方法" class="headerlink" title="4. List 的一些方法"></a>4. List 的一些方法</h3><blockquote><p>Scala 的 seq = Java 的 List<br>Scala 的 List = Java 的 LinkedList</p></blockquote><ol><li>mkString</li><li>drop 丢弃前 n 个元素，返回新列表</li><li>dropRight 丢弃最后 n 个元素，返回新列表</li><li>head 返回第一个元素</li><li>tail 返回所有元素，除第一个</li><li>last 返回最后一个元素</li><li>init 返回所有元素，除最后一个</li><li>take 返回前 n 个元素</li><li>takeRight 返回后 n 个元素<br>……</li></ol><p><a href="#list">更多详情见33</a></p><p><a href="https://www.runoob.com/scala/scala-lists.html" target="_blank" rel="noopener">List常用方法</a></p><h3 id="5-Map-的初始化"><a href="#5-Map-的初始化" class="headerlink" title="5. Map 的初始化"></a>5. Map 的初始化</h3><p>(key1 -&gt; val1, key2 -&gt; val2)</p><h3 id="6-Set-和-Map"><a href="#6-Set-和-Map" class="headerlink" title="6. Set 和 Map"></a>6. Set 和 Map</h3><ol><li>可变：修改集合本身</li><li>不可变：创建并返回一个新的集合</li></ol><h3 id="7-reduceLeft-和-reduceRight"><a href="#7-reduceLeft-和-reduceRight" class="headerlink" title="7. reduceLeft 和 reduceRight"></a>7. reduceLeft 和 reduceRight</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val longestLine = lines.reduceLeft(</span><br><span class="line">      (a, b) =&gt; if(a.length &gt; b.length) a else b</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>reduceLeft 会把自动把第一个、第二个的比较结果保存，再和第三个进行比较，以此类推，最后返回一个值。</p><p>eg：求和 求最大值等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.reduceLeft(_ + _)</span><br><span class="line">array.reduceLeft(_ max _)</span><br></pre></td></tr></table></figure><p>reduceRight 会从尾部开始拿两个数据进行计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val list = List(1,2,3,4,5)</span><br><span class="line">list.reduce(_ - _) // -13</span><br><span class="line">list.reduceLeft(_ - _) // -13</span><br><span class="line">list.reduceRight(_ - _) // 3 先计算 4-5，然后是 3-(4-5) ...</span><br></pre></td></tr></table></figure><h3 id="8-Scala自带的特质：-Application"><a href="#8-Scala自带的特质：-Application" class="headerlink" title="8. Scala自带的特质： Application"></a>8. Scala自带的特质： Application</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object test extends Application &#123;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特质 Application 声明了带有适合的签名的 main 方法，继承 Application 之后，可以把原先放在 main 方法中的代码直接放在单例对象的大括号之间，这样代码比显式的 main 会显得要短，但也存在几个缺点：</p><ol><li><p>如果运行时有参数，那就必须得带有显式的 main 方法</p></li><li><p>如果程序是多线程的话，就需要显式的 main 方法</p></li><li><p>某些 JVM 的实现没有优化被 Application 特质执行的对象的初始化代码</p></li></ol><h3 id="9-富包装器"><a href="#9-富包装器" class="headerlink" title="9. 富包装器"></a>9. 富包装器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">代码                    结果</span><br><span class="line">0 max 5                 5</span><br><span class="line">-2.7 abs                2.7</span><br><span class="line">-2.7 round              -3L</span><br><span class="line">1.5 isInfinity          false</span><br><span class="line">(1.0/0) isInfinity      true</span><br><span class="line">4 to 6                  range(4, 5, 6)</span><br><span class="line">&quot;bob&quot; capitalize        &quot;Bob&quot;</span><br><span class="line">&quot;robert&quot; drop 2         &quot;bert&quot;</span><br></pre></td></tr></table></figure><h3 id="10-先决条件：precondition"><a href="#10-先决条件：precondition" class="headerlink" title="10. 先决条件：precondition"></a>10. 先决条件：precondition</h3><p>在构造器中可以定义一个先决条件：对传递给方法或构造器的参数的值进行限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Rational(n: Int, d: Int)&#123;</span><br><span class="line">      require(d != 0)</span><br><span class="line">      override def toString = n + &quot;/&quot; + d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>require 方法会带一个布尔型参数。如果传入的值是真，require 会正常返回，并进行下面的操作。反之，require 会通过抛出 IllegalArgumentException 来阻止对象被构造。</p><h3 id="11-从构造器-auxiliary-constructor"><a href="#11-从构造器-auxiliary-constructor" class="headerlink" title="11. 从构造器 auxiliary constructor"></a>11. 从构造器 auxiliary constructor</h3><p>有时候一个类里面需要多个构造器，比如构造分数时，分子为1时就不需要传递分子这个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Rational(n: Int, d: Int)&#123;</span><br><span class="line">      require(d != 0)</span><br><span class="line">      override def toString = n + &quot;/&quot; + d</span><br><span class="line">      def this(n: Int) = this(n, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造器从 <code>def this(...)</code> 开始，几乎完全调用主构造器，直接传递主构造器的参数。</p><blockquote><p>主构造器是类的唯一入口点。</p></blockquote><h3 id="12-最大公约数-greatest-common-divisor"><a href="#12-最大公约数-greatest-common-divisor" class="headerlink" title="12. 最大公约数 greatest common divisor"></a>12. 最大公约数 greatest common divisor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private def gcd(a: Int, b: Int): Int = if(b == 0) a else gcd(b, a % b)</span><br></pre></td></tr></table></figure><h3 id="13-闭包"><a href="#13-闭包" class="headerlink" title="13. 闭包"></a>13. 闭包</h3><p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var factor = 3  </span><br><span class="line">val multiplier = (i:Int) =&gt; i * factor</span><br></pre></td></tr></table></figure><h3 id="14-for-循环"><a href="#14-for-循环" class="headerlink" title="14. for 循环"></a>14. for 循环</h3><h4 id="14-1-简单的循环"><a href="#14-1-简单的循环" class="headerlink" title="14.1 简单的循环"></a>14.1 简单的循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(i &lt;- 1 to 4) 1, 2, 3, 4</span><br><span class="line">for(i &lt;- 1 until 4) 1, 2, 3</span><br></pre></td></tr></table></figure><h4 id="14-2-在-for-循环中添加过滤器"><a href="#14-2-在-for-循环中添加过滤器" class="headerlink" title="14.2 在 for 循环中添加过滤器"></a>14.2 在 for 循环中添加过滤器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(</span><br><span class="line">      file &lt;- files </span><br><span class="line">      if file.isFile;</span><br><span class="line">      if file.getName.endsWith(&quot;.scala&quot;)</span><br><span class="line">) println(file)</span><br></pre></td></tr></table></figure><blockquote><p>如果添加超过一个过滤器，if字句必须用分号分隔。</p></blockquote><h4 id="14-3-嵌套枚举"><a href="#14-3-嵌套枚举" class="headerlink" title="14.3 嵌套枚举"></a>14.3 嵌套枚举</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def fileLines(file: java.io.File) = scala.io.Source.fromFile(file).getLines.tolist</span><br><span class="line"></span><br><span class="line">def grep(pattern: String) = &#123;</span><br><span class="line">      for&#123;</span><br><span class="line">            file &lt;- files</span><br><span class="line">            if file.getName.endsWith(&quot;.scala&quot;)</span><br><span class="line">            line &lt;- fileLines(file)</span><br><span class="line">            if line.trim.mathces(pattern)</span><br><span class="line">      &#125; println(file + &quot;: &quot; + line.trim)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grep(&quot;.*gcd.*&quot;)</span><br></pre></td></tr></table></figure><h4 id="14-4-创建新集合"><a href="#14-4-创建新集合" class="headerlink" title="14.4 创建新集合"></a>14.4 创建新集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &#123;字句&#125; yield &#123;循环体&#125;</span><br></pre></td></tr></table></figure><p>for 表达式在每次执行的时候都会产生一个值，在 for 表达式完成之后，返回的结果将是一个包含了所有产生的值的集合。结果集合的类型取决于枚举子句处理的结合类型。</p><h3 id="15-模式匹配"><a href="#15-模式匹配" class="headerlink" title="15. 模式匹配"></a>15. 模式匹配</h3><h4 id="15-1-match-表达式"><a href="#15-1-match-表达式" class="headerlink" title="15.1 match 表达式"></a>15.1 match 表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val firstArg = if (args.length &gt; 0 ) args(0) else &quot;&quot;</span><br><span class="line">firstArg match &#123;</span><br><span class="line">  case &quot;salt&quot; =&gt; println(&quot;pepper&quot;)</span><br><span class="line">  case &quot;chips&quot; =&gt; println(&quot;salsa&quot;)</span><br><span class="line">  case &quot;eggs&quot; =&gt; println(&quot;bacon&quot;)</span><br><span class="line">  case _ =&gt; println(&quot;¿&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺省情况用下划线说明，这是常用在 Scala 里作为占位符表示完全不清楚的值的通配符。</p><p>这段代码和 Java 的 switch 相比有几点不同：</p><ol><li>任何类型的常量都可以用在 case 语句中，而不仅仅是 int 或是枚举类型。</li><li>每个 case 语句无需使用 break，Scala不支持 “fall through”。</li><li>Scala 的缺省匹配为’_’，其作用类似 Java 中的 default。</li></ol><p>而最关键的一点是 Scala 的 match 表达式有返回值，上面的代码使用的是 println 打印，而实际上你可以使用表达式，比如修改上面的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val firstArg = if (args.length &gt; 0 ) args(0) else &quot;&quot;</span><br><span class="line">val friend = firstArg match &#123;</span><br><span class="line">  case &quot;salt&quot; =&gt; &quot;pepper&quot; </span><br><span class="line">  case &quot;chips&quot; =&gt; &quot;salsa&quot; </span><br><span class="line">  case &quot;eggs&quot; =&gt; &quot;bacon&quot; </span><br><span class="line">  case _ =&gt; &quot;¿&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-更多详情见32"><a href="#15-2-更多详情见32" class="headerlink" title="15.2 更多详情见32"></a>15.2 <a href="#match">更多详情见32</a></h4><h3 id="16-重复参数"><a href="#16-重复参数" class="headerlink" title="16. 重复参数"></a>16. 重复参数</h3><p>Scala 允许指明函数的最后一个参数可以是重复的。这可以允许用户向函数传入可变长度参数列表。想要标注一个重复参数，在参数的类型之后放一个星号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def echo(args: String*) = </span><br><span class="line">      for (arg &lt;- args) println(arg)</span><br><span class="line"></span><br><span class="line">echo()</span><br><span class="line">echo(&quot;one&quot;)</span><br><span class="line">echo(&quot;one&quot;, &quot;two&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>echo 函数里被声明为类型 String 的 args，传入到函数中的其实是 Array[String]。但是我们并不能直接传递给 echo 函数一个数组（数组中的每一个元素都是 String）。但是可以换成下面的写法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array(&quot;one&quot;, &quot;two&quot;)</span><br><span class="line">echo(arr: _*)</span><br></pre></td></tr></table></figure><p>这个标注告诉编译器把 arr 的每个元素当作参数，而不是当作单一的参数传给 echo。</p><h3 id="17-尾递归"><a href="#17-尾递归" class="headerlink" title="17. 尾递归"></a>17. 尾递归</h3><p>使用递归函数来消除需要使用 var 变量的 while 循环。下面为一个使用逼近方法求解的一个递归函数表达：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def approximate(guess: Double) : Double =</span><br><span class="line">      if (isGoodEnough(guess)) guess</span><br><span class="line">      else approximate(improve(guess))</span><br></pre></td></tr></table></figure><p>通过实现合适的 isGoodEnough 和 improve 函数，说明这段代码在搜索问题中经常使用。 如果你打算 approximate 运行的快些，你很可能使用下面循环来实现什么的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def approximateLoop(initialGuess: Double) : Double = &#123;</span><br><span class="line">      var guess = initialGuess</span><br><span class="line">      while(!isGoodEnough(guess))</span><br><span class="line">      guess=improve(guess)</span><br><span class="line">      guess</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从简洁度和避免使用 var 变量上看，使用函数化编程递归比较好。但是有 while 循环是否运行效率更高些？实际上，如果我们通过测试，两种方法所需时间几乎相同，这听起来有些不可思议，因为回调函数看起来比使用循环要耗时得多。</p><p>其实，对于 approximate 的递归实现，Scala 编译器会做些优化，我们可以看到 approximate 的实现，最后一行还是调用 approximate 本身，我们把这种递归叫做尾递归。Scala 编译器可以检测到尾递归而使用循环来代替。因此，你应该习惯使用递归函数来解决问题，如果是尾递归，那么在效率时不会有什么损失。</p><blockquote><p>在函数最后一行调用自身时，不能再有任何其他操作，如果有其他的类似于 ±1 的操作的话就不算是尾递归。</p></blockquote><p>Scala优化尾递归的方案：所有的调用将在一个框架内执行。</p><p>但也有其局限的地方：因为 JVM 指令集使实现更加先进的尾递归形式变得很难。Scala 仅优化了直接实现尾递归的函数。如果递归是间接的，如下面代码所示，那就没有优化的可能性了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def isEven(x:Int): Boolean =</span><br><span class="line">      if(x==0) true else isOdd(x-1)</span><br><span class="line">def isOdd(x:Int): Boolean=</span><br><span class="line">      if(x==0) false else isEven(x-1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序的例子</span><br><span class="line">def quicksort(ls: List[Int]): List[Int] = &#123;</span><br><span class="line">      if (ls.isEmpty)</span><br><span class="line">            ls</span><br><span class="line">      else</span><br><span class="line">            quicksort(ls.filter(_ &lt; ls.head)) ::: ls.head :: quicksort(ls.filter(_ &gt; ls.head))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-exists"><a href="#18-exists" class="headerlink" title="18. exists"></a>18. exists</h3><p>Scala 标准库中的一个高阶函数，可以用来替换一定的循环结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def containsOdd(nums: List[Int]): Boolean = &#123;</span><br><span class="line">      var exists = false</span><br><span class="line">      for (num &lt;- nums)</span><br><span class="line">            if(num % 2 == 1)</span><br><span class="line">                  exists = true</span><br><span class="line">      exists</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以替换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)</span><br></pre></td></tr></table></figure><h3 id="19-Curry-柯里化"><a href="#19-Curry-柯里化" class="headerlink" title="19. Curry 柯里化"></a>19. Curry 柯里化</h3><p>Curry化指的是：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def oldSum(x: Int, y: Int) = x + y</span><br><span class="line">oldSum(1, 2)</span><br><span class="line"></span><br><span class="line">经过 Curry 化后</span><br><span class="line">def curriedSum(x: Int)(y: Int) = x + y</span><br><span class="line">curriedSum(1)(2)</span><br><span class="line"></span><br><span class="line">Curry 化的过程类似于以下过程：</span><br><span class="line">def first(x: Int) = (y: Int) =&gt; x + y</span><br><span class="line">val second = first(1)</span><br><span class="line">second(2)</span><br></pre></td></tr></table></figure><h3 id="20-大括号和小括号"><a href="#20-大括号和小括号" class="headerlink" title="20. 大括号和小括号"></a>20. 大括号和小括号</h3><p>Scala的任何方法在调用时，如果只传入一个参数，就能可选地使用大括号来代替小括号包围参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;Hello, world!&quot;)</span><br><span class="line">println&#123;&quot;Hello, world!&quot;&#125;</span><br></pre></td></tr></table></figure><p>但是如果有2个及以上参数时，是不可以使用大括号的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val g = &quot;Hello, world!&quot; </span><br><span class="line">g.substring&#123;7, 9&#125;  错误</span><br><span class="line">g.substring(7, 9)  正确</span><br></pre></td></tr></table></figure><blockquote><p>在传入一个参数时可以用大括号替代小括号的机制的目的是让客户程序员能写出包围在大括号内的函数文本。这可以让方法调用感觉更像控制抽象。</p></blockquote><h3 id="21-编写新的控制结构"><a href="#21-编写新的控制结构" class="headerlink" title="21. 编写新的控制结构"></a>21. 编写新的控制结构</h3><p>如何编写新的控制结构？创建带函数做参数的方法。</p><blockquote><p>函数是可以被当做参数传递的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def withPrintWriter(file: File, op: PrintWriter =&gt; Unit) &#123;  </span><br><span class="line">    val writer = new PrintWriter(file)  </span><br><span class="line">    try &#123;  </span><br><span class="line">      op(writer)  </span><br><span class="line">    &#125; finally &#123;  </span><br><span class="line">      writer.close()  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">withPrintWriter(  </span><br><span class="line">    new File(&quot;date.txt&quot;),  </span><br><span class="line">    writer =&gt; writer.println(new java.util.Date)  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用这个方法的好处是，由 withPrintWriter 而不是用户的代码，确认文件在结尾被关闭。因此忘记关闭文件是不可能的。这个技巧被称为贷出模式：loan pattern，因为控制抽象函数，如 withPrintWriter，打开了资源并”贷出”给函数。例如，前面例子里的 withPrintWriter 把 PrintWriter 借给函数op。当函数完成的时候，它发出信号说明它不再需要”借”的资源。于是资源被关闭在finally块中，以确信其确实被关闭，而忽略函数是正常结束返回还是抛出了异常。</p><p>结合第 20 条笔记，把 withPrintWriter 方法的参数 curry 化，这样可以使得方法在调用时，可以用大括号来编写方法体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def withPrintWriter(file: File)(op: PrintWriter =&gt; Unit) &#123;  </span><br><span class="line">    val writer = new PrintWriter(file)  </span><br><span class="line">    try &#123;  </span><br><span class="line">      op(writer)  </span><br><span class="line">    &#125; finally &#123;  </span><br><span class="line">      writer.close()  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">方法调用时使用大括号：</span><br><span class="line">val file = new File(&quot;date.txt&quot;)</span><br><span class="line">withPrintWriter(file)&#123;</span><br><span class="line">    writer =&gt; writer.println(new java.util.Date)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-叫名参数-by-name-parameter"><a href="#22-叫名参数-by-name-parameter" class="headerlink" title="22. 叫名参数 by-name parameter"></a>22. 叫名参数 by-name parameter</h3><h3 id="23-Scala的类层级"><a href="#23-Scala的类层级" class="headerlink" title="23. Scala的类层级"></a>23. Scala的类层级</h3><p><img src="https://atts.w3cschool.cn/attachments/image/wk/scaladevelopmentguide/16.png" alt="类层级"></p><ol><li><p>Any 是所有其他类的超类，Nothing 是所有其他类的子类。</p></li><li><p>Unit 类相当于 Java 的 void 类型，被用作不返回任何结果的方法的结果类型。</p></li><li><p>值类的空间是扁平的：所有的值类都是 scala.AnyVal 的子类型，但是它们不是互相的子类。代之以它们不同的值类类型之间可以隐式地互相转换。例如，需要的时候，类 scala.Int 的实例可以自动放宽（通过隐式转换）到类 scala.Long 的实例。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">42 max 43</span><br><span class="line">42 min 43</span><br><span class="line">1 until 5 =&gt; scala.collection.immutable.Range = Range(1, 2, 3, 4)</span><br><span class="line">1 to 5 =&gt; scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>像 max、min、until、to、abs 等方法都定义在类 scala.runtime.RichInt 里，当你在 Int 上调用没有定义在 Int 上但定义在 RichInt 上的方法时，会自动进行从类 Int 到 RichInt 的隐式转换。</p><ol start="4"><li><p>AnyRef 是所有引用类的基类，是 Java 中 java.lang.Object 的别名。</p></li><li><p>关于相等</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Java代码 </span><br><span class="line">boolean isEqual(int x,int y) &#123; </span><br><span class="line">  return x == y; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(isEqual(421,421)); 结果是true</span><br><span class="line"></span><br><span class="line">// Java代码 </span><br><span class="line">boolean isEqual(Integer x, Integer y) &#123; </span><br><span class="line">  return x == y; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(isEqual(421,421)); 结果是false</span><br></pre></td></tr></table></figure><p>原因是在第一个 isEqual 中，x 和 y 会被自动装箱，从 Int 到 Integer，但是第二个里面的参数被装箱两次，导致是两个不一样的对象，判断是false。</p><p>而在 Scala 中，x 和 y 的类型是 Int 或者 Any 都不会影响 x = y 的判断结果。同理，Java 中字符串判等需要用 equals。</p><blockquote><p>但是，有些情况你需要使用引用相等代替用户定义的相等。例如，某些时候效率是首要因素，你想要把某些类哈希合并： hash cons 然后通过引用相等比较它们的实例，为这种情况，类 AnyRef 定义了附加的 eq 方法，它不能被重载并且实现为引用相等（也就是说，它表现得就像 Java 里对于引用类型的 == 那样）。同样也有一个 eq 的反义词，被称为 ne。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val x = new String(&quot;abc&quot;)</span><br><span class="line">val y = new String(&quot;abc&quot;)</span><br><span class="line">scala&gt; x == y</span><br><span class="line">res0: Boolean = true</span><br><span class="line">scala&gt; x eq y // 这里相当于两个 String 对象</span><br><span class="line">res1: Boolean = false</span><br><span class="line">scala&gt; x ne y</span><br><span class="line">res2: Boolean = true</span><br><span class="line"></span><br><span class="line">如果说是两个字符串比较</span><br><span class="line">val a = &quot;abc&quot;</span><br><span class="line">val b = &quot;abc&quot;</span><br><span class="line">a == b 和 a eq b 的结果都是 true</span><br></pre></td></tr></table></figure><ol start="6"><li>Nothing 类是所有其他类的子类，然而这个类型没有任何实例（也就是没有任何值对应 Nothing 类型）。它的一个用法是示意应用程序非正常终止。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def error(message:String) : Nothing =</span><br><span class="line">      throw new RuntimeException(message)</span><br><span class="line"></span><br><span class="line">def divide(x:Int,y:Int):Int=</span><br><span class="line">      if(y!=0) x/y</span><br><span class="line">      else error(&quot;Cannot divide by Zero&quot;)</span><br></pre></td></tr></table></figure><p>error 的返回类型就是 Nothing，告诉调用者该方法没有正常退出（抛出异常）。在调用 error 方法时，因为返回类型是 Nothing，而 Nothing 又是 Int 的子类，而 divide 方法的返回值类型恰恰是 Int。</p><h3 id="24-特质：trait"><a href="#24-特质：trait" class="headerlink" title="24. 特质：trait"></a>24. 特质：trait</h3><p>特质：trait 是 Scala 里复用代码的基础单元。特质封装了方法和字段的定义，其他类可以通过 extends 类继承，并且可以混入任意个特质。最常用到的两种方式：拓宽瘦接口为宽接口和定义可堆叠的改变。</p><blockquote><p>和接口不同，特质的方法可以有实现，像是抽象类。</p></blockquote><p>定义一个 Trait 的方法和定义一个类的方法非常类似，除了它使用 trait 而非 class 关键字来定义一个 trait。</p><p>特质和类在大多数方面都是一样的，语法也是一样的。除了以下两点。</p><ol><li>特质不能有任何“类”参数，即传递给类的主构造器的参数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class point(x: Int, y: Int) 可以</span><br><span class="line">trait point(x: Int, y: Int) 不可以</span><br></pre></td></tr></table></figure><ol start="2"><li>不论在类的哪个角落，super 的调用都是静态绑定的。在特质中，它们是动态绑定的，即特质中的 super 调用的方法只有当特质混入到具体类的时候才被决定。（可以想象特质只是这么写，它可以被不同的类继承，或者说它可以混入到不同的类中，调用的方法会因为混入到的类不同而不同）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">trait Equal &#123;</span><br><span class="line">   def isEqual(x: Any): Boolean</span><br><span class="line">   def isNotEqual(x: Any): Boolean = !isEqual(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Point(xc: Int, yc: Int) extends Equal &#123;</span><br><span class="line">   var x: Int = xc</span><br><span class="line">   var y: Int = yc</span><br><span class="line">   </span><br><span class="line">   def isEqual(obj: Any) = obj.isInstanceOf[Point] &amp;&amp; obj.asInstanceOf[Point].x == y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Demo &#123;</span><br><span class="line">   def main(args: Array[String]) &#123;</span><br><span class="line">      val p1 = new Point(2, 3)</span><br><span class="line">      val p2 = new Point(2, 4)</span><br><span class="line">      val p3 = new Point(3, 3)</span><br><span class="line"></span><br><span class="line">      println(p1.isNotEqual(p2))</span><br><span class="line">      println(p1.isNotEqual(p3))</span><br><span class="line">      println(p1.isNotEqual(2))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25-Ordered-特质"><a href="#25-Ordered-特质" class="headerlink" title="25. Ordered 特质"></a>25. Ordered 特质</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class test extends Ordered[test]&#123;</span><br><span class="line">      ...</span><br><span class="line">      def compare(that: test) = this.number - that.number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ordered 特质通过 compare 方法实现了 &lt;, &gt;, &lt;= , &gt;= 的比较。但是对于 equals 并没有实现。因为 equals 需要检查传入对象的类型，然而因为类型擦除，Ordered 特质本身无法做这种测试。</p><h3 id="26-可改动堆叠"><a href="#26-可改动堆叠" class="headerlink" title="26. 可改动堆叠"></a>26. 可改动堆叠</h3><p>一个类混入多个特质时，越靠近右侧的特质越先起作用。</p><p>每个特质 extends 某个抽象类，并可以覆写其中的某些方法以实现功能1、2、3，之后我们去写一个类的时候可以按照自己的需要混入实现了特定功能的特质。</p><h3 id="27-特质的用和不用"><a href="#27-特质的用和不用" class="headerlink" title="27. 特质的用和不用"></a>27. 特质的用和不用</h3><p>在实现一个可重用的行为集合时，是用特质还是用抽象类，没有固定的规则，以下给出了几个可供参考的规律：</p><ol><li><p>如果行为不会被重用<br>那么就把它做成具体类。具体类没有可重用的行为。</p></li><li><p>如果要在多个不相关的类中重用<br>做成特质。只有特质可以混入到不同的类层级中。</p></li><li><p>如果希望从 Java 代码中继承它<br>使用抽象类。</p></li><li><p>如果效率非常重要<br>倾向于类。大多数 Java 运行时都能让类成员的虚方法调用快于接口方法调用。特质会编译成接口，会付出微小的性能代价。然而，仅当你知道存疑的特质构成了性能瓶颈，并且有证据说明使用类代替能确实解决问题，才做这样的选择。</p></li><li><p>如果以上情况之外，还是不知道<br>尝试特质。毕竟可以随时改变。</p></li></ol><h3 id="28-访问包中对象"><a href="#28-访问包中对象" class="headerlink" title="28. 访问包中对象"></a>28. 访问包中对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package launch&#123;</span><br><span class="line">  class Booster3</span><br><span class="line">&#125;</span><br><span class="line">package bobsrockets&#123;</span><br><span class="line">  package navigtion&#123;</span><br><span class="line">    package launch&#123;</span><br><span class="line">      class Booster1</span><br><span class="line">  &#125;</span><br><span class="line">  class MissionControl&#123;</span><br><span class="line">    val booster1 = new launch.Booster1</span><br><span class="line">    val booster2 = new bobsrockets.launch.Booster2</span><br><span class="line">    val booster3 = new _root_.launch.Booster3</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  package launch&#123;</span><br><span class="line">    class Booster2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 lunch 包定义在最近的包含作用域中，所以，launch.Booster1 即可指到第一个 booster 类。<br>第二个通过写全引用路径来指代引用的类。<br>Scala在所有用户可创建的包之外提供了名为 <em>root</em> 的包，任何写出来的顶层包都被当做是 <em>root</em>  包的成员。因此，<em>root</em>.launch 可以访问到顶层的 launch 包。</p><h3 id="29-隐式引用"><a href="#29-隐式引用" class="headerlink" title="29. 隐式引用"></a>29. 隐式引用</h3><p>Scala 在每个程序隐式添加了一些引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.lang._</span><br><span class="line">import scala._</span><br><span class="line">import Predef._</span><br></pre></td></tr></table></figure><blockquote><p>出现在靠后位置的引用将覆盖靠前的引用。比如 StringBuilder 会被看作是 scala.StringBuilder 而不是 java.lang.StringBuilder</p></blockquote><h3 id="30-访问修饰符"><a href="#30-访问修饰符" class="headerlink" title="30. 访问修饰符"></a>30. 访问修饰符</h3><h4 id="30-1-私有成员"><a href="#30-1-私有成员" class="headerlink" title="30.1 私有成员"></a>30.1 私有成员</h4><p>private 的成员仅在包含了成员定义的类或对象内部可见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">  class Inner&#123;</span><br><span class="line">    private def f()&#123;</span><br><span class="line">      println(&quot;f&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    class InnerMost&#123;</span><br><span class="line">      f() //OK</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  (new Inner).f();// error: f is not accessible</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f 在 Inner 中被声明为 private，而访问不在类 Inner 之内。相反，在类 InnerMost 里访问 f 没有问题，因为这个访问包含在 Inner 类之内。Java 允许这两种访问，因为它允许外部类访问其内部类的私有成员。</p><h4 id="30-2-保护成员"><a href="#30-2-保护成员" class="headerlink" title="30.2 保护成员"></a>30.2 保护成员</h4><p>保护成员只在定义了成员的类的子类中可以被访问。Java 中还允许在同一个包的其他类中进行这种访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class p&#123;</span><br><span class="line">  class Super&#123;</span><br><span class="line">    protected def f() &#123;</span><br><span class="line">      println(&quot;f&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Sub extends Super&#123;</span><br><span class="line">    f()</span><br><span class="line">  &#125;</span><br><span class="line">  class Other&#123;</span><br><span class="line">    (new Super).f() //error: f is not accessible</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="30-3-保护的作用域"><a href="#30-3-保护的作用域" class="headerlink" title="30.3 保护的作用域"></a>30.3 保护的作用域</h4><p>private[x] 或 protected[x]<br>其中 x 代表某个包，类或者对象，表示可以访问这个 Private 或的 protected 的范围直到 X。</p><h3 id="31-几种单元测试的失败报告"><a href="#31-几种单元测试的失败报告" class="headerlink" title="31. 几种单元测试的失败报告"></a>31. 几种单元测试的失败报告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assert(width === 2) </span><br><span class="line">如果失败，会得到 “3 did not equal 2” 这样的信息。三等号操作符不能区分实际结果和期望结果</span><br><span class="line"></span><br><span class="line">expert(2)&#123;</span><br><span class="line">      width</span><br><span class="line">&#125;</span><br><span class="line">如果失败，会得到 “Expected 2, but got 3”</span><br></pre></td></tr></table></figure><h3 id="32-样本类与模式匹配"><a href="#32-样本类与模式匹配" class="headerlink" title="32. 样本类与模式匹配"></a>32. <span id="match">样本类与模式匹配</span></h3><h4 id="32-1-样本类"><a href="#32-1-样本类" class="headerlink" title="32.1 样本类"></a>32.1 样本类</h4><p>样本类常常用于描述不可变的值对象(Value Object)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class Expr</span><br><span class="line"></span><br><span class="line">case class Var(name: String) extends Expr</span><br><span class="line">case class Number(num: Double) extends Expr</span><br><span class="line">case class UnOp(operator: String, arg: Expr) extends Expr</span><br><span class="line">case class BinOp(operator: String, left: Expr, Right: Expr) extends Expr</span><br><span class="line"></span><br><span class="line">ps: Var 等类没有结构体，所以可以省略花括号</span><br></pre></td></tr></table></figure><p>Scala 编译器会对样本类自动添加一些方法。</p><ul><li>自动添加与类名一样的工厂方法，即可用 <code>Var(&quot;x&quot;)</code> 来代替 <code>new Var(&quot;x&quot;)</code></li><li>样本类参数列表中的所有参数隐式获得 val 前缀</li><li>自动地生成equals, canEqual, hashCode, toString, copy, showArray, showObject等方法</li></ul><h4 id="32-2-模式匹配的种类"><a href="#32-2-模式匹配的种类" class="headerlink" title="32.2 模式匹配的种类"></a>32.2 模式匹配的种类</h4><p>Scala：选择器 match { 备选项 }<br>Java：switch { 选择器 } { 备选项 }</p><h5 id="32-2-1-通配模式"><a href="#32-2-1-通配模式" class="headerlink" title="32.2.1 通配模式"></a>32.2.1 通配模式</h5><p>_ 匹配任一对象。还可以用来忽略对象中不关心的部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr match &#123;</span><br><span class="line">      case BinOp(op, left, right) =&gt; println(expr + &quot;is a binary operation&quot;)</span><br><span class="line">      case _ =&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般来说，都需要在最后加一个 <code>case _ =&gt;</code>，除非之前的 case 已经将所有的可能性都考虑到了，要不然会报 MatchError 错误。</p></blockquote><h5 id="32-2-2-常量模式"><a href="#32-2-2-常量模式" class="headerlink" title="32.2.2 常量模式"></a>32.2.2 常量模式</h5><p>常量模式仅匹配自身。任何字面量都可以用作常量。另外，任何的 val 或单例对象也可以被用作常量。例如，单例对象 Nil 是只匹配空列表的模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def describe(x: Any) = x match &#123;</span><br><span class="line">      case 5 =&gt; &quot;five&quot;</span><br><span class="line">      case true =&gt; &quot;true&quot;</span><br><span class="line">      case &quot;hello&quot; =&gt; &quot;hi&quot;</span><br><span class="line">      case Nil =&gt; &quot;empty list&quot;</span><br><span class="line">      case _ =&gt; &quot;something else&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="32-2-3-变量模式"><a href="#32-2-3-变量模式" class="headerlink" title="32.2.3 变量模式"></a>32.2.3 变量模式</h5><p>Scala 用小写字母开始的简单名会被当做是模式变量；所有其他的引用会被认为是常量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Math.&#123; E, Pi&#125;</span><br><span class="line">E match &#123;</span><br><span class="line">      case Pi =&gt; &quot;strange match&quot;</span><br><span class="line">      case -&gt; &quot;ok&quot;</span><br><span class="line">&#125;</span><br><span class="line">只会输出 ok，因为 E 不能匹配 Pi</span><br><span class="line"></span><br><span class="line">val pi = Math.Pi</span><br><span class="line">E match &#123;</span><br><span class="line">      case pi =&gt; &quot;strange match&quot;</span><br><span class="line">&#125;</span><br><span class="line">由于 pi 是变量模式，它可以匹配任意输入，因此之后的情况都访问不到，甚至如果写上 `case _ =&gt; &quot;ok&quot;` 还会报错。</span><br></pre></td></tr></table></figure><p>有两种方式来给模式常量使用小写字母名。</p><ol><li><p>常量是某个对象的字段，可以在其之上用限定符前缀。例如，pi 是变量模式，但是 <code>this.pi</code>、<code>obj.pi</code> 都是常量。</p></li><li><p>添加反引号。<code>pi</code> 会再次被解释为常量。</p></li></ol><h5 id="32-2-4-构造器模式"><a href="#32-2-4-构造器模式" class="headerlink" title="32.2.4 构造器模式"></a>32.2.4 构造器模式</h5><p>支持深度匹配：不只检查顶层对象是否一致，还会检查对象的内容是否匹配内层的模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 某个商店售卖物品，有时物品捆绑在一起打折出售</span><br><span class="line">abstract class Item</span><br><span class="line">case class Product(description: String, price: Double) extends Item</span><br><span class="line">case class Bundle(description: String, discount: Double, items: Item*) extends Item</span><br><span class="line"></span><br><span class="line">def price(it: Item): Double = it match &#123;</span><br><span class="line">  case Product(_, p) =&gt; p</span><br><span class="line">  case Bundle(_, disc, its @ _*) =&gt; its.map(price _).sum * (100-disc) /100</span><br><span class="line">  // 这里@表示将嵌套的值绑定到变量its</span><br><span class="line">  // map 中的 price 指的是 def price 方法，而不是 Product 中的变量，可以写成 its.map(price(_)).sum，即把 its 中的每一个 Product 对象都传递给 price 方法。</span><br><span class="line">  // 还可以继续简写成 its.map(price).sum 的形式 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">val bun1 = Bundle(&quot;Father&apos;s day special&quot;, 20.0, Product(&quot;Massager&quot;, 188.0))</span><br><span class="line">val bun2 = Bundle(&quot;Appliances on sale&quot;, 10.0, Product(&quot;Haier Refrigerato, 3000.0),Product(&quot;Geli air conditionor&quot;,2000.0))</span><br><span class="line"></span><br><span class="line">// 商品组合1 八折结果</span><br><span class="line">scala&gt; price(bun1)</span><br><span class="line">res5: Double = 150.4</span><br><span class="line">// 商品组合2 九折结果</span><br><span class="line">scala&gt; price(bun2)</span><br><span class="line">res6: Double = 4500.0</span><br></pre></td></tr></table></figure><h5 id="32-2-5-序列模式"><a href="#32-2-5-序列模式" class="headerlink" title="32.2.5 序列模式"></a>32.2.5 序列模式</h5><p>可以像匹配样本类那样匹配如 List 或 Array 这样的序列类型。并可以指定模式内任意数量的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">匹配 0 开头的三元素列表模式</span><br><span class="line">expr match &#123;</span><br><span class="line">      case List(0, _, _) =&gt; &quot;a&quot;</span><br><span class="line">      case _ =&gt; &quot;b&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">匹配 0 开头的任意长度的列表模式</span><br><span class="line">expr match &#123;</span><br><span class="line">      case List(0, _*) =&gt; &quot;a&quot;</span><br><span class="line">      case _ =&gt; &quot;b&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="32-2-6-元组模式"><a href="#32-2-6-元组模式" class="headerlink" title="32.2.6 元组模式"></a>32.2.6 元组模式</h5><p>匹配元组。</p><h5 id="32-2-7-类型模式"><a href="#32-2-7-类型模式" class="headerlink" title="32.2.7 类型模式"></a>32.2.7 类型模式</h5><p>可以当做类型测试和类型转换的简易替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def generalSize(x: Any) = x match &#123;</span><br><span class="line">      case s: String =&gt; s.length</span><br><span class="line">      case m: Map[_, _] =&gt; m.size</span><br><span class="line">      case _ =&gt; 1</span><br><span class="line">&#125;</span><br><span class="line">参数是 any 类型，因此任何值都可以接受。这里就用了 s 来指代 string，但是不能写成 x.length，因为 Any 类型没有 length 成员。</span><br><span class="line"></span><br><span class="line">相对复杂的版本：</span><br><span class="line">类型测试: expr.isInstanceOf[String]</span><br><span class="line">类型转换: expr.asInstanceOf[String]</span><br></pre></td></tr></table></figure><h5 id="32-2-8-类型擦除规则"><a href="#32-2-8-类型擦除规则" class="headerlink" title="32.2.8 类型擦除规则"></a>32.2.8 类型擦除规则</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def isIntIntMap(x: Any) = x match &#123;</span><br><span class="line">      case m: Map[Int, Int] =&gt; true</span><br><span class="line">      case _ =&gt; false</span><br><span class="line">&#125;</span><br><span class="line">isIntIntMap(Map(1 -&gt; 1)) 返回 true</span><br><span class="line">isIntIntMap(Map(&quot;a&quot; -&gt; &quot;b&quot;)) 返回 true</span><br><span class="line">原因是: 类型参数信息并没有保留到运行期。系统所能做的只是判断这个值是某种任意类型参数的 Map。</span><br></pre></td></tr></table></figure><p>擦除规则的例外是数组。因为在 Java 和 Scala 里，数组的元素类型与数组值保存在一起，因此可以做模式匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def isStringArray(x: Any) = x match &#123;</span><br><span class="line">      case a: Array[String] =&gt; &quot;yes&quot;</span><br><span class="line">      case _ =&gt; &quot;no&quot;</span><br><span class="line">&#125;</span><br><span class="line">val a = Array(&quot;a&quot;)</span><br><span class="line">isStringArray(a) 返回 yes</span><br><span class="line"></span><br><span class="line">val b = Array(1, 2, 3)</span><br><span class="line">isStringArray(b) 返回 no</span><br></pre></td></tr></table></figure><h5 id="32-2-9-变量绑定"><a href="#32-2-9-变量绑定" class="headerlink" title="32.2.9 变量绑定"></a>32.2.9 变量绑定</h5><p>写法：变量名 @ 模式  </p><p>意义：能像通常的那样做模式匹配，并且如果匹配成功，则把变量设置成匹配的对象，就像使用简单的变量模式那样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr match &#123;</span><br><span class="line">      case UnOp(&quot;abs&quot;, e @ UnOp(&quot;abs&quot;, _)) =&gt; e</span><br><span class="line">      case _ =&gt;</span><br><span class="line">&#125;</span><br><span class="line">其中有一个用 e 作为变量，及 UnOp(&quot;abs&quot;, _) 作为模式的变量绑定模式。如果后者匹配成功，那么后者就可以用 e 来指代。</span><br></pre></td></tr></table></figure><h4 id="32-3-模式守卫"><a href="#32-3-模式守卫" class="headerlink" title="32.3 模式守卫"></a>32.3 模式守卫</h4><p>模式守卫接在模式之后，开始于 if。守卫可以是任意的引用模式中变量的布尔表达式。如果存在模式守卫，只有在守卫返回 true 的时候匹配才成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 仅匹配正整数</span><br><span class="line">case n: Int if n &gt; 0 =&gt; ...</span><br><span class="line">// 仅匹配以 a 开头的字符串</span><br><span class="line">case s: String if s(0) == &apos;a&apos; =&gt; ...</span><br></pre></td></tr></table></figure><h4 id="32-4-模式重叠与封闭类"><a href="#32-4-模式重叠与封闭类" class="headerlink" title="32.4 模式重叠与封闭类"></a>32.4 模式重叠与封闭类</h4><p>在写 case 的时候要注意每一种 case 应该是独立的，如果有重叠的部分，那么后面的 case 可能根本不会执行到。</p><p>但是如何能保证 case 一定考虑到了可能的情况？实际上，可以让 Scala 编译器帮助检测 match 表达式中遗漏的模式组合。做法是让样本类的超类被封闭(sealed)。封闭类除了类定义所在的文件之外，不能再添加任何新的子类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sealed abstract class Expr</span><br><span class="line"></span><br><span class="line">case class Var(name: String) extends Expr</span><br><span class="line">case class Number(num: Double) extends Expr</span><br><span class="line">case class UnOp(operator: String, arg: Expr) extends Expr</span><br><span class="line">case class BinOp(operator: String, left: Expr, Right: Expr) extends Expr</span><br></pre></td></tr></table></figure><p>在使用继承自封闭类的样本类做匹配时，编译器将通过警告信息标识出缺失的模式组合。但是假如你确定缺失的模式组合不会被执行，但是编译器又确实报错了，可以添加 <code>@unchecked</code> 注解，随后的模式的穷举性检查会被抑制掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def describe(e: Expr): String = (e: @unchecked) match &#123;</span><br><span class="line">      case Number(_) =&gt; &quot;a number&quot;</span><br><span class="line">      case Var(_) =&gt; &quot;a variable&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="32-5-Option-类型"><a href="#32-5-Option-类型" class="headerlink" title="32.5 Option 类型"></a>32.5 Option 类型</h4><p>Scala 为可选值定义了一个名为 Option 的标准类型。这种值有两种形式：一种是 Some(x)，其中 x 是实际值；或者是 None 对象，代表缺失的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val capitals = Map(&quot;France&quot; -&gt; &quot;Paris&quot;, &quot;Japan&quot; -&gt; &quot;Tokyo&quot;)</span><br><span class="line">capitals get &quot;France&quot; 返回 Some(Paris)</span><br><span class="line">capitals get &quot;China&quot; 返回 None</span><br></pre></td></tr></table></figure><p>通过模式匹配可以分离可选值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def show(x: Option[String]) = x match &#123;</span><br><span class="line">      case Some(s) =&gt; s</span><br><span class="line">      case None =&gt; &quot;?&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(capitals get &quot;France&quot;) 返回 Paris</span><br><span class="line">show(capitals get &quot;China&quot;) 返回 ?</span><br></pre></td></tr></table></figure><p>类比 Java 中代表没有值的 null，如果忘记了检查的话，会在运行时发生 NullPointerException，但是 Scala 相当于在 <code>get</code> 的返回值之上加了一层包装，如果你没有对它进行处理，在编译的时候就会报类型错误，因为返回值是 <code>Option[String]</code>，而不是 <code>String</code>。</p><h4 id="32-6-模式匹配的一些其他例子"><a href="#32-6-模式匹配的一些其他例子" class="headerlink" title="32.6 模式匹配的一些其他例子"></a>32.6 模式匹配的一些其他例子</h4><ol><li>用在变量定义中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val myTuple = (123, &quot;abc&quot;)</span><br><span class="line">val (number, str) = myTuple</span><br></pre></td></tr></table></figure><ol start="2"><li>可用于 for 循环 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for((country, city) &lt;- capitals)&#123;</span><br><span class="line">      println(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有时候可能并不能保证匹配不会出错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val results = List(Some(&quot;a&quot;), None, Some(&quot;b&quot;))</span><br><span class="line">for(Some(x) &lt;- results)&#123;</span><br><span class="line">      println(x)</span><br><span class="line">&#125;</span><br><span class="line">结果只能打印出 a 、 b 两种情况。</span><br><span class="line">不能被匹配出来的值，比如 None，会自动被丢弃。</span><br></pre></td></tr></table></figure><h3 id="33-List-列表"><a href="#33-List-列表" class="headerlink" title="33. List 列表"></a>33. <span id="list">List 列表</span></h3><ol><li><p>列表是不可变的，不能通过赋值来改变列表的元素。其次，列表具有递归结构，而数据是连续的。</p></li><li><p>所有列表都是由两个基础构造块 Nil 和 :: 构造出来的。其中，Nil 表示空列表，中缀操作符 :: 表示右侧列表加在左侧列表之后。</p></li><li><p>插入排序：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def isort(xs: List[Int]): List[Int] = &#123;</span><br><span class="line">      if (xs.isEmpty) Nil</span><br><span class="line">      else insert(xs.head, isort(xs.tail))</span><br><span class="line">&#125;</span><br><span class="line">def insert(x: Int, xs: List[Int]): List[Int] = &#123;</span><br><span class="line">      if (xs.isEmpty || x &lt;= xs.head) x :: xs</span><br><span class="line">      else xs.head :: insert(x, xs.tail)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用了模式匹配的插入排序：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def isort(xs: List[Int]): List[Int] = xs match &#123;</span><br><span class="line">      case List() =&gt; List()</span><br><span class="line">      case x :: xs1 =&gt; insert(x, isort(xs1))</span><br><span class="line">&#125;</span><br><span class="line">def insert(x: Int, xs: List[Int]): List[Int] = xs match &#123;</span><br><span class="line">      case List() =&gt; List()</span><br><span class="line">      case y :: ys =&gt; </span><br><span class="line">            if(x &lt;= y) x :: xs </span><br><span class="line">            else y :: insert(x, ys)</span><br><span class="line">&#125;</span><br><span class="line">在这里 xs1、 ys 能代表 xs.tail, 原因是 xs 进行模式匹配的时候，如果不为空，拿出第一个元素进行匹配，满足 xs.head :: xs.tail 的形式，于是就用 x、 y 来代替 xs.head, xs1、ys 来代替 xs.tail</span><br></pre></td></tr></table></figure><ol start="5"><li>两个列表的连接操作：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def append(xs: List[Int], ys: List[Int]): List[Int] = xs match &#123;</span><br><span class="line">      case List() =&gt; ys</span><br><span class="line">      case x :: xs1 =&gt; x :: append(xs1, ys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>判断列表是否为空时，应该用 <code>List.isEmpty</code>，不推荐用 <code>List.length</code>，因为获取长度比较费时。</p></li><li><p>head、tail 运行时间都是常量，而 init、last 需要遍历整个列表以计算结果，因此耗费的时间和列表长度成正比。因此，组织好数据，以便让所有的访问都集中在列表的头部。</p></li><li><p>splitAt 方法：在指定位置拆分列表，返回对偶(pair)列表(可以看做返回一个元组，里面一共两个元素，类型均为列表)</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xs.splitAt(2) 等效于 (xs.take(n), xs.drop(n))</span><br><span class="line"></span><br><span class="line">abcde splitAt 2</span><br><span class="line">(List(a, b), List(c, d, e))</span><br></pre></td></tr></table></figure><ol start="9"><li>元素选择：apply 和 indices 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abcde apply 2</span><br><span class="line">等于</span><br><span class="line">abcde(2)</span><br><span class="line">返回结果都是 c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xs apply n 等价于 (xs drop n).head</span><br></pre></td></tr></table></figure><p>indices 方法可以返回指定列表的所有有效索引值组成的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcde.indices 返回 List(0, 1, 2, 3, 4)</span><br></pre></td></tr></table></figure><ol start="10"><li>啮合列表：zip 方法</li></ol><p>zip 方法是 List 类的内建方法，但是 unzip 是 List 对象的方法。</p><p>可以把两个列表组成一个对偶列表。如果两个列表长度不一致，不能匹配的元素会被丢弃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abcde.indices zip abcde</span><br><span class="line">返回 List((0, a), (1, b), (2, c), (3, d), (4, e))</span><br><span class="line"></span><br><span class="line">abcde zip List(1, 2, 3)</span><br><span class="line">返回 List((a, 1), (b, 2), (c, 3))</span><br></pre></td></tr></table></figure><p>如果用将元素和索引啮合在一起，可以使用 zipWithIndex 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abcde.zipWithIndex</span><br><span class="line">返回 List((a, 0), (b, 1), (c, 2), (d, 3), (e, 4))</span><br></pre></td></tr></table></figure><ol start="11"><li>显示列表：toString 和 mkString 方法</li></ol><p>toString 返回列表的标准字符串表达形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xs mkString(pre, seq, post) // 前缀，分隔符，后缀</span><br><span class="line">xs mkSrtring seq 等价于 xs mkString (&quot;&quot;, seq, &quot;&quot;)</span><br><span class="line">xs mkString 等价于 xs mkString &quot;&quot;</span><br></pre></td></tr></table></figure><p>mkString 方法还有名为 addString 的变体，可以把构件好的字符串添加到 StringBuilder（scala.StringBuilder） 对象中，而不是作为结果返回。因为 mkString 和 addString 方法都继承自 List 的超特质 Iterable，因此它们可以引用到各种可枚举的集合类上。</p><ol start="12"><li>转换列表：toArray、copyToArray</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List =&gt; Array : List.toArray </span><br><span class="line">Array =&gt; List : Array.toString.toList</span><br><span class="line"></span><br><span class="line">xs copyToArray (arr, start)</span><br><span class="line">把列表 xs 的所有元素复制到数组 arr 中，填入位置开始为 start。必须确保数组 arr 有足够的空间来存放全部列表元素。</span><br></pre></td></tr></table></figure><ol start="13"><li>归并排序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def msort[T](less: (T, T) =&gt; Boolean)(xs: List[T]: List[T]) = &#123;</span><br><span class="line">      def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match &#123;</span><br><span class="line">            case (Nil, _) =&gt; ys</span><br><span class="line">            case (_, Nil) =&gt; xs</span><br><span class="line">            case (x :: xs1, y :: ys1) =&gt; </span><br><span class="line">                  if(less(x, y)) x :: merge(xs1, ys) </span><br><span class="line">                  else y :: merge(xs, ys1)</span><br><span class="line">      &#125;</span><br><span class="line">      val n = xs.length / 2</span><br><span class="line">      if(n == 0) xs</span><br><span class="line">      else &#123;</span><br><span class="line">           val (ys, zs) = xs splitAt n</span><br><span class="line">           merge(msort(less)(ys), msort(less)(zs)) </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msort((x: Int, y: Int) =&gt; x &lt; y)(List(5, 7, 3, 1))</span><br><span class="line">返回 List(1, 3, 5, 7)</span><br></pre></td></tr></table></figure><ol start="14"><li>列表间的映射：map、flatMap、foreach</li></ol><p>map 返回的是包含列表的列表， flatMap 返回的是把所有元素列表连接之后的单个列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val words = List(&quot;the&quot;, &quot;fox&quot;)</span><br><span class="line">words.map(_.toList) 返回 List(List(&quot;t&quot;, &quot;h&quot;, &quot;e&quot;), List(&quot;f&quot;, &quot;o&quot;, &quot;x&quot;))</span><br><span class="line">words.flatMap(_.toList) 返回 List(&quot;t&quot;, &quot;h&quot;, &quot;e&quot;, &quot;f&quot;, &quot;o&quot;, &quot;x&quot;)</span><br></pre></td></tr></table></figure><p>foreach 操作结果是 Unit，不会产生结果列表。</p><ol start="15"><li>列表过滤：filter、partition、find、takeWhile、dropWhile、span</li></ol><p>filter(p) 返回条件 p 判断为 True 的所有元素组成的列表。</p><p>partition(p) 返回的是列表对。其中一个包含所有论断 p 为 True 的元素，另一个包含所有论断 p 为 False 的元素。</p><p><code>xs partition p 等价于 (xs filter p, xs filter (!p(_)))</code></p><p>find(p) 只返回满足条件 p 为 True 的第一个元素，若无则返回 None。</p><p>takeWhile(p) 返回列表中最长的能满足条件 p 的前缀。dropWhile 则返回移除了最长的能满足条件 p 的前缀的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(1, 2, 3, -4, 5).takeWhile(_ &gt; 0) 返回 List(1, 2, 3)</span><br></pre></td></tr></table></figure><p>span 是把 takeWhile 和 dropWhile 组合成一个操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xs span p 等价于 (xs takeWhile p, xs dropWhile p)</span><br><span class="line"></span><br><span class="line">List(1, 2, 3, -4, 5).span(_ &gt; 0)</span><br><span class="line">返回 (List(1, 2, 3), List(-4, 5))</span><br></pre></td></tr></table></figure><ol start="16"><li>列表的论断：forall、exists</li></ol><p>forall(p) 如果列表的所有元素满足 p 则返回 true；而 exists(p) 只要有一个值满足 p 就返回 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def hasZeroRow(m: List[List[Int]]) = m exists (row =&gt; row forall (_ == 0))</span><br></pre></td></tr></table></figure><ol start="17"><li>折叠列表： 左折叠 /: 和 右折叠 :\</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">左折叠 可以用 foldLeft 代替</span><br><span class="line">(z /: List(a, b, c)) (op) 等价于 op(op(op(z, a), b), c)</span><br><span class="line"></span><br><span class="line">右折叠 可以用 foldRight 代替</span><br><span class="line">(List(a, b, c) :\ z) (op) 等价于 op(a, op(b, op(c, z)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reverse 方法反转列表的运行时间是列表长度的平方。使用左折叠方法来实现一个运行时间为线性的反转方法。</span><br><span class="line"></span><br><span class="line">def reverseLeft[T](xs: List[T]) = </span><br><span class="line">      (List[T] /: xs) &#123;(ys, y) =&gt; y :: ys&#125;</span><br></pre></td></tr></table></figure><ol start="18"><li>列表排序：sort</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(1, -3, 4, 2, 5) sort (_ &gt; _)</span><br></pre></td></tr></table></figure><ol start="19"><li><p>List 对象的几种方法</p><ol><li>List.apply(1, 2, 3)</li><li>List.range(1, 5)</li><li>List.make(5, ‘a’)</li><li>List.unzip</li><li>List.flatten</li><li>List.concat</li><li>List.map2</li><li>List.forall2</li><li>List.exists2</li></ol></li></ol><h3 id="34-集合类型"><a href="#34-集合类型" class="headerlink" title="34. 集合类型"></a>34. 集合类型</h3><p>Iterable 是主要特质，它同时还是可变和不可变序列（Seq）、集（Set）以及映射（Map）的超特质。序列是有序的集合，例如数组和列表。集可以通过 == 方法确定对每个对象最多只包含一个。映射则包含了键值映射关系的集合。</p><h4 id="34-1-序列"><a href="#34-1-序列" class="headerlink" title="34.1 序列"></a>34.1 序列</h4><ol><li>列表缓存</li></ol><p>引入 ListBuffer 可以更高效地通过添加元素的方式构建列表。支持常量时间的添加和前缀操作。元素添加使用 += 操作符，前缀使用 +: 操作符。</p><p>可以避免栈溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import scala.collection.mutable.ListBuffer 只在可变集合包中</span><br><span class="line">val buf = new ListBuffer[Int]</span><br><span class="line">buf += 1 </span><br><span class="line">buf += 2 返回 ListBuffer(1, 2)</span><br><span class="line">3 +: buf 返回 Listbuffer(3, 1, 2)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">2. 数组缓存</span><br><span class="line"></span><br><span class="line">ArrayBuffer 保留了 Array 的所有操作，还额外允许在序列开始和结束的地方添加和删除元素。可以避免栈溢出。</span><br></pre></td></tr></table></figure><p>import scala.collection.mutable.ArrayBuffer 只在可变集合包中<br>val buf = new ArrayBuffer[Int]<br>buf += 1<br>buf += 2 返回 ArrayBuffer(1, 2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 队列</span><br><span class="line"></span><br><span class="line">有可变和不可变两种。对于不可变队列来说，使用 enqueue 添加元素，dequeue 返回由队列头部元素和移除该元素之后的剩余队列组成的对偶（tuple2）。对于可变队列来说，可以使用 +=、++= 来添加元素，dequeue 方法只从队列移除头部元素并返回。</span><br></pre></td></tr></table></figure><p>import scala.collection.immutable.Queue<br>val empty = new Queue[Int]<br>val has1 = empty.enqueue(1)<br>val has123 = has1.enqueue(List(2, 3))<br>val (element, has23) = has123.dequeue</p><p>import scala.collection.mutable.Queue<br>val queue = new Queue[Int]<br>queue += “a”<br>queue ++= List(“b”, “c”)<br>queue.dequeue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 栈</span><br><span class="line"></span><br><span class="line">有可变和不可变两种。推入元素 push，弹出元素 pop，只获取栈顶元素而不移除 top。</span><br><span class="line"></span><br><span class="line">5. 字符串（经 RichString 隐式转换）</span><br></pre></td></tr></table></figure><p>def hasUpperCase(s: String) = s.exists(_.isUpperCase)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">字符串 s 调用了 exists 方法，而 String 类本身没有这个方法。因为会隐式转换为含有这个方法的 RichString 类，类型是 Seq[Char]。</span><br><span class="line"></span><br><span class="line">#### 34.2 集（Set）和映射（Map）</span><br><span class="line"></span><br><span class="line">默认情况下使用的 Set 和 Map，获得的都是不可变对象。如果需要用到可变版本，需要新引用可变集合包。</span><br><span class="line"></span><br><span class="line">List 可使用的部分方法在集和映射中也可以使用。</span><br><span class="line"></span><br><span class="line">1. 集</span><br><span class="line"></span><br><span class="line">集的关键特性在于它可以使用对象的 == 操作检查，确保任何时候每个对象只在集中保留最多一个副本。即 元素不可重复。</span><br></pre></td></tr></table></figure><p>val text = “see spot run. run, spot. run!”<br>val wordsArray = text.split(“[ !,.]+”) // 使用正则表达式分隔字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 默认的集和映射</span><br><span class="line"></span><br><span class="line">为了追求性能，当元素数量是1，2，3，4这四种情况的时候，对应的集的类型是 `immutable.Set1, immutable.Set2, immutable.Set3, immutable.Set4`，当元素数量大于等于5的时候，其类型是 `immutable.HashSet`。数量为0时，类型为 `immutable.EmptySet`(映射同理)。</span><br><span class="line"></span><br><span class="line">3. 有序的集和映射</span><br><span class="line"></span><br><span class="line">可以引用不可变类型的 TreeSet、TreeMap（只有不可变版本），这两个类实现了 SortedSet、 SortedMap 特质，具体顺序取决于 Ordered 特质。</span><br><span class="line"></span><br><span class="line">4. 同步的集和映射</span><br><span class="line"></span><br><span class="line">如果需要线程安全的映射，可以把 SynchronizedMap 特质混入到想要的特定类实现中。</span><br></pre></td></tr></table></figure><p>import scala.collection.mutable.{Map, SynchronizedMap, HashMap}<br>object MapMaker [<br>      def makeMap: Map[String, String] = {<br>            new HashMap[String, String] with SynchronizedMap[String, String] {<br>                  // 覆写 default 方法，如果查询某个键的时候不存在映射，会执行 default 方法。默认会得到 NoSuchElementException<br>                  override def default (key: String) = “……”<br>            }<br>      }<br>]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 34.3 初始化集合</span><br><span class="line"></span><br><span class="line">1. 如果想在一个 Set 中添加不同类型的元素</span><br></pre></td></tr></table></figure><p>import scala.collection.mutable.Set<br>val staff = Set<a href="1">Any</a><br>staff += “a” 返回 staff(1, a)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 把集合初始化为指定类型，例如把列表中的元素保存在 TreeSet 中</span><br></pre></td></tr></table></figure><p>val colors = List(“blue”, “yellow”, “red”)<br>import scala.collection.immutable.TreeSet<br>// 创建空的 TreeSet[String] 对象并使用 ++ 操作符添加列表元素<br>val treeset = TreeSet<a href>String</a> ++ colors</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 可变和不可变集合互转</span><br></pre></td></tr></table></figure><p>不可变到可变：mutable.Set.empty ++ 不可变集合<br>可变到不可变：Set.empty ++ 可变集合<br>```</p><h4 id="34-4-元组"><a href="#34-4-元组" class="headerlink" title="34.4 元组"></a>34.4 元组</h4><p>由于元组可以组合不同类型的对象，因此不能继承自 Iterable。</p><p>元组常用来返回方法的多个值。</p><h3 id="？？-使用高性能算子"><a href="#？？-使用高性能算子" class="headerlink" title="？？ 使用高性能算子"></a>？？ 使用高性能算子</h3><ol><li><p>使用reduceByKey/aggregateByKey替代groupByKey</p></li><li><p>使用mapPartitions替代普通map</p></li><li><p>使用foreachPartitions替代foreach</p></li><li><p>使用filter之后进行coalesce操作</p></li><li><p>使用repartitionAndSortWithinPartitions替代repartition与sort类操作</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala 特殊符号含义</title>
      <link href="/2019/08/01/Scala-1/"/>
      <url>/2019/08/01/Scala-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Scala-特殊符号含义"><a href="#Scala-特殊符号含义" class="headerlink" title="Scala 特殊符号含义"></a>Scala 特殊符号含义</h2><p><a href="https://www.cnblogs.com/boothsun/p/8267250.html" target="_blank" rel="noopener">参考地址</a></p><h3 id="1"><a href="#1" class="headerlink" title="1. :::"></a>1. :::</h3><p>:::（三个冒号）只用于连接两个 List 类型的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val a = List(1, 2)  </span><br><span class="line">val b = List(3, 4)  </span><br><span class="line">val c = a ::: b</span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2. ::"></a>2. ::</h3><p>::（两个冒号）表示普通元素与 List 的连接操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val a = 1  </span><br><span class="line">val b = List(3, 4)  </span><br><span class="line">val c = 1 :: b</span><br></pre></td></tr></table></figure><blockquote><p>:: 是右侧对象的方法，即它是对象 b 的方法，而 :: 左侧的运算数是 :: 方法的参数，所以 1::b 的含义是 b.::(1)</p></blockquote><h3 id="3-gt"><a href="#3-gt" class="headerlink" title="3. =&gt;"></a>3. =&gt;</h3><p>根据其不同数学含义，有不同的意义</p><h4 id="3-1-值"><a href="#3-1-值" class="headerlink" title="3.1 值"></a>3.1 值</h4><p>匿名函数 or lamba 表达式，定义格式：(参数列表) =&gt; 函数体</p><p><code>(x: Int) =&gt; x + 1</code></p><h4 id="3-2-类型"><a href="#3-2-类型" class="headerlink" title="3.2 类型"></a>3.2 类型</h4><p>syntactic sugar 语法糖: 把需要的参数、类型、函数最简化，由编译器来解析（去糖化）</p><blockquote><p>the type Int =&gt; String, is equivalent to the type Function1[Int,String] i.e. a function that takes an argument of type Int and returns a String.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val a: Int =&gt; String = myint =&gt; &quot;my int : &quot; + myint.toString;</span><br><span class="line"></span><br><span class="line">val b: (Int, Int) =&gt; String = (my1, my2) =&gt; &quot;my int : &quot; + my1.toString;</span><br><span class="line"></span><br><span class="line">var c = (x: Int, y:Int) =&gt; &quot;my int : &quot; + x + y</span><br><span class="line"></span><br><span class="line">def d(x: Int): String = &#123;</span><br><span class="line">&quot;my:&quot; + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上四个方式的最终调用方式均为：a/b/c/d(参数)<br>其中 a b c 相当于在变量上赋予了一个函数体，而 d 本身就是一个函数<br>b 有两个参数，调用是必须有两个 Int 类型的参数</p></blockquote><h3 id="4-和-："><a href="#4-和-：" class="headerlink" title="4. :+ 和 +："></a>4. :+ 和 +：</h3><p>:+ 方法：用于在尾部追加元素<br>+: 方法：用于在头部追加元素</p><blockquote><p>冒号永远靠近集合类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; List(1,2,3)</span><br><span class="line">res1: List[Int] = List(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; res1:+2</span><br><span class="line">res2: List[Int] = List(1, 2, 3, 2)</span><br><span class="line"></span><br><span class="line">scala&gt; 3+:res1</span><br><span class="line">res4: List[Int] = List(3, 1, 2, 3)</span><br></pre></td></tr></table></figure><h3 id="5"><a href="#5" class="headerlink" title="5. ++"></a>5. ++</h3><p>用于连接两个 Seq，eg：列表、集合、字符串、Map etc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = List(1,2,3)</span><br><span class="line">a: List[Int] = List(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; a++List(4,5,6)</span><br><span class="line">res7: List[Int] = List(1, 2, 3, 4, 5, 6)</span><br></pre></td></tr></table></figure><h3 id="6-lt"><a href="#6-lt" class="headerlink" title="6. &lt;-"></a>6. &lt;-</h3><p>用于集合遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array(1,2,3,4)</span><br><span class="line">for (i &lt;- arr) &#123;</span><br><span class="line">  println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="7-gt"><a href="#7-gt" class="headerlink" title="7. -&gt;"></a>7. -&gt;</h3><p>用于返回一个二元元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var a = List(1,2,3)</span><br><span class="line">a: List[Int] = List(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; var b = List(4,5,6)</span><br><span class="line">b: List[Int] = List(4, 5, 6)</span><br><span class="line"></span><br><span class="line">scala&gt; val c = a -&gt; b</span><br><span class="line">c: (List[Int], List[Int]) = (List(1, 2, 3),List(4, 5, 6))</span><br></pre></td></tr></table></figure><h3 id="8"><a href="#8" class="headerlink" title="8. ++="></a>8. ++=</h3><p>用于字符串拼接，+= 为可变数组添加元素，可以用来加数值也可以用来拼接字符串，取决于等式左边是什么类型，但是 ++= 只能拼接字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var s:String = &quot;a&quot;</span><br><span class="line">s: String = a</span><br><span class="line">scala&gt; s += &quot;b&quot;</span><br><span class="line">scala&gt; println(s)</span><br><span class="line">ab</span><br><span class="line">scala&gt; s ++= &quot;c&quot;</span><br><span class="line">scala&gt; println(s)</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><h3 id="9"><a href="#9" class="headerlink" title="9. _"></a>9. _</h3><h4 id="9-1-通配符"><a href="#9-1-通配符" class="headerlink" title="9.1 通配符"></a>9.1 通配符</h4><ol><li>_ 可以起到类似于 * 作用的通配符：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.spark.SparkContext._ // 引入所有 jar 包</span><br></pre></td></tr></table></figure><ol start="2"><li>模式匹配</li></ol><p>表示完全不清楚的值的通配符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object MatchTest extends App &#123;</span><br><span class="line">  def matchTest(x: Int): String = x match &#123;</span><br><span class="line">    case 1 =&gt; &quot;one&quot;</span><br><span class="line">    case 2 =&gt; &quot;two&quot;</span><br><span class="line">    case _ =&gt; &quot;many&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  println(matchTest(3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-指代集合中的每一个元素"><a href="#9-2-指代集合中的每一个元素" class="headerlink" title="9.2 指代集合中的每一个元素"></a>9.2 指代集合中的每一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">遍历集合筛选列表中大于某个值的元素</span><br><span class="line">val lst = List(1,2,3,4,5)</span><br><span class="line">val lstFilter = lst.filter(_ &gt; 3)</span><br></pre></td></tr></table></figure><p>当做参数的占位符时，编译器有可能会没有足够的信息推断缺少的参数类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val f = _ + _</span><br></pre></td></tr></table></figure><p>这时，可以使用冒号来指定类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val f = (_: Int) + (_: Int)</span><br></pre></td></tr></table></figure><h4 id="9-3-获取元组中指定下标的元素值"><a href="#9-3-获取元组中指定下标的元素值" class="headerlink" title="9.3 获取元组中指定下标的元素值"></a>9.3 获取元组中指定下标的元素值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ss = (1,&quot;22&quot;,&quot;333&quot;)</span><br><span class="line">println(ss._1)</span><br></pre></td></tr></table></figure><h4 id="9-4-使用模式匹配可以用来获取元组的组员"><a href="#9-4-使用模式匹配可以用来获取元组的组员" class="headerlink" title="9.4 使用模式匹配可以用来获取元组的组员"></a>9.4 使用模式匹配可以用来获取元组的组员</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val m = Map(1 -&gt; 2,2 -&gt; 4)</span><br><span class="line">for ((k,_) &lt;- m) println(k) </span><br><span class="line">//如果不需要所有部件， 则在不需要的部件使用 _ ；本例只取key,因此在value处用 _</span><br></pre></td></tr></table></figure><h4 id="9-5-代表某一类型的默认值"><a href="#9-5-代表某一类型的默认值" class="headerlink" title="9.5 代表某一类型的默认值"></a>9.5 代表某一类型的默认值</h4><blockquote><p>加不加空格都可以<br>对于Int类型来说，它是0<br>对于Double来说，它是0.0<br>对于引用类型来说，它是null</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s: Int = _ </span><br><span class="line">def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-6-作为一个整体，告诉编译器你希望将某个参数当做数序列处理"><a href="#9-6-作为一个整体，告诉编译器你希望将某个参数当做数序列处理" class="headerlink" title="9.6 :_* 作为一个整体，告诉编译器你希望将某个参数当做数序列处理"></a>9.6 :_* 作为一个整体，告诉编译器你希望将某个参数当做数序列处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val s = sum(1 to 5 :_*)      //把1 to 5当作一个序列处理</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br><span class="line">def sum(args: Int*) : Int = &#123;</span><br><span class="line">    var result = 0 ;</span><br><span class="line">    for(s2 &lt;- args) &#123;</span><br><span class="line">      result += s2 ;</span><br><span class="line">    &#125;</span><br><span class="line">    result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10"><a href="#10" class="headerlink" title="10. +="></a>10. +=</h3><p>为可变数组添加元素</p><h3 id="11"><a href="#11" class="headerlink" title="11. -="></a>11. -=</h3><p>从可变数组中移除相应的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var map = Map(1 -&gt; 1,2 -&gt; 2,3 -&gt;3 )</span><br><span class="line">map -= 1</span><br><span class="line">结果：scala.collection.immutable.Map[Int,Int] = Map(2 -&gt; 2, 3 -&gt; 3)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django</title>
      <link href="/2019/05/15/Django-1/"/>
      <url>/2019/05/15/Django-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><h3 id="1-构建项目"><a href="#1-构建项目" class="headerlink" title="1.构建项目"></a>1.构建项目</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h4><pre><code>django-admin startproject StockPro</code></pre><p>目录：</p><ul><li>StockPro: 项目的容器。</li><li>manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。</li><li>StockPro/<strong>init</strong>.py: 一个空文件，告诉 Python 该目录是一个 Python 包。</li><li>StockPro/settings.py: 该 Django 项目的设置/配置。</li><li>StockPro/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。</li><li>StockPro/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。</li></ul><h3 id="2-构建APP"><a href="#2-构建APP" class="headerlink" title="2.构建APP"></a>2.构建APP</h3><p>点击菜单栏的 Tools -&gt; Run manage.py task 选项，之后在输入界面输入 startapp appName(你的App名称) 回车即可。</p><p>Projects vs apps</p><p>所谓 app 是指完成一些功能的 web 应用，比如博客系统（weblog system），公共记录的数据库（a database of public records）或者是一个简单的投票系统（a simple poll app）。project 是指一个特定网站的一系列配置文件和应用的集合。一个项目（project）可以包含多个应用（app）,一个应用（app）可以被多个项目（project）使用。</p><h3 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3.连接数据库"></a>3.连接数据库</h3><p>修改项目根目录下的settings.py</p><p>在子app下的models.py添加需要构建的表<br>在子app下的<em>init</em>.py添加<br>import pymysql<br>pymysql.install_as_MySQLdb()</p><p>需要打开anaconda进入到项目根目录下执行</p><p>python manage.py makemigrations 生成数据库的迁移文件</p><p>python manage.py migrate 生成model下的表</p><h3 id="4-修改tushare返回值"><a href="#4-修改tushare返回值" class="headerlink" title="4.修改tushare返回值"></a>4.修改tushare返回值</h3><p>F:\Anaconda3\Lib\site-packages\tushare\pro\client.py</p><p>原始：</p><pre><code>if result[&apos;code&apos;] != 0:    raise Exception(result[&apos;msg&apos;])data = result[&apos;data&apos;]columns = data[&apos;fields&apos;]items = data[&apos;items&apos;]</code></pre><p>在 <code>if result[&#39;code&#39;] != 0:</code> 上面添加一句 <code>return result</code>，下判断返回的 code 值，如果是2002即为权限问题，如果是0就继续解析</p><h3 id="5-发送邮件"><a href="#5-发送邮件" class="headerlink" title="5.发送邮件"></a>5.发送邮件</h3><pre><code>EMAIL_BACKEND = &apos;django.core.mail.backends.smtp.EmailBackend&apos;EMAIL_USE_SSL = TrueEMAIL_HOST = &apos;smtp.qq.com&apos;  # 如果是 163 改成 smtp.163.comEMAIL_PORT = 465EMAIL_HOST_USER = &apos;386965035@qq.com&apos;EMAIL_HOST_PASSWORD = &apos;cdqbohvhkwydcadh&apos;    # 用授权码来替换qq密码DEFAULT_FROM_EMAIL = EMAIL_HOST_USER</code></pre><p>在 test.py 中如下引用：</p><pre><code>from django.core.mail import send_mail# 一个收件人def send_email(request):    send_mail(&apos;标题&apos;, &apos;文本内容&apos;, &apos;mxxct &lt;from@qq.com&gt;&apos;,              [&apos;to@qq.com&apos;], fail_silently=False)    # mxxct &lt;from@qq.com&gt;：mxxct 用来替换发件人姓名，类似起别称    return HttpResponse(&quot;测试发送邮件&quot;)</code></pre><h3 id="6-项目执行的顺序"><a href="#6-项目执行的顺序" class="headerlink" title="6.项目执行的顺序"></a>6.项目执行的顺序</h3><p>url -&gt; view -&gt; function -&gt; 编译 templates 下的 html -&gt; .html</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qlik Sense学习笔记之插件开发</title>
      <link href="/2019/05/06/QlikSense-4/"/>
      <url>/2019/05/06/QlikSense-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Qlik-Sense学习笔记之插件开发"><a href="#Qlik-Sense学习笔记之插件开发" class="headerlink" title="Qlik Sense学习笔记之插件开发"></a>Qlik Sense学习笔记之插件开发</h2><h3 id="1-开发前的基础工作"><a href="#1-开发前的基础工作" class="headerlink" title="1.开发前的基础工作"></a>1.开发前的基础工作</h3><h4 id="1-1-新建插件"><a href="#1-1-新建插件" class="headerlink" title="1.1 新建插件"></a>1.1 新建插件</h4><p>dev-hub -&gt; Extension-Editor -&gt; Create new project -&gt; 自己起一个名字，在模板 template 下拉列表中选择 Angular Basic Visualization template，之后在 qmc 中下载新建的插件，并导入到 IDE 中编辑打开。</p><h4 id="1-2-项目结构"><a href="#1-2-项目结构" class="headerlink" title="1.2 项目结构"></a>1.2 项目结构</h4><p>新建的插件一共包含4个文件，以插件名称为 test 为例，四个文件分别是：test.js，test.qext, template.html, wbfolder.wbl。</p><ol><li><p>test.js：是主 js 文件，包括插件的一些自定义配置选项，以及获取数据的函数方法，处理数据一般会引用其他的 js 文件，调用其中的函数来处理，以避免文件过长显冗余。</p></li><li><p>test.qext：是一个 json 格式的配置文件，name 是你在使用插件的时候所用到的名字，比如你的项目名称为 test，但是这里的 name 写的是 <code>&quot;name&quot;: &quot;TEST&quot;</code>，那么在打包上传到 qmc 之后，在 qmc 里显示的是 test，但是在具体使用的时候是插件的名称是 TEST。在 description 中可以填写具体插件的描述，如果需要添加自定义图片的话，类似于插件的封面图，可以添加 <code>&quot;preview&quot;:&quot;test.png&quot;</code>，照片可以放在项目的根目录下，直接引用即可，qlik sense 官网给出的图片大小建议是 140*140 png 格式。</p></li><li><p>template.html：是插件内容呈现的页面，使用的语法是 AngularJS。</p></li><li><p>wbfolder.wbl：凡是在这里面填写出来的文件都可以在 dev-hub 中被打开编辑，即如果你引用了类似 echarts.js 这种的文件，你只想使用但不需要编辑，那只需要在 test.js 最上面通过 require 的方式引用即可，无需再添加在 wbfoler.wbl 中。在 dev-hub 中点击某插件时，会最先访问该文件，如果不想让其他使用者在 dev-hub 中打开本插件，可以直接删掉，并不会影响正常使用。</p></li></ol><h4 id="1-3-代码结构"><a href="#1-3-代码结构" class="headerlink" title="1.3 代码结构"></a>1.3 代码结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define( [&quot;qlik&quot;, &quot;text!./template.html&quot;],</span><br><span class="line">    function ( qlik, template ) &#123;</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            template: template,</span><br><span class="line">            support: &#123;</span><br><span class="line">                snapshot: true,</span><br><span class="line">                export: true,</span><br><span class="line">                exportData: false</span><br><span class="line">            &#125;,</span><br><span class="line">            paint: function () &#123;</span><br><span class="line">                return qlik.Promise.resolve();</span><br><span class="line">            &#125;,</span><br><span class="line">            controller: [&apos;$scope&apos;, function ( $scope ) &#123;</span><br><span class="line">                //add your rendering code here</span><br><span class="line">                $scope.html = &quot;Hello World&quot;;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125; );</span><br></pre></td></tr></table></figure><p>刚新建的插件只有这一部分最基础的代码，最上面是通过 require 的方式引入的 template.html，与编写 mashup 时引入文件是一样的。</p><p>support 里面需要配置的是 qlik sense 自带的功能，比如截图、导出数据，我们需要把 exportData 改为 true，这样就可以右键点击插件导出数据了。</p><p>插件第一次运行的时候会先执行 controller 里面的内容，之后会调用 paint 函数，同时每次修改（比如放大缩小插件所在的div）都会调用 paint 函数，以实现自适应或者数据的更新。</p><blockquote><p>paint 函数与 controller 函数之间变量上的互通是通过 $scope 这一个参数来实现的。</p></blockquote><h3 id="2-具体开发"><a href="#2-具体开发" class="headerlink" title="2.具体开发"></a>2.具体开发</h3><p>这里的话会按照 比如要引入文件、获取数据等具体的操作来进行分类说明</p><h4 id="2-1-修改项目结构"><a href="#2-1-修改项目结构" class="headerlink" title="2.1 修改项目结构"></a>2.1 修改项目结构</h4><p>按照 mashup 的编写习惯的话，我们会在项目根目录下新建文件夹，来保证项目结构不会因为文件太多而显得冗余。</p><pre><code>原始项目结构test- test.js- test.qext- template.html- wbfolder.wbl修改后的项目结构test- lib    - js        - xxx.js    - css        - xxx.css    - img        - xxx.png- test.js- test.qext- template.html- wbfolder.wbl</code></pre><p>在 lib 文件夹下存放了开发需要的各种 js、css、img 文件，只需要在 test.js 文件中引入即可。</p><h4 id="2-2-引入-css-文件"><a href="#2-2-引入-css-文件" class="headerlink" title="2.2 引入 css 文件"></a>2.2 引入 css 文件</h4><p>假设 css 文件名称为 style.css，我们可以如下引用该文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">define( [&quot;qlik&quot;, &quot;text!./template.html&quot;, &quot;text!./lib/css/style.css&quot;],</span><br><span class="line">    function ( qlik, template, style ) &#123;</span><br><span class="line">        $(&quot;&lt;style&gt;&quot;).html(style).appendTo(&quot;head&quot;);</span><br><span class="line">        return &#123;</span><br><span class="line">            template: template,</span><br><span class="line">            support: &#123;</span><br><span class="line">                snapshot: true,</span><br><span class="line">                export: true,</span><br><span class="line">                exportData: false</span><br><span class="line">            &#125;,</span><br><span class="line">            paint: function () &#123;</span><br><span class="line">                return qlik.Promise.resolve();</span><br><span class="line">            &#125;,</span><br><span class="line">            controller: [&apos;$scope&apos;, function ( $scope ) &#123;</span><br><span class="line">                //add your rendering code here</span><br><span class="line">                $scope.html = &quot;Hello World&quot;;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; );</span><br></pre></td></tr></table></figure><p>主要是在第一行 define 中通过路径引入该 css 文件，同时在 function 函数中的第一行中将该 css 文件添加到 template.html 文件的头部，即可使用，需要注意的是在 define 中引入的文件，如果你在下面的代码中需要用到这个文件的话，就必须在 function 函数的形参中添加一个指代名称才行， qlik sense 会按照顺序去匹配，缺少形参指代会无法执行。这个形参可以用 ‘_’ 下划线来代替。</p><blockquote><p><code>&quot;text!./lib/css/style.css&quot;</code> 中的 <code>text!</code> ：只有当后面引用的文件是 js 文件的时候可以省略。</p></blockquote><h4 id="2-3-引用-jquery"><a href="#2-3-引用-jquery" class="headerlink" title="2.3 引用 jquery"></a>2.3 引用 jquery</h4><p>类似于 mashup 引用，不需要添加什么 js 文件，直接引用即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">define( [&quot;jquery&quot;, &quot;qlik&quot;, &quot;text!./template.html&quot;, &quot;text!./lib/css/style.css&quot;],</span><br><span class="line">    function ( $, qlik, template, style ) &#123;</span><br><span class="line">        $(&quot;&lt;style&gt;&quot;).html(style).appendTo(&quot;head&quot;);</span><br><span class="line">        return &#123;</span><br><span class="line">            template: template,</span><br><span class="line">            support: &#123;</span><br><span class="line">                snapshot: true,</span><br><span class="line">                export: true,</span><br><span class="line">                exportData: false</span><br><span class="line">            &#125;,</span><br><span class="line">            paint: function () &#123;</span><br><span class="line">                return qlik.Promise.resolve();</span><br><span class="line">            &#125;,</span><br><span class="line">            controller: [&apos;$scope&apos;, function ( $scope ) &#123;</span><br><span class="line">                //add your rendering code here</span><br><span class="line">                $scope.html = &quot;Hello World&quot;;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; );</span><br></pre></td></tr></table></figure><blockquote><p>一般会把 jquery 放在第一个， 并习惯用 ‘$’ 来指代。</p></blockquote><h4 id="2-4-引用-js-文件"><a href="#2-4-引用-js-文件" class="headerlink" title="2.4 引用 js 文件"></a>2.4 引用 js 文件</h4><p>与引用 css 文件不一样的地方是，require 会自动识别 js 文件，即在引用的时候是不需要注明文件拓展名的。以引用 render_radar.js 和 echarts-all.js 文件为例，前者是我们用来处理数据的一个子 js 文件，后者是 echarts 生成图表的官方 js 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define( [&quot;jquery&quot;, &quot;qlik&quot;, &quot;text!./template.html&quot;, &quot;text!./lib/css/style.css&quot;, </span><br><span class="line">        &quot;./lib/js/render_radar&quot;, &quot;./lib/js/echarts-all&quot;],</span><br><span class="line">    function ( $, qlik, template, style, render_radar ) &#123;</span><br><span class="line">        $(&quot;&lt;style&gt;&quot;).html(style).appendTo(&quot;head&quot;);</span><br><span class="line">        return &#123;</span><br><span class="line">            template: template,</span><br><span class="line">            support: &#123;</span><br><span class="line">                snapshot: true,</span><br><span class="line">                export: true,</span><br><span class="line">                exportData: false</span><br><span class="line">            &#125;,</span><br><span class="line">            paint: function () &#123;</span><br><span class="line">                return qlik.Promise.resolve();</span><br><span class="line">            &#125;,</span><br><span class="line">            controller: [&apos;$scope&apos;, function ( $scope ) &#123;</span><br><span class="line">                //add your rendering code here</span><br><span class="line">                $scope.html = &quot;Hello World&quot;;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; );</span><br></pre></td></tr></table></figure><p>你会发现我们只对 render_radar.js 起了一个形参指代的别名，在 function 函数中我们可以通过 render_radar.xxx(p1, p2……) 的方式来调用 render_radar.js 中的函数，而 echarts-all.js 并没有别名指代，这是因为在生成图表的时候我们必须用到 echarts-all.js 这个文件，但是我们并不会对这个文件进行任何操作，那我们就不需要起一个别名指代（可以起但没必要）。</p><h4 id="2-5-调用其他-js-文件中的方法"><a href="#2-5-调用其他-js-文件中的方法" class="headerlink" title="2.5 调用其他 js 文件中的方法"></a>2.5 调用其他 js 文件中的方法</h4><p>在上面我们已经调用了 render_radar.js 文件，在该 js 文件中我们定义以下函数方法：init_radar_chart，这样就可以在 test.js （主 js 文件）中通过 render_radar.init_radar_chart(param1, param2, param3, ……) 方法来调用该函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define([], function()&#123;</span><br><span class="line">    return (&#123;</span><br><span class="line">        init_radar_chart:function(param1, param2, param3, ……)&#123;</span><br><span class="line">            . . .</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里需要注意的是，return 中的函数是外部文件引用本文件时可以调用的函数，如果需要调用本文件的函数可以通过以下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define( [],</span><br><span class="line">function () &#123;</span><br><span class="line">        function func2() &#123;</span><br><span class="line">            console.log(&quot;2&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        return &#123;</span><br><span class="line">            func1:function() &#123;</span><br><span class="line">console.log(&quot;1&quot;);</span><br><span class="line">func2();</span><br><span class="line">&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>同理，我们也可以在 render_radar.js 文件中引用其他的 js 文件（在 define 中引用 js 文件，在 function 中添加形参指代）以便调用其他文件中的函数方法。</p></blockquote><h4 id="2-6-调用图片文件"><a href="#2-6-调用图片文件" class="headerlink" title="2.6 调用图片文件"></a>2.6 调用图片文件</h4><p>如果是在 qext 文件中引用一个图片来作为封面的话好说，可以把图片放到根目录下，直接调用。但是如果是引用一个图片来作为背景图，或者是在设置div的背景图的话，引用的会稍微不同，具体引用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: url(&quot;../extensions/test/background.png&quot;) no-repeat;</span><br></pre></td></tr></table></figure><p>在插件使用图片的时候，qlik sense 会自动封装出来一个路径，如果是按照下面的方式写（前提是 css 和 img 这两个文件夹同级）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: url(&quot;../img/background.png&quot;) no-repeat;</span><br></pre></td></tr></table></figure><p>会报找不到图片的错误，通过查看错误原因，我们可以这样把访问图片的路径固定写成这样，<code>test</code> 是插件名称，这样就可以访问到图片。</p><h4 id="2-7-添加维度、度量等相关自定义配置"><a href="#2-7-添加维度、度量等相关自定义配置" class="headerlink" title="2.7 添加维度、度量等相关自定义配置"></a>2.7 添加维度、度量等相关自定义配置</h4><p>与 template、support、paint、controller 平级，添加一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">definition: &#123;</span><br><span class="line">    type: &quot;items&quot;, // 表明这一级是由好几个item组成，即有子结构体</span><br><span class="line">    component: &quot;accordion&quot;,</span><br><span class="line">    items: &#123;</span><br><span class="line">        dimensions: &#123; // 维度</span><br><span class="line">            uses: &quot;dimensions&quot;,</span><br><span class="line">            items:&#123;</span><br><span class="line">                title: &#123;</span><br><span class="line">                    type: &quot;string&quot;,</span><br><span class="line">                    label: &quot;标题&quot;, </span><br><span class="line">                    ref: &quot;qAttributeExpressions.0.qExpression&quot;, </span><br><span class="line">                    component: &quot;expression&quot;,</span><br><span class="line">                    defaultValue: &quot;&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        measures: &#123; // 度量</span><br><span class="line">            uses: &quot;measures&quot;,</span><br><span class="line">            items:&#123;</span><br><span class="line">                maxMeasure: &#123;</span><br><span class="line">                    type: &quot;string&quot;,</span><br><span class="line">                    label: &quot;度量最大值&quot;,</span><br><span class="line">                    ref: &quot;qAttributeExpressions.0.qExpression&quot;,</span><br><span class="line">                    component: &quot;expression&quot;,</span><br><span class="line">                    defaultValue: &quot;&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        sorting: &#123;  </span><br><span class="line">            uses: &quot;sorting&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        addons: &#123; </span><br><span class="line">            uses: &quot;addons&quot;,</span><br><span class="line">            items: &#123;</span><br><span class="line">                dataHandling: &#123;</span><br><span class="line">                    uses: &quot;dataHandling&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        appearance:&#123; </span><br><span class="line">            uses: &quot;settings&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><a href="https://help.qlik.com/en-US/sense-developer/June2019/Subsystems/Extensions/Content/Sense_Extensions/Howtos/custom-integer-properties.htm" target="_blank" rel="noopener">Qlik Sense官方对自定义属性的介绍</a></p><p>下方链接：<br><a href="https://help.qlik.com/en-US/sense-developer/June2019/Subsystems/Extensions/Content/Sense_Extensions/Howtos/custom-integer-properties.htm" target="_blank" rel="noopener">https://help.qlik.com/en-US/sense-developer/June2019/Subsystems/Extensions/Content/Sense_Extensions/Howtos/custom-integer-properties.htm</a></p><table><thead><tr><th>Field</th><th align="center">Description</th></tr></thead><tbody><tr><td>type</td><td align="center">Used for all custom property type definitions. Can be either <code>string</code>, <code>integer</code>, <code>number</code>, <code>array</code> or <code>boolean</code>.This field is mandatory and should always be “integer” for an integer property type definition.</td></tr><tr><td>component</td><td align="center">Used for defining how the property is visualized in the property panel. Used to override the default component that comes with the type setting.</td></tr><tr><td>label</td><td align="center">Used for defining the label that is displayed in the property panel.</td></tr><tr><td>ref</td><td align="center">Name or ID used to reference a property.</td></tr><tr><td>defaultValue</td><td align="center">Used for defining the default value of your custom property.</td></tr><tr><td>min</td><td align="center">Used for defining the minimum value of the property.</td></tr><tr><td>max</td><td align="center">Used for defining the maximum value of the property.</td></tr></tbody></table><blockquote><p>这段代码中，<code>use</code> 后面写出来的值都是 qlik sense 自己的相关默认配置，固定写法。</p></blockquote><blockquote><p><code>ref</code> 中的值需要着重注意，需要分两种情况来看。</p><ol><li><p>如果这是在维度和度量里的，<code>ref</code> 的填写方式就是上面这样，这是将“标题”中的数据存到了 qMatrix 中，即我们通过 backendApi.getData() 获取数据的时候会一并带回。同时，如果还想添加数据，<code>ref: &quot;qAttributeExpressions.0.qExpression&quot;,</code> 只需要把 0 改成 1 即可，可以一直写。</p></li><li><p>如果是用户填写的一些自定义选项，比如字体大小、字体颜色等选项，我们可以选择下面的写法。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; fontcolor : &#123;</span><br><span class="line">&gt;&gt;    ref: &quot;fontcolor&quot;,</span><br><span class="line">&gt;&gt;    label:&quot;字体颜色&quot;,</span><br><span class="line">&gt;&gt;    type: &quot;string&quot;,</span><br><span class="line">&gt;&gt;    expression: &quot;optional&quot;,</span><br><span class="line">&gt;&gt;    defaultValue: &apos;#1E90FF&apos;</span><br><span class="line">&gt;&gt; &#125;,</span><br><span class="line">&gt;&gt; fontsize: &#123;</span><br><span class="line">&gt;&gt;    type: &quot;integer&quot;,</span><br><span class="line">&gt;&gt;    label: &quot;字体大小&quot;,</span><br><span class="line">&gt;&gt;    ref: &quot;fontsize&quot;,</span><br><span class="line">&gt;&gt;    defaultValue: 24</span><br><span class="line">&gt;&gt;&#125;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol></blockquote><blockquote><p>其中 <code>ref</code> 里的值会直接保存在 <code>$scope.layout</code> 中，可以在 paint 中获取到，并实时进行更新。</p></blockquote><h4 id="2-8-通过-backendApi-来获取数据"><a href="#2-8-通过-backendApi-来获取数据" class="headerlink" title="2.8 通过 backendApi 来获取数据"></a>2.8 通过 backendApi 来获取数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">paint: function (p1,p2) &#123;</span><br><span class="line">    let _this = this;</span><br><span class="line">    var self = this, requestPage = [&#123;</span><br><span class="line">        qTop : 0,</span><br><span class="line">        qLeft : 0,</span><br><span class="line">        qWidth : 10,</span><br><span class="line">        qHeight : 100</span><br><span class="line">    &#125;];</span><br><span class="line">    // backendApi 只能在 paint 函数中使用</span><br><span class="line">    this.backendApi.getData(requestPage).then(function(dataPages) &#123;</span><br><span class="line">        //_this.$scope.data = dataPages[0].qMatrix;</span><br><span class="line">        var vData = dataPages[0].qMatrix;</span><br><span class="line">        console.log(vData);</span><br><span class="line">        </span><br><span class="line">        // 动态获取当前object的高度和宽度，并重新赋值echarts图表，自适应</span><br><span class="line">        var echart_id = &quot;#&quot; + _this.$scope.getId();</span><br><span class="line">        </span><br><span class="line">        var height = p1[0].offsetHeight;</span><br><span class="line">        var width = p1[0].offsetWidth;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        $(echart_id).height(height);</span><br><span class="line">        $(echart_id).width(width);</span><br><span class="line">    &#125;);</span><br><span class="line">    return qlik.Promise.resolve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>requestPage 中定义了我们要如何获取数据，因为 qlik sense 的数据都是存放在数组里的，所以我们可以定义从第几行第几列开始获取，以及获取几列几行数据。一次性获取到的总数量是2W，即 行 * 列 &lt;= 2W，如果超过了这个数据量，可以循环去取。</p><p>你会发现我们在 paint 的函数里添加了两个参数：p1 和 p2。</p><ol><li><p>p1 指代的是整个 object 的信息，比如用户拖拉整个 object 的实时高度和宽度，通过获取这两个值我们可以做到自适应。在官方文档里，这个形参被命名为 $element。</p></li><li><p>p2 里面存放了所有自定义选项的值，比如之前设置的字体颜色、字体大小，都可以在 p2 中获取。在官方文档里，这个形参被命名为 layout。</p></li></ol><h4 id="2-9-创建不同-id"><a href="#2-9-创建不同-id" class="headerlink" title="2.9 创建不同 id"></a>2.9 创建不同 id</h4><p>考虑到可能在同一个工作表中可能会重复使用到同一种插件，对于点击事件来说，大多数情况下需要针对的是 id，而 id 是不可以重复的，所以我们可以通过下面的方式来保证 id 的唯一性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">controller: [&apos;$scope&apos;, function ( $scope ) &#123;</span><br><span class="line">    //add your rendering code here</span><br><span class="line">    $scope.html = &quot;Hello World&quot;;</span><br><span class="line">    </span><br><span class="line">    let generateId = new Date().getTime();</span><br><span class="line">    $scope.getId = function () &#123;</span><br><span class="line">        return generateId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h4 id="2-10-获取关于object更多的相关数据"><a href="#2-10-获取关于object更多的相关数据" class="headerlink" title="2.10 获取关于object更多的相关数据"></a>2.10 获取关于object更多的相关数据</h4><p>这一点在 2.8 已经提到了，但是因为很重要，所以单独再提出来说一遍。</p><p>在 paint: function() 中其实是有参数的，只不过 qlik sense 把参数隐藏了，我们可以添加形参然后打印出来，查看每一个参数的数据格式。</p><p>除了可以获取 object 的相关数据，用户在自定义配置中填写所有的值都可以获取到。我们可以通过数据来编写自适应，可以及时处理数据，同样的，在实现点击跳转功能时，url 或者 sheetID 就是从这里获取的，只不过编写的代码是写在了 controller 中。</p><h4 id="2-11-添加跳转事件"><a href="#2-11-添加跳转事件" class="headerlink" title="2.11 添加跳转事件"></a>2.11 添加跳转事件</h4><p>跳转事件一般有两种，一个是跳转本 App 下的其他任一 sheet 页面，另一个是跳转外部网址。</p><p>要跳转 sheet 页面，就需要获取到当前 app 下所有的 sheet 页面有那些，需要用到 <code>app.getAppObjectList()</code> 这个 api 方法。在 mashup 里是通过 appID 来获取到的 app，在 extension 里需要通过 <code>qlik.currApp()</code> 的方法来获取当前 app。同时需要引入一个 <code>core.utils/deferred</code> 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">define( [&apos;jquery&apos;, &quot;qlik&quot;, &quot;core.utils/deferred&quot;, &quot;text!./template.html&quot;],</span><br><span class="line">function ($, qlik, Deferred, template ) &#123;</span><br><span class="line">var app = qlik.currApp(); // 直接获取app</span><br><span class="line">return &#123;</span><br><span class="line">template: template,</span><br><span class="line">initialProperties:&#123;</span><br><span class="line">eventArray: [] </span><br><span class="line">                // 这里定义了一个 property，之后可以从 layout.eventArray中获取到事件相关的属性值</span><br><span class="line">&#125;,</span><br><span class="line">support:&#123;</span><br><span class="line">... // 省略</span><br><span class="line">&#125;, ...]</span><br><span class="line">&#125;;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>之后在 definition 下，与 appearance 平级的地方添加一下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">events: &#123;</span><br><span class="line">        label: &quot;事件&quot;,</span><br><span class="line">        type: &quot;array&quot;,</span><br><span class="line">        ref: &quot;eventArray&quot;, // 指向 initialProperties 定义的变量</span><br><span class="line">        itemTitleRef: &quot;name&quot;,</span><br><span class="line">        allowAdd: true,</span><br><span class="line">        allowRemove: true,</span><br><span class="line">        addTranslation: &apos;添加事件&apos;,</span><br><span class="line">        items: &#123;</span><br><span class="line">            name: &#123;</span><br><span class="line">                ref: &quot;name&quot;,</span><br><span class="line">                label: &quot;事件名称&quot;,</span><br><span class="line">                type: &quot;string&quot;,</span><br><span class="line">                expression: &quot;optional&quot;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            type: &#123;</span><br><span class="line">                ref: &quot;type&quot;,</span><br><span class="line">                label: &quot;事件类型&quot;,</span><br><span class="line">                component: &quot;dropdown&quot;,</span><br><span class="line">                type: &quot;string&quot;,</span><br><span class="line">                options: [&#123;</span><br><span class="line">                    value: &quot;gotosheet&quot;,</span><br><span class="line">                    label: &quot;跳转工作表&quot;</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    value: &quot;gotowebSite&quot;,</span><br><span class="line">                    label: &quot;跳转网页&quot;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            sheetID: &#123;</span><br><span class="line">                ref: &quot;sheetID&quot;,</span><br><span class="line">                label: &quot;跳转页面&quot;,</span><br><span class="line">                component: &quot;dropdown&quot;,</span><br><span class="line">                type: &quot;string&quot;,</span><br><span class="line">                options: function (data) &#123;</span><br><span class="line">                    var df = Deferred();</span><br><span class="line"></span><br><span class="line">                    app.getAppObjectList(&quot;sheet&quot;, function (reply) &#123;</span><br><span class="line">                        var sheetList = reply.qAppObjectList.qItems.map(function (sheet) &#123;</span><br><span class="line">                            return &#123;</span><br><span class="line">                                value: sheet.qInfo.qId,</span><br><span class="line">                                label: sheet.qMeta.title</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        //console.log(&quot;####&quot;);</span><br><span class="line">                        //console.log(sheetList);</span><br><span class="line"></span><br><span class="line">                        df.resolve(sheetList);</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    return df.promise;</span><br><span class="line">                &#125;,</span><br><span class="line">                show: function (p1, p2, p3) &#123;</span><br><span class="line">                    return p1.type == &quot;gotosheet&quot;;</span><br><span class="line"></span><br><span class="line">                    // console.log(p1);</span><br><span class="line">                    // console.log(p2);</span><br><span class="line">                    // console.log(p3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            webSite: &#123;</span><br><span class="line">                ref: &quot;webSite&quot;,</span><br><span class="line">                label: &quot;网址&quot;,</span><br><span class="line">                type: &quot;string&quot;,</span><br><span class="line">                defaultValue: &apos;&apos;,</span><br><span class="line">                show: function(p1)&#123;</span><br><span class="line">                    return p1.type == &quot;gotowebSite&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sameWindow: &#123;</span><br><span class="line">                ref: &quot;sameWindow&quot;,</span><br><span class="line">                label: &quot;在本页内打开&quot;,</span><br><span class="line">                type: &quot;boolean&quot;,</span><br><span class="line">                defaultValue: true,</span><br><span class="line">                show: function (p1) &#123;</span><br><span class="line">                    return p1.type == &quot;gotowebSite&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 template.html 文件里，在想要添加点击事件的 div 中添加 ng-click 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-click=&quot;gotoAnywhere()&quot; id=&quot;&#123;&#123;getId()&#125;&#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; html &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>之后在 controller 方法中添加对 gotoAnywhere() 函数的编写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$scope.gotoAnywhere = function () &#123;</span><br><span class="line">    // find() 返回的是object类型，返回第一个符合条件的数据</span><br><span class="line">    var res = $scope.layout.eventArray.find(function(item)&#123;</span><br><span class="line">        if(item.type == &apos;gotosheet&apos;)&#123;</span><br><span class="line">            qlik.navigation.gotoSheet(item.sheetID);</span><br><span class="line">        &#125;else if(item.type == &apos;gotowebSite&apos;)&#123;</span><br><span class="line">            // console.log(item);</span><br><span class="line">            var url = item.webSite.startsWith(&quot;http://&quot;) || item.webSite.startsWith(&quot;https://&quot;)   </span><br><span class="line">                        ? item.webSite : &quot;http://&quot; + item.webSite; </span><br><span class="line">            if(!item.sameWindow)</span><br><span class="line">                window.open(url, &quot;_blank&quot;);</span><br><span class="line">            else</span><br><span class="line">                window.open(url, &quot;_self&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>跳转 sheet 页面调用是 Navigation API, 通过 sheetID 就可以直接跳转。但是对于网页来说，需要进行一步转换，因为用户填写的网址没有添加 http:// 或者 https://， qlik 会在自己的域名后直接拼接上 url，会导致打不开页面，所以需要转换一下 url 链接。</p><h4 id="2-12-获取当前服务器下所有的-App-列表-以及获取对应-App-下的-Sheet-列表"><a href="#2-12-获取当前服务器下所有的-App-列表-以及获取对应-App-下的-Sheet-列表" class="headerlink" title="2.12 获取当前服务器下所有的 App 列表 以及获取对应 App 下的 Sheet 列表"></a>2.12 获取当前服务器下所有的 App 列表 以及获取对应 App 下的 Sheet 列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">otherAppID: &#123;</span><br><span class="line">    ref: &quot;otherAppID&quot;,</span><br><span class="line">    label: &quot;其他App&quot;,</span><br><span class="line">    component: &quot;dropdown&quot;,</span><br><span class="line">    type: &quot;string&quot;,</span><br><span class="line">    options: function (data) &#123;</span><br><span class="line">        //var Promise = qlik.Promise;</span><br><span class="line">        var df = Deferred();</span><br><span class="line">        qlik.getGlobal().getAppList(function (items) &#123;</span><br><span class="line">            var appList = items.map(function (item) &#123;</span><br><span class="line">                if(item.qDocId != qlik.currApp().id)&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        value: item.qDocId,</span><br><span class="line">                        label: item.qTitle</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            // console.log(appList);</span><br><span class="line">            df.resolve(appList);</span><br><span class="line">        &#125;);</span><br><span class="line">        return df.promise;</span><br><span class="line">    &#125;,</span><br><span class="line">    show: function (p1, p2, p3) &#123;</span><br><span class="line">        // console.log(p1);</span><br><span class="line">        // console.log(p2);</span><br><span class="line">        // console.log(p3);</span><br><span class="line">        return p1.type == &quot;gotoothersheet&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">otherAppSheetID:&#123;</span><br><span class="line">    ref: &quot;otherAppSheetID&quot;,</span><br><span class="line">    label: &quot;其他App下的工作表&quot;,</span><br><span class="line">    component: &quot;dropdown&quot;,</span><br><span class="line">    type: &quot;string&quot;,</span><br><span class="line">    options: function(data, p1,p2)&#123;</span><br><span class="line">        // console.log(&quot;###&quot;);</span><br><span class="line">        // console.log(p1.layout.eventArray[0].otherAppID);</span><br><span class="line">        // console.log(p2);</span><br><span class="line">        // console.log(data);</span><br><span class="line">        // 这里不使用 data.otherAppID，因为选择工作表后刷新paint，导致data数据发生改变</span><br><span class="line">        // 这里能成功的前提是假设只能有一个跳转事件，有多个的话，下标就会错乱</span><br><span class="line">        var otherApp = qlik.openApp(p1.layout.eventArray[0].otherAppID);</span><br><span class="line">        // console.log(otherApp);</span><br><span class="line">        var defer = Deferred();</span><br><span class="line"></span><br><span class="line">        otherApp.getAppObjectList(&quot;sheet&quot;, function (reply) &#123;</span><br><span class="line">            var otherSheetList = reply.qAppObjectList.qItems.map(function (sheet) &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    value: sheet.qInfo.qId,</span><br><span class="line">                    label: sheet.qMeta.title</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            // console.log(&quot;####&quot;);</span><br><span class="line">            // console.log(otherSheetList);</span><br><span class="line"></span><br><span class="line">            defer.resolve(otherSheetList);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return defer.promise;</span><br><span class="line">    &#125;,</span><br><span class="line">    show: function (p1) &#123;</span><br><span class="line">        // console.log(p1);</span><br><span class="line">        return p1.type == &quot;gotoothersheet&quot; &amp;&amp; p1.otherAppID != &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-13-跳转传参"><a href="#2-13-跳转传参" class="headerlink" title="2.13 跳转传参"></a>2.13 跳转传参</h4><p>APP 之间跳转分两种方式，直接跳转对应 app 下的某一个 sheet 页的方式或者通过 single object 的方式，分别需要用到以下 API：</p><ol><li><p>App Integration API</p><ul><li><a href="https://help.qlik.com/en-US/sense-developer/June2019/Subsystems/APIs/Content/Sense_ClientAPIs/app-integration-api.htm" target="_blank" rel="noopener">官方 API 地址</a></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">官方关于在 url 添加 selections 的例子：</span><br><span class="line">http[s]://&lt;machinename | servername&gt;/&#123;virtual proxy&#125;/sense/app/&#123;appid&#125;/  </span><br><span class="line">sheet/&#123;sheetid&#125;/state/analysis/select/&#123;field&#125;/&#123;value1;value2&#125;/select/&#123;field2&#125;/&#123;value1;value2&#125;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">http://域名/sense/app/eac10684-59bc-4a4f-9b44-b599d961eac0/sheet/a403971e-0f5c-4c51-8342-a72f462bef63/select/企业名称/蚌埠燃气;东莞燃气/select/年月/2019-05</span><br><span class="line"></span><br><span class="line">如果需要先清空之前所有的选择，即每次都以本次打开的选择为优先（因为 selection 是一个全局变量，不同用户对同一个工作表的数据选择都会相互影响），可以在 url 中添加 options 变量，例子如下：</span><br><span class="line"></span><br><span class="line">http://域名/sense/app/eac10684-59bc-4a4f-9b44-b599d961eac0/sheet/a403971e-0f5c-4c51-8342-a72f462bef63/options/clearselections/select/企业名称/蚌埠燃气;东莞燃气/select/年月/2019-05</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Single Integration API</p><ul><li><a href="https://help.qlik.com/en-US/sense-developer/June2019/Subsystems/APIs/Content/Sense_ClientAPIs/single-integration-api.htm" target="_blank" rel="noopener">官方 API 地址</a></li></ul></li></ol><p>官方对于 url 中 “选项” 这一参数的解释如下：</p><table><thead><tr><th align="left">opt</th><th align="center">Description</th></tr></thead><tbody><tr><td align="left">ctxmenu</td><td align="center">enables the context menu.</td></tr><tr><td align="left">currsel</td><td align="center">displays the Selection bar.</td></tr><tr><td align="left">debug</td><td align="center">starts a JavaScript debugger.The debug option can only be defined in the URL.</td></tr><tr><td align="left">noanimate</td><td align="center">turns off animations.</td></tr><tr><td align="left">noselections</td><td align="center">turns off selections.</td></tr><tr><td align="left">nointeraction</td><td align="center">turns off interaction.</td></tr></tbody></table><blockquote><p>ctxmenu 即用户右键点击是的上下文菜单<br>nointeraction 即禁止一切交互，包括用户拖拉表格都会被禁止，所以如果要禁止用户进行一些选择上的操作，参数选择 noselections 即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg：支持上下文菜单（导出数据等）&amp; 在头部显示选择项 &amp; 禁止用户选择</span><br><span class="line"></span><br><span class="line">http://域名/single/?appid=516f7af6-fec7-475b-9750-75a1a590cd86&amp;sheet=567ffa46-a1b8-4d35-8b69-b8885f682b94&amp;opt=ctxmenu,currsel,noselections&amp;select=clearall&amp;select=fieldName,fieldValue&amp;select=fieldName,fieldValue1,fieldValue2</span><br><span class="line"></span><br><span class="line">http://域名/single/?appid=516f7af6-fec7-475b-9750-75a1a590cd86&amp;sheet=567ffa46-a1b8-4d35-8b69-b8885f682b94&amp;opt=ctxmenu,currsel,noselections&amp;select=clearall&amp;select=公司代码,13&amp;select=小区,容城县南张镇,爱佳公寓</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BI </category>
          
          <category> Qlik Sense </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BI </tag>
            
            <tag> Qlik Sense </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挪威的森林</title>
      <link href="/2019/04/19/ReadingNotes-2/"/>
      <url>/2019/04/19/ReadingNotes-2/</url>
      
        <content type="html"><![CDATA[<h2 id="挪威的森林"><a href="#挪威的森林" class="headerlink" title="挪威的森林"></a>挪威的森林</h2><p>上周六读完《云边有个小卖部》，第二天写完读后感，并发起了一个很有意思的活动（是在和朋友聊天的时候学到的），就是让朋友来推荐一本有意义的书，这样一来避免了自己找书的时间，另一方面也可以变相扩展阅读的广度，至于深度，怕是需要不断地研读吧。目前接下来的书单有《娱乐至死》，《活着》，《追风筝的人》。</p><hr><blockquote><p>它类似一种少年时代的憧憬，一种从来不曾实现而且永远不可能实现的憧憬。  </p></blockquote><p>当我在读《挪威的森林》前几章的时候，其实我是读不下去的。有可能是我不习惯村上春树的写作方式，我没有读过他其他的作品，单单就这部书而言，我是感觉他像是在将一个完整的世界描写出来，天上的云，路边的树，街上的人，他把很多事物都描述得很详细，给我一种像是以前小时候写作文的那种感觉，凭着作者的描述你会感受到一个很真实的世界，这有好有坏，好处的是如果你静下心来你会有一个很真实的沉浸感，但是坏处是你可能无法在他如此完整的描述中添加你天马行空的想象。除了描述，最开始读起来会让我感觉很乱，插叙倒叙一起来，木月、直子的名字一直在出现，在阅读伊始不知道他们之间的关系，真的是有点混乱。同时，村上对性的描述之露骨，让我一度觉得这应该被列为禁书之中，同时也让我对翻译人员的文采表示钦佩。</p><blockquote><p>哪里会有人喜欢孤独，不过是不喜欢失望。  </p></blockquote><p>在接下来的几章，我看到了一种颓废又不思上进的生活状态。渡边的大学生活，甚至是整个人生，都是一种自我又冷漠的状态，按部就班的上课，周末天气晴好就洗衣服，天气不好就发呆，晚上偶尔去打工，无所谓旁观者的任何观点与指点，从某种角度上这种能一直保持个性的心态又是极好的。可能这也是村上春树的一种高明之处吧（类似于一种二元的价值观，有好有坏，有正有反，只做呈现，不做评价）。</p><blockquote><p>尽管爱的方式在某一过程中被扭曲得难以思议，但我对直子的爱却是毋庸置疑的，我在自己心田中为直子保留了相当一片未曾被人染指的园地。</p></blockquote><p>我相信一千个人眼中有一千个哈姆雷特，同样我也相信不同的年龄段会有不同的感受。如果是前几年的我看到这本书，可能在读到某一章的时候就因为没有耐心读下去而放弃了，现在的我阅读完这本书之后，我感受到的是一种无助与迷茫。一种凄凉的孤独。渡边在直子和绿子之间徘徊纠结，一边是过去，一边是现在–过去的日子里有他不愿提及的伤痛，以及他自认为故友木月所托的责任；而现实中大胆率真的绿子就像是一座桥梁，让他与真实的世界保持着交流。他就像是被困在井里面一样，没有人可以和他倾心交流，木月已去，直子进了疗养院，敢死队消失了，永泽不能交心，唯一的一个可以说话的绿子，却因为他被过去所困而迟迟不敢靠近。人和人离得那么近，距离却是那么远。这可能也是村上想要表达的东西。</p><hr><p>读完此书脑子莫名混乱，有太多想写，但是写出来又是杂乱无序的，为此我又特地把最后几章看了一遍，又去看了豆瓣上的书评，如此近一天时间，我感觉渡边的形象越来越鲜活，可能是因为他的某些行为在那个年纪我也有过，仿佛是在看自己的某一段过去，亦或是正在进行时的现在……</p><blockquote><p>一听这曲子，我就时常悲哀得不行。也不知为什么，我总是觉得似乎自己在茂密的森林中 迷了路。”直子说，“一个人孤单单的，又冷，里面又黑，又没一个人出来救我。  </p></blockquote><p>我期待多年之后再次拿起这本书的我，不知道那时候我会想到些什么……</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 村上春树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云边有个小卖部</title>
      <link href="/2019/04/14/ReadingNotes-1/"/>
      <url>/2019/04/14/ReadingNotes-1/</url>
      
        <content type="html"><![CDATA[<h2 id="云边有个小卖部"><a href="#云边有个小卖部" class="headerlink" title="云边有个小卖部"></a>云边有个小卖部</h2><blockquote><p>为别人活着，也为自己活着。希望和悲伤，都是一缕光。总有一天，我们会再相遇。</p></blockquote><p>上次读张嘉佳的作品是《从你的全世界路过》，每个小故事连起来，用悲伤的文字来慰藉自己的伤口，从中找到属于自己的一份共鸣，从此也爱上了他的文字。《云边有个小卖部》是逛书店时不经意间看到的，用时五年，期间不断缝缝补补，2018年7月份上市。</p><p>为什么要叫做《云边有个小卖部》呢？<br>刘十三的家乡是一个山间小镇，外婆在院子里开了个小卖部，推开窗户，伸手仿佛能触碰到云朵的边缘，所以这个镇子叫云边镇，这本书叫《云边有个小卖部》。</p><h4 id="1-王莺莺-刘十三"><a href="#1-王莺莺-刘十三" class="headerlink" title="1. 王莺莺 刘十三"></a>1. 王莺莺 刘十三</h4><blockquote><p>“老家这么好？”<br>“祖祖辈辈葬在这里，才叫做故乡。”</p></blockquote><p>刘十三从小和外婆王莺莺生活在这个温柔的小镇上，祖孙俩相依为命，依靠着一个小卖部维持生计。云边镇承载着刘十三的童年，小卖部装着刘十三对外婆所有的疑问和不满，还有一颗不断想逃出去的心。</p><blockquote><p>“王莺莺，为什么天空那么高？”<br>“王莺莺，我告诉你，你必须尊重我的梦想！”<br>“王莺莺，你不要哭，我长大了去大城市生活，到时候我给你寄钱。”</p></blockquote><p>外婆王莺莺，平日里大大咧咧，抽烟喝酒打麻将，在刘十三的眼里，这是非常让他不满意的事情，因为她打麻将，给他的零花钱就少，会阻碍他的梦想。</p><p>说到梦想，刘十三有一个本子，里面写满了他的梦想，只要他写进去的事情，他会不顾一切去完成，这是一个一直在督促他不断成长的东西，但是随着年纪的长大，里面的梦想变得越来越难以实现，比如，考上清华北大，比如，要完成他的保险单业绩…………</p><p>他没有实现清华北大的梦想，但是实现了去远方的梦想，高考考上了一个三本学校，好歹也是离开了王莺莺的魔掌。</p><p>比起他童年里的那些玩伴，他是幸运的，因为他走出了那座山。但是幸运没有持续太久，陌生的城市并没有眷顾这个拼了命的少年郎。毕了业的刘十三找不到稳定的工作，每家公司都只是试用期的三个月，诺大的城市没有他的一片容身之所。</p><p>终于，在某一天夜晚，王莺莺进城。七十岁的外婆，，开了一宿的拖拉机，把七八十斤的行李，一百三十斤的刘十三，全都放到了拖拉机上，把喝得酩酊大醉的刘十三拖回了云边镇。半醉半醒之中的刘十三对外婆的呢喃是内心深处真正的依靠，而外婆对刘十三的温柔与照顾其实一直都在。</p><blockquote><p>“你看到云没有？那些都是天空的翅膀啊。”<br>“从小到大，你都想要去城里，我也没有拦着你，但你总得让我放心啊……”</p></blockquote><p>外婆真想好好活下去，真想永远陪着你，外婆在，你就有家。</p><p>那一天，距离他们的告别最多还有半年的时间。</p><p>刘十三很久后会明白，有些再见，是最后的告别。 </p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_jpg/kKWPRqDfHTkM7f6jsTjZZGOqChibNIuFjNSBwAdn3ibiccDHufgJibONX3k9ZryR0Gk3WQFmzAPezsVWfePJZ0gm2A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p><h4 id="2-刘十三-程霜-牡丹"><a href="#2-刘十三-程霜-牡丹" class="headerlink" title="2. 刘十三 程霜 牡丹"></a>2. 刘十三 程霜 牡丹</h4><blockquote><p>“那么热的夏天，少年的后背被女孩的悲伤烫出一个洞，一直贯穿到心脏，无数个季节的风穿越过这条通道，有一只萤火虫在风里飞舞，忽明忽暗。”</p></blockquote><p>在书中刘十三的这十五年中，程霜一共出现了三次，也一共许下了三个承诺。</p><p>第一次相遇是在小学四年级。那个一直喊着“打劫”的少女的悲伤把少年的后背烫出了一个洞，一直贯穿到心脏。而少年每天早上递给她的小物件让她心心念了每一个清晨，也心心念了她的整个生命。“如果我能活下来，就做你的女朋友”。这是她对他的第一次承诺。</p><p>第二次相遇，程霜目睹了刘十三在车站送别牡丹时的一切，那个被抛弃的少年哭的稀里哗啦，仿佛下一秒就会崩塌，然而真正令程霜伤心的事，他并没有认得自己，或者说，他的眼神里此时都是牡丹，哪怕她抛弃了他，他依旧想的是牡丹。“这次不算，下次见面，如果我能活下来，就做你的女朋友”。这是她对他的第二次承诺。</p><p>第三次相遇，是她回到了云边镇，而他也被外婆拖了回来，于是，两人相遇了。</p><p>这次相遇有两个非常喜欢的情节。</p><p>其中一个是，在湖中小船上，两人做真心话大冒险游戏，她一直在问“如果要选一个人做女朋友，你选牡丹，还是我”，刘十三冒着生命危险，选的都是牡丹。但是细细一想，他真的还喜欢牡丹吗？留下的号码已经变成了空号，之前想说的话他写满了整整一页，每次看的时候都会删删减减，最后就剩下了一句，“你还好吗？”，这不是废话吗。道理他都懂，他只是不甘心，不甘心牡丹说离开就那么的离开了，不甘心她选择了一个那个小平头，他一直在努力着坚持，是在等对方离开，还是在等自己放弃？</p><p>第二个情节是中秋节。因为一些原因，他们“捡”了一个孩子，叫球球。一家四口在桃树下吃饭，外婆做了很多很多好吃的，她看着晚辈们嬉闹着，就好像看到了其乐融融的一家子，这是她一直希望刘十三能够拥有的生活。可能在外婆眼里，早就把程霜当成了孙媳妇，从很早很早的时候就这样了。然而有聚就有散，笑的有多开心哭的就有多伤感。</p><blockquote><p>程霜抱住她，怀里的身体又轻又瘦，她哽咽着说：“外婆你没事的，我们都能活很久的。”<br>王莺莺笑了：“知道了，傻孩子，那，外婆就不说谢谢你了。”<br>在女孩的怀里，老太太轻柔地说：“因为啊，一家人。”  </p></blockquote><p>“如果下次再相见，我们就结婚吧。约好了？”<br>刘十三用力点头，无比郑重：“好。”</p><p>第三个承诺两个人是无比的认真，也是那么的真诚，可惜刘十三等不到了。对于程霜来说，刘十三是一辈子的刘十三。她认为他就是云边镇最好的，哪怕他那么的丑，那么的差劲，找不到稳定的工作，她依旧认为他是完美的，因为他贯穿了她的生命，是她生命中那么亮那么亮的一缕光。而她在他的生命中，就像是那只萤火虫，忽明忽暗，第二天可能就熄灭了。</p><h4 id="3-云边镇"><a href="#3-云边镇" class="headerlink" title="3. 云边镇"></a>3. 云边镇</h4><blockquote><p>“云边有个小卖部，货架堆着岁月和夕阳，背后就是山。老人靠着躺椅假装睡着，小孩子偷走了一块糖。泪水几点钟落地，飞鸟要去向何方。人们聚和离，云朵来又往。讲故事的人，总有一个故事不愿讲。时光飞逝，悄悄话变成纸张。”</p></blockquote><p>这是一个温柔的小镇，也孕育了一群可爱的人。刘十三，牛大田，秦小贞，甚至球球他们都是这个小镇的一部分，他们没有声名显赫的背景，没有大富大贵的经历，他们活得很卑微，卑微到总是生活在逼着他们做出一些选择。</p><p>刘十三好不容易考上了大学，但是奈何工作不如意，最后在烂醉如泥中被外婆连夜拖回了小镇，虽然外人都在嘲讽他，但是外婆依旧在护着他，说他是在外面混的风生水起休假回来，结果因为保险单业绩上不去，还要发动家人一起出谋划策。</p><p>牛大田没有考上大学，只能选择在家乡开一个赌博馆赚点黑心钱，但是又算是有商业头脑，还挣了一点钱，雇的手下却都是以前班上的同学，最后看上了秦小贞，因为爱情烧了自己的赌博馆，也算是回归正途。</p><p>秦小贞是一个外人眼里学成归来的大学生，为了保住颜面，一直都把自己收拾的漂漂亮亮，最后却遭遇意外毁容了。</p><p>球球是一个小孩子，因为父亲的疯癫只能依靠自己，小小年纪就已经长大懂事了，因为受到了刘十三一家的照顾，也感受到了以前未曾感受过的童年快乐。</p><p>他们都是活得辛苦的人，为了活着势必要留着牵念，有了念想活着也容易些。对于他们来说，对于我们来说也是如此。</p><p>还有很多这样的人，他们或许在云边镇，或许不在，但是他们也是这样的一份子，卑微，在生活的压力下被压弯了腰，但却又透露出一股坚强的韧劲，一边被打倒，一边再次生长，不断向上。</p><p>在十三众多朋友中，智哥算是混的不错的了，好歹也在年轻的时候追寻了自己的梦想，在南京的酒馆中唱歌。在写给十三的歌中有如此一句——“刘十三，活着就不算失败”，这一句不止是写给他的，更是写给无数年轻人的，所以才有那么多人反复哼唱着这一句，他们都心有不甘，又心怀渴望。</p><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_jpg/kKWPRqDfHTkM7f6jsTjZZGOqChibNIuFj9oOgARhlwPcnVibJE50yKgRWARjAEvTn2ibgIzwuaxibQAMz7aO3IK9lQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p><h4 id="4-一缕光"><a href="#4-一缕光" class="headerlink" title="4. 一缕光"></a>4. 一缕光</h4><p>刘十三，或者是，我们，在经过了那么多的是是非非之后，懂得了哪些是对自己最重要的，奈何懂得的太晚，晚到这些重要的东西正在一点一点从身边流逝。</p><p>球球最终被送到了福利院，没了生父，没了刘十三一家人，她懂得以后都要一个人了，她懂得隐忍，更加懂事了。牛大田靠着真心感动了秦小贞的父母，祝福他吧。毛婷婷姐嫁到了远方，希望她能获得幸福，希望她的弟弟也能够活得好一些。王莺莺走了，腊月二十三走的。程霜也走了，不单单是再见那么简单，而是真的告别了。刘十三辞了工作，去新加坡找她。程霜最终的承诺还是没有兑现，一直都没有兑现。</p><p>她留下了一幅画，《一缕光》。</p><blockquote><p>生命是有光的。<br>在我熄灭以前，能够照亮你一点，就是我所有能做的了。<br>我爱你，你要记得我。</p></blockquote><p><img src="https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_jpg/kKWPRqDfHTkM7f6jsTjZZGOqChibNIuFjbwrjh3j27DSb8c6PYadoD4ibE94DHSLM4VlTB567JOpiacIBhlTvaU4A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 张嘉佳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qlik Sense学习笔记之单点登录</title>
      <link href="/2019/03/24/QlikSenseSSO/"/>
      <url>/2019/03/24/QlikSenseSSO/</url>
      
        <content type="html"><![CDATA[<h2 id="Qlik-Sense学习笔记之单点登录"><a href="#Qlik-Sense学习笔记之单点登录" class="headerlink" title="Qlik Sense学习笔记之单点登录"></a>Qlik Sense学习笔记之单点登录</h2><h3 id="1-前端接口方式"><a href="#1-前端接口方式" class="headerlink" title="1. 前端接口方式"></a>1. 前端接口方式</h3><pre><code>test(){    $.ajax({      method: &apos;GET&apos;,      url: &apos;http://10.37.148.36:8080/edata-web/SenseSSO/splitJointUrl&apos;,      data: {        eid: &apos;&apos;,        _Account: &quot;itcode&quot;,      },      success: function (result) {        console.log(result);        let arr = JSON.parse(result).data.data.senseUrl.split(&apos;?&apos;);        vm.qlikTicket = arr[1]      }    });  },</code></pre><p>数据返回结果格式如下：</p><pre><code>{    &quot;data&quot;: {        &quot;code&quot;: 200,        &quot;data&quot;: {            &quot;senseUrl&quot;: &quot;http://encndc2sens01.addom.xinaogroup.com/sense/app/9f3b6c30-98df-4aab-a602-1184b0950857?qlikTicket=0ECQkHshAlKCtCrO&amp;eId=&quot;        },        &quot;ip&quot;: &quot;http://encndc2sens01.addom.xinaogroup.com&quot;    }}</code></pre><p>只需要关心 data.ip 以及 data.data 里的 qlikTicket 即可，将 ip 替换并将 qlikTicket 拼接到辛振维所给的的 URL 中就可以访问了。</p><p>如果出现报错：</p><pre><code>Access to XMLHttpRequest at &apos;http://10.37.148.36:8080/edata-web/SenseSSO/splitJointUrl?eid=&amp;_Account=shaosen&apos; from origin &apos;http://localhost:8080&apos; has been blocked by CORS policy: The &apos;Access-Control-Allow-Origin&apos; header contains multiple values &apos;*, *&apos;, but only one is allowed.</code></pre><p>是因为浏览器没有解决跨域问题，解决方法参考下面网址：</p><p><a href="https://www.cnblogs.com/laden666666/p/5544572.html" title="Chrome浏览器的跨域设置" target="_blank" rel="noopener">https://www.cnblogs.com/laden666666/p/5544572.html</a></p><p>重新打开浏览器访问就就可以了。  </p><p>但是对每一个用户都让其设置跨域是不现实的，即 使用前端方式有一定的弊端，所以推荐使用后台接口的方式来实现。  </p><h3 id="2-后台接口方式"><a href="#2-后台接口方式" class="headerlink" title="2. 后台接口方式"></a>2. 后台接口方式</h3><h4 id="2-1-获取证书"><a href="#2-1-获取证书" class="headerlink" title="2.1 获取证书"></a>2.1 获取证书</h4><p>首先需要从 Sense 服务器上获取到认证证书，请联系 大数据赋能群 – 朱胜波，并提供自己电脑的计算机全名（右键 “我的电脑” -&gt; 单击 “属性” -&gt; 查看计算机全名，eg：XINAO-20180212C）或者服务器 IP，将获取到的证书放在本地路径下，修改 SSO.properties 文件中相关属性的值</p><pre><code>CERTFOLDER： 值为本地存放证书的路径或服务器上存放证书的路径PROXYCERT： client.jksPROXYCERTPASS： 由朱胜波提供ROOTCERT： root.jksROOTCERTPASS： 由朱胜波提供</code></pre><h4 id="2-2-修改后台函数"><a href="#2-2-修改后台函数" class="headerlink" title="2.2 修改后台函数"></a>2.2 修改后台函数</h4><p>主要函数如下，查看路径为： /SenseSSO/splitJointUrl  </p><p>其余函数下载压缩包查看，下载链接如下：</p><p><a href="https://pan.enn.cn/l/Y0TM4b" title="Qlick Sense 集成开发资料" target="_blank" rel="noopener">https://pan.enn.cn/l/Y0TM4b</a>  提取密码：sjzt</p><pre><code>@Controller@RequestMapping(value = {&quot;/SenseSSO&quot; })public class SenseSSOController {    /**     * @Title: splitJointUrl     * @Description: 拼接senseurl     * @param id     *            数据库id（对应数据库中的sense url）     * @param ldapTicket     *            LDAP中员工ticket     * @return 拼接之后的url     */    @RequestMapping(value = &quot;splitJointUrl&quot;)    @ResponseBody    public String splitJointUrl(HttpServletRequest request,HttpServletResponse response) {        String uri = request.getRequestURI();        StringBuffer url = request.getRequestURL();        String _Account = request.getParameter(&quot;_Account&quot;);        APIRequestModel _APIRequestModel = new APIRequestModel();        PropertiesHelper _PropertiesHelper = new PropertiesHelper();        //String _Token = null;        response.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);        SenseHelper _SenseHelper = new SenseHelper();        SenseUserModel senseUserModel = new SenseUserModel();        String _SenseUrl=&quot;&quot;;        try {            // 访问数据库获得id对应的Sense中的url            _SenseUrl = _PropertiesHelper.getProfileValue(&quot;SENSEURL&quot;) + &quot;?qlikTicket=&quot;;            System.out.println(_Account);            senseUserModel.setUserId(_Account);            senseUserModel.setUserDirectory(_PropertiesHelper.getProfileValue(&quot;USERDIRECTORY&quot;));        } catch (Exception e) {            _APIRequestModel.setCode(400);            _APIRequestModel.setMessage(e.getMessage());        }        SenseUserModel _SenseUserModel = null;        int ip=1;        String ipString=&quot;&quot;;        for(int i=0;i&lt;3;i++){            try {                // 获取sense中ticket                _SenseUserModel = _SenseHelper.GetSenseTicket(senseUserModel,ip);                if(ip==1){                    //ipString=&quot;http://encndc2clra19.addom.xinaogroup.com&quot;;                    ipString = _PropertiesHelper.getProfileValue(&quot;IP&quot;);                }else if(ip==2){                    //ipString=&quot;http://encndc2clra20.addom.xinaogroup.com&quot;;                    ipString = _PropertiesHelper.getProfileValue(&quot;IP2&quot;);                }/*else{                //ipString=&quot;http://encndc2clra18.addom.xinaogroup.com&quot;;                ipString = _PropertiesHelper.getProfileValue(&quot;SENSEURL&quot;);                }*/                _APIRequestModel.setIp(ipString);            } catch (Exception e) {                _APIRequestModel.setCode(400);                _APIRequestModel.setMessage(e.getMessage());            }            if (_SenseUserModel != null) {                // 拼接url                _SenseUrl += _SenseUserModel.getTicket();                Map&lt;String, String&gt; map = new HashMap&lt;&gt;();                map.put(&quot;senseUrl&quot;, _SenseUrl + &quot;&amp;eId=&quot; + eid);                _APIRequestModel.setData(map);                _APIRequestModel.setCode(200);            } else {                _APIRequestModel.setCode(400);                _APIRequestModel.setMessage(&quot;获取Sense中的Ticket失败！&quot;);            }            if(_APIRequestModel != null &amp;&amp; _APIRequestModel.getCode()==200){                break;            }            ip++;        }        JSONObject obj = new JSONObject();        obj.put(&quot;data&quot;, _APIRequestModel);        return obj.toJSONString();    }}</code></pre><p>前端传给后台只需要传一个 _Account 参数，值为用户的 itcode，该函数会自动帮用户登录到 sense 中，并且获取到对应的服务器 ip 以及对应的 ticket，服务器的 ip 并不一定是一样的，原因在于 sense 登录的负载均衡。该函数返回一个 object 对象，格式及内容如下：</p><pre><code>{    &quot;data&quot;: {        &quot;code&quot;: 200,        &quot;data&quot;: {            &quot;senseUrl&quot;: &quot;http://encndc2sens01.addom.xinaogroup.com/sense/app/9f3b6c30-98df-4aab-a602-1184b0950857?qlikTicket=0ECQkHshAlKCtCrO&amp;eId=&quot;        },        &quot;ip&quot;: &quot;http://encndc2sens01.addom.xinaogroup.com&quot;    }}</code></pre><p>只需要关心 data.ip 以及 data.data 里的 qlikTicket 即可，将 ip 替换并将 qlikTicket 拼接到辛振维所给的的 URL 中就可以访问了。</p>]]></content>
      
      
      <categories>
          
          <category> BI </category>
          
          <category> Qlik Sense </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BI </tag>
            
            <tag> Qlik Sense </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive Sql的日常使用笔记</title>
      <link href="/2019/03/22/Hive-3/"/>
      <url>/2019/03/22/Hive-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Hive-Sql的日常使用笔记"><a href="#Hive-Sql的日常使用笔记" class="headerlink" title="Hive Sql的日常使用笔记"></a>Hive Sql的日常使用笔记</h2><h3 id="1-distinct-和-group-by"><a href="#1-distinct-和-group-by" class="headerlink" title="1. distinct 和 group by"></a>1. distinct 和 group by</h3><p>distinct 只能返回去重的列</p><p>group by 理论上是需要在 select 后面配合聚合函数（sum, avg, max, min, count）来使用的</p><p>select 后面没有在聚合函数中的列都需要写在 group by 的后面，eg： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select A1, A2, A3, max(B) from test group by A1, A2, A3</span><br></pre></td></tr></table></figure><p><code>select distinct(A), B from test</code> 和 <code>select distinct A, B from test</code> 返回的是一样的，返回的都是 A 和 B 的组合值没有重复的结果</p><p>如果需要去重的话，<code>select 需要的列 from A, (select min(主键) from A group by 要去重的列)B where A.主键 = B.主键</code></p><h3 id="2-left-join"><a href="#2-left-join" class="headerlink" title="2. left join"></a>2. left join</h3><p><code>A left join B on A.a1 = B.b and A.a2 = &#39;val&#39;</code> 保留 A 的所有结果，同时 on 后面的结果只针对这一条 left join 语句，不会影响最后的筛选，所以如果要保留所有 A.a2 = ‘val’ 的数据的话，应该在最后写 <code>where A.a2 = &#39;val&#39;</code></p><h3 id="3-if-和-case-when"><a href="#3-if-和-case-when" class="headerlink" title="3. if 和 case when"></a>3. if 和 case when</h3><p>一层： <code>if(A.a = &#39;key&#39;, val1, val2)</code></p><p>两层： <code>if(A.a = &#39;key1&#39;, val1, if(A.a = &#39;key2&#39;, val2, val3))</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case A.a </span><br><span class="line">when &apos;key1&apos; then &apos;val1&apos; </span><br><span class="line">when &apos;key2&apos; then &apos;val2&apos; </span><br><span class="line">else &apos;val3&apos; </span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="4-regexp-replace"><a href="#4-regexp-replace" class="headerlink" title="4. regexp_replace"></a>4. regexp_replace</h3><p>替换掉 A.a 字段中的点 <code>regexp_replace(A.a, &quot;\\.&quot;, &quot;&quot;)</code></p><h3 id="5-cast"><a href="#5-cast" class="headerlink" title="5. cast"></a>5. cast</h3><p><code>cast(A.a as int)</code></p><h3 id="6-concat"><a href="#6-concat" class="headerlink" title="6. concat"></a>6. concat</h3><p><code>concat(A.a,&#39;-01-01&#39;)</code></p><h3 id="7-concat-ws-行转列"><a href="#7-concat-ws-行转列" class="headerlink" title="7. concat_ws 行转列"></a>7. concat_ws 行转列</h3><p><code>concat_ws(&#39;/&#39;, collect_set(label_name))label_name group by key</code></p><blockquote><p>concat 会自动把参数转换为字符串进行拼接，但是 concat_ws 需要提前将数值 cast 成字符串</p></blockquote><h3 id="8-regexp"><a href="#8-regexp" class="headerlink" title="8. regexp"></a>8. regexp</h3><p><code>where trim(A.a) regexp &#39;^[1-9 | A-E]&#39;</code></p><h3 id="9-from-unixtime"><a href="#9-from-unixtime" class="headerlink" title="9. from_unixtime"></a>9. from_unixtime</h3><p><code>from_unixtime(unix_timestamp(),&#39;yyyy-MM-dd hh:mm:ss&#39;) update_time</code></p><h3 id="10-索引"><a href="#10-索引" class="headerlink" title="10. 索引"></a>10. 索引</h3><p>索引基数： 数据列所包含的不同值的数量。索引的基数相对于数据表行数较高（即列中包含很多不同的值，重复的值很少），这个时候创建的索引效果更好。因为查询优化器如果发现某个值出现在表的数据行中的百分比很高的时候，可能会忽略索引直接进行全盘扫描。</p><h3 id="11-row-number"><a href="#11-row-number" class="headerlink" title="11. row_number()"></a>11. row_number()</h3><p><code>row_number() over(partition by 主键 order by 字段1 desc)as r</code></p><h3 id="12-多个条件"><a href="#12-多个条件" class="headerlink" title="12.多个条件"></a>12.多个条件</h3><p><code>if(boolean, res1, if(boolean, res2, if(boolean, res3,……)))</code></p><h3 id="13-nvl"><a href="#13-nvl" class="headerlink" title="13.nvl"></a>13.nvl</h3><p><code>nvl(a,b)</code> 如果a为null 那就取b 只能判断null  不能判断空</p><h3 id="14-decimal"><a href="#14-decimal" class="headerlink" title="14.decimal"></a>14.decimal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cast(round((sum(an) * 100 / sum(tn)),2) as decimal(20,2))</span><br><span class="line"></span><br><span class="line">round((sum(an) * 100 / sum(tn)),2) 可能会出现 84.6599999999 的数据，可能只是 hue 上的 bug，需要再处理一下</span><br></pre></td></tr></table></figure><h3 id="15-补零"><a href="#15-补零" class="headerlink" title="15.补零"></a>15.补零</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(substr(bp, 1, 1) != &apos;X&apos; and bp is not null and trim(bp) != &apos;null&apos; and trim(bp) != &apos;&apos; and trim(bp) != &apos;*&apos;, lpad(bp, 10, &apos;0&apos;), bp)as temp</span><br></pre></td></tr></table></figure><h3 id="16-推数编码出错"><a href="#16-推数编码出错" class="headerlink" title="16.推数编码出错"></a>16.推数编码出错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Incorrect string value: &apos;\xF0\xAF\xA0\xA5&apos; for column &apos;customer_txt&apos; at row 45</span><br></pre></td></tr></table></figure><p>以下几种方法有可能可以解决：</p><ol><li>修改字符集为 utf8mb4</li><li><code>--default-character-set gbk</code> 在 sqoop 最后转换为 gbk 编码</li><li>出错原因是 <code>can&#39;t parse data &#39; &#39;</code> 之类的话，可能是因为特殊字符，需要一个个排查，可以试一下 <code>regexp_replace(field,&#39;\0&#39;,&#39;&#39;)</code></li></ol><h3 id="17-去重"><a href="#17-去重" class="headerlink" title="17.去重"></a>17.去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select distinct t1.objnr </span><br><span class="line">from jest t1 </span><br><span class="line">where t1.stat = &apos;I0002&apos; </span><br><span class="line">and t1.objnr not in (select distinct objnr from jest where stat = &apos;I0076&apos;);</span><br><span class="line"></span><br><span class="line">==&gt; </span><br><span class="line"></span><br><span class="line">select * from</span><br><span class="line">(select objnr, min(if(stat = &apos;I0002&apos;, 0, 1))a, max(if(stat = &apos;I0076&apos;, 1, 0))b</span><br><span class="line">from jest group by objnr)t where t.a = 0 and t.b = 1;</span><br></pre></td></tr></table></figure><h3 id="18-插入数据"><a href="#18-插入数据" class="headerlink" title="18.插入数据"></a>18.插入数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into table values (&apos;05:00&apos;,&apos;6&apos;) ,(&apos;06:00&apos;,&apos;7&apos;), </span><br><span class="line">(&apos;07:00&apos;,&apos;8&apos;), (&apos;08:00&apos;,&apos;9&apos;), (&apos;09:00&apos;,&apos;10&apos;), (&apos;10:00&apos;,&apos;11&apos;), (&apos;11:00&apos;,&apos;12&apos;), (&apos;12:00&apos;,&apos;13&apos;), </span><br><span class="line">(&apos;13:00&apos;,&apos;14&apos;);</span><br></pre></td></tr></table></figure><h3 id="19-每隔N小时取数分组求和"><a href="#19-每隔N小时取数分组求和" class="headerlink" title="19.每隔N小时取数分组求和"></a>19.每隔N小时取数分组求和</h3><p>通过截取字符串，获取时间，除以N保留整数位，分组</p><h3 id="20-正则表达式的匹配"><a href="#20-正则表达式的匹配" class="headerlink" title="20.正则表达式的匹配"></a>20.正则表达式的匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select regexp_replace(&apos;[3]&apos;,&apos;[&apos;,&apos;a&apos;)不识别</span><br><span class="line">select regexp_replace(&apos;[3]&apos;,&apos;\[&apos;,&apos;a&apos;)不识别</span><br><span class="line">select regexp_replace(&apos;[3]&apos;,&apos;\\[&apos;,&apos;a&apos;)识别</span><br><span class="line">select regexp_replace(&apos;[3]&apos;,&apos;]&apos;,&apos;a&apos;)识别</span><br><span class="line">select regexp_replace(&apos;[3]&apos;,&apos;\]&apos;,&apos;a&apos;)识别</span><br><span class="line">select regexp_replace(&apos;[3]&apos;,&apos;\\]&apos;,&apos;a&apos;)识别</span><br><span class="line">select regexp_replace(&apos;[3,.]&apos;,&apos;,&apos;,&apos;a&apos;)识别</span><br><span class="line">select regexp_replace(&apos;[3,.]&apos;,&apos;.&apos;,&apos;a&apos;)aaaaa.会识别为通配符，即所有字符</span><br><span class="line">select regexp_replace(&apos;[3,.]&apos;,&apos;\.&apos;,&apos;a&apos;)不识别</span><br><span class="line">select regexp_replace(&apos;[3,.]&apos;,&apos;\\.&apos;,&apos;a&apos;)[3,a]识别</span><br></pre></td></tr></table></figure><h3 id="21-空字符串关联"><a href="#21-空字符串关联" class="headerlink" title="21.空字符串关联"></a>21.空字符串关联</h3><ol><li>(NULL) 在 join on 的时候不会被关联出来</li><li>‘’ ‘ ‘ 在 join on 的时候会相互关联，只要有匹配项就会关联出来</li><li>(NULL) 只在 left jion 的时候可以出来</li></ol><h3 id="22-lateral-view-explode-列转行"><a href="#22-lateral-view-explode-列转行" class="headerlink" title="22.lateral view explode 列转行"></a>22.lateral view explode 列转行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select gid, assist </span><br><span class="line">from origin_ennenergy_intelligent_operation.wo_baseinfo  </span><br><span class="line">lateral view explode</span><br><span class="line">(split(split(split(regexp_replace(assist_man, &apos;&quot;&apos;,&quot;&quot;), &quot;\\[&quot;)[1],&quot;\\]&quot;)[0], &quot;,&quot;)) aa as assist</span><br></pre></td></tr></table></figure><h3 id="23-userids-包含-gid"><a href="#23-userids-包含-gid" class="headerlink" title="23. userids 包含 gid"></a>23. userids 包含 gid</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find_in_set(gid, userids)  # userids 需要用逗号分隔</span><br><span class="line">instr(userids, gid) 会让 (&apos;2,11&apos;, &apos;1&apos;) 也被筛选出来</span><br></pre></td></tr></table></figure><h3 id="24-pmod-a-b-取模（取余）运算"><a href="#24-pmod-a-b-取模（取余）运算" class="headerlink" title="24.pmod(a, b) 取模（取余）运算"></a>24.pmod(a, b) 取模（取余）运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pmod(7, 4) -&gt; 3</span><br><span class="line">pmod(9, -4) -&gt; -3</span><br><span class="line"># 9 mod -4 商可以取 -2 或 -3，因为 -3 &lt; -2，所以商取 -3，-4 * -3 = 12, 9 - 12 = -3，所以最终结果是 -3</span><br><span class="line">pmod(-9, 4) -&gt; 3</span><br><span class="line"># -9 mod 4 商可以取 -2 或 -3，因为 -3 &lt; -2，所以商取 -3，4 * -3 = -12, -9 - （-12） = 3，所以最终结果是 3</span><br></pre></td></tr></table></figure><h3 id="25-insert-和-insert-overwrite"><a href="#25-insert-和-insert-overwrite" class="headerlink" title="25.insert 和 insert overwrite"></a>25.insert 和 insert overwrite</h3><p>insert overwrite 本质是先覆盖原先的表，再把新的数据插入</p><h3 id="26-insert-和-insert-into"><a href="#26-insert-和-insert-into" class="headerlink" title="26.insert 和 insert into"></a>26.insert 和 insert into</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert table user(id, name) values(1, &apos;zhangsan&apos;);</span><br><span class="line"></span><br><span class="line">insert into table user values(1, &apos;zhangsan&apos;);</span><br></pre></td></tr></table></figure><h3 id="27-max-if-或者-max-case-when-行转列"><a href="#27-max-if-或者-max-case-when-行转列" class="headerlink" title="27.max(if) 或者 max(case when) 行转列"></a>27.max(if) 或者 max(case when) 行转列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select id, </span><br><span class="line">max(if(name = &apos;buss&apos;, pass, &apos;&apos;)) as buss, </span><br><span class="line">max(if(name = &apos;record&apos;, pass, &apos;&apos;)) as record, </span><br><span class="line">max(if(name = &apos;stock&apos;, pass, &apos;&apos;)) as stock, </span><br><span class="line">max(if(name = &apos;client&apos;, pass, &apos;&apos;)) as client</span><br><span class="line">from test0610 </span><br><span class="line">group by id;</span><br><span class="line"></span><br><span class="line">select id, </span><br><span class="line">MAX(CASE WHEN name = &apos;buss&apos; THEN pass END) AS buss,</span><br><span class="line">MAX(CASE WHEN name = &apos;record&apos; THEN pass END) AS record,</span><br><span class="line">MAX(CASE WHEN name = &apos;stock&apos; THEN pass END) AS stock,</span><br><span class="line">MAX(CASE WHEN name = &apos;client&apos; THEN pass END) AS client</span><br><span class="line">from test0610 </span><br><span class="line">group by id;</span><br></pre></td></tr></table></figure><h3 id="28-复制表结构-但不复制数据"><a href="#28-复制表结构-但不复制数据" class="headerlink" title="28.复制表结构 但不复制数据"></a>28.复制表结构 但不复制数据</h3><p><code>create table Test2 like Test1;</code></p><h3 id="29-两个限制条件"><a href="#29-两个限制条件" class="headerlink" title="29.两个限制条件"></a>29.两个限制条件</h3><p>要让每一条数据都满足 balance &lt; 0，gas &gt; 0，转换成 count(if(balance &gt;= 0, 1, 0)) as a, count(if(gas &lt;= 0, 1, 0)) as b，然后 where 中取 a = 0 and b = 0 的数据</p><h3 id="30-join优化"><a href="#30-join优化" class="headerlink" title="30.join优化"></a>30.join优化</h3><ol><li>多表join，其中有一个是最大的表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select /*+ STREAMTABLE(table1) */ tabl1.a, table1.b, table2.c  </span><br><span class="line">from table1 join table2 on ......</span><br></pre></td></tr></table></figure><blockquote><p>hive会假定查询中最后一个表是最大的表。在对每行记录进行连接操作的时候，会尝试将其他表缓存起来，然后扫描最后那个表进行计算。通过 <code>/*+ STREAMTABLE(table1) */</code> 可以显式地指出最大的表是哪一个，hive会将其作为驱动表，哪怕它不是在 join 的最后面</p></blockquote><ol start="2"><li>多表join，其中有一个是最小的表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select /*+ MAPJOIN(table1) */ tabl1.a, table1.b, table2.c  </span><br><span class="line">from table1 join table2 on ......</span><br></pre></td></tr></table></figure><blockquote><p>如果所有表中只有一张表是小表，那么可以在最大的表通过mapper的时候将小表完全放到内存中。Hive可以在map端执行连接过程（称为map-side JOIN），这是因为hive可以和内存中的小表进行逐一匹配，从而省略掉常规连接操作所需要的reduce过程。</p></blockquote><h3 id="31-导出mysql数据库的注释"><a href="#31-导出mysql数据库的注释" class="headerlink" title="31.导出mysql数据库的注释"></a>31.导出mysql数据库的注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">COLUMN_NAME 列名,</span><br><span class="line">COLUMN_TYPE 数据类型,</span><br><span class="line">DATA_TYPE 字段类型,</span><br><span class="line">CHARACTER_MAXIMUM_LENGTH 长度,</span><br><span class="line">IS_NULLABLE 是否为空,</span><br><span class="line">COLUMN_DEFAULT 默认值,</span><br><span class="line">COLUMN_COMMENT 备注 </span><br><span class="line">FROM</span><br><span class="line">INFORMATION_SCHEMA.COLUMNS </span><br><span class="line">table_schema = &apos;库名&apos; </span><br><span class="line">AND </span><br><span class="line">-- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称</span><br><span class="line">table_name = &apos;表名&apos;</span><br></pre></td></tr></table></figure><h3 id="32-count"><a href="#32-count" class="headerlink" title="32. count()"></a>32. count()</h3><pre><code>count(*)：所有行进行统计，包括NULL行count(1)：所有行进行统计，包括NULL行count(column)：统计column所有非NULL行</code></pre><h3 id="33-sum-if…-和-count-if…"><a href="#33-sum-if…-和-count-if…" class="headerlink" title="33. sum(if…) 和 count(if…)"></a>33. sum(if…) 和 count(if…)</h3><p>在计数的时候，以下两种方式是等效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(if(条件判断, 1, 0))</span><br><span class="line"></span><br><span class="line">count(if(条件判断, 字段, NULL))</span><br></pre></td></tr></table></figure><p>原因在于 NULL 并不参加任何计算（但是升序排序的时候 NULL 是第一个，因为ASC码最小）。</p><h3 id="34-sum-over-…"><a href="#34-sum-over-…" class="headerlink" title="34. sum() over(…)"></a>34. sum() over(…)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum() over(partition by year) 计算结果是按照 year 分组来 sum 的总和</span><br><span class="line">sum() over(partition by year order by month) 计算结果是按照 year 分组，1月算的是1月的和，2月算的是 1 - 2月的和， 3月算的是 1 - 3月的和</span><br></pre></td></tr></table></figure><p>同理适用于其他的窗口函数</p><h3 id="35-count-distinct-a-不支持窗口函数，即不支持后面跟着-over-partiton-by-1"><a href="#35-count-distinct-a-不支持窗口函数，即不支持后面跟着-over-partiton-by-1" class="headerlink" title="35. count(distinct a) 不支持窗口函数，即不支持后面跟着 over(partiton by 1)"></a>35. count(distinct a) 不支持窗口函数，即不支持后面跟着 over(partiton by 1)</h3><h3 id="36-size-函数-返回后面map或者array里面的元素个数"><a href="#36-size-函数-返回后面map或者array里面的元素个数" class="headerlink" title="36. size 函数 返回后面map或者array里面的元素个数"></a>36. size 函数 返回后面map或者array里面的元素个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size(collect_set(字段)) over(partiton by 1)</span><br></pre></td></tr></table></figure><h3 id="37-设置变量"><a href="#37-设置变量" class="headerlink" title="37. 设置变量"></a>37. 设置变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set myvar = &quot;test&quot;;</span><br><span class="line">select $&#123;hiveconf:myvar&#125;</span><br></pre></td></tr></table></figure><h3 id="38-coalesce-函数"><a href="#38-coalesce-函数" class="headerlink" title="38. coalesce() 函数"></a>38. coalesce() 函数</h3><p>依次查看每一个表达式，返回第一个非空值，如果都是空，最后返回空值</p><p><code>coalesce(expression_1, expression_2, ...,expression_n)</code></p><h3 id="39-count-distinct-优化"><a href="#39-count-distinct-优化" class="headerlink" title="39. count(distinct) 优化"></a>39. count(distinct) 优化</h3><p>直接使用 count(distinct) 会把数据放入到一个 reducer 下进行计算，导致运行缓慢。</p><p>比如统计本月活跃用户个数</p><p>优化一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 外层SELECT求和</span><br><span class="line">SELECT</span><br><span class="line">    SUM(mau_part) mau</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">    -- 内层SELECT分别进行COUNT(DISTINCT)计算</span><br><span class="line">    SELECT</span><br><span class="line">    substr(uuid, 1, 3) uuid_part,</span><br><span class="line">    COUNT(DISTINCT substr(uuid, 4)) AS mau_part</span><br><span class="line">    FROM detail_sdk_session</span><br><span class="line">    WHERE partition_date &gt;= &apos;2020-01-01&apos; AND partition_date &lt;= nowdate</span><br><span class="line">    GROUP BY substr(uuid, 1, 3)</span><br><span class="line">) t;</span><br><span class="line"></span><br><span class="line">∵ uuid 是唯一的 ∴ 最后的结果 每个uuid_part对应的mau_part都是1，最后求和就是用户总数</span><br><span class="line"></span><br><span class="line">这个写法的好处是，利用 group by 将数据分散到不用的 reducer 进行 count(distinct)计算，提高查询效率</span><br></pre></td></tr></table></figure><blockquote><p>这里 uuid 只截取了3位，如果截取位数过多，假设 uuid 长度为30位，内层 group by 会产生 30^n 个分组，那么外层也需要进行 30^n 次求和</p></blockquote><p>优化二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--  第三层SELECT</span><br><span class="line">SELECT</span><br><span class="line">    SUM(s.mau_part) mau</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">    -- 第二层SELECT</span><br><span class="line">    SELECT</span><br><span class="line">        tag,</span><br><span class="line">        COUNT(*) mau_part</span><br><span class="line">    FROM</span><br><span class="line">    (</span><br><span class="line">        -- 第一层SELECT</span><br><span class="line">        SELECT</span><br><span class="line">            uuid, </span><br><span class="line">            CAST(RAND() * 100 AS BIGINT) tag  -- 为去重后的uuid打上标记，标记为：0-100之间的整数。</span><br><span class="line">        FROM detail_sdk_session</span><br><span class="line">        WHERE partition_date &gt;= &apos;2020-01-01&apos; </span><br><span class="line">        AND partition_date &lt;= nowdate</span><br><span class="line">        AND uuid IS NOT NULL</span><br><span class="line">        GROUP BY uuid   -- 通过GROUP BY，保证去重</span><br><span class="line">    )t</span><br><span class="line">  GROUP BY tag</span><br><span class="line">)s;</span><br><span class="line"></span><br><span class="line">第一层SELECT：对uuid进行去重，并为去重后的uuid打上整数标记</span><br><span class="line">第二层SELECT：按照标记进行分组，统计每个分组下uuid的个数</span><br><span class="line">第三层SELECT：对所有分组进行求和</span><br></pre></td></tr></table></figure><blockquote><p>如果数据量确实很大，也可以增加分组的个数。例如：CAST(RAND() * 1000 AS BIGINT) tag</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qlik Sense学习笔记之简介</title>
      <link href="/2019/03/21/QlikSense-3/"/>
      <url>/2019/03/21/QlikSense-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Qlik-Sense学习笔记之简介"><a href="#Qlik-Sense学习笔记之简介" class="headerlink" title="Qlik Sense学习笔记之简介"></a>Qlik Sense学习笔记之简介</h2><h3 id="1-Qlik-Sense-–-新一代数据分析及可视化平台"><a href="#1-Qlik-Sense-–-新一代数据分析及可视化平台" class="headerlink" title="1.Qlik Sense – 新一代数据分析及可视化平台"></a>1.Qlik Sense – 新一代数据分析及可视化平台</h3><h4 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h4><ul><li>多个文件数据自动关联</li><li>每次点击都会快速重新生成分析结果</li><li>关联数据和不关联数据都能一目了然</li><li>所见即所得，一次开发，电脑和手机都能访问</li></ul><h4 id="1-2-功能"><a href="#1-2-功能" class="headerlink" title="1.2 功能"></a>1.2 功能</h4><ul><li>快捷连接数据文件</li><li>快速数据加载和读取</li><li>拖拽生成图表</li><li>便捷数据导出</li></ul><h4 id="1-3-使用方式"><a href="#1-3-使用方式" class="headerlink" title="1.3 使用方式"></a>1.3 使用方式</h4><ul><li>使用免费客户端自行分析数据</li><li>使用浏览器（IE,谷歌）访问公司的服务器</li></ul><h4 id="1-4-所需要的工具和材料"><a href="#1-4-所需要的工具和材料" class="headerlink" title="1.4 所需要的工具和材料"></a>1.4 所需要的工具和材料</h4><ul><li>客户端/浏览器</li><li>数据文件：QVD文件（文件扩展名为.qvd）</li><li>其他类型的数据文件</li></ul><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3>]]></content>
      
      
      <categories>
          
          <category> BI </category>
          
          <category> Qlik Sense </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BI </tag>
            
            <tag> Qlik Sense </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qlik Sense学习笔记之Mashup开发（二）</title>
      <link href="/2019/01/26/QlikSense-2/"/>
      <url>/2019/01/26/QlikSense-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Qlik-Sense学习笔记之Mashup开发（二）"><a href="#Qlik-Sense学习笔记之Mashup开发（二）" class="headerlink" title="Qlik Sense学习笔记之Mashup开发（二）"></a>Qlik Sense学习笔记之Mashup开发（二）</h2><h4 id="1-Mobile-SPA-UI-Framework"><a href="#1-Mobile-SPA-UI-Framework" class="headerlink" title="1.Mobile SPA UI Framework"></a>1.Mobile SPA UI Framework</h4><ul><li><p>Bootstrap</p><p>  <a href="https://getbootstrap.com/" title="Bootstrap" target="_blank" rel="noopener">https://getbootstrap.com/</a></p></li><li><p>Onsen UI &nbsp;&nbsp;&nbsp;<strong>推荐</strong></p><p>  <a href="https://onsen.io/" title="Onsen UI" target="_blank" rel="noopener">https://onsen.io/</a></p></li></ul><p>可自动侦测IOS和Andriod等设备，自动适应设备的不同相应模式</p><ul><li><p>Leonardo-UI</p><p>  <a href="https://github.com/qlik-oss/leonardo-ui" title="Leonardo-UI" target="_blank" rel="noopener">https://github.com/qlik-oss/leonardo-ui</a></p></li></ul><p>基于 Qlik Sense 自身的一个UI，不需要引入相关的 js、css 文件，只需要保证使用的类是一致的，就可以得到和 Qlik Sense 一样的UI样式，主要是用来开发 Extensions</p><ul><li><p>jQuery Mobile</p><p>  <a href="https://jquerymobile.com/" title="jQuery Mobile" target="_blank" rel="noopener">https://jquerymobile.com/</a></p></li><li><p>Material-UI</p><p>  <a href="https://material-ui.com/" title="Material-UI" target="_blank" rel="noopener">https://material-ui.com/</a></p></li></ul><h4 id="2-实战"><a href="#2-实战" class="headerlink" title="2.实战"></a>2.实战</h4><h5 id="2-1-从零到一"><a href="#2-1-从零到一" class="headerlink" title="2.1 从零到一"></a>2.1 从零到一</h5><h6 id="2-1-1-建立-Mashup-Project"><a href="#2-1-1-建立-Mashup-Project" class="headerlink" title="2.1.1 建立 Mashup Project"></a>2.1.1 建立 Mashup Project</h6><p>方法一：<br>本地Qlik Desktop 中打开Dev Hub -&gt; Mashup Editor -&gt; Basic Template，之后在我的电脑 -&gt; 文档 -&gt; Qlik -&gt; Extensions 中可以找到刚才创建的模板，然后复制整个文件夹到WebStorm或IDEA的workplace下打开。</p><p>方法二：<br>打开Dev Hub -&gt; Mashup Editor -&gt; Basic Template，之后在服务器端下载刚刚创建的模板，会自动打包成zip文件，然后复制整个文件夹到WebStorm或IDEA的workplace下打开。</p><h6 id="2-1-2-配置数据"><a href="#2-1-2-配置数据" class="headerlink" title="2.1.2 配置数据"></a>2.1.2 配置数据</h6><ol><li><p>安装sense-go</p><p> <a href="https://github.com/stefanwalther/sense-go" title="sense-go安装教程" target="_blank" rel="noopener">https://github.com/stefanwalther/sense-go</a></p><pre><code>cnpm install -g sense-go使用 -g 设置sense-go到全局变量 只需安装这一次</code></pre><p> 报错：</p><pre><code>F:\IDEA Workspace\mxxct_demo&gt;npm install -g sense-gonpm ERR! code 1npm ERR! Command failed: F:\Git\cmd\git.EXE checkout 4.0npm ERR! error: pathspec &apos;4.0&apos; did not match any file(s) known to gitnpm ERR!npm ERR! A complete log of this run can be found in:npm ERR!     C:\Users\Lenovo\AppData\Roaming\npm-cache\_logs\2019-01-17T13_39_08_763Z-debug.log</code></pre><p> 更新安装方式：</p><pre><code>在 C 盘下新建一个文件夹，命名为 patch，并将 sense-go.zip 复制到该文件夹下，解压缩到 sense-go 文件夹，执行命名 npm install sense-go -g C:\patch\sense-go</code></pre></li><li><p>新建配置文件</p><p> 打开上面网址，将 sense-go/lib/default-config.yml 中的内容复制下来，在自己项目的根目录下新建一个 yml 文件，文件命名为 <strong>.sense-go.yml</strong> （注意最前面有一个点），并将内容拷贝进去。</p></li><li><p>修改项目目录结构</p><p> sense-go官方文档推荐的项目结构如下：</p><pre><code>| PROJECT-ROOT|-- build         &lt;= all builds, including source code or zipped files    |-- dev       &lt;= target for the development build    |-- release   &lt;= target for the release build|-- docs          &lt;= documentation files, then used by verb|-- src           &lt;= all source files    |-- lib    |-- css       &lt;= see below *        |-- less  &lt;= less files| .sense-go.yml   &lt;= sense-go configuration file (OPTIONAL)| .verb.md        &lt;= verbs readme template| package.jsonbuild文件夹会自动生成，不需要关心  docs文件夹下的文件可以自己管理一下，但是 sense-go 本身不会过多的关心这个目录下的内容  src文件夹存放的是所有的源代码，需要自己创建 lib、css等文件夹</code></pre></li><li><p>配置 yml 文件</p><ul><li><p>修改 packgeName，值为项目名称</p></li><li><p>可以添加一下 version 信息</p></li><li><p>修改 deployment -&gt; toLocal -&gt; enabled 为true，这样就可以使用本地所创建的APP，并把本地 Extensions 路径复制到 localExtensionsBaseDir 下</p><pre><code>deployment:  toLocal:    enabled: true    pathFetching: true              # By default the path will be automatically fetched.    localExtensionsBaseDir: &quot;C:/Users/Lenovo/Documents/Qlik/Sense/Extensions&quot;                                    注意，要把路径中的 &apos;\&apos; 换成 &apos;/&apos; !!!                                    # defaults to the local extension directory of Qlik Sense,                                    # if pathFetching is enabled, this path will be determined automatically    extensionDirOverride:           # Define the extensionDir if you want to deploy to another directory than defined in packageName  qrs:                              # Not implemented, yet    enabled: false    url: null  toSsh:                            # Upload via SSH    enabled: false    host: &quot;192.168.56.11&quot;    port: 22    username: &quot;usr&quot;    password: &quot;foobar&quot;    dest: &quot;/c/Users/usr/Documents/Qlik/Sense/Extensions/whatever-extension&quot;  viaShell:    enabled: false</code></pre></li><li><p>qrs：在项目发布的时候会同步推到Qlik Sense服务器上，尽量不要将 enabled 置为true，可能会导致服务器压力过大</p></li><li><p>修改 lessReduce 中的配置</p><pre><code>lessReduce:# src: &quot;./src/lib/less/main.less&quot;  src: &quot;./src/css/less/main.less&quot;# 这里 main.less 和项目中的文件名必须一致，要不然会找不到文件导致生成的 build 目录下没有 css 样式文件#  dest: &quot;./.tmp/lib/css&quot;  dest: &quot;./.tmp/css&quot;</code></pre></li></ul></li><li><p>添加 main.less 和 qlik.less 文件在 src/lib/css/less 文件夹下</p><p> less 文件夹如果不需要是可以不去配置的，不过因为 less 文件夹会在 build 过程中经过一次编译，并且可以设置一些常用变量，所以配置一下有利于开发。</p><p> 在 main.less 中添加以下代码，引入 qlik.less文件</p><pre><code>@import &quot;qlik&quot;;</code></pre><p> 并且将 mxxct_demo.css 文件中的内容拷贝到 qlik.less 文件中，其中的内容是一些 qlik 默认模板的一些样式设置，然后可以将 mxxct_demo.css 文件删除。</p></li><li><p>删除 wbfolder.wbl 文件，其保存的是当前项目中的文件列表，不过是默认的文件列表，所以并没有什么用</p></li><li><p>修改 mxxct_demo.html 中对 mxxct_demo.js 和 mxxct_demo.css的引用路径，其中 mxxct_demo.css 需要改成 main.less，同时 css 文件夹只有在 build 的时候才会生成，所以这里的路径应该修改为生成 build 之后的文件路径</p></li><li><p>输入命令 sense-go build 来自动生成项目，生成的 build 文件夹会出现在本地 Qlik/Extensions/mxxct_demo 文件夹下，同时会同步在 mashup 当中，可以在 mashup 中点击预览查看，也可以输入 localhost:8848/extensions/mxxct_demo/mxxct_demo.html 进行预览</p></li><li><p>输入命令 sense-go watch:build 来自动监测 .sense-go.yml 从而自动生成 build 文件夹</p></li></ol><h6 id="2-1-3-Hello-Qlik"><a href="#2-1-3-Hello-Qlik" class="headerlink" title="2.1.3 Hello Qlik"></a>2.1.3 Hello Qlik</h6><ol><li><p>在 mxxct_demo.js 文件中，引入 APP</p><pre><code>var app = qlik.openApp(&quot;XXX.qvf&quot;，config)app.getObject(&quot;div的id，比如QV01&quot;,&quot;object的id&quot;);如果需要调用两个服务器上的APP，那么就需要配置两个 config，以及两个 require.config，一般来说是不太需要这种情况的。XXX 指的是本地 Qlik/Sense/Apps 下的文件名称，是从QMC中export出来的文件名（仅限于本地运行）当放到服务器上的时候需要将 XXX.qvf 换成服务器上打开 App 时 url 后的字符串，不带qvf，qvf指的是本地运行的文件。所以尽量写一个 json 文件或者配置文件来配置变量，在上线的时候只需要修改配置即可</code></pre></li><li><p>查看官方API插入到 mxxct_demo.js 文件中来使用</p></li></ol><h6 id="2-1-4-加入类库"><a href="#2-1-4-加入类库" class="headerlink" title="2.1.4 加入类库"></a>2.1.4 加入类库</h6><ol><li><p>第一种方法是静态加载：直接在 mxxct_demo.html 文件中添加，以OnsenUI为例,将对应的js、css文件放到 lib 文件夹下</p><pre><code>&lt;script src=&quot;lib/onsen.ui.js&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>第二种方法是动态加载：首先在 lib 文件夹下创建一个 mxxct_lib.js 文件，然后在 mxxct_demo.js 文件夹中的 require 函数那里，添加在 “js/qlik” 之后，逗号隔开，并且在后面的 function 那里写出对应的引用变量名称。要注意的是，由于 require 已经修改了自己的一个 baseUrl 地址，所以在引用的时候需要使用绝对路径而不能是相对路径，不然会找到文件。</p><pre><code>var prefix = window.location.pathname.substr( 0, window.location.pathname.toLowerCase().lastIndexOf( &quot;/extensions&quot; ) + 1 );var config = {    host: window.location.hostname,    prefix: prefix,    port: window.location.port,    isSecure: window.location.protocol === &quot;https:&quot;};// 在这里默认会把 require.js 中的 baseUrl 给修改掉，所以下面需要改成绝对路径require.config( {    baseUrl: ( config.isSecure ? &quot;https://&quot; : &quot;http://&quot; ) + config.host + (config.port ? &quot;:&quot; + config.port : &quot;&quot;) + config.prefix + &quot;resources&quot;} );// 在 require 中添加引用是不需要在文件后添加 .js 的// 将 require 调整成如下格式，方便查看require( [    &quot;js/qlik&quot;,    &quot;../extensions/mxxct_demo/lib/mxxct_lib&quot;], function (    qlik,    mxxctLib, // 这里设置的引用名称是不支持带 &apos;-&apos; &apos;_&apos; 之类的) {    qlik.setOnError( function ( error ) {        $( &apos;#popupText&apos; ).append( error.message + &quot;&lt;br&gt;&quot; );        $( &apos;#popup&apos; ).fadeIn( 1000 );    } );    $( &quot;#closePopup&quot; ).click( function () {        $( &apos;#popup&apos; ).hide();    } );    //callbacks -- inserted here --    //open apps -- inserted here --    //get objects -- inserted here --    //create cubes and lists -- inserted here --} );</code></pre><p> 每引用一个文件，就需要写一次绝对路径，会略显麻烦，所以可以通过以下方法：引用某一个主 lib.js 文件，然后通过这个文件去引用其他的 js 文件。</p><p> 在 mxxct_lib.js 文件中添加如下代码</p><pre><code>alert(&quot;调用mxxct_lib.js文件成功&quot;);// 这里的 define 函数类似于 mxxct_demo.js 文件中的 require 函数，需要一个数组存放调用的依赖，再加上一个回调函数define([    &quot;./sub_lib1&quot;, // 因为 sub_lib1.js 相对于 mxxct_lib.js 文件是在同一级文件夹下，所以不需要再写绝对路径，通过 ./ 写一个相对路径（当前文件夹下的 sub_lib1.js文件）即可，注意不需要写出来最后的 .js，不然会找不到文件],function(    subLib1){    subLib1.whoAmI();});</code></pre><p> 在 sub_lib1.js 文件中添加如下代码</p><pre><code>define([],function(){    return{        whoAmI:function () {            alert(&quot;mxxct&quot;);            console.log(&quot;调用sub_lib1.js文件&quot;)        }    }});</code></pre><p> <img src="https://images.weserv.nl/?url=https://i.imgur.com/W36y7Sw.png" alt></p></li><li><p>保证类名一样的情况下，使用 Leonnardo UI 可以直接获得和 Qlik Sense 中一样的样式</p></li></ol><h5 id="2-2-渐入佳境"><a href="#2-2-渐入佳境" class="headerlink" title="2.2 渐入佳境"></a>2.2 渐入佳境</h5><p>首先需要获取到对应的 APP 的appid</p><p>打开 Qlik Desktop -&gt; Dev Hub -&gt; 修改 url 中的 dev-hub 为 hub -&gt; 打开 app -&gt; 打开其中一个子 app -&gt; 在 url 的最后添加 /options/developer -&gt; 右键 object 选择 Developer，可以直接查看到 objectID</p><h6 id="2-2-1-动态切换-Object"><a href="#2-2-1-动态切换-Object" class="headerlink" title="2.2.1 动态切换 Object"></a>2.2.1 动态切换 Object</h6><ol><li><p>在获取 Object 的时候，必须要有高度，尽量不要用 min-height，没有高度会不显示，但是可以没有宽度，但是如果要保证换行效果的话，需要加上宽度限制，不然切换到手机屏幕的时候宽度会根据图表的宽度来自动匹配，有可能会导致失去图表效果</p></li><li><p>getObject() 的呈现效果和 visualization.get() 的呈现效果是一样的，都是获取 object 并且呈现，但是 visualization.get() 如果不 show 的话，vis 会一直存在，并且 vis 保存的是整个 object 的一个 datamodal 形式，可以查看到 object 的相关信息，比如图表的类型，组合模式，标题等等，在 layout – qHyperCube 下，可以查看 object 的数据内容，可以单独拿出这部分的数据来单独呈现或生成表格等等。</p><pre><code>var app = qlik.openApp(&apos;xxxName.qvf&apos;,config);    app.getObject(&apos;QV01&apos;, &apos;TT&apos;);var app = qlik.openApp(&apos;xxxName.qvf&apos;,config);    app.visualization.get(&apos;TT&apos;).then(function(vis){        vis.show(&quot;QV01&quot;);    });</code></pre></li><li><p>动态切换</p></li></ol><p>方式一：<br>button 后面添加函数：onclick=”window.fn.getFirst()”，需要把函数写到静态中，然后在主JS文件中写入函数体。</p><p>方式二：<br>通过 jQuery 来绑定 button 的点击事件</p><pre><code>var app = qlik.openApp(&apos;xxxName.qvf&apos;,config);var chart = [];var promises = [];promises.push(app.visualization.get(&apos;TT&apos;).then(function(vis){    // vis.show(&quot;QV01&quot;);    // 返回 promise 的处理结果，但是不知道处理结果是成功还是失败    return Promise.resolve(chart.push(vis));}));promises.push(app.visualization.get(&apos;EJpVXek&apos;).then(function(vis){    // vis.show(&quot;QV02&quot;);    return Promise.resolve(chart.push(vis));}));$(&quot;#btn1&quot;).on(&quot;click&quot;,function () {   $(&quot;#btn1&quot;).addClass(&quot;lui-button--info&quot;);   $(&quot;#btn2&quot;).removeClass(&quot;lui-button--info&quot;);   chart[0].show(&quot;QV01&quot;);});$(&quot;#btn2&quot;).on(&quot;click&quot;,function () {    $(&quot;#btn1&quot;).removeClass(&quot;lui-button--info&quot;);    $(&quot;#btn2&quot;).addClass(&quot;lui-button--info&quot;);    chart[1].show(&quot;QV01&quot;);});// 先把所有的 button 都置为不可选// 当且仅当 promises 中的所有处理结果都存放进来了，即所有获取数据的函数都已经走完了，再执行以下函数Promise.all(promises).then(function () {    chart[0].show(&quot;QV01&quot;);    $(&quot;#btn1&quot;).removeAttr(&quot;disabled&quot;);    $(&quot;#btn2&quot;).removeAttr(&quot;disabled&quot;);});// 需要注意的是，如果在获取 &apos;TT&apos;、&apos;EJpVXek&apos; 之间也存在因为数据量而产生先后顺序错乱的问题，可以固定数组下标来保证先后顺序一致，推荐修改为下面的形式：var app = qlik.openApp(&apos;xxxName.qvf&apos;,config);var chart = [];var promises = [];promises.push(app.visualization.get(&apos;TT&apos;).then(function(vis){    // vis.show(&quot;QV01&quot;);    // 返回 promise 的处理结果，但是不知道处理结果是成功还是失败    return Promise.resolve(vis);}));promises.push(app.visualization.get(&apos;EJpVXek&apos;).then(function(vis){    // vis.show(&quot;QV02&quot;);    return Promise.resolve(vis);}));// 先把所有的 button 都置为不可选// 当且仅当 promises 中的所有处理结果都存放进来了，即所有获取数据的函数都已经走完了，再执行以下函数// 变量 chart 里面的内容可能是异步的，但是通过 Promise.all(promises) 函数对 promises 会再做一次同步操作，会将 chart 的顺序和 promises 的顺序保持一致Promise.all(promises).then(function (chart) {    chart[0].show(&quot;QV01&quot;);    $(&quot;#btn1&quot;).on(&quot;click&quot;,function () {       $(&quot;#btn1&quot;).addClass(&quot;lui-button--info&quot;);       $(&quot;#btn2&quot;).removeClass(&quot;lui-button--info&quot;);       chart[0].show(&quot;QV01&quot;);    });    $(&quot;#btn2&quot;).on(&quot;click&quot;,function () {        $(&quot;#btn1&quot;).removeClass(&quot;lui-button--info&quot;);        $(&quot;#btn2&quot;).addClass(&quot;lui-button--info&quot;);        chart[1].show(&quot;QV01&quot;);    });    $(&quot;#btn1&quot;).removeAttr(&quot;disabled&quot;);    $(&quot;#btn2&quot;).removeAttr(&quot;disabled&quot;);});</code></pre><h6 id="2-2-2-Selection-与-Clear"><a href="#2-2-2-Selection-与-Clear" class="headerlink" title="2.2.2 Selection 与 Clear"></a>2.2.2 Selection 与 Clear</h6><ol><li><p>在筛选项中有一个比较有意思的点，就是可以通过 API 来设置某几个图表或者筛选项的 Alternate State，通过这个 State 的值可以将某些图表和筛选项固定住，比如原先所有的数据都会造成整个 APP 的数据联动，现在要看1月份和2月份的一个饼图对比，在设置了 State 的值之后，这两个饼图的数据不会联动，只会各自根据筛选项进行联动，在保证饼图的算法是一致的情况下，可以获得对照的一个效果。</p></li><li><p>clearAll() 是对整个 APP 来清楚筛选项，所以是 app.clearAll()，Selection 是对某个 Filed 来进行选择，所以是 app.field(“name”).select([0, 1, 2], true, true)</p></li><li><p>qlik.app.field.select(Array, toggle, softlock)</p><ul><li><p>toggle：true 表示之前做的选择会累加不会被清除掉，false 表示之前做的选择全部清除只保留本次的选择，选择 true 的时候如果一个选择 button 点两次会恢复到初始状态，需要根据情况来决定</p></li><li><p>softlock：如果是 true，之前锁住的选择会被覆写掉</p></li></ul></li><li><p>查看要选择的 field 中的数据</p><pre><code>var field = app.field(&apos;实体公司&apos;);field.getData();console.log(field);</code></pre></li><li><p>选择最大值</p><pre><code>$(&quot;#btn6&quot;).on(&quot;click&quot;,function () {    // app.field(&quot;实体公司&quot;).select([0], true, true);    var field = app.field(&apos;实体公司&apos;);    field.getData();    // console.log(field);    // 因为获取数据的问题，刚点击的时候，field.getDdata() 还没获取到数据的时候就已经进行选择了，为了避免这个问题就要加一个延时    setTimeout(function () {        var res = getMaxValueIndex(field.rows);        app.field(&quot;实体公司&quot;).selectValues(res, false, true);    },500);    //field.getData();    //after data is loaded fieldvalues will be in rows array    //field.rows[0].select();});function getMaxValueIndex(paramArray) {    console.log(paramArray);    var names = [];    var tmpMaxValue = Number.MIN_VALUE;    for(var i = 0; i &lt; paramArray.length; i++){        if(Number(paramArray[i].qFrequency) &gt; tmpMaxValue){            tmpMaxValue = Number(paramArray[i].qFrequency);            names = [];            names.push(paramArray[i].qText);        }else if(Number(paramArray[i].qFrequency) == tmpMaxValue){            names.push(paramArray[i].qText);        }    }    console.log(names);    return names;}</code></pre></li></ol><h6 id="2-2-3-变量控制"><a href="#2-2-3-变量控制" class="headerlink" title="2.2.3 变量控制"></a>2.2.3 变量控制</h6><ol><li><p>Qlik 中数据大多以 ( num,string ) 的方式存在，通过 app.variable.setStringValue(qName, qVal) 和 app.variable.setNumValue(qName, qVal) 这两个方法可以对任意一端进行赋值，Qlik 会自动对另一端的值进行改动，不需要再去手动修改</p></li><li><p>当 APP 中同一个 objectID 被三个 button 复用来进行筛选，比如 “30天内”、”90天内”、”全部”，那么就可以通过 app.variable.setStringValue(“qName”,”qValue”) 来进行筛选</p><pre><code>$(&quot;#btn7&quot;).on(&quot;click&quot;,function () {    app.variable.setStringValue(&quot;vTimeRanges&quot;,&quot;in30days&quot;);    $(&quot;#btn7&quot;).addClass(&quot;lui-button--info&quot;);    $(&quot;#btn8&quot;).removeClass(&quot;lui-button--info&quot;);    $(&quot;#btn9&quot;).removeClass(&quot;lui-button--info&quot;);});</code></pre></li><li><p>获取变量中的值，通过 app.variable.getContent() 来获取，并且需要有一个异步函数调用的过程，来对获取到的值进行处理</p><pre><code>app.variable.getContent(&apos;MYVAR&apos;,function ( reply ) {        alert( JSON.stringify( reply ) );} );</code></pre></li></ol><h5 id="2-3-深入浅出"><a href="#2-3-深入浅出" class="headerlink" title="2.3 深入浅出"></a>2.3 深入浅出</h5><h6 id="2-3-1-Hypercube"><a href="#2-3-1-Hypercube" class="headerlink" title="2.3.1 Hypercube"></a>2.3.1 Hypercube</h6><ol><li><p>Qlik 中所有的数据存储方式都是 qHyperCube，不再是数据表中的二维形式。</p></li><li><p>表格的数据是动态加载的，当用户在向下滑动表格的时候，会不断去获取数据动态加载到表格中，其他的 object 是静态加载到前台页面的。</p></li><li><p>通过 </p><pre><code>app.visualization.get(&quot;id&quot;).then(function(vis){    console.log(vis);});</code></pre><p> 来输出 dataModal，在 modal –&gt; layout –&gt; qHyperCube –&gt; qDataPages –&gt; qMatrix 下可以找到当前 object 的所有数据</p><p> 通过 qHyperCube –&gt; qGrandTotalRow 可以得到这个 object 某个维度的总数</p><p> 通过 qHyperCube –&gt; qDimensionInfo 可以得到这个 object 某个维度的描述和字段值</p></li><li><p>如果只是从 qHyperCube 中获取到某些值，展示出来的值是静态的，需要再添加数据联动的效果。</p></li></ol><h6 id="2-3-2-数据联动"><a href="#2-3-2-数据联动" class="headerlink" title="2.3.2 数据联动"></a>2.3.2 数据联动</h6><ol><li><p>通过 vis.table.OnData.bind(listener) 方法来把 vis 的值绑定到 object 上去，但是会遇到一个问题，就是如果这个 object 之前没有被 show 过的话，是无法联动的，所以需要在 .html 中添加一个 style=”display:none” 的一个 div，用来存放需要被联动的 kpi</p></li><li><p>具体代码 copy from demo.js</p><pre><code>// 在 demo.js 中先添加下面的赋值函数function renderKpi(kpi) {    $(&quot;#QV02&quot;).text(kpi.model.layout.qHyperCube.qDataPages[0].qMatrix[0][0].qText);    $(&quot;#QV03&quot;).text(kpi.model.layout.qHyperCube.qDataPages[0].qMatrix[0][1].qText);    $(&quot;#QV05&quot;).text(kpi.model.layout.title).css(&quot;background-color&quot;, kpi.model.layout.subtitle);}// kpi// 在获取到 kpi 之后，将 vis 的值 render 到 objectpromises.push(app.visualization.get(&apos;UtxwSV&apos;).then(function (vis) {    console.log(vis);    var listener = function () {        renderKpi(vis);        // 分页的时候，避免内存溢出将 vis 关闭并且解绑 listener        // vis.close();        // vis.table.OnData.unbind(listener);    };    vis.table.OnData.bind(listener);    return Promise.resolve(vis);}));// 需要在 demo.html 中添加一个 style=&quot;display:none&quot; 的 div，为了让 object 先 show 一下，但是需要隐藏掉，因为不是为了查看某个 object&lt;div id=&quot;cachePool&quot; style=&quot;display:none&quot;&gt;    &lt;div id=&quot;QV04&quot;&gt;&lt;/div&gt;&lt;/div&gt;// 在 demo.js 中的 Promise.all() 函数中添加以下部分Promise.all(promises).then(function (charts) {     // 将 object 先 show 一下    charts[2].show(&quot;QV04&quot;);    // 在第一次获取到数据之后把 kpi 放到 div 中    var kpi = charts[2];    renderKpi(kpi);</code></pre></li></ol><pre><code>        // Selection 的侦听        var selState = app.selectionState();        var listener = function () {            if (selState.selections.length &gt; 0) {                $(&quot;#QV06&quot;).text(selState.selections[0].qSelected);            }        };        selState.OnData.bind(listener);    });如果联动特别多，那么每一个 visualization 都需要绑定一个 listener，所以最好把需要联动的数据集中在一个 object 中，一次性获取到所有的需要联动数据</code></pre><h6 id="2-3-3-Selection的侦听"><a href="#2-3-3-Selection的侦听" class="headerlink" title="2.3.3 Selection的侦听"></a>2.3.3 Selection的侦听</h6><ol><li>查看上方代码，需要注意的是，在 chart 上一次性最多选择6个，大于6个就会显示 n of totalNum（n &gt; 6），所以需要显示更多的选项，就需要去添加一个筛选下拉列表，然后侦听筛选器的选中状态</li></ol><h5 id="2-4-更上层楼"><a href="#2-4-更上层楼" class="headerlink" title="2.4 更上层楼"></a>2.4 更上层楼</h5><h6 id="2-4-1-Object-预读"><a href="#2-4-1-Object-预读" class="headerlink" title="2.4.1 Object 预读"></a>2.4.1 Object 预读</h6><ol><li>预读其实就相当于把 object 先放到了 promise 里面，当所有的 object 都已经放到 promise 中之后，再</li></ol><h6 id="2-4-2-Config-JSON"><a href="#2-4-2-Config-JSON" class="headerlink" title="2.4.2 Config JSON"></a>2.4.2 Config JSON</h6><ol><li><p>把所有的静态变量写在一个 config 文件中，然后在 js 文件中通过 ajax 来调用</p><pre><code>$.ajax({    &apos;type&apos;: &apos;get&apos;,    &apos;url&apos;: &quot;config/system.json&quot;,}).done(function (reply) {    ...})</code></pre></li></ol><h6 id="2-4-3-SPA-的实现"><a href="#2-4-3-SPA-的实现" class="headerlink" title="2.4.3 SPA 的实现"></a>2.4.3 SPA 的实现</h6><ol><li>如果是多个页面进行跳转的话，server 端需要不断提供新的链接信息，socket、session等等，所以 Qlik 推荐使用 SPA 的方式来实现 mashup，可以通过对 div 的 show / hide 或者通过框架对页面重新渲染等</li></ol><h5 id="2-5-登峰造极"><a href="#2-5-登峰造极" class="headerlink" title="2.5 登峰造极"></a>2.5 登峰造极</h5><h6 id="2-5-1-Websocket-与-Engine-API"><a href="#2-5-1-Websocket-与-Engine-API" class="headerlink" title="2.5.1 Websocket 与 Engine API"></a>2.5.1 Websocket 与 Engine API</h6><ol><li>辅助工具 socket.io</li></ol><h6 id="2-5-2-QRS-API-的应用"><a href="#2-5-2-QRS-API-的应用" class="headerlink" title="2.5.2 QRS API 的应用"></a>2.5.2 QRS API 的应用</h6><h6 id="2-5-3-综合应用"><a href="#2-5-3-综合应用" class="headerlink" title="2.5.3 综合应用"></a>2.5.3 综合应用</h6><h4 id="3-DEMO"><a href="#3-DEMO" class="headerlink" title="3.DEMO"></a>3.DEMO</h4>]]></content>
      
      
      <categories>
          
          <category> BI </category>
          
          <category> Qlik Sense </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BI </tag>
            
            <tag> Qlik Sense </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qlik Sense学习笔记之Mashup开发（一）</title>
      <link href="/2018/12/21/QlikSense-1/"/>
      <url>/2018/12/21/QlikSense-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Qlik-Sense学习笔记之Mashup开发（一）"><a href="#Qlik-Sense学习笔记之Mashup开发（一）" class="headerlink" title="Qlik Sense学习笔记之Mashup开发（一）"></a>Qlik Sense学习笔记之Mashup开发（一）</h2><h4 id="1-基于Qlik-Sense-API的Mashup开发"><a href="#1-基于Qlik-Sense-API的Mashup开发" class="headerlink" title="1.基于Qlik Sense API的Mashup开发"></a>1.基于Qlik Sense API的Mashup开发</h4><ol><li><p>Capability API</p><blockquote><p>一定程度上对应了鼠标所能做到的所有操作或功能</p></blockquote></li><li><p>开发工具</p><ul><li>Qlik Sense dev-hub Mashup Editor</li><li>Text Editor<ul><li>Notepad++</li><li>Sublime</li></ul></li><li>IDE<ul><li>Visual Studio Code</li><li>Web Storm</li><li>Eclipse</li></ul></li></ul></li></ol><h4 id="2-Mashup基础代码分析"><a href="#2-Mashup基础代码分析" class="headerlink" title="2.Mashup基础代码分析"></a>2.Mashup基础代码分析</h4><ol><li><p>Project</p><ul><li><p>XXX.html</p></li><li><p>XXX.js</p></li><li><p>XXX.css</p></li><li><p>XXX.qext</p><blockquote><p>qlik文件，用来概括mashup的一些基本信息，比如名称，版本，有什么依赖等。</p></blockquote></li><li><p>wbfolder.wbl</p><blockquote><p>当前mashup有什么文件，有哪些文件是可以在Mashup Editor中罗列出来再次被编辑的。通过Sense go插件可以自动生成。</p></blockquote></li></ul></li><li><p>Require JS</p><blockquote><ol><li>新建一个mashup，在head中自动引入了require.js文件</li><li><code>&lt;script src=&quot;../../resources/assets/external/requirejs/require.js&quot;&gt;&lt;/script&gt;</code></li><li>针对qlik sense的异步调用，优化后的一个require版本  </li><li>可以通过依赖的形式将需要的js文件注入进来，是lazy load的一种方式，只有用到的时候以后才会引入</li></ol></blockquote></li><li><p>Qlik-style.css</p><blockquote><ol><li>新建一个mashup，在head中自动引入了Qlik-style.css文件</li><li><code>&lt;link href=&quot;../../resources/autogenerated/qlik-styles.css&quot; rel=&quot;stylesheet&quot;&gt;</code></li><li>保证object拖动之后渲染效果与图表原先效果保持一致  </li><li>可以覆写这个文件来尝试修改图表样式</li></ol></blockquote></li></ol><h4 id="3-Mashup开发技巧"><a href="#3-Mashup开发技巧" class="headerlink" title="3.Mashup开发技巧"></a>3.Mashup开发技巧</h4><ol><li><p>Qlik Sense Desktop</p><blockquote><p>在Document–Qlik–Sense–Extensions下可以找到Qlik Sense Desktop中的工程目录，以及相关的文件，可以自由增删文件，并可以立即调用</p></blockquote></li><li><p>Qlik 文档</p><ul><li><p><a href="https://help.qlik.com" target="_blank" rel="noopener">https://help.qlik.com</a> </p><blockquote><p>点击下面的Developer，在最左面有一个 API reference</p></blockquote></li></ul></li><li><p>Sense-go</p><ul><li><p><a href="https://github.com/stefanwalther/sense-go" target="_blank" rel="noopener">https://github.com/stefanwalther/sense-go</a></p><blockquote><p>辅助开发插件，只需要设置一下项目名称、版本号、目标输出目录，其他的会自动监听文件变化，并自动编译到目标输出目录中</p></blockquote></li></ul></li><li><p>Qlik Sense Developer Mode</p><blockquote><ol><li>开发中调用图表，是通过 id 去获取调用。</li><li>第一种方式：可以从dev-hub中的Single Configuration中查看</li><li>第二种方式：针对这个页面，可以从页面中查看</li><li><code>http://域名/sense/app/515fc2f7-7779-4d78-b355-250814d16b17/sheet/6d79d8f2-9314-4718-8d48-ff63b72acc21/state/analysis</code></li><li>把/state/analysis修改成/options/developer,然后右键点击图表可以看到 Developer 选项，可以查看object的id还有其中的数据、结构如何。</li></ol></blockquote></li><li><p>引入第三方类库</p><blockquote><ol><li>如果是css文件的话可以直接在head中引入</li><li>但是如果是js文件的话，因为一次性加入的js文件可能过多导致第一次进入太卡，所以放在 app.js 文件 require 函数中统一载入。</li><li>即 第一次进入时先出现loading页面，这个时候载入相关文件和数据</li></ol></blockquote></li><li><p>ID 变与不变</p><blockquote><ol><li>如果复制了一个chart，那两个chart的id  </li><li>但是如果是删除一个chart，然后再重新写一个一样的chart，id会自动改变  </li><li>比如现在有一个piechart，现在想用barchart，但是以后可能还会用piechart，最好是复制一个，然后将其中一个piechart点击右键通过convert转换成barchart  </li><li>可以在js文件夹下创建一个map.js文件，专门存放 objname – objid，或者写一个json文件，这样可以保证修改时不会重新编译整个项目</li></ol></blockquote></li></ol><h4 id="4-Mashup安装与管理"><a href="#4-Mashup安装与管理" class="headerlink" title="4.Mashup安装与管理"></a>4.Mashup安装与管理</h4><ol><li><p>QMC – Qlik Management Console</p></li><li><p>Export / Import</p></li><li><p>多版本处理</p><blockquote><p>修改qext文件中的name，重新导入时候就会区分开</p></blockquote></li><li><p>Qlik Branch</p></li></ol><h4 id="5-Mashup-最常用的-Qlik-API-–-Capability-API"><a href="#5-Mashup-最常用的-Qlik-API-–-Capability-API" class="headerlink" title="5.Mashup 最常用的 Qlik API – Capability API"></a>5.Mashup 最常用的 Qlik API – Capability API</h4><p>因为qlik传递的信息是单节点信息，没有办法绑定js的event事件，所以无法判断传递的数据类型以及根据数据传递事件做出相应的事情。所以需要通过API来获取数据。</p><ul><li><p>Root API</p><blockquote><ol><li>返回高于APP层级的信息，通过getAppList可以返回当前用户有多少app，app有什么信息。  </li><li>openApp：打开一个app，之后才能继续使用APP API  </li><li>resize：Qlik Sense虽然可以自适应，但是如果想把一个chart放到一个div中 ，同时用户可以对div进行拖动放大放小，这时没有触发浏览器的resize，所以就需要resize这个api来辅助实现自适应。  </li><li>sessionApp：如果说想做一个app，让用户可以点进来看，但是用户所有的操作做出的改动不想保留下来，可以使用sessionApp</li><li>setDeviceType：可以强行设置’auto’、’touch’、’desktop’，若未设置则自动检测</li><li>table：能够直接将app中的数据变换成table输出</li></ol></blockquote></li><li><p>App API</p><blockquote><ol><li>clearAll：清空选项</li><li>getObjectProperties：通过传参（appid）获取到chart数据，并进行二次开发</li><li>getObject：直接将app渲染到div中</li></ol></blockquote></li><li><p>Bookmark API</p><blockquote><p>可以存储当前的选择信息，类似于宏操作，可以保留历史</p></blockquote></li><li><p>Field API</p><blockquote><ol><li>QField -&gt; select：因为Qlik Sense中做筛选是在字段上做的，所以所用到的select是在QField下的select方法中，添加字段名称，以及想要选择的下标索引，以及是否需要重新覆写上一次的选择。</li><li>QField -&gt; selectAlternative：互斥选择。选择当前选择的所有其他选项。</li><li>选择的时候有四种颜色：绿色表示当前选择的，白色表示与当前选择相关的选项，深灰色表示不可选，灰色表示可选。白色的可以通过selectPossible方法来选择。</li><li>QField -&gt; selectValues：不知道选项下标，直接传入value，帮助选择</li></ol></blockquote></li><li><p>Global API</p><blockquote><p>用于返回Qlik Sense基本信息，如版本号，server信息，运行状态等</p></blockquote></li><li><p>Table API</p></li><li><p>Navigation API</p></li><li><p>Selection API</p><blockquote><ol><li>专注于当前app中选择的选项，选择的状态等，是基于QField中的select方法的。</li><li>通过对app.selectionState().onData.bind(listener)进行绑定监听，获取当前选中 的选项信息，可以进行下一步的跳转或者其他事件。</li></ol></blockquote></li><li><p>Variable API</p></li><li><p>Visualization API</p><blockquote><ol><li>在app的dataModel基础上，通过create方法可以生成新的图表，或者通过get方法拿到一个图表，在其渲染之前进行一些数据判断或再次筛选。类似于预读功能，先读入配置，等需要渲染的时候再渲染。</li><li>Options：可以获取某一些图表的properties，并可进行适当的替换，所作出的操作不会影响原始数据和图表。</li></ol></blockquote></li></ul><h4 id="6-Mashup-客户端-API"><a href="#6-Mashup-客户端-API" class="headerlink" title="6.Mashup 客户端 API"></a>6.Mashup 客户端 API</h4><ol><li><p>Capability API</p></li><li><p>Extension API / Backend API</p></li><li><p>URL Integration (Single Object /App)</p><blockquote><p>每一个object在single configuration中可以直接复制url地址粘贴在浏览器直接打开，单独占一个websocket，同时可以设置opt=nointeraction（无法选择进行交互）或者删除这一句话来使用户可以选择其中的某一项。</p></blockquote></li></ol><h4 id="7-Qlik-服务端-API"><a href="#7-Qlik-服务端-API" class="headerlink" title="7.Qlik 服务端 API"></a>7.Qlik 服务端 API</h4><ol><li><p>Engine API</p><ul><li>Enigma.js</li><li>.NET SDK</li></ul></li><li><p>QRS API (Qlik Repository Service API)</p><blockquote><ol><li>删除app  修改app 上传文件 etc  </li><li>需要保证header中的X-Qlik-Xrfkey 16位字符串与参数是一样  </li><li>可以查看QRS API endpoints (subset)</li></ol></blockquote></li><li><p>QPS API (Qlik Proxy API)</p><blockquote><ol><li>可以拿到ticket，通过ticket获取一个session，再与Qlik进行交互</li></ol></blockquote></li><li><p>UDC API (User Directory Connector API)</p></li></ol><h4 id="8-Qlik-扩展-API"><a href="#8-Qlik-扩展-API" class="headerlink" title="8.Qlik 扩展 API"></a>8.Qlik 扩展 API</h4><ol><li><p>Customer Connector (QVX)</p></li><li><p>ODAG API (on demand app generation)</p></li><li><p>SSE (Server side extension)</p></li><li><p>Leonardo UI </p></li><li><p>Picasso Chart Lib</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> BI </category>
          
          <category> Qlik Sense </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BI </tag>
            
            <tag> Qlik Sense </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器 Bloom Filter</title>
      <link href="/2018/12/14/Algorithm-5/"/>
      <url>/2018/12/14/Algorithm-5/</url>
      
        <content type="html"><![CDATA[<h2 id="布隆过滤-Bloom-Filter"><a href="#布隆过滤-Bloom-Filter" class="headerlink" title="布隆过滤 Bloom Filter"></a>布隆过滤 Bloom Filter</h2><blockquote><p>它主要用于解决判断一个元素是否在一个集合中，优势在于只需要占用很小的内存空间以及有着高效的查询效率。</p></blockquote><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h3><blockquote><p>它是一个保存了很长的二级制向量，同时结合 Hash 函数实现的。</p></blockquote><p><img src="https://i.imgur.com/nA4kc3K.jpg" alt></p><p>如上图所示：</p><ul><li><p>首先需要初始化一个二进制的数组，长度设为 L（图中为 8），同时初始值全为 0 。</p></li><li><p>当写入一个 A1 = 1000 的数据时，需要进行 H 次 Hash 函数的运算（这里为 2 次）；与 HashMap 有点类似，通过算出的 HashCode 与 L 取模后定位到 0、2 处，将该处的值设为 1。</p></li><li><p>A2 = 2000 也是同理计算后将 4、7 位置设为 1。</p></li><li><p>当有一个 B1 = 1000 需要判断是否存在时，也是做两次 Hash 运算，定位到 0、2 处，此时他们的值都为 1 ，所以认为 B1 = 1000 存在于集合中。</p></li><li><p>当有一个 B2 = 3000 时，也是同理。第一次 Hash 定位到 index = 4 时，数组中的值为 1，所以再进行第二次 Hash 运算，结果定位到 index = 5 的值为 0，所以认为 B2 = 3000 不存在于集合中。</p></li></ul><p>整个的写入、查询的流程就是这样，汇总起来就是：对写入的数据做 H 次 Hash 运算定位到数组中的位置，同时将数据改为 1 。</p><p>当有数据查询时也是同样的方式定位到数组中。一旦其中的有一位为 0 则认为数据肯定不存在于集合，否则数据可能存在于集合中。</p><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><ul><li><p>只要返回数据不存在，则肯定不存在。</p></li><li><p>返回数据存在，但只能是大概率存在。</p></li><li><p>同时不能清除其中的数据。</p></li></ul><p>第一点应该都能理解，重点解释下 2、3 点。为什么返回存在的数据却是可能存在呢，这其实也和 HashMap 类似。</p><p>在有限的数组长度中存放大量的数据，即便是再完美的 Hash 算法也会有冲突，所以有可能两个完全不同的 A、B 两个数据最后定位到的位置是一模一样的。</p><p>这时拿 B 进行查询时那自然就是误报了。删除数据也是同理，当我把 B 的数据删除时，其实也相当于是把 A 的数据删掉了，这样也会造成后续的误报。</p><p>基于以上的 Hash 冲突的前提，所以 Bloom Filter 有一定的误报率，这个误报率和 Hash 算法的次数 H，以及数组长度 L 都是有关的。</p><h3 id="3-自己实现一个布隆过滤"><a href="#3-自己实现一个布隆过滤" class="headerlink" title="3.自己实现一个布隆过滤"></a>3.自己实现一个布隆过滤</h3><p>算法其实很简单不难理解，于是利用 Java 实现了一个简单的雏形：</p><ul><li><p>首先初始化了一个 int 数组。</p></li><li><p>写入数据的时候进行三次 Hash 运算，同时把对应的位置置为 1。</p></li><li><p>查询时同样的三次 Hash 运算，取到对应的值，一旦值为 0 ，则认为数据不存在。</p><pre><code>public class BloomFilters {    /**     * 数组长度     */    private int arraySize;    /**     * 数组     */    private int[] array;    public BloomFilters(int arraySize) {        this.arraySize = arraySize;        array = new int[arraySize];    }    /**     * 写入数据     * @param key     */    public void add(String key) {        int first = hashcode_1(key);        int second = hashcode_2(key);        int third = hashcode_3(key);        array[first % arraySize] = 1;        array[second % arraySize] = 1;        array[third % arraySize] = 1;    }    /**     * 判断数据是否存在     * @param key     * @return     */    public boolean check(String key) {        int first = hashcode_1(key);        int second = hashcode_2(key);        int third = hashcode_3(key);        int firstIndex = array[first % arraySize];        if (firstIndex == 0) {            return false;        }        int secondIndex = array[second % arraySize];        if (secondIndex == 0) {            return false;        }        int thirdIndex = array[third % arraySize];        if (thirdIndex == 0) {            return false;        }        return true;    }</code></pre></li></ul><pre><code>    /**     * hash 算法1     * @param key     * @return     */    private int hashcode_1(String key) {        int hash = 0;        int i;        for (i = 0; i &lt; key.length(); ++i) {            hash = 33 * hash + key.charAt(i);        }        return Math.abs(hash);    }    /**     * hash 算法2     * @param data     * @return     */    private int hashcode_2(String data) {        final int p = 16777619;        int hash = (int) 2166136261L;        for (int i = 0; i &lt; data.length(); i++) {            hash = (hash ^ data.charAt(i)) * p;        }        hash += hash &lt;&lt; 13;        hash ^= hash &gt;&gt; 7;        hash += hash &lt;&lt; 3;        hash ^= hash &gt;&gt; 17;        hash += hash &lt;&lt; 5;        return Math.abs(hash);    }    /**     *  hash 算法3     * @param key     * @return     */    private int hashcode_3(String key) {        int hash, i;        for (hash = 0, i = 0; i &lt; key.length(); ++i) {            hash += key.charAt(i);            hash += (hash &lt;&lt; 10);            hash ^= (hash &gt;&gt; 6);        }        hash += (hash &lt;&lt; 3);        hash ^= (hash &gt;&gt; 11);        hash += (hash &lt;&lt; 15);        return Math.abs(hash);    }}</code></pre><p>测试类：</p><pre><code>@Testpublic void bloomFilterTest(){    long star = System.currentTimeMillis();    BloomFilters bloomFilters = new BloomFilters(10000000) ;    for (int i = 0; i &lt; 10000000; i++) {        bloomFilters.add(i + &quot;&quot;) ;    }    Assert.assertTrue(bloomFilters.check(1+&quot;&quot;));    Assert.assertTrue(bloomFilters.check(2+&quot;&quot;));    Assert.assertTrue(bloomFilters.check(3+&quot;&quot;));    Assert.assertTrue(bloomFilters.check(999999+&quot;&quot;));    Assert.assertFalse(bloomFilters.check(400230340+&quot;&quot;));    long end = System.currentTimeMillis();    System.out.println(&quot;执行时间：&quot; + (end - star));}</code></pre><p>大概三秒就可以写入1000W的数据，并返回判断。</p><p>当数组长度缩小到 100W 时就出现了一个误报，400230340 这个数明明没在集合里，却返回了存在。</p><p>这也体现了 Bloom Filter 的误报率。我们提高数组长度以及 Hash 计算次数可以降低误报率，但相应的 CPU、内存的消耗就会提高；这就需要根据业务需要自行权衡。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Bloom Filter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Bloom Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google面试题（选自公众号）</title>
      <link href="/2018/12/14/Algorithm-4/"/>
      <url>/2018/12/14/Algorithm-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Google面试题（选自公众号）"><a href="#Google面试题（选自公众号）" class="headerlink" title="Google面试题（选自公众号）"></a>Google面试题（选自公众号）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>把你的手机拨号页想象成一个棋盘。棋子走只能走“L”形状，横着两步，竖着一步；或者竖着两步，横着一步。</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/k7OgLAX.png" alt></p><p>现在，假设你拨号只能像棋子一样走“L”形状。每走完一个“L”形拨一次号，起始位置也算拨号一次。问题：从某点开始，在N步内，你可以拨到多少不同的数字？</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>每次面试，我基本都会分成两个部分：首先我们找出算法方案，然后让面试者在代码中实现。我说“我们找出算法方案”，因为这个过程我不是沉默的独裁者。在这样高压下，设计并实现一种算法，45分钟时间并不算充足。</p><p>我通常会让面试者主导讨论，让他们去产生想法，我嘛，就在旁边，时不时地泄漏一点点“天机”。面试者们能力越强，我需要泄漏的“天机”就越少；但是目前为止，我还没遇到一点都不需要我提示的面试者。</p><p>有一点我想强调一下，重要的很：作为面试官，我的职责可不是坐那看着大家失败搞砸。我想要给大家正面的反馈，给大家机会去展现大家最擅长的点。给他们提示，就像是在说：呐，这一步路我给你铺上，但这只是为了让你展示给我，你在后面的路上能走的更远。</p><p>当听完面试官的问题，你应该做什么？切记不要立刻就去写代码，而是在黑板上试着一步一步去分解问题。分解问题能够帮助你寻找到规律，特例等等，逐渐在大脑中形成解决方案。比如，你现在从数字6开始走，能走2步，会有如下组合：</p><pre><code>6–1–86–1–66–7–26–7–66–0–46–0–6</code></pre><p>一共有6种组合。你可以试着用铅笔在纸上画，相信我，有时候动手去解决问题会发生意想不到的事，比你盯着在脑袋里想更神奇。</p><p>怎么样？你脑海里有方案了吗？</p><h4 id="第0阶：到达下一步"><a href="#第0阶：到达下一步" class="headerlink" title="第0阶：到达下一步"></a>第0阶：到达下一步</h4><p>使用这个问题面试，最让我惊讶的是，太多人都卡在了计算从某个特定点跳出时，一共有多少种可能，即邻Neighbors。我的建议是：当你不确定时，先写个占位符，然后请求面试官能否晚点实现这一部分。</p><p>这个问题的复杂性并不在Neighbors的计算；我在意的是你如何计算出总数。所有花费在计算Neighbors上的时间其实都是浪费。</p><p>我会接受“让我们假设有一个函数能给出我Neighbors”。当然，我也可能会让你后面有时间再去实现这一步，你只需要这样写，然后继续。</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/eLz2Xl6.png" alt></p><p>而且，如果一个问题的复杂性不在这里，你也可以问我能不能先略过，一般我都是允许的。我倒是不介意面试者不知道问题的复杂性在哪里，尤其刚开始他们还没有全面了解问题的时候。</p><p>至于Neighbors函数，因为数字永远不变，你可以直接写一个Map然后返回符合的值。</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/S56w55w.png" alt></p><h4 id="第1阶：递归"><a href="#第1阶：递归" class="headerlink" title="第1阶：递归"></a>第1阶：递归</h4><p>聪明的你可能注意到了，这个问题可以通过枚举出所有符合条件的数字，然后计算。这里可以使用递归产生这些值：</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/kiIH6Df.png" alt></p><p>这个方法可以，而且是在面试中最普遍的方法。但是请注意，我们产生了这么多数字却并没有使用他们，我们计算完他们的个数后，就再也不去碰了。所以我建议大家遇到这种情况，尽量去想一下看有没有更好的方案。</p><h4 id="第2阶：数不数数"><a href="#第2阶：数不数数" class="headerlink" title="第2阶：数不数数"></a>第2阶：数不数数</h4><p>怎么在不产生这些数字的情况下计算出个数？可以做到，但需要一点点机智。注意从特定点跳出N次能够拨到的数字个数，等于从它所有临近的点跳出N-1次能够拨到的数字个数的总和。我们可以表达为这样的递归关系：</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/FcLFf4Z.png" alt></p><p>如果你这样想，就会很直观了，跳一次时：6有3个neighbors（1，7和0），当跳0次时每个数字本身算一次，因此每次你只能拨到3个数字。</p><p>怎么会产生这样机智的想法？其实，如果你学了递归，并且在黑板上好好研究，这一点就会变得显而易见。这样你就能继续去解决这个问题，实际上就这一点就有多种实现方法，下面这个便是面试中最常见的：</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/KtKKOi3.png" alt></p><p>就是这样，结合这个函数计算出neighbors 就可以了。这时候，你就可以捏捏肩膀休息下了，因为到这里，你已经刷掉很多人了。</p><p>接下来这个问题我经常问：这个方案的算法理论速度如何？在这个实现中，每次调用count_sequences()都会递归地调用count_sequences()至少2次，因为每个数字至少有2个neighbors。这样会导致runtime成指数增长。</p><p>对于跳1次到20次这样的次数还可以，但是到更大的数字，我们就要碰壁。500次可能就需要整个宇宙的热量来完成运算。</p><h4 id="第3阶：记忆"><a href="#第3阶：记忆" class="headerlink" title="第3阶：记忆"></a>第3阶：记忆</h4><p>那么，我们能做的更好么？使用上面的方法，并不能。我喜欢这个问题，也是因为他能一层一层带出大家的智慧，找到更高效的方法。为了找到更好的方法，让我们看下这个函数是怎么调用的，以count_sequences(6, 4)为例。注意这里用C作为函数名简化。</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/XkdTcIS.png" alt></p><p>你可能注意到了，C(6, 2)运行了3次，每次都是同样的运算并返回同样的值。这里最关键的点在于这些重复的运算，每次你使用过他们的值之后，就没有必要再次计算。</p><p>怎么解决这个问题？记忆。我们那些相同的函数调用和结果，而不是让他们重复。这样，在后面我们就可以直接给出之前的结果。实现方法如下：</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/UH5bvjm.png" alt></p><h4 id="第4阶：动态设计"><a href="#第4阶：动态设计" class="headerlink" title="第4阶：动态设计"></a>第4阶：动态设计</h4><p>如果你再看看前面的递归关系，就会发现递归记忆的方案也有一点局限性：</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/FcLFf4Z.png" alt></p><p>注意跳N次的结果仅仅取决于跳N-1次后调用的结果。同时，缓存中包含着每个次数的所有结果。我之所以说这是个小局限，因为确实不会造成真的问题，当跳的次数增长时，缓存也只是线性增长。但是，毕竟，这还是不够高效。</p><p>怎么办？让我们再来看一看方案和代码。注意，代码中是从最大的次数开始，然后直接递归到最小的次数：</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/dJDLT0C.png" alt></p><p>如果你把整个的函数调用图想象成某种虚拟的树，你就会发现我们在执行深度优先策略。这并没有什么问题，但是它没有利用到浅依赖这个属性。</p><p>如何实现广度优先策略？这里就是一种实现方法：</p><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/zgmD8cK.png" alt></p><p>这个版本比前面递归版好在哪里？其实并没有好很多，但是这个不是递归的，因此即使处理超大数据也很难崩溃。其次，它使用的是常量内存；最后，它仍旧是线性增长，即便处理200000次跳也只用不到20秒。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Topics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Topics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium</title>
      <link href="/2018/12/14/Python-2/"/>
      <url>/2018/12/14/Python-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h2><h3 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1.配置环境"></a>1.配置环境</h3><h4 id="1-1-安装selenium"><a href="#1-1-安装selenium" class="headerlink" title="1.1 安装selenium"></a>1.1 安装selenium</h4><p>pip install selenium</p><h4 id="1-2-安装webdriver"><a href="#1-2-安装webdriver" class="headerlink" title="1.2 安装webdriver"></a>1.2 安装webdriver</h4><p>安装Chrome的webdriver插件</p><p><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></p><p>下载完成之后将 .exe 文件放入到Chrome的安装目录，默认安装路径是<code>C:\Program Files (x86)\Google\Chrome</code>，所以复制到<code>C:\Program Files (x86)\Google\Chrome\Application</code>下。</p><h4 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h4><pre><code>def open_page():    browser = webdriver.Chrome(&quot;C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe&quot;)    browser.get(&apos;http://www.baidu.com/&apos;)</code></pre><h3 id="2-Demo：QQMail"><a href="#2-Demo：QQMail" class="headerlink" title="2.Demo：QQMail"></a>2.Demo：QQMail</h3><pre><code>def open_QQmail():    driver = webdriver.Chrome(&quot;C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe&quot;)    driver.get(&apos;https://mail.qq.com/&apos;)  # 打开QQ邮箱首页    time.sleep(3) # 等待页面载入    # 切换iframe    # selenium只能在一个页面中寻找元素，对于iframe嵌入的页面需要跳转到对应的iframe才能继续操作    login_frame = driver.find_element_by_name(&quot;login_frame&quot;)    driver.switch_to_frame(login_frame)    # 如果已经登录了QQ，那么就需要加上下面这行代码，用于切换到账号密码登录            driver.find_element_by_id(&quot;switcher_plogin&quot;).click()    driver.find_element_by_name(&quot;u&quot;).clear() # 先清空对应文本框的内容    driver.find_element_by_name(&quot;u&quot;).send_keys(&quot;QQ号&quot;) # 输入文本    driver.find_element_by_name(&quot;p&quot;).clear()    driver.find_element_by_name(&quot;p&quot;).send_keys(&quot;QQ密码&quot;)    driver.find_element_by_id(&quot;login_button&quot;).click() # 点击登录按钮    time.sleep(15) # 等待是为了观察页面是否正确跳转    print(driver.current_url) # 打印跳转后的页面url，如果等待时间过短，此时驱动可能还没有完全跳转，打印出来的 current_url 还是 &apos;https://mail.qq.com/&apos;    driver.close()  # 关闭一个标签页，对于 Chrome 来说，关闭唯一一个标签页浏览器也会关闭，但是 Firefox 和 Opera 不会关闭浏览器    # driver.quit()  # 关闭Chrome浏览器</code></pre><h3 id="3-页面交互"><a href="#3-页面交互" class="headerlink" title="3.页面交互"></a>3.页面交互</h3><h4 id="3-1-提交表单"><a href="#3-1-提交表单" class="headerlink" title="3.1 提交表单"></a>3.1 提交表单</h4><pre><code>driver.find_element_by_id(&quot;id&quot;).submit()</code></pre><h4 id="3-2-下拉列表"><a href="#3-2-下拉列表" class="headerlink" title="3.2 下拉列表"></a>3.2 下拉列表</h4><pre><code># 先获取 select 下拉框，然后遍历其中的 option# 效率较低element = driver.find_element_by_xpath(&quot;//select[@name=&apos;name&apos;]&quot;)all_options = element.find_elements_by_tag_name(&quot;option&quot;)for option in all_options:    print(&quot;Value is: %s&quot; % option.get_attribute(&quot;value&quot;))    option.click()# 获取 select 下拉框，通过 option 的下标、文本、值来进行选择from selenium.webdriver.support.ui import Selectselect = Select(driver.find_element_by_name(&apos;name&apos;))select.select_by_index(index)select.select_by_visible_text(&quot;text&quot;)select.select_by_value(value)# 取消选择select = Select(driver.find_element_by_id(&apos;id&apos;))select.deselect_all()# 获取所有已选的选项    select = Select(driver.find_element_by_xpath(&quot;xpath&quot;))all_selected_options = select.all_selected_options# 获取所有可选的选项options = select.options</code></pre><h4 id="3-3-元素拖拽"><a href="#3-3-元素拖拽" class="headerlink" title="3.3 元素拖拽"></a>3.3 元素拖拽</h4><pre><code># 先指定被拖动的元素（Source）和拖动目标元素（Target）element = driver.find_element_by_name(&quot;source&quot;)target = driver.find_element_by_name(&quot;target&quot;)from selenium.webdriver import ActionChainsaction_chains = ActionChains(driver)action_chains.drag_and_drop(element, target).perform()</code></pre><h4 id="3-4-页面切换"><a href="#3-4-页面切换" class="headerlink" title="3.4 页面切换"></a>3.4 页面切换</h4><pre><code># 切换窗口driver.switch_to_window(&quot;windowName&quot;)# 获取每个窗口的操作对象for handle in driver.window_handles:    driver.switch_to_window(handle)# 切换iframedriver.switch_to_frame(&quot;iframeName&quot;)# 通过“.”操作符你还可以获得子frame，并通过下标指定任意framedriver.switch_to_frame(&quot;frameName.0.child&quot;)# 返回父framedriver.switch_to_default_content()</code></pre><h4 id="3-5-弹窗处理"><a href="#3-5-弹窗处理" class="headerlink" title="3.5 弹窗处理"></a>3.5 弹窗处理</h4><pre><code># 获取页面出现了弹窗提示alert = driver.switch_to_alert()</code></pre><h4 id="3-6-历史记录"><a href="#3-6-历史记录" class="headerlink" title="3.6 历史记录"></a>3.6 历史记录</h4><pre><code>driver.forward()driver.back()</code></pre><h4 id="3-7-cookie"><a href="#3-7-cookie" class="headerlink" title="3.7 cookie"></a>3.7 cookie</h4><pre><code># 添加cookiecookie = {‘name’ : ‘foo’, ‘value’ : ‘bar’}driver.add_cookie(cookie)# 获取cookiedriver.get_cookies()</code></pre><h3 id="4-元素获取"><a href="#4-元素获取" class="headerlink" title="4.元素获取"></a>4.元素获取</h3><h4 id="4-1-单个元素获取"><a href="#4-1-单个元素获取" class="headerlink" title="4.1 单个元素获取"></a>4.1 单个元素获取</h4><pre><code>find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector</code></pre><h4 id="4-2-多个元素获取"><a href="#4-2-多个元素获取" class="headerlink" title="4.2 多个元素获取"></a>4.2 多个元素获取</h4><pre><code>find_elements_by_namefind_elements_by_xpathfind_elements_by_link_textfind_elements_by_partial_link_textfind_elements_by_tag_namefind_elements_by_class_namefind_elements_by_css_selector</code></pre><h3 id="5-页面等待"><a href="#5-页面等待" class="headerlink" title="5.页面等待"></a>5.页面等待</h3><p>现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。这会让元素定位困难而且会提高产生 ElementNotVisibleException 的概率。  </p><p>所以 Selenium 提供了两种等待方式，一种是隐式等待，一种是显式等待。隐式等待是等待特定的时间，显式等待是指定某一条件直到条件完成时才继续执行。</p><h4 id="5-1-显式等待"><a href="#5-1-显式等待" class="headerlink" title="5.1 显式等待"></a>5.1 显式等待</h4><p>显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。</p><pre><code>from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Chrome()driver.get(&quot;http://www.&quot;)try:    element = WebDriverWait(driver, 10).until(        EC.presence_of_element_located((By.ID, &quot;id&quot;))    )finally:    driver.quit()</code></pre><p>程序默认会 500ms 调用一次来查看元素是否已经生成，如果本来元素就是存在的，那么会立即返回。</p><p>下面是一些内置的等待条件，你可以直接调用这些条件，而不用自己写某些等待条件了。</p><blockquote><p>title_is<br>title_contains<br>presence_of_element_located<br>visibility_of_element_located<br>visibility_of<br>presence_of_all_elements_located<br>text_to_be_present_in_element<br>text_to_be_present_in_element_value<br>frame_to_be_available_and_switch_to_it<br>invisibility_of_element_located<br>element_to_be_clickable – it is Displayed and Enabled.<br>staleness_of<br>element_to_be_selected<br>element_located_to_be_selected<br>element_selection_state_to_be<br>element_located_selection_state_to_be<br>alert_is_present</p></blockquote><h4 id="5-2-隐式等待"><a href="#5-2-隐式等待" class="headerlink" title="5.2 隐式等待"></a>5.2 隐式等待</h4><pre><code>#  默认等待时间是0秒，一旦设置该值，隐式等待是设置该WebDriver的实例的生命周期。driver = webdriver.Chrome()driver.implicitly_wait(10) # secondsdriver.get(&quot;http://somedomain/url_that_delays_loading&quot;)myDynamicElement = driver.find_element_by_id(&quot;id&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫</title>
      <link href="/2018/12/14/Python-1/"/>
      <url>/2018/12/14/Python-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Python爬虫"><a href="#Python爬虫" class="headerlink" title="Python爬虫"></a>Python爬虫</h2><blockquote><p> 以爬取豆瓣电影评价为例 </p></blockquote><h3 id="1-准备header"><a href="#1-准备header" class="headerlink" title="1.准备header"></a>1.准备header</h3><pre><code>def get_header(movie_id):    UserAgent_List = [        &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36&quot;,        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2226.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2224.3 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.93 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.93 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 4.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.2309.372 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.2117.157 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.47 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1866.237 Safari/537.36&quot;,    ]    header = {        &apos;User-agent&apos;: random.choice(UserAgent_List),        &apos;Host&apos;: &apos;movie.douban.com&apos;,        &apos;Referer&apos;: &apos;https://movie.douban.com/subject/&apos; + movie_id + &apos;/?from=showing&apos;,    }    &apos;&apos;&apos;    HTTP来源地址（referer，或 HTTP referer）是HTTP表头的一个字段，用来表示从哪儿链接到目前的网页，采用的格式是URL。    换句话说，借着HTTP来源地址，目前的网页可以检查访客从哪里而来，这也常被用来对付伪造的跨网站请求。    &apos;&apos;&apos;    time.sleep(random.randint(5, 15))  # 增加随机等待时间，防止速度太快被封    return header</code></pre><h3 id="2-初始化url"><a href="#2-初始化url" class="headerlink" title="2.初始化url"></a>2.初始化url</h3><pre><code>def get_url(movie_id):    base_url = &apos;https://movie.douban.com/subject/&apos;    url = base_url + movie_id + &apos;/comments?status=P&apos;    return url</code></pre><h3 id="3-开始爬取页面"><a href="#3-开始爬取页面" class="headerlink" title="3.开始爬取页面"></a>3.开始爬取页面</h3><pre><code>def start_spider(movie_id, url, header):    print(url)    cur_page = requests.get(url, header, timeout=8)    if cur_page.status_code == 200:  # 当成功获取到网页连接时        soup = BeautifulSoup(cur_page.text, &apos;html5lib&apos;,                             from_encoding=&apos;utf-8&apos;)  # 指定使用哪种解析器: 目前支持, lxml, html5lib, 和 html.parser        comment_block = soup.find_all(&apos;div&apos;, class_=&apos;comment-item&apos;)  # 找到所有的评论模块 包括头像和文本内容，头像用于获取用户主页，以便于查询用户信息        for comment in comment_block:            result_list = []            nick_name = comment.find(&apos;div&apos;, class_=&apos;avatar&apos;).a[&apos;title&apos;]            result_list.append(nick_name)            user_url = comment.find(&apos;div&apos;, class_=&apos;avatar&apos;).a[&apos;href&apos;]            result_list.append(user_url)            # print(nick_name)            # print(user_url)            user_list = spider_for_user(user_url, header) # 去获取评价对应的用户基本信息            result_list.extend(user_list)  # 在 result_list 之后续接 user_list            # print(user_list)            star_level = comment.find(&apos;span&apos;, class_=&apos;rating&apos;)            if star_level:                star_level = star_level[&apos;title&apos;]                if star_level == &apos;力荐&apos;:                    star = &apos;五星&apos;                elif star_level == &apos;推荐&apos;:                    star = &apos;四星&apos;                elif star_level == &apos;还行&apos;:                    star = &apos;三星&apos;                elif star_level == &apos;较差&apos;:                    star = &apos;二星&apos;                elif star_level == &apos;很差&apos;:                    star = &apos;一星&apos;                else:                    star = &apos;&apos;            else:                star = &apos;&apos;            result_list.append(star)            # print(star)            comment_time = comment.find(&apos;span&apos;, class_=&apos;comment-time &apos;).text.strip()            result_list.append(comment_time)            # print(comment_time)            comment_vote = comment.find(&apos;span&apos;, class_=&apos;votes&apos;)            if comment_vote:                comment_vote = comment_vote.text            else:                comment_vote = &apos;&apos;            result_list.append(comment_vote)            # print(comment_vote)            comment_content = comment.find(&apos;span&apos;, class_=&apos;short&apos;).text            result_list.append(comment_content)            # 清除标点符号，方便之后分词和词频统计            pattern = re.compile(r&apos;[\u4e00-\u9fa5]+&apos;)            filterdata = re.findall(pattern, comment_content)            cleaned_comment = &apos;&apos;.join(filterdata)            result_list.append(cleaned_comment)            # print(cleaned_comment)            # print(comment_content)            print(result_list)            # 创建并打开文件            with open(&quot;G:/movie.csv&quot;, mode=&quot;a+&quot;, encoding=&quot;utf-8-sig&quot;, newline=&apos;&apos;) as csvFile:                # encoding=&quot;utf-8-sig&quot; python3 中文编码                # 获得 writer对象 delimiter是分隔符 默认为 &quot;,&quot;                writer = csv.writer(csvFile)                # 调用 writer的 writerow方法将 test_writer_data写入 test_writer.csv文件                writer.writerow(result_list)        next_page = soup.find(&apos;a&apos;, class_=&apos;next&apos;)        if next_page:            tmp = next_page[&apos;href&apos;].strip().replace(&quot;&amp;amp;&quot;, &quot;&quot;).split(&quot;&amp;&quot;)[0].split(&quot;?&quot;)[                1]  # 先移除前后空格，再去除 &amp;amp;，再通过 &amp; 删除多余参数，再通过？只保留下start参数            # tmp = start=20            next_url = &apos;&apos;.join(tmp)        if next_url:            header = get_header(movie_id)            # print(url + &apos;&amp;&apos; + next_url)            start_spider(movie_id, url.split(&quot;&amp;&quot;)[0] + &apos;&amp;&apos; + next_url, header)</code></pre><h3 id="4-爬取用户基本信息"><a href="#4-爬取用户基本信息" class="headerlink" title="4.爬取用户基本信息"></a>4.爬取用户基本信息</h3><pre><code>def spider_for_user(url, header):    user_list = []    user_page = requests.get(url, header, timeout=8)    if user_page.status_code == 200:  # 当成功获取到网页连接时        soup = BeautifulSoup(user_page.text, &apos;html5lib&apos;,                             from_encoding=&apos;utf-8&apos;)  # 指定使用哪种解析器: 目前支持, lxml, html5lib, 和 html.parser        user_info = soup.find(&apos;div&apos;, class_=&apos;basic-info&apos;)  # 找到用户基本信息模块        if user_info:            user_img = user_info.find(&apos;img&apos;, class_=&apos;userface&apos;)[&apos;src&apos;]            if user_img:                user_list.append(user_img)            else:                user_list.append(&quot;&quot;)            # print(user_img)            location = user_info.find(&apos;div&apos;, class_=&apos;user-info&apos;).a            if location:                location = location.text.strip()                user_list.append(location)            else:                user_list.append(&quot;&quot;)            # print(location.strip())            tmp_info = user_info.find(&apos;div&apos;, class_=&apos;pl&apos;)            if tmp_info:                user_name = tmp_info.text.split(&quot; &quot;)[0]                create_time = tmp_info.text.split(&quot; &quot;)[2].split(&quot;加入&quot;)[0]                if user_name:                    user_list.append(user_name)                else:                    user_list.append(&quot;&quot;)                if create_time:                    user_list.append(create_time)                else:                    user_list.append(&quot;&quot;)            else:                user_list.append(&quot;&quot;)                user_list.append(&quot;&quot;)                # tmp_info.text : lingrui1995  2012-08-07加入                # tmp_info.text.split(&quot; &quot;) : [&apos;lingrui1995&apos;, &apos;&apos;, &apos;2012-08-07加入&apos;]                # print(user_name)                # print(create_time)        else:            user_list.append(&quot;&quot;)            user_list.append(&quot;&quot;)            user_list.append(&quot;&quot;)            user_list.append(&quot;&quot;)    return user_list</code></pre><h3 id="5-写入csv文件"><a href="#5-写入csv文件" class="headerlink" title="5.写入csv文件"></a>5.写入csv文件</h3><pre><code>if __name__ == &apos;__main__&apos;:    &apos;&apos;&apos;    movie_id = &apos;3878007&apos;    url = get_url(movie_id)    header = get_header(movie_id)    cookie = get_cookie()    # 先写入 csv 文件的第一行，也就是 head_list 信息    head_list = [&apos;昵称&apos;, &apos;用户首页&apos;, &apos;用户头像&apos;, &apos;地点&apos;, &apos;用户名称&apos;, &apos;注册时间&apos;, &apos;评分&apos;, &apos;评论时间&apos;, &apos;评论喜欢人数&apos;, &apos;评论内容&apos;, &apos;评论纯文本&apos;]    with open(&quot;G:/movie.csv&quot;, mode=&quot;w&quot;, encoding=&apos;utf-8-sig&apos;, newline=&apos;&apos;) as csvFile:        # encoding = &apos;utf-8-sig&apos; 是因为对于UTF-8编码，Excel要求BOM(字节顺序标记)写在文件的开始，否则它会假设这是ANSI编码        # newline = &apos;&apos; 保证文件在写入一行之后下一行不会有多余的空行        # mode        # r : 以只读模式打开（缺省模式）（必须保证文件存在）        # w : 以只写模式打开。若文件存在，则会自动清空文件，然后重新创建；若文件不存在，则新建文件。使用这个模式必须要保证文件所在目录存在，文件可以不存在。该模式下不能使用read*()方法。        # a : 以追加模式打开。若文件存在，则会追加到文件的末尾；若文件不存在，则新建文件。该模式不能使用read*()方法。        # 下面四个模式要和上面的模式组合使用        # &apos;b&apos;：以二进制模式打开        # &apos;t&apos;： 以文本模式打开（缺省模式）        # &apos;+&apos;：以读写模式打开        # &apos;U&apos;：以通用换行符模式打开        # 常见的mode组合        # &apos;r&apos; 或 &apos;rt&apos;： 默认模式，文本读模式        # &apos;w&apos; 或 &apos;wt&apos;： 以文本写模式打开（打开前文件会被清空）        # &apos;rb&apos;：以二进制读模式打开        # &apos;ab&apos;：以二进制追加模式打开        # &apos;wb&apos;：以二进制写模式打开（打开前文件会被清空）        # &apos;r+&apos;：以文本读写模式打开，可以写到文件任何位置；默认写的指针开始指在文件开头, 因此会覆写文件        # &apos;w+&apos;：以文本读写模式打开（打开前文件会被清空）。可以使用read * ()        # &apos;a+&apos;：以文本读写模式打开（写只能写在文件末尾）。可以使用read * ()        # &apos;rb+&apos;：以二进制读写模式打开        # &apos;wb+&apos;：以二进制读写模式打开（打开前文件会被清空）        # &apos;ab+&apos;：以二进制读写模式打开        # 获得 writer对象        writer = csv.writer(csvFile)        # 调用 writer的 writerow方法将 test_writer_data写入 test_writer.csv文件        writer.writerow(head_list)    start_spider(movie_id, url, header)    &apos;&apos;&apos;    with open(&quot;F:\PythonProjects\movie.csv&quot;, mode=&quot;r&quot;, encoding=&apos;utf-8-sig&apos;, newline=&apos;&apos;) as csvFile:        csv_reader = csv.reader(csvFile)        for row in csv_reader:            print(row)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系型和非关系型数据库对比</title>
      <link href="/2018/12/11/DB-1/"/>
      <url>/2018/12/11/DB-1/</url>
      
        <content type="html"><![CDATA[<h4 id="关系型数据库-Structured-Query-Language"><a href="#关系型数据库-Structured-Query-Language" class="headerlink" title="关系型数据库 Structured Query Language"></a>关系型数据库 Structured Query Language</h4><h5 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h5><ol><li><p>事务处理时保持数据的一致性</p><blockquote><p>如果读取的过程中其他事务对数据有写入操作，查询出来的结果也依旧是读取开始前的状态，不会呈现修改后的结果。</p></blockquote></li><li><p>以标准化为前提，数据更新的开销很小（相同字段基本上只有一处）</p></li><li><p>可以使用join等复杂查询</p></li></ol><h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2.缺点"></a>2.缺点</h5><ol><li><p>扩展困难</p><blockquote><p>由于存在类似join这样多表查询机制，使得数据库在扩展方面很难。</p></blockquote></li><li><p>读写慢</p><blockquote><p>这种情况主要发生在数据量达到一定规模时由于关系型数据库的系统逻辑非常复杂，使得其非常容易发生死锁等并发问题，所以导致其读写速度下滑非常严重</p></blockquote></li><li><p>成本高</p><blockquote><p>企业级数据库的许可证价格高，并随着规模的增加而不断增加</p></blockquote></li><li><p>有限的支撑容量</p><blockquote><p>现有的关系型解决方案还无法支撑海量数据</p></blockquote></li></ol><h4 id="非关系型数据库-Not-Only-Structured-Query-Language"><a href="#非关系型数据库-Not-Only-Structured-Query-Language" class="headerlink" title="非关系型数据库 Not Only Structured Query Language"></a>非关系型数据库 Not Only Structured Query Language</h4><h5 id="1-优点-1"><a href="#1-优点-1" class="headerlink" title="1.优点"></a>1.优点</h5><ol><li><p>扩展方便</p><blockquote><p>典型例子是Cassandra，由于其架构是类似于经典的P2P，所以能通过轻松地添加新的节点来扩展这个集群</p></blockquote></li><li><p>快读读写</p><blockquote><p>主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作</p></blockquote></li><li><p>低廉成本</p><blockquote><p>这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本</p></blockquote></li></ol><h5 id="2-缺点-1"><a href="#2-缺点-1" class="headerlink" title="2.缺点"></a>2.缺点</h5><ol><li><p>不提供对SQL的支持，需要学习对应的语言</p></li><li><p>支持的特性不够丰富</p><blockquote><p>现有产品所提供的功能都比较有限，大多数NoSQL数据库都不支持事务，也不像MS SQL Server和Oracle那样能提供各种附加功能，比如BI和报表等</p></blockquote></li><li><p>现有产品的不够成熟</p></li></ol><h5 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h5><ol><li><p>数据库表schema经常变化</p><blockquote><p>比如在线商城，维护产品的属性经常要增加字段，这就意味着ORMapping层的代码和配置要改，如果该表的数据量过百万，新增字段会带来额外开销（重建索引等）。NoSQL应用在这种场景，可以极大提升DB的可伸缩性，开发人员可以将更多的精力放在业务层。</p></blockquote></li><li><p>数据库表字段是复杂数据类型</p><blockquote><p>对于复杂数据类型，比如SQL Sever提供了可扩展性的支持，像xml类型的字段。很多用过的同学应该知道，该字段不管是查询还是更改，效率非常一般。主要原因是是DB层对xml字段很难建高效索引，应用层又要做从字符流到dom的解析转换。NoSQL以json方式存储，提供了原生态的支持，在效率方便远远高于传统关系型数据库。</p></blockquote></li><li><p>高并发数据库请求</p><blockquote><p>此类应用常见于web2.0的网站，很多应用对于数据一致性要求很低，而关系型数据库的事务以及大表join反而成了”性能杀手”。在高并发情况下，sql与no-sql的性能对比由于环境和角度不同一直是存在争议的，并不是说在任何场景，no-sql总是会比sql快。有篇article和大家分享下，<a href="http://artur.ejsmont.org/blog/content/insert-performance-comparison-of-nosql-vs-sql-servers" target="_blank" rel="noopener">http://artur.ejsmont.org/blog/content/insert-performance-comparison-of-nosql-vs-sql-servers</a></p></blockquote></li><li><p>海量数据的分布式存储</p><blockquote><p>海量数据的存储如果选用大型商用数据，如Oracle，那么整个解决方案的成本是非常高的，要花很多钱在软硬件上。NoSQL分布式存储，可以部署在廉价的硬件上，是一个性价比非常高的解决方案。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题（Medium）</title>
      <link href="/2018/12/05/LeetCode-2/"/>
      <url>/2018/12/05/LeetCode-2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode刷题"><a href="#LeetCode刷题" class="headerlink" title="LeetCode刷题"></a>LeetCode刷题</h2><h3 id="Type：Medium"><a href="#Type：Medium" class="headerlink" title="Type：Medium"></a>Type：Medium</h3><p><a href="https://leetcode-cn.com/problemset/all/" title="LeetCode" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a></p><h5 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="#8 字符串转换整数"></a>#8 字符串转换整数</h5><p>需要注意几个测试用例</p><pre><code>&quot;  +0 123&quot;&quot; 0012&quot;&quot;3.14&quot;</code></pre><p>先判断是否有正负号，然后循环数组，需要记得把 <code>Character.isDigit(sc[i])</code> 加在循环条件里，保证只有当下一个字符是数字的时候才会把数值加起来。</p><pre><code>class Solution {public int myAtoi(String str) {    boolean isPos = true;    char[] sc = (str.trim() + &quot; &quot;).toCharArray();    int i = 0;    if (sc[0] == &apos;-&apos;) {        isPos = false;        i++;    } else if (sc[0] == &apos;+&apos;) {        isPos = true;        i++;    }    long value = 0;    while (i &lt; sc.length &amp;&amp; Character.isDigit(sc[i])) {        value = value * 10 + (sc[i] - &apos;0&apos;);        i++;        if (value &gt; Integer.MAX_VALUE) {            return isPos ? Integer.MAX_VALUE : Integer.MIN_VALUE;        }    }    value = isPos ? value : -value;    return (int) value;}}</code></pre><h5 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="#15 三数之和"></a>#15 三数之和</h5><p>首先对原数组进行排序。<br>最先想到的是三重循环，优化：<br>要满足 a + b + c = 0 ，则 a 一定是非正数，即 i 对应的数一定要小于等于 0 的，等于0的时候 a b c 都为 0 。同时 i 的循环应该是从 0 到 length - 3 的，即 0 &lt;= i &lt; length - 2 , 因为 j 要大于 i ，同理 k 要大于 j 。  </p><p>实现如下：</p><pre><code>class Solution {public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    Arrays.sort(nums);    int v1;    int v2;    int v3;    for(int i = 0; i &lt; nums.length-1 &amp;&amp; nums[i] &lt;= 0; ++i){        v1 = nums[i];        int j = i + 1;        int k = nums.length - 1;        while(k &gt; j){            v2 = nums[j];            v3 = nums[k];            if(v1 + v2 + v3 &gt; 0){                k--;            }else if(v1 + v2 + v3 &lt; 0){                j++;            }            else if(v1 + v2 + v3 == 0){                List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();                tmp.add(v1);                tmp.add(v2);                tmp.add(v3);                if(!res.contains(tmp)){a                    res.add(tmp);                }                j++;                k--;            }        }    }    return res;}}</code></pre><p>上面这种写法虽然能满足题目，但是会超时，时间主要会消耗在 res.add() 之前的去重上。所以想通过 HashSet 来辅助去重（Hash表的查询时间O（1）因为查询的是每个元素的hashcode）。</p><blockquote><p>想要可以自动拓展的数组 =&gt; List<br>想要元素不重复的数组 =&gt; Set<br>set内部排序由每个元素的hashcode决定</p></blockquote><p>双重循环，v3 = -(v1 + v2) , 借助 HashMap 来判断原数组是否有 v3 这个值同时下标必须在 v2 之后，满足的话就可以放进 Set 中。</p><pre><code>class Solution {public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {    Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;();    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();    Arrays.sort(nums);    for(int i = 0;i &lt; nums.length;++i){        map.put(nums[i],i);    }    int v1;    int v2;    int v3;    for(int i = 0; i &lt; nums.length - 2 &amp;&amp; nums[i] &lt;= 0; ++i){        for(int j = i + 1; j &lt; nums.length - 1 &amp;&amp; j &gt; i; ++j){            v1 = nums[i];            v2 = nums[j];            v3 = -(v1 + v2);            if(map.containsKey(v3) &amp;&amp; map.get(v3) &gt; j){                res.add(Arrays.asList(v1,v2,v3));            }        }    }    return new ArrayList&lt;&gt;(res);}}</code></pre><h5 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="#701 二叉搜索树中的插入操作"></a>#701 二叉搜索树中的插入操作</h5><p>current 为当前结点，如果当前结点为 null ，那么就记录下 current 对应的 parent 结点，插入值小于 parent 结点的值，插入在左子树，反之插入在右子树</p><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {public TreeNode insertIntoBST(TreeNode root, int val) {    if(root == null){        root = new TreeNode(val);        return root;    }    boolean isLeft = false;    TreeNode current = root;    TreeNode parent = root;    while(current != null){        parent = current;        if(val &lt; current.val){            current = current.left;            isLeft = true;        }else{            current = current.right;            isLeft = false;        }    }    TreeNode vNode = new TreeNode(val);    if(isLeft == true){        parent.left = vNode;    }else{        parent.right = vNode;    }    return root;}}</code></pre><h5 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="#2 两数相加"></a>#2 两数相加</h5><p>不能将链表中的每个元素一次性全部取出然后相加，然后把计算后的数值每一位都插入到链表中，因为可能会超出int整数范围。所以只能同时遍历两个链表对每一个元素依次相加。<br>需要用到的是一个进位符号，如果当前位置加和大于等于10，进位置为1；还需要一个curNode，作为辅助指针，指向当前应该插入的位置。<br>需要注意的测试用例是：  </p><pre><code>[9],[9]</code></pre><p>输出的结果应该是[8,1]，首先当两数相加大于等于10的时候，sum应该等于对10取余。同时如果 l1 和 l2 如果都计算完了，但是进位标识是1的话还需要再添加一个元素进去。</p><pre><code>/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {public ListNode addTwoNumbers(ListNode l1, ListNode l2) {    int carry = 0; // 进位    ListNode head = new ListNode(0);    ListNode curNode = head; // 辅助指针    while(l1 != null || l2 != null){        int sum = tmp;        if(l1 != null){            sum += l1.val;        }        if(l2 != null){            sum += l2.val;        }        ListNode tmpNode;        if(sum &gt;= 10){            carry = 1;            tmpNode = new ListNode(sum % 10);        }else{            carry = 0;            tmpNode = new ListNode(sum);        }        curNode.next = tmpNode;        curNode = curNode.next;        if(l1 != null){            l1 = l1.next;        }        if(l2 != null){            l2 = l2.next;        }    }    if(carry == 1){        ListNode tmpNode = new ListNode(1);        curNode.next = tmpNode;    }    return head.next;}}</code></pre><h5 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="#120 三角形最小路径和"></a>#120 三角形最小路径和</h5><p>从最后一层往上计算，当前一层的值等于下一层相邻的两个数取最小再加上当前一层的数，不断网上，一直到第一层。<br>第一种方式：借助一个 n + 1 大小的数组，记录每一层的值，（最后一层是初始化的过程），然后输出数组第一个值就是最小路径和。</p><pre><code>class Solution {public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {    if(triangle == null || triangle.size() == 0){        return 0;    }    int[] res = new int[triangle.size()+1];    for(int i = triangle.size() - 1; i &gt;= 0; --i){        for(int j = 0; j &lt; triangle.get(i).size(); ++j){            res[j] = Math.min(res[j],res[j+1]) + triangle.get(i).get(j);        }    }    return res[0];}}</code></pre><p>第二种方式：从倒数第二层开始计算，计算出当前位置的最小值后，直接重新赋值，不需要新的空间</p><pre><code>class Solution {public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {    if(triangle == null || triangle.size() == 0){        return 0;    }    for(int i = triangle.size() - 2; i &gt;= 0; --i){        for(int j = 0; j &lt; triangle.get(i).size(); ++j){            Integer re = Math.min(triangle.get(i+1).get(j),triangle.get(i+1).get(j+1)) + triangle.get(i).get(j);            triangle.get(i).set(j,re);        }    }    return triangle.get(0).get(0);}}</code></pre><h5 id="220-存在重复元素Ⅲ"><a href="#220-存在重复元素Ⅲ" class="headerlink" title="#220 存在重复元素Ⅲ"></a>#220 存在重复元素Ⅲ</h5><p>跟 #217 #219 关联性不大，#217 是找到重复元素，#219是找到重复元素并且是在一定范围内。这道题是要保证在一定的范围内（k），两个值的差的绝对值要不大于某个数（t）。<br>前面的 #217 可以使用双重循环运行完所有的测试用例，但是 #220 使用双重循环就会超时，所以使用 treeset 来辅助计算，二叉树的插入、删除、搜索都是O（logN）。总的时间复杂度降为O（N * logN）。</p><p>修改前：</p><pre><code>class Solution {public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {    if(nums.length == 0 || k &lt;= 0)        return false;    for(int i = 0; i &lt; nums.length; ++i){        for(int j = i+1; j &lt;= i + k; ++j){            if(j &gt;= nums.length)                break;            long val = 0; // 用 long 是为了避免 int 超出范围            val = Math.abs((long)nums[i] - (long)nums[j]) &gt; val ? Math.abs((long)nums[i] - (long)nums[j]) : val;            if(val &lt;= t)                return true;        }    }    return false;}}</code></pre><p>修改后：</p><pre><code>class Solution {public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {    if(nums.length &lt; 2 || k &lt; 1 || t &lt; 0)        return false;    TreeSet &lt;Long&gt; set = new TreeSet&lt;Long&gt;();    for(int i = 0; i &lt; nums.length; ++i){        // set.subSet() 返回的类型是 SortedSet，返回值的范围是 [(long)nums[i]-t,(long)nums[i]+t+1))        SortedSet &lt;Long&gt; subSet = set.subSet((long)nums[i]-t,(long)nums[i]+t+1);        if(!subSet.isEmpty())            return true;        if(i &gt;= k)            set.remove((long)nums[i-k]);        set.add((long)nums[i]);    }    return false;}}</code></pre><h5 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="#881 救生艇"></a>#881 救生艇</h5><p>贪心（双指针）  </p><p>思路</p><p>如果最重的人可以与最轻的人共用一艘船，那么就这样安排。否则，最重的人无法与任何人配对，那么他们将自己独自乘一艘船。</p><p>这么做的原因是，如果最轻的人可以与任何人配对，那么他们也可以与最重的人配对。</p><p>算法</p><p>令 people[i] 指向当前最轻的人，而 people[j] 指向最重的那位。</p><p>然后，如上所述，如果最重的人可以与最轻的人共用一条船（即 people[j] + people[i] &lt;= limit），那么就这样做；否则，最重的人自己独自坐在船上</p><pre><code>class Solution {    public int numRescueBoats(int[] people, int limit) {        Arrays.sort(people);        int i = 0;        int j = people.length - 1;        int boat = 0;        while(i &lt;= j){            boat++;            if(people[i] + people[j] &lt;= limit){                i++;            }            j--;        }        return boat;    }}</code></pre><h5 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="#35 搜索插入位置"></a>#35 搜索插入位置</h5><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>二分查找</p><pre><code>class Solution {    public int searchInsert(int[] nums, int target) {        if(target &lt; nums[0]){            return 0;        }else if(target &gt; nums[nums.length - 1]){            return nums.length;        }else {            int low = 0;            int high = nums.length - 1;            while(low &lt;= high){                int mid = (low + high) / 2;                if(target &lt; nums[mid]){                    high = mid - 1;                }else if(target == nums[mid]){                    return mid;                }else {                    low = mid + 1;                }            }            return low;        }    }}</code></pre><h5 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="#74 搜索二维矩阵"></a>#74 搜索二维矩阵</h5><p>先查找符合的行，然后下标从 1 … matrix[0].length - 2 通过二分查找来查找元素</p><pre><code> class Solution {    public boolean searchMatrix(int[][] matrix, int target) {        if(matrix.length == 0 || matrix[0].length == 0){            return false;        }        int low = 0;        int high = matrix.length - 1;        while(low &lt;= high){            int mid = (low + high) / 2;            if(target &lt; matrix[mid][0]){                // 在 1 3 5 7 中查询                high = mid - 1;            }else if(target == matrix[mid][0] || target == matrix[mid][matrix[0].length - 1]){                return true;            }else if(target &gt; matrix[mid][matrix[0].length - 1]){                // 在 23 30 34 50 中查询                low = mid + 1;            }else {                // 在 10 11 16 20 中查询                int l = 1; // 已经排除 10 和 20 不可能了                int h = matrix[0].length - 2;                while(l &lt;= h){                    int m = (l + h) / 2;                    if(target &lt; matrix[mid][m]){                        h = m - 1;                    }else if(target == matrix[mid][m]){                        return true;                    }else {                        l = m + 1;                    }                }                // 缺少这个 return 的话，会一直死循环                return false;            }        }        return false;    }}</code></pre><h5 id="240-搜索二维矩阵Ⅱ"><a href="#240-搜索二维矩阵Ⅱ" class="headerlink" title="#240 搜索二维矩阵Ⅱ"></a>#240 搜索二维矩阵Ⅱ</h5><p>矩阵具有以下特性：<br>1.每行的元素从左到右升序排列。<br>2.每列的元素从上到下升序排列。</p><p>从左下或者右上开始判断都可以，按台阶形状进行判断</p><pre><code>class Solution {    public boolean searchMatrix(int[][] matrix, int target) {        if(matrix.length == 0 || matrix[0].length == 0){            return false;        }        // 从左下开始判断        // int i = matrix.length - 1;        // int j = 0;        // while(i &gt;= 0 &amp;&amp; j &lt; matrix[0].length){        //     if(matrix[i][j] == target){        //         return true;        //     }else if(matrix[i][j] &lt; target){        //         j = j + 1;        //     }else {        //         i = i - 1;        //     }        // }        // 从右上开始判断        int i = 0;        int j = matrix[0].length - 1;        while(i &lt; matrix.length &amp;&amp; j &gt;= 0){            if(matrix[i][j] == target){                return true;            }else if(matrix[i][j] &gt; target){                j = j - 1;            }else {                i = i + 1;            }        }        return false;    }}</code></pre><h5 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="#11 盛最多水的容器"></a>#11 盛最多水的容器</h5><p>Area = Max ( min ( height[i], height[j] ) * ( j-i ) ) { 其中 0 &lt;= i &lt; j &lt; height.size() }<br>使用两个指针，值小的指针向内移动，这样就减小了搜索空间。因为面积取决于指针的距离与值小的值乘积，如果值大的值向内移动，距离一定减小，而求面积的另外一个乘数一定小于等于值小的值，因此面积一定减小，而我们要求最大的面积，因此值大的指针不动，而值小的指针向内移动遍历。</p><pre><code>class Solution {    public int maxArea(int[] height) {        int i = 0;        int j = height.length - 1;        int area = 0;        while(i &lt; j){            int h = Math.min(height[i], height[j]);            area = Math.max(area, (j - i) * h);            if(h == height[i])                i++;            else                j--;        }        return area;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题（Easy）</title>
      <link href="/2018/12/05/LeetCode-1/"/>
      <url>/2018/12/05/LeetCode-1/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode刷题"><a href="#LeetCode刷题" class="headerlink" title="LeetCode刷题"></a>LeetCode刷题</h2><h3 id="Type：Easy"><a href="#Type：Easy" class="headerlink" title="Type：Easy"></a>Type：Easy</h3><p><a href="https://leetcode-cn.com/problemset/all/" title="LeetCode" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a></p><h5 id="7-整数翻转"><a href="#7-整数翻转" class="headerlink" title="#7 整数翻转"></a>#7 整数翻转</h5><p>注意int整数范围<br>-2147483638 ~  2147483637<br>在翻转计算之前需要判断翻转后是否会超出范围</p><pre><code>class Solution {public int reverse(int x) {    int res = 0;    while(x != 0){        int tmp = x % 10;        x = x / 10;        if((res &gt; Integer.MAX_VALUE / 10) || (res == Integer.MAX_VALUE/10 &amp;&amp; tmp &gt; 7)){            return 0;        }        if((res &lt; Integer.MIN_VALUE / 10) || (res == Integer.MIN_VALUE/10 &amp;&amp; tmp &lt; -8)){            return 0;        }        res = res * 10 + tmp;    }    return res;}}</code></pre><h5 id="9-回文数"><a href="#9-回文数" class="headerlink" title="#9 回文数"></a>#9 回文数</h5><p>如果整数是回文数，那么后一半一定等于前一半<br>取一半长度的数，判等即可，要注意奇数长度的数</p><pre><code>class Solution {public boolean isPalindrome(int x) {    if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0))        return false;    int reverse = 0;    while(x &gt; reverse){        int tmp = x % 10;        reverse = reverse * 10 + tmp;        x = x / 10;    }    if(x == reverse || x == reverse / 10)        return true;    else        return false;}}</code></pre><h5 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="#53 最大子序和"></a>#53 最大子序和</h5><p><a href="https://mxxt.github.io/2018/11/19/Algorithm-1/" title="最大子序和" target="_blank" rel="noopener">https://mxxt.github.io/2018/11/19/Algorithm-1/</a></p><h5 id="66-加一"><a href="#66-加一" class="headerlink" title="#66 加一"></a>#66 加一</h5><p>一开始想的是循环数组拼成整数，加1，然后再放进数组里，问题是，数组里每个下标元素只存储一个数字，数组是不会超出范围的，但是int是有上下限的，所以不能把它转出int加1<br>∴ 对数组从后先前循环，最后一位加1，如果等于10，就继续循环（即相当于进位1），如果小于10，就直接加1然后break循环</p><pre><code>class Solution {public int[] plusOne(int[] digits) {    int n = digits.length;    if(n == 0){        int[] res = new int[1];        res[0] = 0;        return res;    }    for(int i = n - 1; i &gt;= 0; --i){        if(digits[i] + 1 == 10){            digits[i] = 0;        }else{            digits[i]++;            break;        }    }    if(digits[0] == 0){        n++;        int[] res = new int[n];        res[0] = 1;        for(int i = 1; i &lt; n;i++){            res[i] = digits[i-1];        }        return res;    }else{        return digits;    }}}</code></pre><h5 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="#125 验证回文串"></a>#125 验证回文串</h5><p>针对几个测试用例去修改代码  </p><pre><code>&quot;a&quot;    true&quot;....a..&quot; true&quot;.&quot; true</code></pre><p>第一种方法：<br>先判断字符串有没有字母或数字，只要有一个即可，如果没有的话直接返回true（即为回文串）。再从前和从后同时循环，如果 i 位置不是字母或数字，i++同时continue直接继续进行循环，同理如果 j 位置不是字母或数字，j–同时continue直接继续进行循环。如果 i 和 j 位置都是字母或数字，比较两个位置的字符，不相等就返回false</p><pre><code>class Solution {public boolean isPalindrome(String s) {    String tmp = s.replace(&quot; &quot;,&quot;&quot;).toLowerCase();    if(tmp.length() == 0){        return true;    }    int i = 0;    int j = tmp.length() - 1;    boolean flag = false;    for(i = 0; i &lt;= j; ++i){        if(Character.isLetterOrDigit(tmp.charAt(i))){            flag = true;            break;        }    }    if(flag == false)        return true;    while(i &lt;= j){        if(!Character.isLetterOrDigit(tmp.charAt(i))){            i++;            continue;        }        if(!Character.isLetterOrDigit(tmp.charAt(j))){            j--;            continue;        }        if(tmp.charAt(i) != (tmp.charAt(j))){            return false;        }else{            i++;            j--;            flag = true;        }    }    return flag;}}</code></pre><p>第二种方法：<br>使用StringBuilder来帮助计算。从头循环字符串，如果 i 位置是字母或数字，就添加到StringBuilder中，最后判断StringBuilder.toString()和StringBuilder.reverse().toString()是否相等即可</p><pre><code>class Solution {public boolean isPalindrome(String s) {    s = s.toLowerCase();    int n = s.length();    if(n == 0){        return true;    }    StringBuilder tmp = new StringBuilder();    for(int i = 0; i &lt; n; ++i){        if(Character.isLetterOrDigit(s.charAt(i))){            tmp.append(s.charAt(i));        }    }    if(tmp.toString().equals(tmp.reverse().toString())){        return true;    }else{        return false;    }}}</code></pre><h5 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="#70 爬楼梯"></a>#70 爬楼梯</h5><p>仿Fibonacci数列，n = 1 时返回 1，n = 2 时返回 2，n = 3 时开始循环（<strong>不能用递归！</strong>递归会自动创建系统栈，对空间和时间都不友好，会超时）</p><pre><code>class Solution {public int climbStairs(int n) {    if(n == 1){        return 1;    }    if(n == 2){        return 2;    }    int sum = 0;    int s1 = 1;    int s2 = 2;    int step = 3;    while(step &lt;= n){        sum = s1 + s2;        s1 = s2;        s2 = sum;        ++step;    }    return sum;}}</code></pre><h5 id="263-丑数"><a href="#263-丑数" class="headerlink" title="#263 丑数"></a>#263 丑数</h5><p>对 num 不断用 2，3，5去除，如果余数最终只有 1，2，3，5 这四种情况是就返回true，说明没有别的因数（这个因数不能用 2，3，5 表示）</p><pre><code>class Solution {public boolean isUgly(int num) {    if(num &lt;= 0){        return false;    }    while(num % 2 == 0){        num /= 2;    }    while(num % 3 == 0){        num /= 3;    }    while(num % 5 == 0){        num /= 5;    }    return (num == 1 || num == 2 || num == 3 || num == 5);}}</code></pre><h5 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="#26 删除排序数组中的重复项"></a>#26 删除排序数组中的重复项</h5><p>用 i 来控制数组的长度，如果 j 找到下一个不同的数则记录到 i 里</p><pre><code>class Solution {public int removeDuplicates(int[] nums) {    if(nums.length == 0)        return 0;    int i = 0;    for(int j = 1; j &lt; nums.length; ++j){        if(nums[j] != nums[i]){            nums[i+1] = nums[j];            i++;        }    }    System.out.println(i+1);    return i+1;}}</code></pre><h5 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="#441 排列硬币"></a>#441 排列硬币</h5><p>求的是 1 + 2 + 3 + … + x  &lt; n 即<br>(1 + x) x &lt; 2n =&gt; x² + x - 2n &lt; 0<br>△x = b² - 4ac = 1 + 8n<br>x = (-b ± △x^½) / 2a =&gt; x = ((1 + 8n)^½ - 1) / 2<br>因为 n 可能会超出int范围，所以需要转换一下类型</p><pre><code>class Solution {    public int arrangeCoins(int n) {        return (int)(Math.sqrt(1 + 8 * (long)n) - 1) / 2;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树和堆（julyedu网课整理）</title>
      <link href="/2018/12/05/Algorithm-3/"/>
      <url>/2018/12/05/Algorithm-3/</url>
      
        <content type="html"><![CDATA[<h2 id="树和堆（julyedu网课整理）"><a href="#树和堆（julyedu网课整理）" class="headerlink" title="树和堆（julyedu网课整理）"></a>树和堆（julyedu网课整理）</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h3><h4 id="1-1-树的定义"><a href="#1-1-树的定义" class="headerlink" title="1.1 树的定义"></a>1.1 树的定义</h4><p>它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ol><li>每个节点有零个或多个子节点</li><li>没有父节点的节点称为根节点</li><li>每一个非根节点有且只有一个父节点</li><li>除了根节点外，每个子节点可以分为多个不相交的子树</li></ol><h4 id="1-2-堆的定义"><a href="#1-2-堆的定义" class="headerlink" title="1.2 堆的定义"></a>1.2 堆的定义</h4><p>堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质：</p><ol><li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</li><li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li><li>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</li></ol><h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2 基本操作"></a>2 基本操作</h3><h4 id="2-1-树的基本操作"><a href="#2-1-树的基本操作" class="headerlink" title="2.1 树的基本操作"></a>2.1 树的基本操作</h4><ol><li>遍历：前中后序遍历；层次遍历</li><li>序列化与反序列化</li><li>深度：最大深度，最小深度。</li></ol><h4 id="2-2-堆的基本操作"><a href="#2-2-堆的基本操作" class="headerlink" title="2.2 堆的基本操作"></a>2.2 堆的基本操作</h4><ol><li>插入元素，调整新元素使之满足堆条件。</li><li>删除元素，调整新元素使之满足堆条件。</li></ol><h3 id="3-树和堆的应用场景"><a href="#3-树和堆的应用场景" class="headerlink" title="3 树和堆的应用场景"></a>3 树和堆的应用场景</h3><ol><li>C++ STL的set与map（红黑树）</li><li>数据库索引（B+树）</li><li>优先队列（堆）</li><li>语法树</li><li>决策树</li><li>游戏场景管理（八叉树或BSP树）</li></ol><h3 id="4-树和堆相关算法"><a href="#4-树和堆相关算法" class="headerlink" title="4 树和堆相关算法"></a>4 树和堆相关算法</h3><ol><li>递归</li><li>分治</li><li>深度优先搜索</li><li>广度优先搜索</li></ol><h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5 例题"></a>5 例题</h3><p><strong>求公共最近的父节点</strong>：给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p><p><img src="https://i.imgur.com/3uOqnT5.png" alt></p><p>对于上面例子：LCA(3, 5) = 4; LCA(6, 7) = 7</p><h4 id="5-1-思路"><a href="#5-1-思路" class="headerlink" title="5.1 思路"></a>5.1 思路</h4><ol><li><p>如果以LCA为根节点，那么A、B必定分别位于该节点的左右子树。</p></li><li><p>如果不满足条件1，A、B都位于LCA的左子树，那么显然LCA左子树上的节点应该成为LCA。</p><p>==&gt; ∴ 从根节点开始，对于根节点的左右子树结点都进行如下循环：找左子树，如果存在A或B返回left（值等于结点值）；找右子树，如果存在A或B返回right（值等于结点值）。如果对于某一个结点，left和right都是有值的，那么就返回这个结点。</p></li></ol><h4 id="5-2-Demo"><a href="#5-2-Demo" class="headerlink" title="5.2 Demo"></a>5.2 Demo</h4><pre><code>TreeNode lowestCommonAncestor(TreeNode root, TreeNode A, TreeNode B) {    // write your code here    if(root ==  null || root == A || root == B){        return root;    }    TreeNode left = lowestCommonAncestor(root.left, A, B);    TreeNode right = lowestCommonAncestor(root.right, A, B);    if(left &amp;&amp; right){        return root;            }else{        left ? return left : return right;    }}  </code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> julyedu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> julyedu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构实现之单向循环链表</title>
      <link href="/2018/11/27/Algorithm-7/"/>
      <url>/2018/11/27/Algorithm-7/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构实现之单向循环链表"><a href="#数据结构实现之单向循环链表" class="headerlink" title="数据结构实现之单向循环链表"></a>数据结构实现之单向循环链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Copyright (C), 2015-2018, XXX有限公司</span><br><span class="line"> * FileName: CircleLinkedList</span><br><span class="line"> * Author:   猫熊小才天</span><br><span class="line"> * Date:     2018/11/26 17:06</span><br><span class="line"> * Description: 单向循环链表</span><br><span class="line"> * History:</span><br><span class="line"> * &lt;author&gt;          &lt;time&gt;          &lt;version&gt;          &lt;desc&gt;</span><br><span class="line"> * 作者姓名           修改时间           版本号              描述</span><br><span class="line"> */</span><br><span class="line">package main.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 〈一句话功能简述〉&lt;br&gt;</span><br><span class="line"> * 〈单向循环链表〉</span><br><span class="line"> * 在循环的时候不能使用如下方法：</span><br><span class="line"> * Node tmp = head;</span><br><span class="line"> * while(tmp.next != null)&#123;</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> * 会出现死循环，换成</span><br><span class="line"> * for(int i = 1; i &lt;= getSize(); ++i)</span><br><span class="line"> * @author 猫熊小才天</span><br><span class="line"> * @create 2018/11/26</span><br><span class="line"> * @since 1.0.0</span><br><span class="line"> */</span><br><span class="line">public class CircleLinkedList &#123;</span><br><span class="line"></span><br><span class="line">private class Node &#123;</span><br><span class="line">int data; // 结点中的数据</span><br><span class="line">Node next = null; // 下一个结点的地址信息</span><br><span class="line"></span><br><span class="line">public Node(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Node() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node head = null; // 保存头结点</span><br><span class="line">private Node tail = null; // 保存尾节点</span><br><span class="line">private int size; // 保存已有的的结点数</span><br><span class="line"></span><br><span class="line">public CircleLinkedList() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 头插法</span><br><span class="line"> * </span><br><span class="line"> * @param data</span><br><span class="line"> */</span><br><span class="line">public void headAdd(int data) &#123;</span><br><span class="line">// 如果链表为空</span><br><span class="line">if (isEmpty()) &#123;</span><br><span class="line">head = new Node(data);</span><br><span class="line">head.next = head;</span><br><span class="line">tail = head;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">Node newNode = new Node(data);</span><br><span class="line">           // 让新结点指向head</span><br><span class="line">newNode.next = head;</span><br><span class="line">           // 然后让新结点作为head</span><br><span class="line">head = newNode;</span><br><span class="line">           // 将尾结点指向头结点</span><br><span class="line">tail.next = head;</span><br><span class="line">&#125;</span><br><span class="line">++size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 尾插法</span><br><span class="line"> * </span><br><span class="line"> * @param data</span><br><span class="line"> */</span><br><span class="line">public void tailAdd(int data) &#123;</span><br><span class="line">// 如果链表为空</span><br><span class="line">if (isEmpty()) &#123;</span><br><span class="line">head = new Node(data);</span><br><span class="line">head.next = head;</span><br><span class="line">tail = head;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    Node newNode = new Node(data);</span><br><span class="line">    // 让尾结点指向新结点</span><br><span class="line">    tail.next = newNode;</span><br><span class="line">    // 让新结点指向头结点</span><br><span class="line">    newNode.next = head;</span><br><span class="line">    // 将新结点作为尾结点</span><br><span class="line">    tail = newNode;</span><br><span class="line">       &#125;</span><br><span class="line">       ++size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 删除第index个结点</span><br><span class="line">    * @param index</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public boolean deleteNodeByIndex(int index) &#123;</span><br><span class="line">       boolean res = false;</span><br><span class="line">       if (isEmpty()) &#123;</span><br><span class="line">           System.out.println(&quot;单向循环链表为空&quot;);</span><br><span class="line">           res = false;</span><br><span class="line">       &#125;</span><br><span class="line">       /**</span><br><span class="line">        * 如果输入的下标超过单向循环链表的范围</span><br><span class="line">        */</span><br><span class="line">       if (index &lt; 1 || index &gt; getSize()) &#123;</span><br><span class="line">           System.out.println(&quot;输入下标不在单向循环链表的范围中&quot;);</span><br><span class="line">           res = false;</span><br><span class="line">       &#125;else if(index == 1)&#123;</span><br><span class="line">           // 删除头结点</span><br><span class="line">           Node tmp = new Node(head.next.data);</span><br><span class="line">           // 让tmp等于head的下一个结点</span><br><span class="line">           tmp.next = head.next.next;</span><br><span class="line">           // 将tmp赋值给head，即相当于删除了原先的head</span><br><span class="line">           head = tmp;</span><br><span class="line">           // 尾结点指向新的头结点</span><br><span class="line">           tail.next = head;</span><br><span class="line">           System.out.println(&quot;删除头结点成功&quot;);</span><br><span class="line">           res = true;</span><br><span class="line">       &#125;else if(index == getSize())&#123;</span><br><span class="line">           // 删除尾结点</span><br><span class="line">           // 获取倒数第二个结点</span><br><span class="line">           Node tmp = getDataByIndex(getSize() - 1);</span><br><span class="line">           // 让倒数第二个结点指向head</span><br><span class="line">           tmp.next = head;</span><br><span class="line">           // tmp赋值到新的尾结点</span><br><span class="line">           tail = tmp;</span><br><span class="line">           System.out.println(&quot;删除尾结点成功&quot;);</span><br><span class="line">           res = true;</span><br><span class="line">       &#125;else if(index &gt; 1 &amp;&amp; index &lt; getSize())&#123;</span><br><span class="line">           // 删除的是中间任一结点</span><br><span class="line">           // 获取第 index - 1 个结点</span><br><span class="line">           Node prev = getDataByIndex(index - 1);</span><br><span class="line">           // 需要删除的结点即第index-1个结点的next</span><br><span class="line">           Node cur = prev.next;</span><br><span class="line">           prev.next = cur.next;</span><br><span class="line">           System.out.println(&quot;删除第&quot; + index + &quot;个结点成功&quot;);</span><br><span class="line">           res = true;</span><br><span class="line">       &#125;</span><br><span class="line">       --size;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 删除单向循环链表中数据为data的所有结点</span><br><span class="line">    * @param data</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public boolean deleteNodeByData(int data) &#123;</span><br><span class="line">       if (isEmpty()) &#123;</span><br><span class="line">           System.out.println(&quot;单向循环链表为空&quot;);</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       boolean res = false;</span><br><span class="line">       int count = 0;</span><br><span class="line">       // 先循环将头结点删除，直到头结点中的data≠data</span><br><span class="line">       Node tmp = head;</span><br><span class="line">       for(int i = 1; i &lt;= getSize(); ++i)&#123;</span><br><span class="line">           if(tmp.data == data)&#123;</span><br><span class="line">               tmp = tmp.next;</span><br><span class="line">               head = tmp;</span><br><span class="line">               tail = head;</span><br><span class="line">               ++count;</span><br><span class="line">               --size; // 需要将size减少！！！</span><br><span class="line">               res = true;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 再循环将尾结点删除，直到尾结点中的data≠data</span><br><span class="line">       Node tmp2 = tail;</span><br><span class="line">       for(int i = 1; i &lt;= getSize(); ++i)&#123;</span><br><span class="line">           if(tmp.data == data)&#123;</span><br><span class="line">               tmp = getDataByIndex(getSize() - 1);</span><br><span class="line">               tmp.next = head;</span><br><span class="line">               tail = tmp;</span><br><span class="line">               ++count;</span><br><span class="line">               --size;</span><br><span class="line">               res = true;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node preNode = head;</span><br><span class="line">       Node curNode = head.next;</span><br><span class="line">       for(int i = 1; i &lt;= getSize(); ++i)&#123;</span><br><span class="line">           if(curNode.data == data)&#123;</span><br><span class="line">               preNode.next = curNode.next;</span><br><span class="line">               ++count;</span><br><span class="line">               --size;</span><br><span class="line">               res = true;</span><br><span class="line">           &#125;</span><br><span class="line">           preNode = curNode;</span><br><span class="line">           curNode = curNode.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(res == true)&#123;</span><br><span class="line">           System.out.println(&quot;共删除了&quot; + count + &quot;个结点&quot;);</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           System.out.println(&quot;删除失败&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 获取index位置下的Node数据</span><br><span class="line">    * @param index</span><br><span class="line">    */</span><br><span class="line">   public Node getDataByIndex(int index)&#123;</span><br><span class="line">       if (isEmpty()) &#123;</span><br><span class="line">           System.out.println(&quot;单向循环链表为空&quot;);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;else if(index &lt; 1 || index &gt; getSize())&#123;</span><br><span class="line">           System.out.println(&quot;输入下标不在单向循环链表的范围中&quot;);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           Node res = head;</span><br><span class="line">           for(int i = 1; i &lt;= getSize() &amp;&amp; res.next != null; ++i)&#123;</span><br><span class="line">               if(i == index)&#123;</span><br><span class="line">                   System.out.println(&quot;第&quot; + index + &quot;个结点的数据是：&quot; + res.data);</span><br><span class="line">                   return res;</span><br><span class="line">               &#125;</span><br><span class="line">               res = res.next;</span><br><span class="line">           &#125;</span><br><span class="line">           return res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断链表是否为空</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return size == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回链表长度</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 清空线性表</span><br><span class="line"> */</span><br><span class="line">public void clear() &#123;</span><br><span class="line">// 将头结点和尾结点设为空</span><br><span class="line">head = null;</span><br><span class="line">tail = null;</span><br><span class="line">size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 打印单向链表 如果传过来的参数head是list.reHead即为逆向输出</span><br><span class="line"> * </span><br><span class="line"> * @param head</span><br><span class="line"> */</span><br><span class="line">public void printCircleLinkedList(Node head) &#123;</span><br><span class="line">Node tmp = head;</span><br><span class="line">for(int i = 1; i &lt;= getSize(); ++i)&#123;</span><br><span class="line">           System.out.print(tmp.data);</span><br><span class="line">           tmp = tmp.next;</span><br><span class="line">           if (i != getSize()) &#123;</span><br><span class="line">               System.out.print(&quot; -&gt; &quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       CircleLinkedList list = new CircleLinkedList();</span><br><span class="line">       list.tailAdd(5);</span><br><span class="line">       list.tailAdd(2);</span><br><span class="line">       list.tailAdd(4);</span><br><span class="line">       list.tailAdd(1);</span><br><span class="line">       list.tailAdd(5);</span><br><span class="line">       list.tailAdd(3);</span><br><span class="line">       list.tailAdd(5);</span><br><span class="line">       list.printCircleLinkedList(list.head);</span><br><span class="line"></span><br><span class="line">       /*list.deleteNodeByIndex(3);</span><br><span class="line">       list.printCircleLinkedList(list.head);*/</span><br><span class="line"></span><br><span class="line">       //list.getDataByIndex(6);</span><br><span class="line"></span><br><span class="line">       /*list.deleteNodeByData(5);</span><br><span class="line">       list.printCircleLinkedList(list.head);*/</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">5 -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 3 -&gt; 5</span><br><span class="line">第2个结点的数据是：2</span><br><span class="line">删除第3个结点成功</span><br><span class="line">5 -&gt; 2 -&gt; 1 -&gt; 5 -&gt; 3 -&gt; 5</span><br><span class="line"></span><br><span class="line">5 -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 3 -&gt; 5</span><br><span class="line">删除头结点成功</span><br><span class="line">2 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 3 -&gt; 5</span><br><span class="line"></span><br><span class="line">5 -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 3 -&gt; 5</span><br><span class="line">第5个结点的数据是：5</span><br><span class="line">删除第6个结点成功</span><br><span class="line">5 -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 5</span><br><span class="line"></span><br><span class="line">5 -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 3 -&gt; 5</span><br><span class="line">第4个结点的数据是：1</span><br><span class="line"></span><br><span class="line">5 -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 3 -&gt; 5</span><br><span class="line">共删除了3个结点</span><br><span class="line">2 -&gt; 4 -&gt; 1 -&gt; 3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> CircleLinkedList </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> CircleLinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构实现之单向链表</title>
      <link href="/2018/11/26/Algorithm-6/"/>
      <url>/2018/11/26/Algorithm-6/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构实现之单向链表"><a href="#数据结构实现之单向链表" class="headerlink" title="数据结构实现之单向链表"></a>数据结构实现之单向链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Copyright (C), 2015-2018, XXX有限公司</span><br><span class="line"> * FileName: LinkedList</span><br><span class="line"> * Author:   猫熊小才天</span><br><span class="line"> * Date:     2018/11/26 10:43</span><br><span class="line"> * Description: 单向链表</span><br><span class="line"> * History:</span><br><span class="line"> * &lt;author&gt;          &lt;time&gt;          &lt;version&gt;          &lt;desc&gt;</span><br><span class="line"> * 作者姓名           修改时间           版本号              描述</span><br><span class="line"> */</span><br><span class="line">package main.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 〈一句话功能简述〉&lt;br&gt; </span><br><span class="line"> * 〈单向链表〉</span><br><span class="line"> *</span><br><span class="line"> * @author 猫熊小才天</span><br><span class="line"> * @create 2018/11/26</span><br><span class="line"> * @since 1.0.0</span><br><span class="line"> */</span><br><span class="line">public class LinkedList &#123;</span><br><span class="line"></span><br><span class="line">   private Node head = null;</span><br><span class="line"></span><br><span class="line">   /***</span><br><span class="line">    * data 存放数据</span><br><span class="line">    * next 存放下一个结点</span><br><span class="line">    */</span><br><span class="line">   private class Node &#123;</span><br><span class="line">       int data; // 结点中的数据</span><br><span class="line">       Node next = null; // 下一个结点的地址信息</span><br><span class="line"></span><br><span class="line">       public Node(int data)&#123;</span><br><span class="line">           this.data = data;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public Node() &#123;</span><br><span class="line">           super();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">    * 插入新的结点（尾插法）</span><br><span class="line">    * 头插法：</span><br><span class="line">    * Node newNode = new Node(d);</span><br><span class="line">    * newNode.next = head;</span><br><span class="line">    * head = newNode;</span><br><span class="line">    * @param data</span><br><span class="line">    */</span><br><span class="line">   public void addNode(int data)&#123;</span><br><span class="line">       Node newNode = new Node(data); // 初始化一个结点</span><br><span class="line">       if(head == null)&#123;</span><br><span class="line">           head = newNode;</span><br><span class="line">           return;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           Node tmp = head;</span><br><span class="line">           while(tmp.next != null)&#123;</span><br><span class="line">               tmp = tmp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           tmp.next = newNode;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 删除第index个结点</span><br><span class="line">    * @param index</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public boolean deleteNodeByIndex(int index)&#123;</span><br><span class="line">       /**</span><br><span class="line">        * 如果输入的下标超过单向链表的范围</span><br><span class="line">        */</span><br><span class="line">       if(index &lt; 1 || index &gt; length())&#123;</span><br><span class="line">           System.out.println(&quot;输入下标不在单向链表的范围中&quot;);</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * index == 1，即删除第一个，将head往后移</span><br><span class="line">        */</span><br><span class="line">       if(index == 1)&#123;</span><br><span class="line">           head = head.next;</span><br><span class="line">           System.out.println(&quot;删除头结点成功&quot;);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int i = 2; // 比较下标，head下标为1，所以从2开始判断</span><br><span class="line">       Node preNode = head;</span><br><span class="line">       Node curNode = head.next;</span><br><span class="line">       while(curNode != null)&#123;</span><br><span class="line">           if(index == i)&#123;</span><br><span class="line">               preNode.next = curNode.next;</span><br><span class="line">               System.out.println(&quot;删除第&quot; + index + &quot;个结点成功&quot;);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           preNode = curNode;</span><br><span class="line">           curNode = curNode.next;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(&quot;删除失败&quot;);</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 返回单向链表的长度</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public int length()&#123;</span><br><span class="line">       int len = 0;</span><br><span class="line">       Node tmp = head;</span><br><span class="line">       while(tmp != null)&#123;</span><br><span class="line">           ++len;</span><br><span class="line">           tmp = tmp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return len;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 删除单向链表中数据为data的所有结点</span><br><span class="line">    * @param data</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public boolean deleteNodeByData(int data)&#123;</span><br><span class="line">       if(head == null)&#123;</span><br><span class="line">           System.out.println(&quot;单向链表为空&quot;);</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       boolean flag = false;</span><br><span class="line">       int count = 0;</span><br><span class="line">       // 先循环将头结点删除，直到头结点中的data≠data</span><br><span class="line">       Node tmp = head;</span><br><span class="line">       while(tmp != null)&#123;</span><br><span class="line">           if(tmp.data == data)&#123;</span><br><span class="line">               tmp = tmp.next;</span><br><span class="line">               head = tmp;</span><br><span class="line">               ++count;</span><br><span class="line">               flag = true;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       Node preNode = head;</span><br><span class="line">       Node curNode = head.next;</span><br><span class="line">       while(curNode != null)&#123;</span><br><span class="line">           if(curNode.data == data)&#123;</span><br><span class="line">               preNode.next = curNode.next;</span><br><span class="line">               flag = true;</span><br><span class="line">               ++count;</span><br><span class="line">           &#125;</span><br><span class="line">           preNode = curNode;</span><br><span class="line">           curNode = curNode.next;</span><br><span class="line">       &#125;</span><br><span class="line">       if(flag == true)&#123;</span><br><span class="line">           System.out.println(&quot;共删除了&quot; + count + &quot;个结点&quot;);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           System.out.println(&quot;删除失败&quot;);</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 获取所有符合data数据的结点的下标</span><br><span class="line">    * @param data</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public String getDataIndex(int data)&#123;</span><br><span class="line">       String indexStr = &quot;&quot;;</span><br><span class="line">       if(head == null)&#123;</span><br><span class="line">           System.out.println(&quot;单向链表为空&quot;);</span><br><span class="line">           return indexStr + &quot;查无此数据&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       int idx = 1;</span><br><span class="line">       Node tmp = head;</span><br><span class="line">       while(tmp != null)&#123;</span><br><span class="line">           if(tmp.data == data)&#123;</span><br><span class="line">               indexStr = indexStr + idx + &quot;,&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">           ++idx;</span><br><span class="line">           tmp = tmp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       if(indexStr.equals(&quot;&quot;))&#123;</span><br><span class="line">           indexStr = &quot;查无此数据&quot;;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           indexStr = &quot;符合查询数据的结点下标是：&quot; + indexStr.substring(0,indexStr.length() - 1);</span><br><span class="line">       &#125;</span><br><span class="line">       return indexStr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 打印单向链表</span><br><span class="line">    * 如果传过来的参数head是list.reHead即为逆向输出</span><br><span class="line">    * @param head</span><br><span class="line">    */</span><br><span class="line">   public void printLinkedList(Node head) &#123;</span><br><span class="line">       Node tmp = head;</span><br><span class="line">       while (tmp != null) &#123;</span><br><span class="line">           System.out.print(tmp.data);</span><br><span class="line">           tmp = tmp.next;</span><br><span class="line">           if(tmp != null)&#123;</span><br><span class="line">               System.out.print(&quot; -&gt; &quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 非递归方式反转单向链表</span><br><span class="line">    */</span><br><span class="line">   public void reverseList()&#123;</span><br><span class="line">       if (head == null)</span><br><span class="line">           return;</span><br><span class="line">       Node pre = head; // 上一结点</span><br><span class="line">       Node cur = head.next; // 当前结点</span><br><span class="line">       Node tmp = null; // 临时结点，用于保存当前结点的指针域（即下一结点）</span><br><span class="line">       while(cur != null)&#123; // 当前结点为null，说明位于尾结点</span><br><span class="line">           tmp = cur.next;</span><br><span class="line">           cur.next = pre; // 反转指针指向</span><br><span class="line"></span><br><span class="line">           // 指针向下移动</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">       // 最后将原链表的头节点的指针域置为null，还回新链表的头结点，即原链表的尾结点</span><br><span class="line">       head.next = null;</span><br><span class="line">       reHead = pre;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 采用递归方式逆向输出单向链表</span><br><span class="line">    * @param head</span><br><span class="line">    */</span><br><span class="line">   public void printReverse(Node head)&#123;</span><br><span class="line">       if(head != null)&#123;</span><br><span class="line">           printReverse(head.next);</span><br><span class="line">           System.out.println(head.data + &quot; &quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       LinkedList list = new LinkedList();</span><br><span class="line">       list.addNode(5);</span><br><span class="line">       list.addNode(3);</span><br><span class="line">       list.addNode(1);</span><br><span class="line">       list.addNode(5);</span><br><span class="line">       list.addNode(2);</span><br><span class="line">       list.addNode(55);</span><br><span class="line">       list.addNode(36);</span><br><span class="line">       list.addNode(5);</span><br><span class="line"></span><br><span class="line">       /*System.out.println(&quot;单向链表的长度为：&quot; + list.length());</span><br><span class="line">       System.out.println(&quot;打印单向链表：&quot;);</span><br><span class="line">       list.printLinkedList(list.head);*/</span><br><span class="line"></span><br><span class="line">       /*list.deleteNodeByIndex(2);</span><br><span class="line">       System.out.println(&quot;单向链表的长度为：&quot; + list.length());</span><br><span class="line">       System.out.println(&quot;打印单向链表：&quot;);</span><br><span class="line">       list.printLinkedList(list.head);*/</span><br><span class="line"></span><br><span class="line">       /*list.deleteNodeByData(5);</span><br><span class="line">       System.out.println(&quot;单向链表的长度为：&quot; + list.length());</span><br><span class="line">       System.out.println(&quot;打印单向链表：&quot;);</span><br><span class="line">       list.printLinkedList(list.head);*/</span><br><span class="line"></span><br><span class="line">       /*System.out.println(list.getDataIndex(5));*/</span><br><span class="line"></span><br><span class="line">       list.printLinkedList(list.head);</span><br><span class="line">       list.reverseList();</span><br><span class="line">       list.printLinkedList(list.reHead);</span><br><span class="line"></span><br><span class="line">       // list.printReverse(list.head);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">单向链表的长度为：8</span><br><span class="line">打印单向链表：</span><br><span class="line">5 -&gt; 3 -&gt; 1 -&gt; 5 -&gt; 2 -&gt; 55 -&gt; 36 -&gt; 5</span><br><span class="line"></span><br><span class="line">删除第2个结点成功</span><br><span class="line">单向链表的长度为：7</span><br><span class="line">打印单向链表：</span><br><span class="line">5 -&gt; 1 -&gt; 5 -&gt; 2 -&gt; 55 -&gt; 36 -&gt; 5</span><br><span class="line"></span><br><span class="line">共删除了3个结点</span><br><span class="line">单向链表的长度为：4</span><br><span class="line">打印单向链表：</span><br><span class="line">1 -&gt; 2 -&gt; 55 -&gt; 36</span><br><span class="line"></span><br><span class="line">单向链表的长度为：8</span><br><span class="line">打印单向链表：</span><br><span class="line">5 -&gt; 3 -&gt; 1 -&gt; 5 -&gt; 2 -&gt; 55 -&gt; 36 -&gt; 5</span><br><span class="line">符合查询数据的结点下标是：1,4,8</span><br><span class="line"></span><br><span class="line">5 -&gt; 3 -&gt; 1 -&gt; 5 -&gt; 2 -&gt; 55 -&gt; 36 -&gt; 15</span><br><span class="line">15 -&gt; 36 -&gt; 55 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 3 -&gt; 5</span><br><span class="line"></span><br><span class="line">15 36 55 2 5 1 3 5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> LinkedList </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈&amp;队列&amp;并查集&amp;哈希表（julyedu网课整理）</title>
      <link href="/2018/11/25/Algorithm-2/"/>
      <url>/2018/11/25/Algorithm-2/</url>
      
        <content type="html"><![CDATA[<h2 id="栈-amp-队列-amp-并查集-amp-哈希表（julyedu网课整理）"><a href="#栈-amp-队列-amp-并查集-amp-哈希表（julyedu网课整理）" class="headerlink" title="栈&amp;队列&amp;并查集&amp;哈希表（julyedu网课整理）"></a>栈&amp;队列&amp;并查集&amp;哈希表（julyedu网课整理）</h2><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>存放数据的线性表</li><li>操作：入栈/队列、出栈/队列、判断满/空</li><li>空间复杂度：O(n)</li><li>单次操作时间复杂度：O(1)</li><li>区别<ul><li>先进后出（FILO, First In Last Out）</li><li>先进先出（FIFO, First In First Out）</li></ul></li></ul><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h4><ul><li>数组和链表皆可（线性表）</li><li>指针（辅助变量）<ul><li>栈顶/底指针</li><li>队头/尾指针</li></ul></li><li>关键：出入元素的同时移动指针<ul><li>队列的头/尾指针都要改变</li><li>栈只有栈顶指针改变，栈底指针不变</li></ul></li></ul><h4 id="3-栈的应用：括号匹配检测"><a href="#3-栈的应用：括号匹配检测" class="headerlink" title="3.栈的应用：括号匹配检测"></a>3.栈的应用：括号匹配检测</h4><ul><li>括号、引号等符号是成对出现的，必须相互匹配</li><li>设计一个算法，自动检测输入的字符串中的括号是否匹配</li><li>比如：</li><li>{}[([][])]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配</li><li>[(])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不匹配</li><li>(()]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不匹配    </li></ul><p>思路：<br>从左到右扫描字符串，当入栈一个 ‘[‘ 时就期待一个 ‘]’ ，当且仅当入栈一个 ‘[‘ 后紧跟着一个 ‘] ‘时， ‘[‘ 出栈。  </p><p>leetcode #394</p><h4 id="4-栈的应用：模拟系统栈"><a href="#4-栈的应用：模拟系统栈" class="headerlink" title="4.栈的应用：模拟系统栈"></a>4.栈的应用：模拟系统栈</h4><pre><code>int F(int n) {    if (n &lt;= 1)        return 1;    return n * F(n – 1);}递归，时间空间复杂度O(n)</code></pre><p><strong>生产上应谨慎使用递归，多个项目运行时可能造成栈溢出</strong><br>原因：每一次递归都要记录上一次的地址，以及下一次的结果，不断递归下去，就会不断增加栈的压力  </p><p>模拟系统栈：</p><pre><code>do {    if (!back) { // back是边界判断        if (n &lt;= 1) {            back = true;            ret = 1;            continue;        }           n进栈;            --n;    ｝else｛        ret *= 出栈；    ｝} while (栈不为空);</code></pre><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>存放数据的集合关系，如｛1，2｝｛3，4｝｛5｝</li><li>支持操作<ul><li>建立新集合</li><li>查找某个元素属于哪个集合</li><li>合并两个集合</li></ul></li><li>均摊时间复杂度近似O(1)</li></ul><h4 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h4><ul><li>假设n个节点，初始时点与点之间没有连接</li><li>给出一系列的连接操作</li><li>一次连接操作不产生环，则接受，否则被抛弃</li></ul><h3 id="哈希表（散列表）"><a href="#哈希表（散列表）" class="headerlink" title="哈希表（散列表）"></a>哈希表（散列表）</h3><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>根据关键码值(Key，Value)而直接进行访问的数据结构</li><li>操作：根据（Key, Value）进行<ul><li>插入，查找，删除（可以没有）</li></ul></li><li>空间复杂度：O(n)</li><li>单次操作时间复杂度：O(1)</li><li>本质：Key的索引</li></ul><h4 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2.实现"></a>2.实现</h4><p>就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。<br>而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位</p><h4 id="3-例题：Top-K"><a href="#3-例题：Top-K" class="headerlink" title="3.例题：Top K"></a>3.例题：Top K</h4><blockquote><p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。<br>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p></blockquote><p>一共分为两个步骤，第一个是需要先统计出每个Query的次数，第二个是根据统计结果，找出Top K</p><h5 id="3-1-统计"><a href="#3-1-统计" class="headerlink" title="3.1 统计"></a>3.1 统计</h5><h6 id="3-1-1-归并排序"><a href="#3-1-1-归并排序" class="headerlink" title="3.1.1 归并排序"></a>3.1.1 归并排序</h6><p>归并排序和快速排序的期望时间复杂度O(nlogn)<br>遍历的时间复杂度O(n)<br>∴总体的时间复杂度是O(n)+O(nlogn) = O(nlogn)</p><h6 id="3-1-2-HashTable"><a href="#3-1-2-HashTable" class="headerlink" title="3.1.2 HashTable"></a>3.1.2 HashTable</h6><p>HashTable的查询速度非常的快，几乎是O(1)的时间复杂度。<br>维护一个Key为Query字串，Value为该Query出现次数的HashTable，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。<br>最终我们在O(N)的时间复杂度内完成了对该海量数据的处理。</p><h5 id="3-2-找出Top-K"><a href="#3-2-找出Top-K" class="headerlink" title="3.2 找出Top K"></a>3.2 找出Top K</h5><h6 id="3-2-1-直接排序"><a href="#3-2-1-直接排序" class="headerlink" title="3.2.1 直接排序"></a>3.2.1 直接排序</h6><p>三百万数据，每条记录是255Byte，大约0.712G，所以1G内存可以存下</p><h6 id="3-2-2-部分排序"><a href="#3-2-2-部分排序" class="headerlink" title="3.2.2 部分排序"></a>3.2.2 部分排序</h6><p>题目要求是求出Top 10，因此我们没有必要对所有的Query都进行排序，我们只需要维护一个10个大小的数组，初始化放入10个Query，按照每个Query的统计次数由大到小排序，然后遍历这300万条记录，每读一条记录就和数组最后一个Query对比，如果小于这个Query，那么继续遍历，否则，将数组中最后一条数据淘汰，加入当前的Query。最后当所有的数据都遍历完毕之后，那么这个数组中的10个Query便是我们要找的Top10了。<br>不难分析出，这样，算法的最坏时间复杂度是O(N*K)， 其中K是指top多少。</p><p>####### 3.2.3 最小堆<br><strong>求最大的K个数–最小堆–堆顶放的是K个数里最小的那一个<br>求最小的K个数–最大堆–堆顶放的是K个数里最大的那一个</strong>  </p><blockquote><p>具体过程是，堆顶存放的是整个堆中最小的数，现在遍历N个数，把<strong>最先遍历到的k个数</strong>存放到最小堆中，并假设它们就是我们要找的最大的k个数，X1&gt;X2…Xmin(堆顶)，而后遍历后续的N-K个数，一一与堆顶元素进行比较，如果遍历到的Xi大于堆顶元素Xmin，则把Xi放入堆中，而后更新整个堆，更新的时间复杂度为logK，如果Xi&lt;Xmin，则不更新堆，整个过程的复杂度为<strong>O(K)</strong> + O((N-K)*logK)=O(N * logK)</p></blockquote><p>总结：<br>第一步用HashTable统计每个Query出现的次数，时间复杂度为O(n);<br>第二步用采用最小堆找出Top K，时间复杂度O(N*logK)<br>最终时间复杂度为O(N) + O(N’ * logK)，N为一千万，N’为三百万</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> julyedu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> julyedu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识总结</title>
      <link href="/2018/11/22/OS-1/"/>
      <url>/2018/11/22/OS-1/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-OS引论"><a href="#第一章-OS引论" class="headerlink" title="第一章 OS引论"></a>第一章 OS引论</h2><h3 id="1-OS定义"><a href="#1-OS定义" class="headerlink" title="1 OS定义"></a>1 OS定义</h3><p>操作系统是一组能有效地控制和管理计算机软件和硬件硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。是配置在计算机硬件上的第一层软件。是现代计算机系统中最基本和最重要的系统软件。</p><h3 id="2-OS目标：有效性、方便性、可扩充性、开放性"><a href="#2-OS目标：有效性、方便性、可扩充性、开放性" class="headerlink" title="2 OS目标：有效性、方便性、可扩充性、开放性"></a>2 OS目标：有效性、方便性、可扩充性、开放性</h3><h3 id="3-推动OS发展的主要动力"><a href="#3-推动OS发展的主要动力" class="headerlink" title="3 推动OS发展的主要动力"></a>3 推动OS发展的主要动力</h3><ol><li>不断提高计算机资源的利用率</li><li>方便用户</li><li>器件的不断更新和换代</li><li>计算机体系结构的不断发展 </li><li>不断提出新的应用需求</li></ol><h3 id="4-OS作用："><a href="#4-OS作用：" class="headerlink" title="4 OS作用："></a>4 OS作用：</h3><ol><li>OS作为用户和计算机硬件系统之间的接口</li><li>OS作为计算机系统资源的管理者</li><li>OS实现了对计算机资源的抽象</li></ol><h3 id="5-OS发展历程"><a href="#5-OS发展历程" class="headerlink" title="5 OS发展历程"></a>5 OS发展历程</h3><h4 id="5-1-单道批处理系统"><a href="#5-1-单道批处理系统" class="headerlink" title="5.1 单道批处理系统"></a>5.1 单道批处理系统</h4><h5 id="5-1-1-缺点"><a href="#5-1-1-缺点" class="headerlink" title="5.1.1 缺点"></a>5.1.1 缺点</h5><p>系统中的资源得不到充分的利用</p><h4 id="5-2-多道批处理系统"><a href="#5-2-多道批处理系统" class="headerlink" title="5.2 多道批处理系统"></a>5.2 多道批处理系统</h4><p>用户提交的作业先存放在外存上，形成一个后备队列，利用其因IO操作而暂停时的CPU空档时间，再调度下一程序</p><h5 id="5-2-1-优点"><a href="#5-2-1-优点" class="headerlink" title="5.2.1 优点"></a>5.2.1 优点</h5><p>资源利用率高；系统吞吐量大；</p><h5 id="5-2-2-缺点"><a href="#5-2-2-缺点" class="headerlink" title="5.2.2 缺点"></a>5.2.2 缺点</h5><p>平均周转时间长；无交互能力；</p><h5 id="5-2-3-需要解决的问题："><a href="#5-2-3-需要解决的问题：" class="headerlink" title="5.2.3 需要解决的问题："></a>5.2.3 需要解决的问题：</h5><ol><li>处理机争用问题</li><li>内存分配和保护问题</li><li>IO设备分配问题</li><li>文件的组织和管理问题</li><li>作业管理问题</li><li>用户与系统的接口问题</li></ol><h5 id="5-2-4-分时系统"><a href="#5-2-4-分时系统" class="headerlink" title="5.2.4 分时系统"></a>5.2.4 分时系统</h5><p>在一台主机上连接多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源  </p><ol><li><p>引入原因：为了满足用户对人一机交互的需求  </p></li><li><p>特征：</p><ul><li>多路性  </li><li>独立性   </li><li>及时性（作业直接放入内存，采用时间片轮转运行方式）  </li><li>交互性  </li></ul></li></ol><h5 id="5-2-5-实时系统"><a href="#5-2-5-实时系统" class="headerlink" title="5.2.5 实时系统"></a>5.2.5 实时系统</h5><p>类型：周期性实时任务和非周期性实时任务；硬实时任务和软实时任务</p><h5 id="5-2-6-※实时系统和分时系统特征的比较"><a href="#5-2-6-※实时系统和分时系统特征的比较" class="headerlink" title="5.2.6 ※实时系统和分时系统特征的比较"></a>5.2.6 ※实时系统和分时系统特征的比较</h5><ol><li>多路性 <ul><li>分时系统的多路性表现为系统按分时原则多个终端用户服务</li><li>实时系统的多路性表现为系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。</li></ul></li><li>独立性</li><li>及时性</li><li>交互性</li><li>可靠性<ul><li>实时系统要求系统高度可靠，往往采取多级容错措施来保障系统的安全性及数据的安全性。</li></ul></li></ol><h5 id="5-2-7-微软OS发展"><a href="#5-2-7-微软OS发展" class="headerlink" title="5.2.7 微软OS发展"></a>5.2.7 微软OS发展</h5><ol><li>单用户单任务操作系统 eg：CP/M  MS-DOS</li><li>单用户多任务操作系统 eg：Windows</li><li>多用户多任务操作系统 eg：Unix</li></ol><h3 id="6-OS的主要功能"><a href="#6-OS的主要功能" class="headerlink" title="6 OS的主要功能"></a>6 OS的主要功能</h3><h4 id="6-1-处理机管理功能"><a href="#6-1-处理机管理功能" class="headerlink" title="6.1 处理机管理功能"></a>6.1 处理机管理功能</h4><p>∵处理机分配和运行都是以进程为基本单位 ∴对处理机的管理可归结为对进程的管理  </p><ul><li>※进程互斥：指多个进程在对临界资源进行访问时，应采用互斥方式</li><li>※进程同步：指在相互合作去完成共同任务的多个进程之间，由同步机构对它们的执行次序加以协调</li></ul><h4 id="6-2-存储器管理功能"><a href="#6-2-存储器管理功能" class="headerlink" title="6.2 存储器管理功能"></a>6.2 存储器管理功能</h4><p>为多道程序的运行提供良好的环境，提高存储器的利用率，方便用户使用，并能从逻辑上扩充内存<br>※静态&amp;动态分配方式</p><h4 id="6-3-设备管理功能"><a href="#6-3-设备管理功能" class="headerlink" title="6.3 设备管理功能"></a>6.3 设备管理功能</h4><h5 id="6-3-1-主要任务"><a href="#6-3-1-主要任务" class="headerlink" title="6.3.1 主要任务"></a>6.3.1 主要任务</h5><ol><li>完成用户进程提出的IO请求，为用户进程分配所需的IO设备，并完成指定的IO操作</li><li>提高CPU和IO设备的利用率，提高IO速度，方便用户使用IO设备  </li></ol><p>设备处理程序又称为设备驱动程序</p><h4 id="6-4-文件管理功能"><a href="#6-4-文件管理功能" class="headerlink" title="6.4 文件管理功能"></a>6.4 文件管理功能</h4><h4 id="6-5-OS的基本特性"><a href="#6-5-OS的基本特性" class="headerlink" title="6.5 OS的基本特性"></a>6.5 OS的基本特性</h4><h5 id="6-5-1-异"><a href="#6-5-1-异" class="headerlink" title="6.5.1 异"></a>6.5.1 异</h5><ol><li>批处理系统有着高的资源利用率和系统吞吐量</li><li>分时系统能获得及时响应（∵作业直接放入内存）</li><li>实时系统具有实时特征</li></ol><h5 id="6-5-2-同"><a href="#6-5-2-同" class="headerlink" title="6.5.2 同"></a>6.5.2 同</h5><p>并发，共享，虚拟，异步（※并发和共享是多用户多任务OS的两个最基本的特征）<br>并发——正是程序能并发执行这一特征，才使得OS能有效地提高系统中的资源利用率，增加吞吐量  </p><ul><li>并行：指两个或多个事件在同一时刻发生</li><li>并发：指两个或多个事件在同一时间间隔内发生</li></ul><h4 id="6-6-OS结构设计"><a href="#6-6-OS结构设计" class="headerlink" title="6.6 OS结构设计"></a>6.6 OS结构设计</h4><h5 id="6-6-1-整体"><a href="#6-6-1-整体" class="headerlink" title="6.6.1 整体"></a>6.6.1 整体</h5><h5 id="6-6-2-模块化（模块—接口法）（无序模块法）"><a href="#6-6-2-模块化（模块—接口法）（无序模块法）" class="headerlink" title="6.6.2 模块化（模块—接口法）（无序模块法）"></a>6.6.2 模块化（模块—接口法）（无序模块法）</h5><h6 id="6-6-2-1-内聚性"><a href="#6-6-2-1-内聚性" class="headerlink" title="6.6.2.1 内聚性"></a>6.6.2.1 内聚性</h6><p>指模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越强。</p><h6 id="6-6-2-2-耦合性"><a href="#6-6-2-2-耦合性" class="headerlink" title="6.6.2.2 耦合性"></a>6.6.2.2 耦合性</h6><p>指模块间相互联系和相互影响的程度。耦合度越低，模块独立性越强。</p><h6 id="6-6-2-3-优点"><a href="#6-6-2-3-优点" class="headerlink" title="6.6.2.3 优点"></a>6.6.2.3 优点</h6><ol><li>提高OS设计的正确性、可理解性和可维护性</li><li>增加OS的适应性</li><li>加速OS的开发过程。</li></ol><h6 id="6-6-2-4-缺点"><a href="#6-6-2-4-缺点" class="headerlink" title="6.6.2.4 缺点"></a>6.6.2.4 缺点</h6><p>OS设计阶段，设计者每一个决定应该建立在上一个决定的基础上，模块化结构中各模块齐头并进，无法寻找一个可靠的决定顺序，造成决定的“无序性”。</p><h5 id="6-6-3-分层——高层仅依赖于紧邻它的底层"><a href="#6-6-3-分层——高层仅依赖于紧邻它的底层" class="headerlink" title="6.6.3 分层——高层仅依赖于紧邻它的底层"></a>6.6.3 分层——高层仅依赖于紧邻它的底层</h5><h6 id="6-6-3-1-优点"><a href="#6-6-3-1-优点" class="headerlink" title="6.6.3.1 优点"></a>6.6.3.1 优点</h6><ol><li>易保证系统的正确性</li><li>易扩充和易维护性</li></ol><h6 id="6-6-3-2-缺点"><a href="#6-6-3-2-缺点" class="headerlink" title="6.6.3.2 缺点"></a>6.6.3.2 缺点</h6><p>系统效率低</p><pre><code>∵层次结构是分层单向依赖，OS每执行一个功能，通常要自上而下穿越多个层次</code></pre><h5 id="6-6-4-客户-服务器模式"><a href="#6-6-4-客户-服务器模式" class="headerlink" title="6.6.4 客户/服务器模式"></a>6.6.4 客户/服务器模式</h5><h6 id="6-6-4-1-优点"><a href="#6-6-4-1-优点" class="headerlink" title="6.6.4.1 优点"></a>6.6.4.1 优点</h6><ol><li>数据的分布处理和存储</li><li>便于集中管理</li><li>灵活性和可扩充性</li><li>易于改编应用软件。</li></ol><h6 id="6-6-4-2-缺点"><a href="#6-6-4-2-缺点" class="headerlink" title="6.6.4.2 缺点"></a>6.6.4.2 缺点</h6><p>存在着不可靠性和瓶颈问题。一旦服务器故障，将导致整个网络瘫痪。</p><h5 id="6-6-5-微内核——将操作系统最基本的部分放入微内核"><a href="#6-6-5-微内核——将操作系统最基本的部分放入微内核" class="headerlink" title="6.6.5 微内核——将操作系统最基本的部分放入微内核"></a>6.6.5 微内核——将操作系统最基本的部分放入微内核</h5><h6 id="6-6-5-1-基本功能"><a href="#6-6-5-1-基本功能" class="headerlink" title="6.6.5.1 基本功能"></a>6.6.5.1 基本功能</h6><ol><li>进程（线程）管理</li><li>低级存储器管理</li><li>中断和陷入处理。</li></ol><h6 id="6-6-5-2-优点"><a href="#6-6-5-2-优点" class="headerlink" title="6.6.5.2 优点"></a>6.6.5.2 优点</h6><ol><li>提高了系统的可扩展性</li><li>增强了系统的可靠性</li><li>可移植性</li><li>提供了对分布式系统的支持</li><li>融入了面向对象技术。</li></ol><h2 id="第二章-进程的描述和控制"><a href="#第二章-进程的描述和控制" class="headerlink" title="第二章 进程的描述和控制"></a>第二章 进程的描述和控制</h2><h3 id="1-前驱图——有向无循环图"><a href="#1-前驱图——有向无循环图" class="headerlink" title="1 前驱图——有向无循环图"></a>1 前驱图——有向无循环图</h3><h3 id="2-程序顺序执行时的特征："><a href="#2-程序顺序执行时的特征：" class="headerlink" title="2 程序顺序执行时的特征："></a>2 程序顺序执行时的特征：</h3><ol><li>顺序性：每一操作必须在下一个操作开始之前结束</li><li>封闭性：程序运行时独占全机资源，资源的状态只有本程序才能改变它，一旦执行，结果不受外界影响</li><li>可再现性</li></ol><h3 id="3-程序并发执行"><a href="#3-程序并发执行" class="headerlink" title="3 程序并发执行"></a>3 程序并发执行</h3><ol><li>原因：为了提高资源利用率和系统吞吐量，通常采用多道程序技术，将多个程序同时装入内存，并发运行</li><li>特征：<ul><li>间断性</li><li>失去封闭性</li><li>不可再现性</li></ul></li></ol><h3 id="※4-进程"><a href="#※4-进程" class="headerlink" title="※4 进程"></a>※4 进程</h3><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。包括程序段、数据段和PCB三部分。<br>创建进程实质上就是创建进程实体中的PCB。</p><h5 id="4-2-特征"><a href="#4-2-特征" class="headerlink" title="4.2 特征"></a>4.2 特征</h5><p>除了进程具有程序没有的PCB结构以外，还具有：  </p><ul><li>动态性 进程是动态的，程序是静态的</li><li>并发性 没有建立PCB的程序是不能参与并发执行的</li><li>独立性</li><li>异步性</li></ul><h5 id="4-3-状态：就绪-执行-阻塞"><a href="#4-3-状态：就绪-执行-阻塞" class="headerlink" title="4.3 状态：就绪 执行 阻塞"></a>4.3 状态：就绪 执行 阻塞</h5><p><img src="https://i.imgur.com/zVMz6TN.jpg" alt></p><h5 id="4-4-进程控制——是进程管理中最基本的功能"><a href="#4-4-进程控制——是进程管理中最基本的功能" class="headerlink" title="4.4 进程控制——是进程管理中最基本的功能"></a>4.4 进程控制——是进程管理中最基本的功能</h5><h6 id="4-4-1-OS内核"><a href="#4-4-1-OS内核" class="headerlink" title="4.4.1 OS内核"></a>4.4.1 OS内核</h6><ol><li><p>定义：<br>通常将一些与硬件紧密相关的模块（如中断处理程序等）、各种常用设备的驱动程序以及运行频率较高的模块（如时钟管理、进程调度），都安排在紧靠硬件的软件层次中，将它们常驻内存——内核。目的是便于对这些软件进行保护，提高OS的运行效率。</p></li><li><p>状态：</p><ul><li>系统态：又称管态，内核态，具有较高的特权，能执行一切指令，访问所有寄存器和存储区</li><li>用户态：又称目态</li></ul></li><li><p>功能：支撑功能、资源管理功能</p><ul><li>支撑功能：<ul><li>中断处理：中断处理是内核最基本的功能。</li><li>时钟管理：时钟管理是内核的一项基本功能。</li><li>原语操作：“原子操作”，即不可分割的基本单位。∴原语在执行过程中不允许被中断。原子操作在系统态下执行，常驻内存。</li></ul></li><li>资源管理功能：<ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul></li></ol><h6 id="4-4-2-进程的创建"><a href="#4-4-2-进程的创建" class="headerlink" title="4.4.2 进程的创建"></a>4.4.2 进程的创建</h6><ol><li>允许一个进程创建另一个进程。但Windows不存在任何进程层次结构的概念。</li><li>进程图</li><li>引起创建进程的事件：用户登录、作业调度、提供服务、应用请求</li><li>创建过程<br>OS调用进程创建原语Create→申请空白PCB→为新进程分配其运行所需的资源→初始化进程控制块PCB→如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li></ol><h6 id="4-4-3-进程的终止"><a href="#4-4-3-进程的终止" class="headerlink" title="4.4.3 进程的终止"></a>4.4.3 进程的终止</h6><ol><li>引起进程终止的事件：<ul><li>正常结束、异常结束（越界错、保护错、非法指令、运行超时 etc）、外界干预</li></ul></li><li>终止过程<br> OS调用进程终止原语Terminate → 根据被终止进程的标识符，从PCB中检索出该进程的PCB，从中读出该进程的状态 → 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度 → 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控的进程 → 将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统 → 将被终止进程(PCB)从所在队列(或链表)中移出，等待其它程序来搜集信息</li></ol><h6 id="4-4-4-进程的阻塞和唤醒"><a href="#4-4-4-进程的阻塞和唤醒" class="headerlink" title="4.4.4 进程的阻塞和唤醒"></a>4.4.4 进程的阻塞和唤醒</h6><ol><li>引起进程阻塞和唤醒的事件：<br> 向系统请求共享资源失败、等待某种操作的完成、新数据尚未到达、等待新任务的到达。</li><li>进程阻塞过程：<br> 进程通过调用阻塞原语Block将自己阻塞。可见，阻塞是进程自身的一种主动行为。由于该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列。</li><li>进程唤醒过程：<br> 唤醒原语Wakeup首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。</li></ol><h6 id="4-4-5-进程的挂起和激活"><a href="#4-4-5-进程的挂起和激活" class="headerlink" title="4.4.5 进程的挂起和激活"></a>4.4.5 进程的挂起和激活</h6><ol><li>挂起：<br> 使用挂起原语Suspend。检查被挂起的进程状态，若是活动就绪状态，则改为静止就绪状态；若活动阻塞状态，则改为静止阻塞状态；把该进程的PCB复制到指定内存区域；若正在执行，则重新调度。</li><li>激活：<br> 使用激活原语Active。将进程调入内存，若为静止就绪，则改为活动就绪；ruo为静止阻塞，则改为活动阻塞。</li><li></li></ol><p><img src="https://i.imgur.com/GT1kqim.png" alt></p><h5 id="4-5-进程同步：硬件同步机制、信号量机制（最常用）、管程机制"><a href="#4-5-进程同步：硬件同步机制、信号量机制（最常用）、管程机制" class="headerlink" title="4.5 进程同步：硬件同步机制、信号量机制（最常用）、管程机制"></a>4.5 进程同步：硬件同步机制、信号量机制（最常用）、管程机制</h5><h6 id="4-5-1-两种制约关系"><a href="#4-5-1-两种制约关系" class="headerlink" title="4.5.1 两种制约关系"></a>4.5.1 两种制约关系</h6><ol><li>间接相互制约关系：对于临界资源，多个进程只能互斥访问&nbsp;&nbsp;&nbsp;&nbsp;进程互斥</li><li>直接相互制约关系：源于进程之间的相互合作&nbsp;&nbsp;&nbsp;&nbsp;进程同步</li></ol><h6 id="4-5-2-互斥共享方式："><a href="#4-5-2-互斥共享方式：" class="headerlink" title="4.5.2 互斥共享方式："></a>4.5.2 互斥共享方式：</h6><p>在一段时间内，只允许一个进程访问某个资源，仅当当前进程访问完毕并释放该资源后，才允许另外一个进程对其访问，这种资源共享方式成为互斥式共享。</p><h6 id="4-5-3-临界区：每个进程中访问临界资源的那段代码成为临界区"><a href="#4-5-3-临界区：每个进程中访问临界资源的那段代码成为临界区" class="headerlink" title="4.5.3 临界区：每个进程中访问临界资源的那段代码成为临界区"></a>4.5.3 临界区：每个进程中访问临界资源的那段代码成为临界区</h6><h6 id="4-5-4-同步机制应遵循的规则：空闲让进；忙则等待；有限等待；让权等待"><a href="#4-5-4-同步机制应遵循的规则：空闲让进；忙则等待；有限等待；让权等待" class="headerlink" title="4.5.4 同步机制应遵循的规则：空闲让进；忙则等待；有限等待；让权等待"></a>4.5.4 同步机制应遵循的规则：空闲让进；忙则等待；有限等待；让权等待</h6><h6 id="4-5-5-硬件同步机制"><a href="#4-5-5-硬件同步机制" class="headerlink" title="4.5.5 硬件同步机制"></a>4.5.5 硬件同步机制</h6><p>关中断：实现互斥的最简单的方法之一。进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开        中断。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，也就不会发        生进程或线程切换。<br>缺点：滥用关中断权力可能导致严重后果；关中断时间过长，会影响系统效率，限制了处理器交叉执        行程序的能力；关中断方法也不适用于多CPU 系统。  </p><ul><li>利用Test-and-Set指令实现互斥 ：借助一条硬件指令——“测试并建立”指令TS以实现互斥。</li><li>利用Swap指令实现进程互斥：<ul><li>Ⅵ信号量机制</li><li>整型信号量：P V操作 P–wait V–signal</li><li>记录型信号量</li><li>AND信号量</li><li>信号量集</li></ul></li></ul><blockquote><p>④进程同步<br>描述：能够并发、改善利用率、提高吞吐量、但使系统复杂<br>一、进程同步的基本概念<br>制约关系：间接相互制约关系、直接相互制约关系<br>间接相互制约关系：互斥共享<br>直接相互制约关系：合作共享，异步性要做好<br>临界资源：生产者-消费者问题、<br>临界区、：进入区、临界区、退出区、剩余区<br>同步机制应遵循的规则：空闲让进、忙则等待、有限等待、让权等待  </p><p>二、硬件同步机制<br>关中断：缺点多：滥用关中断.造成严重后果、关中断时间过长、不适用于多CPU系统（因为一个处理器关中断并不能防止进程在其他处理器上执行相同的临界段代码）<br>Test-and-Set：不断测试lock，如果是FALSE，就进入临界区，并lock == TRUE；否则测试到TS(s) == TRUE<br>Swap指令：一直等，直到key == TRUE<br>但以上都不符合“让权等待”原则  </p><p>三、信号量机制<br>整形信号量：S≤0，就一直等，直到释放互斥资源<br>记录型信号量：整形信号量不符合“让权等待”原则。如果有资源，就分配，如果无，就插入阻塞队列；释放资源，如果有等待，就激活<br>AND型信号量：一口气全分配<br>信号量集：有多个信号量（S信号量,至少要t个,每次分配d个）  </p><p>四、信号量的应用<br>利用信号量实现进程互斥：mutex = ( -1, 0, 1）= （无，一临一阻队， 一临一信队）<br>利用信号量实现前趋关系：需要的信号量被占用了，就这样实现 </p><p>经典进程的同步问题<br>一、生产者-消费者问题<br>记录型信号量解决：如果缓冲区空，而且能够获取信号量，就投放产品；如果缓冲区有产品，而且能够获取信号量，就消费<br>AND信号量解决：一口气全分配<br>管程解决：利用管程只有一个进程能够使用的属性  </p><p>二、哲学家进餐问题<br>记录型信号量解决：先拿左.后那右、先放左.后放右<br>解决死锁：最多4人取筷子、先检查.有左右筷子才能取、奇左右.偶右左<br>AND信号量解决：一口气全分配  </p><p>三、读者-写者问题<br>描述：可以多读一、一旦开始写.就不能读或写<br>记录型信号量解决：<br>读操作：等rmutex就是为了改readcount→无人读？看看是否在写.等wmutex→readcount++→自增完成.rmutex还你→读读读→等rmutex为了自减readcount→无人读？可以写了.还你wmutex<br>写操作：等wmutex.即无读无写→写完.还你wmutex<br>利用信号量集机制：<br>读：限制reader个数→如果mx是1.就读→最后释放一个reader个数<br>写：如果mx是1.并且读者数为0.就写→写完释放mx</p></blockquote><h5 id="4-6-进程通信——进程之间的信息交换"><a href="#4-6-进程通信——进程之间的信息交换" class="headerlink" title="4.6 进程通信——进程之间的信息交换"></a>4.6 进程通信——进程之间的信息交换</h5><h6 id="4-6-1-高级通信机制分为四大类：共享存储器系统；管道通信系统；信息传递系统；客户机-服务器系统。"><a href="#4-6-1-高级通信机制分为四大类：共享存储器系统；管道通信系统；信息传递系统；客户机-服务器系统。" class="headerlink" title="4.6.1 高级通信机制分为四大类：共享存储器系统；管道通信系统；信息传递系统；客户机-服务器系统。"></a>4.6.1 高级通信机制分为四大类：共享存储器系统；管道通信系统；信息传递系统；客户机-服务器系统。</h6><h6 id="4-6-2-共享存储器系统可分为两种：基于共享数据结构的通信方式；基于共享存储区的通信方式。"><a href="#4-6-2-共享存储器系统可分为两种：基于共享数据结构的通信方式；基于共享存储区的通信方式。" class="headerlink" title="4.6.2 共享存储器系统可分为两种：基于共享数据结构的通信方式；基于共享存储区的通信方式。"></a>4.6.2 共享存储器系统可分为两种：基于共享数据结构的通信方式；基于共享存储区的通信方式。</h6><h6 id="4-6-3-为了协调双方的通信，管道机制必须提供以下三方面的协调能力："><a href="#4-6-3-为了协调双方的通信，管道机制必须提供以下三方面的协调能力：" class="headerlink" title="4.6.3 为了协调双方的通信，管道机制必须提供以下三方面的协调能力："></a>4.6.3 为了协调双方的通信，管道机制必须提供以下三方面的协调能力：</h6><ol><li>互斥，即当一个进程正在对pipe执行读/写操作时，其它(另一)进程必须等待。</li><li>同步，指当写(输入)进程把一定数量(如4 KB)的数据写入pipe，便去睡眠等待，直到读(输出)进程取走数据后再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后才将之唤醒。</li><li>确定对方是否存在，只有确定了对方已存在时才能进行通信。</li></ol><h5 id="4-7-进程管理中的数据结构——资源信息表或进程信息表"><a href="#4-7-进程管理中的数据结构——资源信息表或进程信息表" class="headerlink" title="4.7 进程管理中的数据结构——资源信息表或进程信息表"></a>4.7 进程管理中的数据结构——资源信息表或进程信息表</h5><h6 id="4-7-1-OS管理的这些数据结构一般分为以下四类："><a href="#4-7-1-OS管理的这些数据结构一般分为以下四类：" class="headerlink" title="4.7.1 OS管理的这些数据结构一般分为以下四类："></a>4.7.1 OS管理的这些数据结构一般分为以下四类：</h6><p>内存表、设备表、文件表和用于进程管理的进程表，通常进程表又被称为进程控制块PCB。</p><h6 id="4-7-2-PCB的作用："><a href="#4-7-2-PCB的作用：" class="headerlink" title="4.7.2 PCB的作用："></a>4.7.2 PCB的作用：</h6><ol><li>作为独立运行基本单位的标志</li><li>能实现间断性运行方式</li><li>提供进程管理所需要的信息</li><li>提供进程调度所需要的信息</li><li>实现与其它进程的同步与通信。</li></ol><h6 id="4-7-3-PCB中的信息："><a href="#4-7-3-PCB中的信息：" class="headerlink" title="4.7.3 PCB中的信息："></a>4.7.3 PCB中的信息：</h6><ol><li>进程标识符</li><li>处理机状态</li><li>进程调度信息</li><li>进程控制信息</li></ol><h6 id="4-7-4-PCB的组织方式："><a href="#4-7-4-PCB的组织方式：" class="headerlink" title="4.7.4 PCB的组织方式："></a>4.7.4 PCB的组织方式：</h6><ol><li>线性方式</li><li>链接方式</li><li>索引方式</li></ol><h3 id="※※※5-经典进程的同步问题"><a href="#※※※5-经典进程的同步问题" class="headerlink" title="※※※5 经典进程的同步问题"></a>※※※5 经典进程的同步问题</h3><h3 id="6-线程——作为调度与分派的基本单位"><a href="#6-线程——作为调度与分派的基本单位" class="headerlink" title="6 线程——作为调度与分派的基本单位"></a>6 线程——作为调度与分派的基本单位</h3><h4 id="6-1-引入"><a href="#6-1-引入" class="headerlink" title="6.1 引入"></a>6.1 引入</h4><ol><li>进程——解决了单处理机程序并发执行的问题</li><li>线程——提高程序并发执行的速度</li></ol><h4 id="6-2-线程与进程的比较"><a href="#6-2-线程与进程的比较" class="headerlink" title="6.2 线程与进程的比较"></a>6.2 线程与进程的比较</h4><ol><li>调度的基本单位</li><li>并发性</li><li>拥有资源：线程只拥有一点必不可少的能保证独立运行的资源</li><li>独立性：在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多</li><li>系统开销：线程小；在一些OS中，线程的切换、同步和通信都不需要OS内核的干预</li><li>支持多处理机系统</li></ol><h4 id="6-3-线程的状态：执行-就绪-阻塞-线程控制块：TCB"><a href="#6-3-线程的状态：执行-就绪-阻塞-线程控制块：TCB" class="headerlink" title="6.3 线程的状态：执行 就绪 阻塞 线程控制块：TCB"></a>6.3 线程的状态：执行 就绪 阻塞 线程控制块：TCB</h4><h4 id="6-4-多线程OS中的进程属性"><a href="#6-4-多线程OS中的进程属性" class="headerlink" title="6.4 多线程OS中的进程属性"></a>6.4 多线程OS中的进程属性</h4><ol><li>进程是一个可拥有资源的基本单位，仍是作为系统资源分配的基本单位</li><li>多个线程可并发执行</li><li>进程已不是可执行的实体，而把线程作为独立运行的基本单位</li></ol><h4 id="6-5-线程的实现方式"><a href="#6-5-线程的实现方式" class="headerlink" title="6.5 线程的实现方式"></a>6.5 线程的实现方式</h4><ol><li>内核支持线程KST </li><li>用户级线程ULT</li></ol><h2 id="第三章-处理机的调度与死锁"><a href="#第三章-处理机的调度与死锁" class="headerlink" title="第三章 处理机的调度与死锁"></a>第三章 处理机的调度与死锁</h2><p><img src="https://i.imgur.com/0Xndyhj.png" alt></p><p><img src="https://i.imgur.com/XACXmgy.png" alt></p><h3 id="3-1-注："><a href="#3-1-注：" class="headerlink" title="3.1 注："></a>3.1 注：</h3><h4 id="3-1-1-调度层次"><a href="#3-1-1-调度层次" class="headerlink" title="3.1.1 调度层次"></a>3.1.1 调度层次</h4><ol><li>高级调度：又叫长程调度或作业调度或接纳调度，对象是作业，主要用于多道批处理系统，在分时系统和实时系统中不设置高级调度</li><li>低级调度：又叫短程调度或进程调度，对象是进程。是最基本的一种调度，三种OS中都必须配置此种调度</li><li>内存调度，就是存储器管理中的对换功能提高内存利用率和系统吞吐率</li></ol><h4 id="3-1-2-处理机调度算法的共同目标"><a href="#3-1-2-处理机调度算法的共同目标" class="headerlink" title="3.1.2 处理机调度算法的共同目标"></a>3.1.2 处理机调度算法的共同目标</h4><p><img src="https://i.imgur.com/dPP8Qge.png" alt></p><ol><li>处理机利用率：</li><li>公平性：使诸进程都获得合理的CPU 时间</li><li>平衡性：使系统中的CPU和各种外部设备都能经常处于忙碌状态</li><li>策略强制执行</li></ol><h4 id="3-1-3-批处理系统的目标"><a href="#3-1-3-批处理系统的目标" class="headerlink" title="3.1.3 批处理系统的目标"></a>3.1.3 批处理系统的目标</h4><ol><li><p>平均周转时间短<br>周转时间是指从作业被提交给系统开始，到作业完成为止的这段时间间隔（被称为作业周转时间），包括：外存上等待时间，进程在就绪队列上等待时间，CPU上执行时间，等待IO时间。<br> 应使作业周转时间和作业的平均周转时间尽可能短。可把平均周转时间描述为：<img src="https://i.imgur.com/Ul0zTce.png" alt></p><p> 平均带权周转时间则可表示为： <img src="https://i.imgur.com/UA1tKzN.png" alt></p><p> 作业的周转时间T与系统为它提供服务的时间Ts之比，即W = T/Ts</p></li><li><p>系统吞吐量高 吞吐量是指在单位时间内系统所完成的作业数，因而它与批处理作业的平均长度有关。</p></li><li><p>处理机利用率高</p></li></ol><h4 id="3-1-4-分时系统的目标"><a href="#3-1-4-分时系统的目标" class="headerlink" title="3.1.4 分时系统的目标"></a>3.1.4 分时系统的目标</h4><ol><li>响应时间快<br> 响应时间是指从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间间隔</li><li>均衡性</li></ol><h4 id="3-1-5-实时系统的目标"><a href="#3-1-5-实时系统的目标" class="headerlink" title="3.1.5 实时系统的目标"></a>3.1.5 实时系统的目标</h4><ol><li>截止时间的保证</li><li>可预测性</li></ol><h4 id="3-1-6-作业：包括程序、数据和一份作业说明书。"><a href="#3-1-6-作业：包括程序、数据和一份作业说明书。" class="headerlink" title="3.1.6 作业：包括程序、数据和一份作业说明书。"></a>3.1.6 作业：包括程序、数据和一份作业说明书。</h4><ol><li>在批处理系统中，是以作业作为基本单位从外存调入内存的。  </li><li>作业步：在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤得到结果。</li><li>作业控制块JCB：保存了系统对作业进行管理和调度所需的全部信息。</li><li>作业运行的三个阶段：收容 运行 完成</li><li>作业运行的三个状态：后备状态 运行状态 完成状态</li></ol><h4 id="3-1-7-作业调度的主要任务："><a href="#3-1-7-作业调度的主要任务：" class="headerlink" title="3.1.7 作业调度的主要任务："></a>3.1.7 作业调度的主要任务：</h4><ol><li>根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求</li><li>按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源</li><li>将新创建的进程排在就绪队列上等待调度。</li></ol><h4 id="3-1-8-短作业优先算法SJF——以作业的长短来计算优先级，作业的长短是以作业所要求的运行时间来衡量的"><a href="#3-1-8-短作业优先算法SJF——以作业的长短来计算优先级，作业的长短是以作业所要求的运行时间来衡量的" class="headerlink" title="3.1.8 短作业优先算法SJF——以作业的长短来计算优先级，作业的长短是以作业所要求的运行时间来衡量的"></a>3.1.8 短作业优先算法SJF——以作业的长短来计算优先级，作业的长短是以作业所要求的运行时间来衡量的</h4><h5 id="3-1-8-1-SJF算法可以分别用于作业调度和进程调度。"><a href="#3-1-8-1-SJF算法可以分别用于作业调度和进程调度。" class="headerlink" title="3.1.8.1 SJF算法可以分别用于作业调度和进程调度。"></a>3.1.8.1 SJF算法可以分别用于作业调度和进程调度。</h5><p>缺点：  </p><ol><li>必须预知作业的运行时间。很难准确估计作业的运行时间，一般都会偏长估计。  </li><li>对长作业非常不利，长作业的周转时间会明显地增长。该算法完全忽视作业的等待时间，可能使作业等待时间过长，出现饥饿现象。  </li><li>人—机无法实现交互。  </li><li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。  </li></ol><h5 id="3-1-8-2-高响应比优先调度算法HRRN"><a href="#3-1-8-2-高响应比优先调度算法HRRN" class="headerlink" title="3.1.8.2 高响应比优先调度算法HRRN"></a>3.1.8.2 高响应比优先调度算法HRRN</h5><ol><li><p>FCFS算法只考虑作业等待时间，而忽视了作业运行时间</p></li><li><p>SJF算法只考虑作业运行时间，而忽视了作业等待时间</p></li><li><p>HRRN算法考虑了两者，既照顾了短作业，又不使长作业等待时间过长，从而改善了处理机调度的性能<br><img src="https://i.imgur.com/0U7D6Az.png" alt></p><ul><li>等待时间相同，要求的服务时间越短，优先级越高，类似SJF</li><li>要求服务时间相同，等待时间越长，优先级越高，类似FCFS</li><li>对于长作业，随等待时间的增加，优先级提高。</li></ul></li></ol><h4 id="3-1-9-进程调度"><a href="#3-1-9-进程调度" class="headerlink" title="3.1.9 进程调度"></a>3.1.9 进程调度</h4><h5 id="3-1-9-1-三种类型OS"><a href="#3-1-9-1-三种类型OS" class="headerlink" title="3.1.9.1 三种类型OS"></a>3.1.9.1 三种类型OS</h5><ol><li>单用户操作系统:DOS</li><li>分时操作系统:WIndows,Unix,Linux</li><li>实时操作系统:uCOS-II,VxWorks</li></ol><h5 id="3-1-9-2-进程调度的任务："><a href="#3-1-9-2-进程调度的任务：" class="headerlink" title="3.1.9.2 进程调度的任务："></a>3.1.9.2 进程调度的任务：</h5><p>保存处理机的现场信息，按某种算法选取进程，把处理器分配给进程 </p><h5 id="3-1-9-3-进程调度方式"><a href="#3-1-9-3-进程调度方式" class="headerlink" title="3.1.9.3 进程调度方式"></a>3.1.9.3 进程调度方式</h5><ol><li>非抢占方式：一旦把处理机分配给某进程后，就一直让它运行下去，决不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机。</li><li>抢占方式：允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。</li><li>原则：优先权原则，短进程优先原则，时间片原则</li></ol><h5 id="3-1-9-4-※轮转调度算法"><a href="#3-1-9-4-※轮转调度算法" class="headerlink" title="3.1.9.4 ※轮转调度算法"></a>3.1.9.4 ※轮转调度算法</h5><h5 id="3-1-9-5-※优先级调度算法"><a href="#3-1-9-5-※优先级调度算法" class="headerlink" title="3.1.9.5 ※优先级调度算法"></a>3.1.9.5 ※优先级调度算法</h5><h5 id="3-1-9-6-※多级反馈队列算法"><a href="#3-1-9-6-※多级反馈队列算法" class="headerlink" title="3.1.9.6 ※多级反馈队列算法"></a>3.1.9.6 ※多级反馈队列算法</h5><h5 id="3-1-9-7-※基于公平原则的调度算法"><a href="#3-1-9-7-※基于公平原则的调度算法" class="headerlink" title="3.1.9.7 ※基于公平原则的调度算法"></a>3.1.9.7 ※基于公平原则的调度算法</h5><h4 id="3-1-10-实时调度"><a href="#3-1-10-实时调度" class="headerlink" title="3.1.10 实时调度"></a>3.1.10 实时调度</h4><h5 id="3-1-10-1-实现实时调度的基本条件"><a href="#3-1-10-1-实现实时调度的基本条件" class="headerlink" title="3.1.10.1 实现实时调度的基本条件"></a>3.1.10.1 实现实时调度的基本条件</h5><ol><li>提供必要的信息</li><li>系统处理能力强</li><li>采用抢占式调度机制</li><li>具有快速切换机制</li></ol><h5 id="3-1-10-2-实时调度的分类"><a href="#3-1-10-2-实时调度的分类" class="headerlink" title="3.1.10.2 实时调度的分类"></a>3.1.10.2 实时调度的分类</h5><ol><li>非抢占式调度算法：非抢占式轮转调度算法；非抢占式优先调度算法</li><li>抢占式调度算法：基于时钟中断的抢占式优先级调度算法；立即抢占的优先级调算法（要求OS具有快速响应外部事件的能力）</li></ol><h5 id="3-1-10-3-※最早截止时间优先EDF算法"><a href="#3-1-10-3-※最早截止时间优先EDF算法" class="headerlink" title="3.1.10.3 ※最早截止时间优先EDF算法"></a>3.1.10.3 ※最早截止时间优先EDF算法</h5><ol><li>非抢占式调度方式用于非周期实时任务</li><li>抢占式调度方式用于周期实时任务</li></ol><h5 id="3-1-10-4-※最低松弛度优先LLF算法"><a href="#3-1-10-4-※最低松弛度优先LLF算法" class="headerlink" title="3.1.10.4 ※最低松弛度优先LLF算法"></a>3.1.10.4 ※最低松弛度优先LLF算法</h5><p>优先级倒置及解决方法</p><h4 id="3-1-11-※死锁"><a href="#3-1-11-※死锁" class="headerlink" title="3.1.11 ※死锁"></a>3.1.11 ※死锁</h4><h5 id="3-1-11-1-定义："><a href="#3-1-11-1-定义：" class="headerlink" title="3.1.11.1 定义："></a>3.1.11.1 定义：</h5><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的（Deadlock）。</p><h5 id="3-1-11-2-产生死锁的必要条件，必须同时具备，缺一不可："><a href="#3-1-11-2-产生死锁的必要条件，必须同时具备，缺一不可：" class="headerlink" title="3.1.11.2 产生死锁的必要条件，必须同时具备，缺一不可："></a>3.1.11.2 产生死锁的必要条件，必须同时具备，缺一不可：</h5><ol><li>互斥条件</li><li>请求和保持条件</li><li>不可抢占条件</li><li>循环等待条件</li></ol><h5 id="3-1-11-3-计算机中的死锁"><a href="#3-1-11-3-计算机中的死锁" class="headerlink" title="3.1.11.3 计算机中的死锁"></a>3.1.11.3 计算机中的死锁</h5><p>死锁的起因，通常是源于多个进程对资源的争夺，不仅是对不可抢占资源进行争夺时会发生死锁，而且对可消耗资源（又称为临时性资源）进行争夺时也会引起死锁。</p><ol><li>竞争不可抢占性资源引起死锁</li><li>竞争可消耗资源引起死锁</li><li>进程推进顺序不当引起死锁</li></ol><h5 id="3-1-11-4-处理死锁的方法"><a href="#3-1-11-4-处理死锁的方法" class="headerlink" title="3.1.11.4 处理死锁的方法"></a>3.1.11.4 处理死锁的方法</h5><h6 id="3-1-11-4-1-预防死锁"><a href="#3-1-11-4-1-预防死锁" class="headerlink" title="3.1.11.4.1 预防死锁"></a>3.1.11.4.1 预防死锁</h6><ol><li>破坏“请求和保持”条件</li><li>破坏“不可抢占”条件</li><li>破坏“循环等待”条件</li></ol><h6 id="3-1-11-4-2-避免死锁-eg：利用银行家算法避免死锁"><a href="#3-1-11-4-2-避免死锁-eg：利用银行家算法避免死锁" class="headerlink" title="3.1.11.4.2 避免死锁 eg：利用银行家算法避免死锁"></a>3.1.11.4.2 避免死锁 eg：利用银行家算法避免死锁</h6><h6 id="3-1-11-4-3-检测死锁"><a href="#3-1-11-4-3-检测死锁" class="headerlink" title="3.1.11.4.3 检测死锁"></a>3.1.11.4.3 检测死锁</h6><p>为了能对系统中是否已发生了死锁进行检测，在系统中必须：保存有关资源的请求和分配信息；提供一种算法，它利用这些信息来检测系统是否已进入死锁状态。</p><ol><li>资源分配图</li><li>死锁定理</li><li>死锁检测中的数据结构</li></ol><h6 id="3-1-11-4-4-解除死锁"><a href="#3-1-11-4-4-解除死锁" class="headerlink" title="3.1.11.4.4 解除死锁"></a>3.1.11.4.4 解除死锁</h6><p><img src="https://i.imgur.com/d6rQods.png" alt></p><h2 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h2><h3 id="4-1-存储层次"><a href="#4-1-存储层次" class="headerlink" title="4.1 存储层次"></a>4.1 存储层次</h3><p><img src="https://i.imgur.com/9PSHyPC.png" alt></p><ol><li>寄存器和主存储器被称为可执行存储器。</li><li>主存储器简称内存或主存，是计算机系统中的主要部件，用于保存进程运行时的程序和数据。</li><li>高速缓存介于寄存器和存储器之间的存储器，主要用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数，这样可大幅度地提高程序执行速度</li><li>磁盘缓存本身并不是一种实际存在的存储器</li></ol><h3 id="4-2-应用程序的编译、链接、装入"><a href="#4-2-应用程序的编译、链接、装入" class="headerlink" title="4.2 应用程序的编译、链接、装入"></a>4.2 应用程序的编译、链接、装入</h3><h4 id="4-2-1-链接："><a href="#4-2-1-链接：" class="headerlink" title="4.2.1 链接："></a>4.2.1 链接：</h4><p>由链接程序(Linker)将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块(Load Module)</p><ol><li>静态链接</li><li>装入时动态链接</li><li>运行时动态链接</li></ol><h4 id="4-2-2-装入：由装入程序-Loader-将装入模块装入内存"><a href="#4-2-2-装入：由装入程序-Loader-将装入模块装入内存" class="headerlink" title="4.2.2 装入：由装入程序(Loader)将装入模块装入内存"></a>4.2.2 装入：由装入程序(Loader)将装入模块装入内存</h4><ol><li>绝对装入：在编译时就知道程序将要在内存中的物理地址，产生绝对地址(即物理地址)的目标代码。</li><li>可重定位装入：又称为静态重定位。对于用户程序编译所形成的若干个目标模块，它们的起始地址通常都是从0开始的，程序中的其它地址也都是相对于起始地址计算的。</li><li>动态运行时装入：又称为动态重定位。装入程序把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行的时候。</li><li>重定位：把在装入时对目标程序中指令和数据地址的修改过程称为重定位。逻辑地址→物理地址</li></ol><h3 id="4-3-连续分配存储管理方式"><a href="#4-3-连续分配存储管理方式" class="headerlink" title="4.3 连续分配存储管理方式"></a>4.3 连续分配存储管理方式</h3><h4 id="4-3-1-单一连续分配："><a href="#4-3-1-单一连续分配：" class="headerlink" title="4.3.1 单一连续分配："></a>4.3.1 单一连续分配：</h4><p>单道程序环境，在用户区内存中，仅装有一道用户程序，即整个内存的用户空间由该程序独占</p><h4 id="4-3-2-固定分区分配："><a href="#4-3-2-固定分区分配：" class="headerlink" title="4.3.2 固定分区分配："></a>4.3.2 固定分区分配：</h4><p>将内存划分为多个固定大小的分区，每个分区装入一道作业，例如IBM 360。程序通常采用静态重定位的方式装入内存。<br>缺点：不能实现各进程共享一个主寸去，利用率低，会产生内部碎片</p><h5 id="4-3-2-1-划分分区的方法"><a href="#4-3-2-1-划分分区的方法" class="headerlink" title="4.3.2.1 划分分区的方法"></a>4.3.2.1 划分分区的方法</h5><ol><li>分区大小相等：缺乏灵活性，但方便实用，被广泛采用。</li><li>分区大小不等：一般会划分成多个较小分区、适量中等分区和少量大分区。</li></ol><h5 id="4-3-2-2-内存分配："><a href="#4-3-2-2-内存分配：" class="headerlink" title="4.3.2.2 内存分配："></a>4.3.2.2 内存分配：</h5><p>将分区按其大小进行排队，建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态(是否已分配)。</p><h4 id="4-3-3-动态分区分配："><a href="#4-3-3-动态分区分配：" class="headerlink" title="4.3.3 动态分区分配："></a>4.3.3 动态分区分配：</h4><p>为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业</p><h3 id="4-4-※基于顺序搜索的动态分区分配算法——适用于不太大的系统。"><a href="#4-4-※基于顺序搜索的动态分区分配算法——适用于不太大的系统。" class="headerlink" title="4.4 ※基于顺序搜索的动态分区分配算法——适用于不太大的系统。"></a>4.4 ※基于顺序搜索的动态分区分配算法——适用于不太大的系统。</h3><p>将系统中的空闲分区连接成一个链。但对于大型系统，因为链太长，所以效率低下。</p><ol><li>首次适应(first fit，FF)算法</li><li>循环首次适应(next fit，NF)算法</li><li>最佳适应(best fit，BF)算法</li><li>最坏适应(worst fit，WF)算法</li></ol><h3 id="4-5-基于索引搜索的动态分区分配算法——大中型系统中采用"><a href="#4-5-基于索引搜索的动态分区分配算法——大中型系统中采用" class="headerlink" title="4.5 基于索引搜索的动态分区分配算法——大中型系统中采用"></a>4.5 基于索引搜索的动态分区分配算法——大中型系统中采用</h3><ol><li>快速适应(quick fit)算法 又称为分类搜索法</li><li>伙伴系统(buddy system)</li><li>哈希算法</li></ol><h3 id="4-6-内部碎片-amp-amp-外部碎片的区别"><a href="#4-6-内部碎片-amp-amp-外部碎片的区别" class="headerlink" title="4.6 内部碎片&amp;&amp;外部碎片的区别"></a>4.6 内部碎片&amp;&amp;外部碎片的区别</h3><p><img src="https://i.imgur.com/K6vInmQ.png" alt></p><h3 id="4-7-※非连续（离散）分配存储管理方式"><a href="#4-7-※非连续（离散）分配存储管理方式" class="headerlink" title="4.7 ※非连续（离散）分配存储管理方式"></a>4.7 ※非连续（离散）分配存储管理方式</h3><h4 id="4-7-1-分页存储管理方式"><a href="#4-7-1-分页存储管理方式" class="headerlink" title="4.7.1 分页存储管理方式"></a>4.7.1 分页存储管理方式</h4><p>内存空间分为若干个“物理块”或“页框”。<br>页和块大小相同。<br><img src="https://i.imgur.com/HNuLTZw.png" alt></p><ol><li>页面——进程的逻辑地址空间被分成若干个页，并加从0开始的编号；内存的物理地址空间分成若干物理块，并加从0开始的编号。最后会形成页内碎片。</li><li>页面大小通常为1K-8K</li><li>页表——在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。每个进程有一个页表。由页号和块号组成。 </li></ol><h4 id="4-7-2-地址变换机构——逻辑地址物理地址-借助页表完成"><a href="#4-7-2-地址变换机构——逻辑地址物理地址-借助页表完成" class="headerlink" title="4.7.2 地址变换机构——逻辑地址物理地址 借助页表完成"></a>4.7.2 地址变换机构——逻辑地址物理地址 借助页表完成</h4><ol><li>基本的地址变换机构<br> 大部分页表是驻留内存的。<br> 系统中仅设置一个页表寄存器（PTR），存放页表在内存中的起始地址和长度。<br> 进程未执行时，页表起始地址和长度放在该进程的PCB中，执行时才装入页表寄存器。  </li></ol><p><img src="https://i.imgur.com/8HlYsAP.jpg" alt></p><ol start="2"><li>具有块表的地址变换机构<br> 为提高地址变换速度，增设特殊高速缓冲寄存器，又称“联想寄存器”或“快表”。<br> CPU给出有效地址，在快表中查找页号：如果找到，直接可以读出物理地址；如果找不到，再到内存中找，并重新修改快表（如果快表已满，则需要换出一个被认为是不再需要的页表项）</li></ol><p><img src="https://i.imgur.com/YNZE2we.jpg" alt></p><h4 id="4-7-3-访问内存的有效时间-Effective-Access-Time，EAT"><a href="#4-7-3-访问内存的有效时间-Effective-Access-Time，EAT" class="headerlink" title="4.7.3 访问内存的有效时间(Effective Access Time，EAT)"></a>4.7.3 访问内存的有效时间(Effective Access Time，EAT)</h4><h5 id="4-7-3-1-定义："><a href="#4-7-3-1-定义：" class="headerlink" title="4.7.3.1 定义："></a>4.7.3.1 定义：</h5><p>从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间。<br>假设访问一次内存的时间为t，在基本分页存储管理方式中，有效访问时间分为第一次访问内存时间(即查找页表对应的页表项所耗费的时间t)与第二次访问内存时间(即将需要的指令或数据取出所耗费的时间t)之和：<br><code>EAT = t + t = 2t</code><br>在引入快表的分页存储管理方式中，有效访问时间的计算公式即为：<br><code>EAT=а×λ+(t+λ)(1—а)+t=2t+λ—t×а</code><br>上式中，λ表示查找快表所需要的时间，а表示命中率，t表示访问一次内存所需要的时间。</p><h4 id="4-7-4-两级和多级页表"><a href="#4-7-4-两级和多级页表" class="headerlink" title="4.7.4 两级和多级页表"></a>4.7.4 两级和多级页表</h4><p>两级页表：为离散分配的页表再建立一张页表，称为外层页表(Outer Page Table)，在每个页表项中记录了页表页面的物理块号。为了方便实现地址变换，在地址变换机构中，同样需要增设一个外层页表寄存器，用于存放外层页表的始址</p><h4 id="4-7-5-反置页表"><a href="#4-7-5-反置页表" class="headerlink" title="4.7.5 反置页表"></a>4.7.5 反置页表</h4><h4 id="4-7-6-分段存储管理方式：用户程序地址空间分为若干大小不同的段"><a href="#4-7-6-分段存储管理方式：用户程序地址空间分为若干大小不同的段" class="headerlink" title="4.7.6 分段存储管理方式：用户程序地址空间分为若干大小不同的段"></a>4.7.6 分段存储管理方式：用户程序地址空间分为若干大小不同的段</h4><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">单道多道</td><td align="center">单一连续分配固定分区分配</td></tr><tr><td align="center">使用不同大小的程序要求</td><td align="center">固定分区分配动态分区分配</td></tr><tr><td align="center">提高内存利用率</td><td align="center">连续分配离散分配（分页）</td></tr><tr><td align="center">满足程序员编程和使用方便</td><td align="center">出现分段（需要语言编译程序支持）</td></tr></tbody></table><h5 id="4-7-6-1-引入原因"><a href="#4-7-6-1-引入原因" class="headerlink" title="4.7.6.1 引入原因"></a>4.7.6.1 引入原因</h5><ol><li>方便编程</li><li>信息共享</li><li>信息保护</li><li>动态增长</li><li>动态链接<br> 在程序运行过程中，当需要调用某个目标程序时，才将该段(目标程序)调入内存并进行链接。 动态链接要求的是以目标程序（段）作为链接的基本单位。∴分段存储管理方式非常适合动态链接</li></ol><h5 id="4-7-6-2-基本原理"><a href="#4-7-6-2-基本原理" class="headerlink" title="4.7.6.2 基本原理"></a>4.7.6.2 基本原理</h5><h6 id="4-7-6-2-1-分段"><a href="#4-7-6-2-1-分段" class="headerlink" title="4.7.6.2.1 分段"></a>4.7.6.2.1 分段</h6><p>分段地址中的地址具有如下结构</p><p><img src="https://i.imgur.com/dLYKYgX.png" alt></p><p>该地址结构中，允许一个作业最长有64K个段，每个段最长64KB</p><h6 id="4-7-6-2-2-段表——为每个进程建立一张段映射表"><a href="#4-7-6-2-2-段表——为每个进程建立一张段映射表" class="headerlink" title="4.7.6.2.2 段表——为每个进程建立一张段映射表"></a>4.7.6.2.2 段表——为每个进程建立一张段映射表</h6><p>在分段式存储管理系统中，则是为每个分段分配一个连续的分区。进程中的各个段，可以离散地装入内存中不同的分区中。每个段占一个表项，记录该段在内存中的起始地址（基址）和段长。</p><h6 id="4-7-6-2-3-地址变换机构"><a href="#4-7-6-2-3-地址变换机构" class="headerlink" title="4.7.6.2.3 地址变换机构"></a>4.7.6.2.3 地址变换机构</h6><h4 id="4-7-7-分页和分段的主要区别"><a href="#4-7-7-分页和分段的主要区别" class="headerlink" title="4.7.7 分页和分段的主要区别"></a>4.7.7 分页和分段的主要区别</h4><ol><li>页是信息的物理单位，分页仅仅是系统管理上的需要，对用户不可见。段是逻辑单位，分段的目的是能更好地满足用户的需要。</li><li>页的大小固定且由系统决定，每个系统中只能有一种大小的页面。段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分</li></ol><h4 id="4-7-8-信息分享"><a href="#4-7-8-信息分享" class="headerlink" title="4.7.8 信息分享"></a>4.7.8 信息分享</h4><p>可重入代码又称为纯代码，是一种允许多个进程同时访问的代码。</p><h4 id="4-7-9-段页式存储管理方式：上面两点结合，目前应用很广"><a href="#4-7-9-段页式存储管理方式：上面两点结合，目前应用很广" class="headerlink" title="4.7.9 段页式存储管理方式：上面两点结合，目前应用很广"></a>4.7.9 段页式存储管理方式：上面两点结合，目前应用很广</h4><h5 id="4-7-9-1-基本原理："><a href="#4-7-9-1-基本原理：" class="headerlink" title="4.7.9.1 基本原理："></a>4.7.9.1 基本原理：</h5><p>先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。</p><p><img src="https://i.imgur.com/cZ2SJT1.jpg" alt></p><h5 id="4-7-9-2-地址变换过程"><a href="#4-7-9-2-地址变换过程" class="headerlink" title="4.7.9.2 地址变换过程"></a>4.7.9.2 地址变换过程</h5><p>配置一个段表寄存器，存放段表始址和段长TL。<br>首先利用段号S，将它与段长TL进行比较，若未越界，利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，利用逻辑地址中的段内页号P来获得对应页的页表项位置，读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。</p><p><img src="https://i.imgur.com/x2nyHi0.jpg" alt></p><h5 id="4-7-9-3-为了获得一条指令或数据，需要三次访问内存。"><a href="#4-7-9-3-为了获得一条指令或数据，需要三次访问内存。" class="headerlink" title="4.7.9.3 为了获得一条指令或数据，需要三次访问内存。"></a>4.7.9.3 为了获得一条指令或数据，需要三次访问内存。</h5><ol><li>访问内存中的段表，取得页表地址。</li><li>访问内存中的页表，取得物理块号，并与页内地址合并成物理地址。</li><li>取出内存中的指令或数据。</li></ol><p><img src="https://i.imgur.com/lw2tRmJ.png" alt></p><h2 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h2><h3 id="5-1-定义："><a href="#5-1-定义：" class="headerlink" title="5.1 定义："></a>5.1 定义：</h3><p>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</p><h3 id="5-2-特征：多次性，对换性，虚拟性"><a href="#5-2-特征：多次性，对换性，虚拟性" class="headerlink" title="5.2 特征：多次性，对换性，虚拟性"></a>5.2 特征：多次性，对换性，虚拟性</h3><h3 id="5-3-※实现方法"><a href="#5-3-※实现方法" class="headerlink" title="5.3 ※实现方法"></a>5.3 ※实现方法</h3><h4 id="5-3-1-分页请求系统："><a href="#5-3-1-分页请求系统：" class="headerlink" title="5.3.1 分页请求系统："></a>5.3.1 分页请求系统：</h4><p>在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。  </p><p><img src="https://i.imgur.com/AVm6Fhy.jpg" alt></p><h5 id="5-3-1-1硬件支持："><a href="#5-3-1-1硬件支持：" class="headerlink" title="5.3.1.1硬件支持："></a>5.3.1.1硬件支持：</h5><ol><li>请求分页的页表机制</li><li>缺页中断机构</li><li>※地址变换机构</li></ol><h5 id="5-3-1-2-实现请求分页的软件：用于实现调页的软件和实现页面置换的软件。"><a href="#5-3-1-2-实现请求分页的软件：用于实现调页的软件和实现页面置换的软件。" class="headerlink" title="5.3.1.2 实现请求分页的软件：用于实现调页的软件和实现页面置换的软件。"></a>5.3.1.2 实现请求分页的软件：用于实现调页的软件和实现页面置换的软件。</h5><h5 id="5-3-1-3-请求分页中的内存分配："><a href="#5-3-1-3-请求分页中的内存分配：" class="headerlink" title="5.3.1.3 请求分页中的内存分配："></a>5.3.1.3 请求分页中的内存分配：</h5><ol><li>最小物理块数的确定：指能保证进程正常运行所需要的最小物理块数</li><li>内存分配策略：<ul><li>固定分配局部置换</li><li>可变分配全局置换</li><li>可变分配局部置换</li></ul></li><li>物理块分配算法：<ul><li>平均分配算法</li><li>按比例分配算法</li><li>考虑优先权的分配算法</li></ul></li></ol><h4 id="5-3-2-请求分段系统："><a href="#5-3-2-请求分段系统：" class="headerlink" title="5.3.2 请求分段系统："></a>5.3.2 请求分段系统：</h4><p>在分段系统的基础上增加了请求调段及分段置换功能后形成的段式虚拟存储系统。</p><h5 id="5-3-2-1-硬件支持："><a href="#5-3-2-1-硬件支持：" class="headerlink" title="5.3.2.1 硬件支持："></a>5.3.2.1 硬件支持：</h5><ol><li>请求分段的段表机制</li><li>缺页中断机构</li><li>地址变换机构</li></ol><h5 id="5-3-2-2-软件支持：用于实现请求调段的软件和实现段置换的软件。"><a href="#5-3-2-2-软件支持：用于实现请求调段的软件和实现段置换的软件。" class="headerlink" title="5.3.2.2 软件支持：用于实现请求调段的软件和实现段置换的软件。"></a>5.3.2.2 软件支持：用于实现请求调段的软件和实现段置换的软件。</h5><h3 id="5-4-页面调入策略"><a href="#5-4-页面调入策略" class="headerlink" title="5.4 页面调入策略"></a>5.4 页面调入策略</h3><h4 id="5-4-1-何时调入页面"><a href="#5-4-1-何时调入页面" class="headerlink" title="5.4.1 何时调入页面"></a>5.4.1 何时调入页面</h4><ol><li>预调页策略：调入那些预计不久之后便会被访问的页面，目前成功率仅约50%。但某些方面取得了良好的效果。</li><li>请求调页策略：若发现页面不在内存，立即提出请求，由OS将其调入内存。该方法易于实现，目前虚拟存储器中，大多采用该策略。</li></ol><h4 id="5-4-2-从何处调入页面"><a href="#5-4-2-从何处调入页面" class="headerlink" title="5.4.2 从何处调入页面"></a>5.4.2 从何处调入页面</h4><p>请求调页系统的外存分为两部分：文件区（离散分配方式，慢）和对换区（连续分配方式，快）。  </p><ol><li>系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页速度。</li><li>系统缺少足够的对换区空间，这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改，则不必再将它们重写到磁盘(换出)，以后再调入时，仍从文件区直接调入。但对于那些可能被修改的部分，在将它们换出时便须调到对换区，以后需要时再从对换区调入。</li></ol><h4 id="5-4-3-页面调入过程"><a href="#5-4-3-页面调入过程" class="headerlink" title="5.4.3 页面调入过程"></a>5.4.3 页面调入过程</h4><h4 id="5-4-4-缺页率"><a href="#5-4-4-缺页率" class="headerlink" title="5.4.4 缺页率"></a>5.4.4 缺页率</h4><p>假设一个进程的逻辑空间为n页，系统为其分配的内存物理块数为m(m≤n)。如果在进程的运行过程中，访问页面成功(即所访问页面在内存中)的次数为S，访问页面失败(即所访问页面不在内存中，需要从外存调入)的次数为F，则该进程总的页面访问次数为A = S + F，那么该进程在其运行过程中的缺页率即为 f = F / A</p><h5 id="5-4-4-1-影响缺页率的几个因素："><a href="#5-4-4-1-影响缺页率的几个因素：" class="headerlink" title="5.4.4.1 影响缺页率的几个因素："></a>5.4.4.1 影响缺页率的几个因素：</h5><ol><li>页面大小</li><li>进程所分配的物理块数目</li><li>页面置换算法</li><li>程序固有特性（程序编制的局部化程度）</li></ol><p>假设被置换的页面被修改的概率是β，其缺页中断处理时间为ta，被置换页面没有被修改的缺页中断时间为tb，那么，缺页中断处理时间的计算公式为t=β×ta+(1—β)×tb</p><h3 id="5-5-※页面置换算法"><a href="#5-5-※页面置换算法" class="headerlink" title="5.5 ※页面置换算法"></a>5.5 ※页面置换算法</h3><h4 id="5-5-1-最佳置换算法-OPT-："><a href="#5-5-1-最佳置换算法-OPT-：" class="headerlink" title="5.5.1 最佳置换算法(OPT)："></a>5.5.1 最佳置换算法(OPT)：</h4><p>其所选择的被淘汰页面将是以后永不使用的，或许是在最长(未来)时间内不再被访问的页面。采用最佳置换算法通常可保证获得最低的缺页率。<br>该算法是无法实现的，可以利用该算法去评价其它算法。</p><h4 id="5-5-2-先进先出-FIFO-页面置换算法："><a href="#5-5-2-先进先出-FIFO-页面置换算法：" class="headerlink" title="5.5.2 先进先出(FIFO)页面置换算法："></a>5.5.2 先进先出(FIFO)页面置换算法：</h4><p>淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。</p><h4 id="5-5-3-Belady异常："><a href="#5-5-3-Belady异常：" class="headerlink" title="5.5.3 Belady异常："></a>5.5.3 Belady异常：</h4><p>当所分配的物理块数增大而缺页中断数不减反增的异常现象。<br>FIFO算法可能出现Belady异常，而LRU和OPT算法永远不会出现Belady异常。</p><h4 id="5-5-4-最近最久未使用（LRU）置换算法："><a href="#5-5-4-最近最久未使用（LRU）置换算法：" class="headerlink" title="5.5.4 最近最久未使用（LRU）置换算法："></a>5.5.4 最近最久未使用（LRU）置换算法：</h4><p>选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间，选择该时间最大的做为淘汰对象。</p><h4 id="5-5-5-最少使用（LFU-置换算法："><a href="#5-5-5-最少使用（LFU-置换算法：" class="headerlink" title="5.5.5 最少使用（LFU)置换算法："></a>5.5.5 最少使用（LFU)置换算法：</h4><p>选择在最近时期使用最少的页面作为淘汰页。</p><h4 id="5-5-6-Clock置换算法"><a href="#5-5-6-Clock置换算法" class="headerlink" title="5.5.6 Clock置换算法"></a>5.5.6 Clock置换算法</h4><h4 id="5-5-7-改进的Clock置换算法"><a href="#5-5-7-改进的Clock置换算法" class="headerlink" title="5.5.7 改进的Clock置换算法"></a>5.5.7 改进的Clock置换算法</h4><h4 id="5-5-8-页面缓冲算法（PBA）"><a href="#5-5-8-页面缓冲算法（PBA）" class="headerlink" title="5.5.8 页面缓冲算法（PBA）"></a>5.5.8 页面缓冲算法（PBA）</h4><h5 id="5-5-8-1-PBA算法的主要特点是："><a href="#5-5-8-1-PBA算法的主要特点是：" class="headerlink" title="5.5.8.1 PBA算法的主要特点是："></a>5.5.8.1 PBA算法的主要特点是：</h5><ol><li>显著地降低了页面换进、换出的频率，使磁盘I/O的操作次数大为减少，因而减少了页面换进、换出的开销；</li><li>正是由于换入换出的开销大幅度减小，才能使其采用一种较简单的置换策略，如先进先出(FIFO)算法，它不需要特殊硬件的支持，实现起来非常简单。 <ul><li>空闲页面链表</li><li>修改页面链表</li></ul></li></ol><h4 id="5-5-9-访问内存的有效时间"><a href="#5-5-9-访问内存的有效时间" class="headerlink" title="5.5.9 访问内存的有效时间"></a>5.5.9 访问内存的有效时间</h4><p>与基本分页存储管理方式不同，在请求分页管理方式中，内存有效访问时间不仅要考虑访问页表和访问实际物理地址数据的时间，还必须要考虑到缺页中断的处理时间。   </p><ol><li>被访问页在内存中，且其对应的页表在快表中  <ul><li>EAT=λ+t λ：查找快表的时间 t：访问实际物理地址所需的时间  </li></ul></li><li>被访问页在内存中，且其对应的页表不在快表中  <ul><li>EAT=λ+t+λ+t 查找快表时间、查找页表时间、更新快表、访问实际物理地址所需的时间  </li></ul></li><li>被访问页不在内存中<ul><li>EAT=λ+t+ε+λ+t 查找快表、查找页表、处理缺页中断时间、更新快表、访问实际物理地址 </li></ul></li></ol><h2 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h2><h3 id="6-1-IO系统的主要任务："><a href="#6-1-IO系统的主要任务：" class="headerlink" title="6.1 IO系统的主要任务："></a>6.1 IO系统的主要任务：</h3><p>完成用户提出的IO请求，提高IO速率，提高设备的利用率</p><h3 id="6-2-IO系统的基本功能"><a href="#6-2-IO系统的基本功能" class="headerlink" title="6.2 IO系统的基本功能"></a>6.2 IO系统的基本功能</h3><p>隐藏物理设备的细节，与设备的无关性，提高处理机和IO设备的利用率，对IO设备进行控制，确保对设备的正确共享，错误处理</p><h3 id="6-3-IO设备分类："><a href="#6-3-IO设备分类：" class="headerlink" title="6.3 IO设备分类："></a>6.3 IO设备分类：</h3><ol><li>按使用特性分<ul><li>人机交互类外设，如打印机、显示器、键盘、鼠标等</li><li>存储设备，如磁盘、光盘等</li><li>网络通信设备，如各种网络接口、调制解调器</li></ul></li><li>按传输速率分<ul><li>低速设备，如键盘、鼠标。每秒几个到数百个字节</li><li>中速设备，如打印机。每秒数千个字节至数万个字节</li><li>高速设备，如磁盘。每秒数百个千字节到千兆字节</li></ul></li><li>按信息交换单位分<ul><li>块设备，属于有结构设备，如磁盘</li><li>字符设备，属于无结构设备，如打印机</li></ul></li></ol><h3 id="6-4-IO控制方式："><a href="#6-4-IO控制方式：" class="headerlink" title="6.4 IO控制方式："></a>6.4 IO控制方式：</h3><ol><li>程序直接控制方式</li><li>中断驱动方式</li><li>DMA方式</li><li>通道控制方式</li></ol><h3 id="6-5-系统调用是应用程序取得OS所有服务的唯一途径。C语言中，首先提供了与系统调用相对应的库函数。"><a href="#6-5-系统调用是应用程序取得OS所有服务的唯一途径。C语言中，首先提供了与系统调用相对应的库函数。" class="headerlink" title="6.5 系统调用是应用程序取得OS所有服务的唯一途径。C语言中，首先提供了与系统调用相对应的库函数。"></a>6.5 系统调用是应用程序取得OS所有服务的唯一途径。C语言中，首先提供了与系统调用相对应的库函数。</h3><h3 id="6-6-缓冲区的引入"><a href="#6-6-缓冲区的引入" class="headerlink" title="6.6 缓冲区的引入"></a>6.6 缓冲区的引入</h3><ol><li>缓和CPU与I/O设备间速度不匹配的矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li><li>解决数据粒度不匹配的问题</li><li>提高CPU和I/O设备之间的并行性。</li></ol><h3 id="6-7-各种缓冲区"><a href="#6-7-各种缓冲区" class="headerlink" title="6.7 各种缓冲区"></a>6.7 各种缓冲区</h3><ol><li>单缓冲区</li><li>双缓冲区</li><li>环形缓冲区</li><li>缓冲池</li></ol><h2 id="第七章-文件管理"><a href="#第七章-文件管理" class="headerlink" title="第七章 文件管理"></a>第七章 文件管理</h2><p>系统运行时，计算机以进程为基本单位进行资源的调度和分配；在用户进行的输入输出中，则以文件为基本单位。</p><h3 id="7-1-文件的组成："><a href="#7-1-文件的组成：" class="headerlink" title="7.1 文件的组成："></a>7.1 文件的组成：</h3><p>包含一块存储空间（其实是存储空间中的数据），包含分类和检索信息，包含关于访问权限的信息。</p><h3 id="7-2-文件的结构：数据项、记录和文件"><a href="#7-2-文件的结构：数据项、记录和文件" class="headerlink" title="7.2 文件的结构：数据项、记录和文件"></a>7.2 文件的结构：数据项、记录和文件</h3><h4 id="7-2-1-数据项：在文件系统中，数据项是最低级的数据组织形式。"><a href="#7-2-1-数据项：在文件系统中，数据项是最低级的数据组织形式。" class="headerlink" title="7.2.1 数据项：在文件系统中，数据项是最低级的数据组织形式。"></a>7.2.1 数据项：在文件系统中，数据项是最低级的数据组织形式。</h4><p>可分为以下两种类型：  </p><ol><li>基本数据项：用于描述一个对象的某种属性的一个值，例如姓名、证件号码、日期等。是数据中可命名的最小逻辑数据单位，即原子数据。  </li><li>组合数据项：由多个基本数据项组成。</li></ol><h4 id="7-2-2-记录：是一组相关数据项的集合，用于描述一个对象在某方面的属性。"><a href="#7-2-2-记录：是一组相关数据项的集合，用于描述一个对象在某方面的属性。" class="headerlink" title="7.2.2 记录：是一组相关数据项的集合，用于描述一个对象在某方面的属性。"></a>7.2.2 记录：是一组相关数据项的集合，用于描述一个对象在某方面的属性。</h4><p>如一个考生报名记录包括姓名、出生日期、报考学校、身份证号等一系列域。</p><h4 id="7-2-3-文件：是指由创建者所定义的、具有文件名的一组相关元素的集合。"><a href="#7-2-3-文件：是指由创建者所定义的、具有文件名的一组相关元素的集合。" class="headerlink" title="7.2.3 文件：是指由创建者所定义的、具有文件名的一组相关元素的集合。"></a>7.2.3 文件：是指由创建者所定义的、具有文件名的一组相关元素的集合。</h4><p>可分为以下两种类型：  </p><ol><li>有结构文件：文件由一组相似记录组成，又称记录式文件。例如报考某一学校的所有考生报名信息。</li><li>无结构文件：看作一个字符流，又称流式文件。例如一个二进制文件或字符文件。</li></ol><h3 id="7-3-文件的属性"><a href="#7-3-文件的属性" class="headerlink" title="7.3 文件的属性"></a>7.3 文件的属性</h3><ol><li>名称，唯一。</li><li>标识符，文件系统内标识文件的唯一标志，一般为数字。</li><li>类型，一般由不同的扩展名表示。</li><li>位置。</li><li>大小。</li><li>保护，对文件进行保护的访问控制信息。</li><li>时间、日期和用户标识，创建、上次修改、上次访问等信息。</li></ol><h3 id="7-4-文件的基本操作"><a href="#7-4-文件的基本操作" class="headerlink" title="7.4 文件的基本操作"></a>7.4 文件的基本操作</h3><h3 id="7-5-文件的打开与关闭"><a href="#7-5-文件的打开与关闭" class="headerlink" title="7.5 文件的打开与关闭"></a>7.5 文件的打开与关闭</h3><p>每个打开的文件都有如下信息：  </p><ol><li>文件指针，这个指针对打开文件的某个进程来说是唯一的。</li><li>文件打开计数，多个进程共用一个文件时用。</li><li>文件磁盘位置，该信息直接存入内存，避免每个文件操作都从磁盘读取。</li><li>访问权限。</li></ol><h3 id="7-6-文件的逻辑结构——指文件在外存上的存储组织形式"><a href="#7-6-文件的逻辑结构——指文件在外存上的存储组织形式" class="headerlink" title="7.6 文件的逻辑结构——指文件在外存上的存储组织形式"></a>7.6 文件的逻辑结构——指文件在外存上的存储组织形式</h3><ol><li>无结构文件（流式文件）</li><li>有结构文件（记录式文件）<ul><li>顺序文件 </li><li>索引文件 </li><li>索引顺序文件 </li><li>直接文件或散列文件</li></ul></li></ol><h3 id="7-7-目录结构：目录在用户（应用程序）所需要的文件名和文件之间提供一种映射"><a href="#7-7-目录结构：目录在用户（应用程序）所需要的文件名和文件之间提供一种映射" class="headerlink" title="7.7 目录结构：目录在用户（应用程序）所需要的文件名和文件之间提供一种映射"></a>7.7 目录结构：目录在用户（应用程序）所需要的文件名和文件之间提供一种映射</h3><ol><li>实现“按名存取”。</li><li>提高对目录的检索速度。</li><li>文件共享。</li><li>允许文件重名。</li></ol><h3 id="7-8-文件控制块FCB：用来存放控制文件需要的各种信息的数据结构-，以实现“按名存取”。"><a href="#7-8-文件控制块FCB：用来存放控制文件需要的各种信息的数据结构-，以实现“按名存取”。" class="headerlink" title="7.8 文件控制块FCB：用来存放控制文件需要的各种信息的数据结构,，以实现“按名存取”。"></a>7.8 文件控制块FCB：用来存放控制文件需要的各种信息的数据结构,，以实现“按名存取”。</h3><p>FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。<br>FCB包含： 文件基本信息；存取控制信息；使用信息。</p><h3 id="7-9-索引结点"><a href="#7-9-索引结点" class="headerlink" title="7.9 索引结点"></a>7.9 索引结点</h3><h4 id="7-9-1-引入："><a href="#7-9-1-引入：" class="headerlink" title="7.9.1 引入："></a>7.9.1 引入：</h4><p>在检索目录文件的过程中，只用到了文件名，仅当找到一个目录项时，才需要从该目录项中读出该文件的物理地址。因此，有的系统采用将文件名和文件描述信息分开的方法，文件描述信息单独形成一个称为索引结点的数据结构，简称为i结点。在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成。</p><h4 id="7-9-2-索引结点主要包括以下内容："><a href="#7-9-2-索引结点主要包括以下内容：" class="headerlink" title="7.9.2 索引结点主要包括以下内容："></a>7.9.2 索引结点主要包括以下内容：</h4><ol><li>文件主标识符，即拥有该文件的个人或小组的标识符；</li><li>文件类型，包括正规文件、目录文件或特别文件；</li><li>文件存取权限，指各类用户对该文件的存取权限；</li><li>文件物理地址，每一个索引结点中含有13个地址项，即iaddr(0)～iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号；</li><li>文件长度，指以字节为单位的文件长度；</li><li>文件连接计数，表明在本文件系统中所有指向该(文件的)文件名的指针计数；</li><li>文件存取时间，指出本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间。</li></ol><h3 id="7-10-文件目录结构"><a href="#7-10-文件目录结构" class="headerlink" title="7.10 文件目录结构"></a>7.10 文件目录结构</h3><p>需要执行的操作：搜索、创建文件、删除文件、显示目录、修改目录。</p><ol><li>单级文件目录</li><li>两级文件目录</li><li>多级目录结构（树形结构目录)：最通用且实用的文件目录无疑是树形结构目录</li></ol><h3 id="7-11-文件共享"><a href="#7-11-文件共享" class="headerlink" title="7.11 文件共享"></a>7.11 文件共享</h3><ol><li>基于有向无环图实现文件共享：有向无环图DAG，利用索引结点（硬链接）（文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针）</li><li>利用符号链接实现文件共享（软链接）</li></ol><h2 id="第八章-磁盘存储器的管理"><a href="#第八章-磁盘存储器的管理" class="headerlink" title="第八章 磁盘存储器的管理"></a>第八章 磁盘存储器的管理</h2><h3 id="8-1-磁盘存储器"><a href="#8-1-磁盘存储器" class="headerlink" title="8.1 磁盘存储器"></a>8.1 磁盘存储器</h3><p>∵磁盘存储器不仅容量大，存取速度快，而且可以实现随机存取 ∴磁盘存储器是实现虚拟存储器和存放文件最理想的外存。</p><h3 id="8-2-磁盘存储器管理的主要任务和要求："><a href="#8-2-磁盘存储器管理的主要任务和要求：" class="headerlink" title="8.2 磁盘存储器管理的主要任务和要求："></a>8.2 磁盘存储器管理的主要任务和要求：</h3><ol><li>有效地利用存储空间</li><li>提高磁盘的IO速度</li><li>提高磁盘系统的可靠性</li></ol><h3 id="8-3-常见的外存组织方式："><a href="#8-3-常见的外存组织方式：" class="headerlink" title="8.3 常见的外存组织方式："></a>8.3 常见的外存组织方式：</h3><ol><li><p>连续组织方式（连续分配方式）</p><ul><li>优点：顺序访问容易；顺序访问速度快</li><li>缺点：<ul><li>要求为一个文件分配连续的存储空间</li><li>必须事先知道文件的长度</li><li>不能灵活地删除和插入记录</li><li>对于那些动态增长的文件，由于事先很难知道文件的文件，很难分配空间。</li></ul></li></ul></li><li><p>链接组织方式</p><ul><li>优点：<ul><li>消除了磁盘的外部碎片，提高了外存的利用率</li><li>对插入、删除和修改记录都非常容易</li><li>能适应文件的动态增长，无需事先知道文件的大小。</li></ul></li><li>隐式链接：只适用于顺序访问</li><li>显式链接：把用于链接文件各物理块的指针显式地存放在内存的一张链接表中——文件分配表FAT</li></ul></li><li><p>索引组织方式</p></li></ol><h3 id="8-4-文件存储空间的管理："><a href="#8-4-文件存储空间的管理：" class="headerlink" title="8.4 文件存储空间的管理："></a>8.4 文件存储空间的管理：</h3><ol><li>空闲表法</li><li>空闲链表法</li><li>位视图法（位视图 盘块的分配 回收）</li></ol><h3 id="8-5-提高磁盘IO速度方法："><a href="#8-5-提高磁盘IO速度方法：" class="headerlink" title="8.5 提高磁盘IO速度方法："></a>8.5 提高磁盘IO速度方法：</h3><ol><li>改进目录结构及检索目录方法来减少查找时间</li><li>选取好的文件存储结构，以提高对文件的访问速度</li><li>提高磁盘IO速度，能将文件中的数据块快速地从磁盘传送到内存中，或者相反</li></ol><h3 id="8-6-磁盘高速缓存："><a href="#8-6-磁盘高速缓存：" class="headerlink" title="8.6 磁盘高速缓存："></a>8.6 磁盘高速缓存：</h3><p>在内存中为磁盘盘块设置的一个缓冲区，在缓冲区中保存了某些盘块的副本。</p><h3 id="8-7-提高磁盘IO速度的其他方法："><a href="#8-7-提高磁盘IO速度的其他方法：" class="headerlink" title="8.7 提高磁盘IO速度的其他方法："></a>8.7 提高磁盘IO速度的其他方法：</h3><ol><li>提前读</li><li>延迟写</li><li>优化物理块的分布</li><li>虚拟盘</li></ol><h3 id="8-8-磁盘容错技术往往也被人们称为系统容错技术SFT。"><a href="#8-8-磁盘容错技术往往也被人们称为系统容错技术SFT。" class="headerlink" title="8.8 磁盘容错技术往往也被人们称为系统容错技术SFT。"></a>8.8 磁盘容错技术往往也被人们称为系统容错技术SFT。</h3><h3 id="8-9-提高磁盘可靠性技术："><a href="#8-9-提高磁盘可靠性技术：" class="headerlink" title="8.9 提高磁盘可靠性技术："></a>8.9 提高磁盘可靠性技术：</h3><p>第一级容错技术SFT1，第二级容错技术SFT2，集群技术的容错，后备系统（磁带机，硬盘，光盘驱动器）</p><h2 id="第九章-补充-操作系统的生命周期"><a href="#第九章-补充-操作系统的生命周期" class="headerlink" title="第九章 补充 操作系统的生命周期"></a>第九章 补充 操作系统的生命周期</h2><h3 id="9-1-开发方法"><a href="#9-1-开发方法" class="headerlink" title="9.1 开发方法"></a>9.1 开发方法</h3><ol><li>交叉开发<ul><li>开发新操作系统，移植操作系统到新机器。</li></ul></li><li>增量开发<ul><li>在已有操作系统上作内核，驱动程序更新和升级。</li></ul></li></ol><h3 id="9-2-引导程序的特征："><a href="#9-2-引导程序的特征：" class="headerlink" title="9.2 引导程序的特征："></a>9.2 引导程序的特征：</h3><ol><li>必须是512B，因为BIOS只读512B到内存。</li><li>结尾两个字节必须是“55AA”，这是引导扇区的标志。</li><li>引导程序总是放在磁盘的0磁头，0磁道，1扇区(CHS，Cylinder-head-sector，寻址方式）。 </li></ol><p>由此可知，即使你随意编写一段512B的程序，只要放在该位置，并符合第2点，BIOS都会认为这是你的引导程序，并将其调入内存。</p><h3 id="9-3-操作系统究竟如何开始"><a href="#9-3-操作系统究竟如何开始" class="headerlink" title="9.3 操作系统究竟如何开始:"></a>9.3 操作系统究竟如何开始:</h3><h4 id="9-3-1-由boot-s（bootsect-s）开始"><a href="#9-3-1-由boot-s（bootsect-s）开始" class="headerlink" title="9.3.1 由boot.s（bootsect.s）开始"></a>9.3.1 由boot.s（bootsect.s）开始</h4><p>boot被bios加载至7c00h（31k）处，并将自己移动到了地址90000h（576k）处，并跳转至那里。 使用BIOS中断将‘setup’直接加载到自己的后面地址90200h（576.5k)。将system加载到地址10000h处。</p><h4 id="9-3-2-调入setup-s"><a href="#9-3-2-调入setup-s" class="headerlink" title="9.3.2 调入setup.s"></a>9.3.2 调入setup.s</h4><h4 id="9-3-3-调入system模块，第一个文件是head-s，在此启动main-c"><a href="#9-3-3-调入system模块，第一个文件是head-s，在此启动main-c" class="headerlink" title="9.3.3 调入system模块，第一个文件是head.s，在此启动main.c"></a>9.3.3 调入system模块，第一个文件是head.s，在此启动main.c</h4><h4 id="9-3-4-执行main-c"><a href="#9-3-4-执行main-c" class="headerlink" title="9.3.4 执行main.c"></a>9.3.4 执行main.c</h4>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot打包部署</title>
      <link href="/2018/11/19/SpringBoot-7/"/>
      <url>/2018/11/19/SpringBoot-7/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot打包部署"><a href="#Spring-Boot打包部署" class="headerlink" title="Spring Boot打包部署"></a>Spring Boot打包部署</h2><h3 id="第一种方式-打包成jar包部署在服务器上"><a href="#第一种方式-打包成jar包部署在服务器上" class="headerlink" title="第一种方式 打包成jar包部署在服务器上"></a>第一种方式 打包成jar包部署在服务器上</h3><h4 id="1-1-添加插件"><a href="#1-1-添加插件" class="headerlink" title="1.1 添加插件"></a>1.1 添加插件</h4><pre><code>&lt;plugin&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;</code></pre><h4 id="1-2-打包"><a href="#1-2-打包" class="headerlink" title="1.2 打包"></a>1.2 打包</h4><p><img src="https://i.imgur.com/kOk16n2.png" alt></p><p>点开lifecycle 双击install 自动开始打包</p><h4 id="1-3-放到linux服务器上，使用-java-jar-SCM-v1-0-jar-命令运行"><a href="#1-3-放到linux服务器上，使用-java-jar-SCM-v1-0-jar-命令运行" class="headerlink" title="1.3 放到linux服务器上，使用 java -jar SCM-v1.0.jar 命令运行"></a>1.3 放到linux服务器上，使用 java -jar SCM-v1.0.jar 命令运行</h4><h4 id="1-4-报错：8080端口被占用"><a href="#1-4-报错：8080端口被占用" class="headerlink" title="1.4 报错：8080端口被占用"></a>1.4 报错：8080端口被占用</h4><p>Verify the connector’s configuration, identify and stop any process that’s listening on port 8080, or configure this application to listen on another port.<br>使用 lsof -i tcp:8080 命令来查看8080使用情况<br>解决：<br>①kill -9 进程的PID号 命令 杀死进程<br>②在application.properties文件中添加 server.port=8004 修改内置tomcat默认端口  </p><h3 id="第二种方式-使用Docker打包成镜像文件"><a href="#第二种方式-使用Docker打包成镜像文件" class="headerlink" title="第二种方式 使用Docker打包成镜像文件"></a>第二种方式 使用Docker打包成镜像文件</h3><h4 id="2-1-在pom-xml-–-properties-中添加以下内容"><a href="#2-1-在pom-xml-–-properties-中添加以下内容" class="headerlink" title="2.1 在pom.xml – properties 中添加以下内容"></a>2.1 在pom.xml – properties 中添加以下内容</h4><p><strong>prefix 必须小写字母或者包含数字的字符串，不可以是大写！！！</strong></p><pre><code>&lt;properties&gt;   &lt;docker.image.prefix&gt;springboot&lt;/docker.image.prefix&gt;&lt;/properties&gt;</code></pre><h4 id="2-2-在pom-xml文件中添加docker插件"><a href="#2-2-在pom-xml文件中添加docker插件" class="headerlink" title="2.2 在pom.xml文件中添加docker插件"></a>2.2 在pom.xml文件中添加docker插件</h4><pre><code>&lt;!-- Docker maven plugin --&gt;&lt;plugin&gt;    &lt;groupId&gt;com.spotify&lt;/groupId&gt;    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;    &lt;configuration&gt;        &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;        &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;targetPath&gt;/&lt;/targetPath&gt;                &lt;directory&gt;${project.build.directory}&lt;/directory&gt;                &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/configuration&gt;&lt;/plugin&gt;&lt;!-- Docker maven plugin --&gt;</code></pre><h4 id="2-3-在src-main-docker文件夹下创建Dockerfile文件，Dockerfile-文件用来说明如何来构建镜像"><a href="#2-3-在src-main-docker文件夹下创建Dockerfile文件，Dockerfile-文件用来说明如何来构建镜像" class="headerlink" title="2.3 在src/main/docker文件夹下创建Dockerfile文件，Dockerfile 文件用来说明如何来构建镜像"></a>2.3 在src/main/docker文件夹下创建Dockerfile文件，Dockerfile 文件用来说明如何来构建镜像</h4><p><img src="https://i.imgur.com/9BhAsFM.png" alt></p><pre><code>FROM openjdk:8-jdk-alpineVOLUME /tmpADD scm-v1.0.jar scm.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/scm.jar&quot;]</code></pre><p><strong>上面两个 scm.jar 的名字必须是一致的</strong></p><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:  </p><ol><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载  </li><li>VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录  </li><li>ADD ，拷贝文件并且重命名  </li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT  </li></ol><h4 id="2-4-构建docker环境"><a href="#2-4-构建docker环境" class="headerlink" title="2.4 构建docker环境"></a>2.4 构建docker环境</h4><pre><code>yum install docker</code></pre><h4 id="2-5-安装jdk"><a href="#2-5-安装jdk" class="headerlink" title="2.5 安装jdk"></a>2.5 安装jdk</h4><pre><code>yum -y install java-1.8.0-openjdk*</code></pre><p>配置环境变量 打开 vim /etc/profile 添加一下内容  </p><pre><code>export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64 export PATH=$PATH:$JAVA_HOME/bin </code></pre><p>修改完成之后，使其生效  </p><pre><code>source /etc/profile</code></pre><p>输入java -version 返回版本信息则安装正常。</p><h4 id="2-6-安装maven"><a href="#2-6-安装maven" class="headerlink" title="2.6 安装maven"></a>2.6 安装maven</h4><p>首先配置Apache源</p><pre><code>wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo</code></pre><p>使用yum安装</p><pre><code>yum -y install apache-maven</code></pre><h4 id="2-7-将完整的项目文件打包为zip文件，上传到linux下"><a href="#2-7-将完整的项目文件打包为zip文件，上传到linux下" class="headerlink" title="2.7 将完整的项目文件打包为zip文件，上传到linux下"></a>2.7 将完整的项目文件打包为zip文件，上传到linux下</h4><p>进入到项目路径下进行打包测试</p><pre><code>#打包mvn package#启动java -jar target/spring-boot-docker-1.0.jar</code></pre><p>运行之后输入ip:端口号进行测试<br>成功之后使用Dockerfile构建镜像文件<br><strong>必须先使用 mvn package 打包之后才能使用 docker:build 因为docker构建镜像需要把打包的jar文件复制到镜像中！！！需要管理员权限！！！</strong></p><h4 id="2-8-构建镜像"><a href="#2-8-构建镜像" class="headerlink" title="2.8 构建镜像"></a>2.8 构建镜像</h4><pre><code>mvn package docker:build</code></pre><p><img src="https://i.imgur.com/tXdcr3H.png" alt></p><blockquote><p>注：docker构建镜像时会从34.205.207.96下面拉openjdk，可能会超时，多试几次就好了<br>成功之后查看镜像文件</p></blockquote><p><img src="https://i.imgur.com/Txu8TJL.png" alt></p><h4 id="2-9-运行镜像文件"><a href="#2-9-运行镜像文件" class="headerlink" title="2.9 运行镜像文件"></a>2.9 运行镜像文件</h4><p>输入以下指令运行镜像文件</p><pre><code>docker run -p 8004:8004 -t springbootdocker/scm </code></pre><p>同时会自动创建对应的容器来运行镜像文件 </p><p><img src="https://i.imgur.com/lqKNL7S.png" alt></p><p>-p: 端口映射，格式为：主机(宿主)端口:容器端口<br>容器端口号与application.properties中写的server.port一致<br>主机（宿主）端口号是要访问虚拟机或服务器的端口号<br>比如application.properties中  </p><pre><code>server.port=8004</code></pre><p>如果是 <code>docker run -p 8004:8004 -t springbootdocker/scm</code> 就访问 服务器<code>IP:8004/user/home</code>启动<br>如果是 <code>docker run -p 8080:8004 -t springbootdocker/scm</code> 就访问 服务器<code>IP:8080/user/home</code>启动</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法初步（julyedu网课整理）</title>
      <link href="/2018/11/19/Algorithm-1/"/>
      <url>/2018/11/19/Algorithm-1/</url>
      
        <content type="html"><![CDATA[<h2 id="算法初步（julyedu网课整理）"><a href="#算法初步（julyedu网课整理）" class="headerlink" title="算法初步（julyedu网课整理）"></a>算法初步（julyedu网课整理）</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><h5 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h5><p>基本运算  </p><h5 id="O-logn"><a href="#O-logn" class="headerlink" title="O(logn)"></a>O(logn)</h5><p>二分查找 分治类问题基本上都有log  </p><h5 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h5><p>线性查找  </p><h5 id="O-n²"><a href="#O-n²" class="headerlink" title="O(n²)"></a>O(n²)</h5><p>冒泡排序；选择排序  </p><h5 id="O-n的3次方"><a href="#O-n的3次方" class="headerlink" title="O(n的3次方)"></a>O(n的3次方)</h5><p>Floyd最短路；普通矩阵乘法  </p><h5 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h5><p>归并排序和快速排序的期望复杂度；<br>基于比较排序的算法下界<br>原因：a1 a2 …… an 等n个数 共有n！次种分布可能<br>比较一次 ai &gt; aj 就筛选出来一半的结果 n！/ 2<br>比较第二次 ai &gt; aj 就筛选出来一半结果的一半 n！/ 4 = n！/ 2 ²<br>做k次比较 n！/ 2的k次方<br>所以要经过多少次比较才能得到最后的排序结果？<br>n！/ 2的k次方 = 1<br>n！ = 2的k次方<br>两边同时以2为底 log<br>log(n！) = k<br>因为log(n！)  &lt; log(n的n次方)<br>所以 k ≈ log(n的n次方) ≈ nlogn 下限最坏是nlogn  </p><h5 id="O-2的n次方"><a href="#O-2的n次方" class="headerlink" title="O(2的n次方)"></a>O(2的n次方)</h5><p>暴力枚举所有子集  </p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数据在内存中连续存储：数组；非连续存储：链表、树；<br>vector(C++) 读写速率都是O(1)<br>当数组空间满了，vector会自动开辟一个两倍空间，丢弃原来的空间，将原始数据copy过来，有k个数则时间复杂度O(k)</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>算法优化的时候会从最内层循环开始，因为最内层会被一直循环执行<br>ex:一个数组中，某一子集的和最大<br>ans = -2147483647 作为判断的下界<br>int最小值 -2147483648 最大值2147483647<br>暴力枚举：三重循环  </p><pre><code>for i ← 1 to n    for j ← i to n          sum ← a[i] + ... + a[j]        ans ← max(ans,sum)时间复杂度O(n的3次方) 附加空间复杂度O(1)</code></pre><p>优化枚举：两重循环<br>a[2] + a[3]<br>a[2] + a[3] + a[4]<br>=&gt; 不需要挨个加一遍，只需要把之前的结果保存再加后面的那一个数即可</p><pre><code>for i ← 1 to n       sum ← 0    for j ← i to n          sum ← sum + a[j]        ans ← max(ans,sum)时间复杂度O(n²) 附加空间复杂度O(1)</code></pre><p>贪心算法：一重循环</p><pre><code>sum ← 0; ans ← 0for i ← 1 to n    sum = sum + a[i]    ans ← max(ans,sum)    if(sum &lt; 0)        sum ← 0时间复杂度O(n) 附加空间复杂度O(1)</code></pre><p>if(sum &lt; 0) sum ← 0 这部分是代码最终优化之后的结果，但是直接看的话不容易理解</p><p>再优化：求最大值问题转化成求最小值问题<br>问题是求 max(a[i]…a[j])<br>假设 s[i] = a[0] + … + a[i]<br>那么问题就转化成 max(s[j] - s[i - 1])<br>对数组中的每一个j来说，s[j]是固定的，循环累加得到<br>那么问题就转化成 max(P - s[i - 1])，找到min(s[i - 1])</p><pre><code>public int maxSubArray(int[] nums) {    int n = nums.length;    if(n == 0)        return 0;    int si = 0;     int sj = 0;     int minSi = 0;     int ans = Integer.MIN_VALUE;    for(int j = 0; j &lt; n; ++j){        sj += nums[j];        if(si &lt; minSi)            minSi = si;        if(sj - minSi &gt; ans)            ans = sj - minSi;        si += nums[j];    }    return ans;}</code></pre><p>ex：[-2,1,-3,4,-1,2,1,-5,4]  </p><table><thead><tr><th>sj</th><th>minSi</th><th>ans</th><th>si</th><th>j</th></tr></thead><tbody><tr><td>-2</td><td>0</td><td>-2</td><td>-2</td><td>0</td></tr><tr><td>-1</td><td>-2</td><td>1</td><td>-1</td><td>1</td></tr><tr><td>-4</td><td>-2</td><td>1</td><td>-4</td><td>2</td></tr><tr><td>0</td><td>-4</td><td>4</td><td>0</td><td>3</td></tr><tr><td>-1</td><td>-4</td><td>4</td><td>-1</td><td>4</td></tr><tr><td>1</td><td>-4</td><td>5</td><td>1</td><td>5</td></tr><tr><td>2</td><td>-4</td><td>5</td><td>2</td><td>6</td></tr></tbody></table><p>sj不断累积<br>minSi取[0]…[j]中最小的那一个值<br>ans取sj - minSi中最大的那个一个值</p><p>优化：<br>sj += nums[j]<br>可以直接删掉，sj = si +nums[j]</p><pre><code>public int maxSubArray(int[] nums) {    int n = nums.length;    if(n == 0)        return 0;    int si = 0;     int minSi = 0;     int ans = Integer.MIN_VALUE;    for(int j = 0; j &lt; n; ++j){        if(si &lt; minSi)            minSi = si;        if(si + nums[j] - minSi &gt; ans)            ans = si + nums[j] - minSi;        si += nums[j];    }    return ans;}</code></pre><p>之后 if(si &lt; minSi) 可以表示为 if(si - minSi &lt; 0)<br>新建一个变量 sum 用来表示 si - minSi 进行变量替换,初始值为0<br>同时因为此时已经没有 minSi 了，所以对 si 的增量就相当于对 sum 的增量，所以 si += nums[j]就可以表示为 sum += nums[j]</p><pre><code>public int maxSubArray(int[] nums) {    int n = nums.length;    if(n == 0)        return 0;    int sum = 0;    int ans = Integer.MIN_VALUE;    for(int j = 0; j &lt; n; ++j){        if(sum &lt; 0)            sum = 0;        if(sum + nums[j] &gt; ans)            ans = sum + nums[j];        sum += nums[j];    }    return ans;}</code></pre><p>此时的代码和贪心法的一重循环是一致的</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> julyedu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> julyedu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot注解与资源文件配置</title>
      <link href="/2018/11/18/SpringBoot-6/"/>
      <url>/2018/11/18/SpringBoot-6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-不需要多余的配置文件信息"><a href="#1-不需要多余的配置文件信息" class="headerlink" title="1.不需要多余的配置文件信息"></a>1.不需要多余的配置文件信息</h3><p><img src="https://images.weserv.nl/?url=https://i.imgur.com/3tbNB0o.png" alt> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">application.properties</span><br><span class="line">mybatis.type-aliases-package=com.mxxd.SCM.Dao</span><br><span class="line">mybatis.mapper-locations=classpath:mybatis/mapper/*.xml</span><br><span class="line"></span><br><span class="line">spring.datasource.driverClassName = com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url = jdbc:mysql://localhost:3306/scm?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">spring.datasource.username = root</span><br><span class="line">spring.datasource.password =</span><br><span class="line"></span><br><span class="line">spring.freemarker.template-loader-path=classpath:/template/</span><br><span class="line">spring.freemarker.suffix=.ftl</span><br><span class="line">spring.freemarker.cache=false</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br></pre></td></tr></table></figure><p>Dao层mapper 添加注解 @Repository</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">//@Select(&quot;SELECT * FROM `users` where user_username = #&#123;username&#125; and user_password = #&#123;password&#125;&quot;)</span><br><span class="line">public UserEntity login(String username, String password);</span><br><span class="line"></span><br><span class="line">public UserEntity queryUser(String name);</span><br><span class="line"></span><br><span class="line">public boolean insert(UserEntity user);</span><br><span class="line"></span><br><span class="line">public boolean update(UserEntity user);</span><br><span class="line"></span><br><span class="line">public boolean delete(int id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper.xml文件 <mapper namespace> 添加对应mapper文件的位置</mapper></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.mxxd.SCM.Dao.UserMapper&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;userMap&quot; type=&quot;com.mxxd.SCM.Entity.UserEntity&quot; &gt;</span><br><span class="line">&lt;id column=&quot;user_id&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;user_username&quot; property=&quot;username&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;user_password&quot; property=&quot;password&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;user_name&quot; property=&quot;name&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;user_phone&quot; property=&quot;phone&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;user_email&quot; property=&quot;email&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;user_address&quot; property=&quot;address&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;user_authority&quot; property=&quot;authority&quot; /&gt;</span><br><span class="line">&lt;result column=&quot;is_login&quot; property=&quot;is_login&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;login&quot; parameterType=&quot;String&quot; resultMap=&quot;userMap&quot;&gt;</span><br><span class="line">  select *</span><br><span class="line">  from users where user_username = #&#123;0&#125; and user_password = #&#123;1&#125;</span><br><span class="line">   &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;queryUser&quot; resultMap=&quot;userMap&quot;&gt;</span><br><span class="line">select *</span><br><span class="line">from users</span><br><span class="line">where 1=1</span><br><span class="line">&lt;if test=&quot;id !=0&quot;&gt;</span><br><span class="line">and user_id = #&#123;id&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;username !=null and username !=&apos;&apos; &quot;&gt;</span><br><span class="line">and user_username = #&#123;username&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;password !=null and password !=&apos;&apos; &quot;&gt;</span><br><span class="line">and user_password = #&#123;password&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;name !=null and name !=&apos;&apos; &quot;&gt;</span><br><span class="line">and user_name like &quot;%&quot; #&#123;name&#125;&quot;%&quot;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;insert id=&quot;insert&quot; parameterType=&quot;com.mxxd.SCM.Entity.UserEntity&quot; &gt;</span><br><span class="line">   INSERT INTO</span><br><span class="line">  users</span><br><span class="line">  (user_username,user_password,user_name,user_phone,user_email,user_address,user_authority,is_login)</span><br><span class="line">   VALUES</span><br><span class="line">  (#&#123;username&#125;, #&#123;password&#125;, #&#123;name&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;address&#125;,#&#123;authority&#125;,#&#123;is_login&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">&lt;update id=&quot;update&quot; parameterType=&quot;com.mxxd.SCM.Entity.UserEntity&quot; &gt;</span><br><span class="line">UPDATE</span><br><span class="line">users</span><br><span class="line">SET</span><br><span class="line">&lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;user_username = #&#123;username&#125;,&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;password != null and password != &apos;&apos;&quot;&gt;user_password = #&#123;password&#125;,&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt;user_name = #&#123;name&#125;,&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;phone != null and phone != &apos;&apos;&quot;&gt;user_phone = #&#123;phone&#125;,&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;email != null and email != &apos;&apos;&quot;&gt;user_email = #&#123;email&#125;,&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;address != null and address != &apos;&apos;&quot;&gt;user_address = #&#123;address&#125;,&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;authority != null and authority != &apos;&apos;&quot;&gt;user_authority = #&#123;authority&#125;,&lt;/if&gt;</span><br><span class="line">WHERE</span><br><span class="line">user_id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br><span class="line"></span><br><span class="line">&lt;delete id=&quot;delete&quot; parameterType=&quot;Integer&quot; &gt;</span><br><span class="line">   DELETE FROM</span><br><span class="line">   users</span><br><span class="line">   WHERE</span><br><span class="line">   user_id =#&#123;0&#125;</span><br><span class="line">&lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>Service层只需要一个service类即可 不需要一个接口一个实现类 添加注解 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Autowired 是指自动生成get和set方法</span><br><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">public UserEntity login(String username, String password)&#123;</span><br><span class="line">UserEntity user = userMapper.login(username,password);</span><br><span class="line">return user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类添加注解 @MapperScan(“com.mxxd.SCM.Dao”)自动扫描Dao层mapper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&quot;com.mxxd.SCM.Dao&quot;)</span><br><span class="line">public class ScmApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">   SpringApplication.run(ScmApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-前端不推荐jsp，推荐thymeleaf或freemarker"><a href="#2-前端不推荐jsp，推荐thymeleaf或freemarker" class="headerlink" title="2.前端不推荐jsp，推荐thymeleaf或freemarker"></a>2.前端不推荐jsp，推荐thymeleaf或freemarker</h3><p>使用freemarker<br>pom.xml文件添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>前端使用 .ftl 文件<br>在resources文件夹下创建两个目录：static 和 template<br>static：目录下创建css、js、img三个目录，存放静态资源文件<br>template：目录下存放 XX.ftl 文件<br>在com.mxxd.SCM目录下创建一个Conf目录，配置springboot的静态资源文件目录  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   @Configuration</span><br><span class="line">public class WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">       registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">   public HttpMessageConverter&lt;String&gt; responseBodyConverter() &#123;</span><br><span class="line">       StringHttpMessageConverter converter = new StringHttpMessageConverter(</span><br><span class="line">               Charset.forName(&quot;UTF-8&quot;));</span><br><span class="line">       return converter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void configureMessageConverters(</span><br><span class="line">           List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">       super.configureMessageConverters(converters);</span><br><span class="line">       converters.add(responseBodyConverter());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void configureContentNegotiation(</span><br><span class="line">           ContentNegotiationConfigurer configurer) &#123;</span><br><span class="line">       configurer.favorPathExtension(false);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ftl 文件中如下引用<br><img src="https://images.weserv.nl/?url=https://i.imgur.com/q7Fbw3O.png" alt></p><p>如果要引用其他页面，使用 &lt;#include /&gt;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#include &quot;header.ftl&quot; encoding=&quot;UTF-8&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="3-启动项目必须启动XXXApplication启动类"><a href="#3-启动项目必须启动XXXApplication启动类" class="headerlink" title="3.启动项目必须启动XXXApplication启动类"></a>3.启动项目必须启动XXXApplication启动类</h3><p><strong>不能进行单元测试！！！</strong> 因为需要等SpringBoot把所有的配置全部编译完成之后才能运行，不然会找不到BeanFactory</p><h3 id="4-测试controller层调用service调用mapper连接数据库返回值是否正确"><a href="#4-测试controller层调用service调用mapper连接数据库返回值是否正确" class="headerlink" title="4.测试controller层调用service调用mapper连接数据库返回值是否正确"></a>4.测试controller层调用service调用mapper连接数据库返回值是否正确</h3><pre><code>@Controller@RequestMapping(&quot;/user&quot;)public class UserController {@Autowiredprivate UserService userService;/** 启动之后访问 /user/test 会自动跳转到index.ftl* 如果直接访问index.ftl是无法访问成功的* 因为ftl文件是一个模板文件，需要经过后台跳转才能进行渲染成网页*/@RequestMapping(&quot;/test&quot;)public String home(){    return &quot;index&quot;;}@RequestMapping(&quot;/home&quot;)public ModelAndView login() {    UserEntity userEntity = userService.login(&quot;admin&quot;, &quot;admin&quot;);    ModelAndView mv = new ModelAndView();    if (userEntity == null) {        mv.addObject(&quot;message&quot;, &quot;用户名或密码错误，请重新输入！&quot;);        mv.setViewName(&quot;index&quot;);    } else {    mv.addObject(&quot;user&quot;, userEntity);    mv.setViewName(&quot;index&quot;);    }    System.out.println(userEntity);    System.out.println(mv.getModel());    System.out.println(mv.getViewName());    return mv;    }}</code></pre><p>直接在页面上进行测试，@Test 使用会报空指针错误<br>添加 @ResponseBody 注解不用返回页面，直接打印输出结果<br>前端直接使用 ${user.name} 获取user里name属性值 ${user}获取user整个对象值  </p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot测试与打包</title>
      <link href="/2018/11/18/SpringBoot-5/"/>
      <url>/2018/11/18/SpringBoot-5/</url>
      
        <content type="html"><![CDATA[<h3 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h3><h4 id="1-1-在pom-xml中添加以下依赖即可"><a href="#1-1-在pom-xml中添加以下依赖即可" class="headerlink" title="1.1 在pom.xml中添加以下依赖即可"></a>1.1 在pom.xml中添加以下依赖即可</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="1-2-开发测试类"><a href="#1-2-开发测试类" class="headerlink" title="1.2 开发测试类"></a>1.2 开发测试类</h4><p>以最简单的helloworld为例，在测试类的类头部需要添加：@RunWith(SpringRunner.class)和@SpringBootTest注解，在测试方法的顶端添加@Test即可，最后在方法上点击右键run就可以运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void hello() &#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入了MockMvc支持了对Controller层的测试，简单示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class HelloControlerTests &#123;</span><br><span class="line"></span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    //初始化执行</span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception &#123;</span><br><span class="line">        mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //验证controller是否正常响应并打印返回结果</span><br><span class="line">    @Test</span><br><span class="line">    public void getHello() throws Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //验证controller是否正常响应并判断返回结果是否正确</span><br><span class="line">    @Test</span><br><span class="line">    public void testHello() throws Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(equalTo(&quot;Hello World&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h3><p>一种是打包成jar包直接运行，一种是打包成war包放到tomcat服务器下</p><h4 id="2-1-打成jar包"><a href="#2-1-打成jar包" class="headerlink" title="2.1 打成jar包"></a>2.1 打成jar包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 项目跟目录（和pom.xml同级）</span><br><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><p><strong>需要在linux下运行，同时需要安装好maven</strong><br>或者执行下面的命令<br>排除测试代码后进行打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package  -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>打包完成后的jar包会生成到target目录下，命名一般是 项目名+版本号.jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动jar包命令</span><br><span class="line">java -jar  target/spring-boot-scheduler-1.0.0.jar</span><br></pre></td></tr></table></figure><p>这种方式，只要控制台关闭，服务就不能访问了。<br>下面我们使用在后台运行的方式来启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar target/spring-boot-scheduler-1.0.0.jar &amp;</span><br></pre></td></tr></table></figure><p>也可以在启动的时候选择读取不同的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar app.jar --spring.profiles.active=dev</span><br></pre></td></tr></table></figure><p>也可以在启动的时候设置jvm参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms10m -Xmx80m -jar app.jar &amp;</span><br></pre></td></tr></table></figure><h4 id="2-2-打成war包"><a href="#2-2-打成war包" class="headerlink" title="2.2 打成war包"></a>2.2 打成war包</h4><p>可以通过导出war包，也可以使用命令完成<br>①修改pom.xml文件，将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><p>②在打包时排除tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在这里将scope属性设置为provided，这样在最终形成的WAR中不会包含这个JAR包，因为Tomcat或Jetty等服务器在运行时将会提供相关的API类<br>③注册启动类<br>创建ServletInitializer.java，继承SpringBootServletInitializer ，覆盖configure()，把启动类Application注册进去。外部web应用服务器构建Web Application Context的时候，会把启动类添加进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ServletInitializer extends SpringBootServletInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;</span><br><span class="line">        return application.sources(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package  -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>会在target目录下生成：项目名+版本号.war文件，拷贝到tomcat服务器中启动即可</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot添加定时任务</title>
      <link href="/2018/11/18/SpringBoot-4/"/>
      <url>/2018/11/18/SpringBoot-4/</url>
      
        <content type="html"><![CDATA[<p>定时任务<br>在启动类上面加上 @EnableScheduling即可开启定时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建定时任务实现类<br>①</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SchedulerTask &#123;</span><br><span class="line"></span><br><span class="line">    private int count=0;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron=&quot;*/6 * * * * ?&quot;)</span><br><span class="line">    private void process()&#123;</span><br><span class="line">        System.out.println(&quot;this is scheduler task runing  &quot;+(count++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Scheduler2Task &#123;</span><br><span class="line"></span><br><span class="line">    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    @Scheduled(fixedRate = 6000)</span><br><span class="line">    public void reportCurrentTime() &#123;</span><br><span class="line">        System.out.println(&quot;现在时间：&quot; + dateFormat.format(new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is scheduler task runing  0</span><br><span class="line">现在时间：09:44:17</span><br><span class="line">this is scheduler task runing  1</span><br><span class="line">现在时间：09:44:23</span><br><span class="line">this is scheduler task runing  2</span><br><span class="line">现在时间：09:44:29</span><br><span class="line">this is scheduler task runing  3</span><br><span class="line">现在时间：09:44:35</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled 参数可以接受两种定时的设置，一种是我们常用的cron=&quot;*/6 * * * * ?&quot;,一种是 fixedRate = 6000，两种都表示每隔六秒打印一下内容。</span><br><span class="line">fixedRate 说明</span><br><span class="line">@Scheduled(fixedRate = 6000) ：上一次开始执行时间点之后6秒再执行</span><br><span class="line">@Scheduled(fixedDelay = 6000) ：上一次执行完毕时间点之后6秒再执行</span><br><span class="line">@Scheduled(initialDelay=1000, fixedRate=6000) ：第一次延迟1秒后执行，之后按fixedRate的规则每6秒执行一次</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Spring Boot项目（二）</title>
      <link href="/2018/11/18/SpringBoot-3/"/>
      <url>/2018/11/18/SpringBoot-3/</url>
      
        <content type="html"><![CDATA[<p>json接口<br>添加@RestController注解</p><p>自定义Filter<br>Spring boot自动添加了OrderedCharacterEncodingFilter 和 HiddenHttpMethodFilter<br>实现自定义Fliter需要添加@Configuration注解，将自定义Fliter加入过滤链</p><p>自定义Property<br>配置在application.properties中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mxxct_name=猫熊小才天</span><br><span class="line">mxxct_pass=12345</span><br></pre></td></tr></table></figure><p><strong>需要和Application放在同级</strong></p><p><img src="https://i.imgur.com/F0wXZOQ.png" alt></p><p><img src="https://i.imgur.com/qnH76kz.png" alt></p><p>application.properties文件默认编码是ISO-8859-1，所以要添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.uri-encoding=UTF-8</span><br><span class="line">spring.http.encoding.charset=UTF-8</span><br><span class="line">spring.http.encoding.enabled=true</span><br><span class="line">spring.http.encoding.force=true</span><br><span class="line">spring.messages.encoding=UTF-8</span><br></pre></td></tr></table></figure><p>如果还不行的话，在File -&gt; Settings -&gt; Editor -&gt; File Encodings中将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Spring Boot项目（一）</title>
      <link href="/2018/11/18/SpringBoot-2/"/>
      <url>/2018/11/18/SpringBoot-2/</url>
      
        <content type="html"><![CDATA[<p>访问<a href="http://start.spring.io/自动创建项目" target="_blank" rel="noopener">http://start.spring.io/自动创建项目</a><br>在pom.xml文件中添加支持web的模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>pom.xml文件中默认有两个模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-starter：核心模块，包括自动配置支持、日志和YAML；</span><br><span class="line">spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito</span><br></pre></td></tr></table></figure><p>在src/main/java中重新编写一个controller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloWorldController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RestController的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了<br>启动程序，访问<a href="http://localhost:8080/hello即可" target="_blank" rel="noopener">http://localhost:8080/hello即可</a></p><p>编辑tomcat启动配置  </p><ol><li>On ‘Update’ action 选择 Update classes and resources  </li><li>1 （调试模式 jsp java文件可以立即生效）  </li><li>2 （运行模式 jsp立即生效 java需要重新加载）</li><li>On frame deactivation 选择 Do nothing</li></ol><p>热部署：就是容器状态在运行的情况下重新部署整个项目，在这种情况下一般整个内存会清空，重新加载，简单来说就是Tomcat或者其他的web服务器会帮我们重新加载项目，这种方式可能会造成session丢失等情况</p><p>热加载：就是容器状态在运行的情况下重新加载改变编译后的类，在这种情况下内存不会清空，session不会丢失，但容易造成内存溢出，或者找不到方法。因为内存无法转变成对像，一般改变类的结构和模型就会有异常，在已经有的变量和方法中改变是不会出问题的</p><p>在pom.xml文件中添加以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">   &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架之间的比较</title>
      <link href="/2018/11/18/SpringBoot-1/"/>
      <url>/2018/11/18/SpringBoot-1/</url>
      
        <content type="html"><![CDATA[<h4 id="Spring-MVC开发的麻烦："><a href="#Spring-MVC开发的麻烦：" class="headerlink" title="Spring MVC开发的麻烦："></a>Spring MVC开发的麻烦：</h4><ol><li>依赖太多，而且要注意版本兼容。spring的包，mybatis或hibernate的包，spring和其整合包，日志包，json包，还有版本兼容</li><li>配置太多。要配置注解驱动，配置数据库连接池，配置mybatis或hibernate，配置事务管理器，配置资源映射，在web.xml中配置启动spring和spring mvc</li><li>部署和运行麻烦。要部署到tomcat中，不能直接用java命令运行。</li></ol><h4 id="Spring-boot"><a href="#Spring-boot" class="headerlink" title="Spring boot"></a>Spring boot</h4><ol><li>通过starter和依赖管理解决依赖问题</li><li>通过自动配置，解决配置复杂问题</li><li>通过内嵌web容器，由应用启动tomcat，而不是用tomcat启动应用</li></ol><h5 id="Spring-boot-和-Spring-Cloud的比较"><a href="#Spring-boot-和-Spring-Cloud的比较" class="headerlink" title="Spring boot 和 Spring Cloud的比较"></a>Spring boot 和 Spring Cloud的比较</h5><ol><li>Spring boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架  </li><li>Spring boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring boot，属于依赖的关系。</li></ol><h5 id="Spring-boot的优点"><a href="#Spring-boot的优点" class="headerlink" title="Spring boot的优点"></a>Spring boot的优点</h5><ol><li>Spring 组件很多，需要一个个去配置，还有版本兼容问题，影响开发速度  </li><li>Spring boot提供了一个方案，可以先不关心如何配置，快速启动开发，进行业务逻辑编写，各种需要的技术，加入starter就配置好了，直接使用。  </li><li>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/2018/11/18/Search/"/>
      <url>/2018/11/18/Search/</url>
      
        <content type="html"><![CDATA[<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="1-顺序查找（线性查找）"><a href="#1-顺序查找（线性查找）" class="headerlink" title="1. 顺序查找（线性查找）"></a>1. 顺序查找（线性查找）</h3><p>时间复杂度为O(n)<br>说明：适合于存储结构为顺序存储或链式存储的线性表  </p><h3 id="2-折半查找（二分查找）"><a href="#2-折半查找（二分查找）" class="headerlink" title="2. 折半查找（二分查找）"></a>2. 折半查找（二分查找）</h3><p>时间复杂度为O(logn)<br>说明：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。  </p><h3 id="3-插值查找-折半查找的优化"><a href="#3-插值查找-折半查找的优化" class="headerlink" title="3. 插值查找(折半查找的优化)"></a>3. 插值查找(折半查找的优化)</h3><p>时间复杂度O(log(logn))<br>折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：<br><code>mid=(low+high)/2, 即mid=low+1/2*(high-low);</code><br>通过类比，我们可以将查找的点改进为如下：<br><code>mid=low+(key-a[low])/(a[high]-a[low])*(high-low)</code><br>也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。  </p><h3 id="4-树表查找"><a href="#4-树表查找" class="headerlink" title="4. 树表查找"></a>4. 树表查找</h3><h4 id="4-1-二叉树查找算法"><a href="#4-1-二叉树查找算法" class="headerlink" title="4.1 二叉树查找算法"></a>4.1 二叉树查找算法</h4><p><strong>复杂度分析</strong>：插入和查找时间复杂度O(logn)，但在最坏的情况下【比如一棵斜线形状的树，查找最后一个节点】有O(n)的时间复杂度<br><strong>基本思想</strong>：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。<br><strong>二叉查找树</strong>（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：<br>1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>3）任意节点的左、右子树也分别为二叉查找树。<br><strong>二叉查找树性质</strong>：对二叉查找树进行中序遍历，即可得到有序的数列。  </p><p><strong>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</strong>  </p><h4 id="4-2-平衡查找树之2-3查找树"><a href="#4-2-平衡查找树之2-3查找树" class="headerlink" title="4.2 平衡查找树之2-3查找树"></a>4.2 平衡查找树之2-3查找树</h4><p><strong>2-3查找树定义</strong>：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个节点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：<br>1）要么为空，要么：<br>2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。<br>3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。<br><img src="http://images.cnitblog.com/blog/94031/201403/252248421868855.png" alt>  </p><p><strong>2-3查找树的性质</strong>：  1）如果中序遍历2-3查找树，就可以得到排好序的序列；<br>2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）<br>性质2）如下图所示：<br><img src="http://images.cnitblog.com/blog/94031/201403/252249082017906.png" alt>  </p><p><strong>复杂度分析</strong>：  2-3树的查找效率与树的高度是息息相关的。<br>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN<br>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN<br>距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。<br>对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。  </p><h4 id="4-3-平衡查找树之红黑树"><a href="#4-3-平衡查找树之红黑树" class="headerlink" title="4.3 平衡查找树之红黑树"></a>4.3 平衡查找树之红黑树</h4><p>2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。 </p><p><strong>基本思想</strong>：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。<br><img src="http://images.cnitblog.com/blog/94031/201403/270024368439888.png" alt><br><strong>红黑树的定义</strong>：红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：<br>1）红色节点向左倾斜<br>2）一个节点不可能有两个红色链接<br>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。<br>下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。<br><img src="http://images.cnitblog.com/blog/94031/201403/270024386864059.png" alt><br><strong>红黑树的性质</strong>：整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。<br>复杂度分析：最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。<br>下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：<br><img src="http://images.cnitblog.com/blog/94031/201403/270027354528654.png" alt><br><strong>红黑树的平均高度大约为logn。</strong>  </p><h4 id="4-4-B树和B-树（B-Tree-B-Tree）"><a href="#4-4-B树和B-树（B-Tree-B-Tree）" class="headerlink" title="4.4 B树和B+树（B Tree/B+ Tree）"></a>4.4 B树和B+树（B Tree/B+ Tree）</h4><p>平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。<br>维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。<br><strong>B树定义</strong>：  B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。<br>1）根节点至少有两个子节点<br>2）每个节点有M-1个key，并且以升序排列<br>3）位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间<br>4）其它节点至少有M/2个子节点<br>下图是一个M=4 阶的B树:<br><img src="http://images.cnitblog.com/blog/94031/201403/290047034539184.png" alt><br>可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入<br>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4<br>的演示动画：<br><img src="http://files.cnblogs.com/files/yangecnu/btreebuild.gif" alt>  </p><p><strong>B+树定义</strong>：  B+树是对B树的一种变形树，它与B树的差异在于：<br>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。<br>如下图，是一个B+树:<br><img src="http://images.cnitblog.com/blog/94031/201403/290050048129679.png" alt><br>下图是B+树的插入动画：<br><img src="http://files.cnblogs.com/files/yangecnu/Bplustreebuild.gif" alt><br><strong>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</strong><br><strong>B+ 树的优点在于</strong>：  1）由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。<br>2）B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。<br><strong>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</strong><br>下面是B 树和B+树的区别图：<br><img src="http://images.cnitblog.com/blog/94031/201403/290050088914733.png" alt>  </p><h3 id="5-分块查找"><a href="#5-分块查找" class="headerlink" title="5. 分块查找"></a>5. 分块查找</h3><p><strong>分块查找又称索引顺序查找，它是顺序查找的一种改进方法</strong>。  <strong>算法思想</strong>：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……<br><strong>算法流程</strong>：  step1 先选取各块中的最大关键字构成一个索引表；<br>step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；<br>然后，在已确定的块中用顺序法进行查找。  </p><h3 id="6-哈希查找"><a href="#6-哈希查找" class="headerlink" title="6. 哈希查找"></a>6. 哈希查找</h3><p><strong>哈希表的两大特点</strong>：”直接定址”与”解决冲突”。<br><strong>哈希函数的规则是</strong>：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。<br><strong>算法思想</strong>：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。<br><strong>算法流程</strong>：  1）用给定的哈希函数构造哈希表；<br>2）根据选择的冲突处理方法解决地址冲突；<br>常见的解决冲突的方法：拉链法和线性探测法。<br>3）在哈希表的基础上执行哈希查找。<br><strong>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</strong><br><strong>复杂度分析</strong>：  单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。  </p><p><img src="http://images.cnitblog.com/blog/94031/201410/312301180197071.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2018/11/18/Sort/"/>
      <url>/2018/11/18/Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><img src="http://upload-images.jianshu.io/upload_images/1156494-ab4cecff133d87b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="http://upload-images.jianshu.io/upload_images/1156494-62f859c2ac6f95ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p><h3 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="1. 直接插入排序"></a>1. 直接插入排序</h3><p><img src="http://upload-images.jianshu.io/upload_images/1156494-936d9f02b6aac880.gif?imageMogr2/auto-orient/strip" alt><br><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=7cf7502408e93901420f856c1a853f82/e7cd7b899e510fb30f0a9f93d033c895d1430ca6.jpg" alt="image">  </p><p><strong>核心思想</strong>：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。<br>因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成：<br>第一层循环：遍历待比较的所有数组元素<br>第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。<br>如果：selected &gt; ordered，那么将二者交换<br><strong>代码实现</strong>：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#直接插入排序</span><br><span class="line">def insert_sort(L): </span><br><span class="line">    # 遍历数组中的所有元素，其中0号索引元素默认已排序，因此从1开始</span><br><span class="line">    for x in range(1,len(L)):</span><br><span class="line">        # 将该元素与已排序好的前序数组依次比较，如果该元素小，则交换</span><br><span class="line">        # range(x-1,-1,-1):从x-1倒序循环到0</span><br><span class="line">        for i in range(x-1,-1,-1):</span><br><span class="line">            # 判断：如果符合条件则交换</span><br><span class="line">            if L[i] &gt; L[i+1]:</span><br><span class="line">                L[i+1], L[i] = L[i], L[i+1]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 2. 希尔排序  </span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1156494-80700e24aed3d83e.png?imageMogr2/auto-orient/strip%7CimageView2/2)  </span><br><span class="line">**算法思想**：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。  </span><br><span class="line">同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成：  </span><br><span class="line">第一层循环：将gap依次折半，对序列进行分组，直到gap=1  </span><br><span class="line">第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。  </span><br><span class="line">**代码实现**：</span><br></pre></td></tr></table></figure><p>#希尔排序<br>def insert_shell(L):</p><pre><code>#初始化gap值，此处利用序列长度的一般为其赋值gap = (int)(len(L)/2)#第一层循环：依次改变gap值对列表进行分组while (gap &gt;= 1):#下面：利用直接插入排序的思想对分组数据进行排序#range(gap,len(L)):从gap开始    for x in range(gap,len(L)):#range(x-gap,-1,-gap):从x-gap开始与选定元素开始倒序比较，每个比较元素之间间隔gap        for i in range(x-gap,-1,-gap):#如果该组当中两个元素满足交换条件，则进行交换            if L[i] &gt; L[i+gap]:                temp = L[i+gap]                L[i+gap] = L[i]                L[i] =temp#while循环条件折半    gap = (int)(gap/2)  </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3. 简单选择排序  </span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1156494-25821a7cb5aec881.gif?imageMogr2/auto-orient/strip)  </span><br><span class="line"></span><br><span class="line">![image](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=09c1144f3301213fdb3e468e358e5db4/48540923dd54564e1689c4afb9de9c82d0584fb3.jpg)  </span><br><span class="line"></span><br><span class="line">**基本思想**：比较+交换。  </span><br><span class="line">1）从待排序序列中，找到关键字最小的元素；  </span><br><span class="line">2）如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；  </span><br><span class="line">3）从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。  </span><br><span class="line">因此，我们可以发现，简单选择排序也是通过两层循环实现。  </span><br><span class="line">第一层循环：依次遍历序列当中的每一个元素  </span><br><span class="line">第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。  </span><br><span class="line">**代码实现**：</span><br></pre></td></tr></table></figure><pre><code># 简单选择排序def select_sort(L):#依次遍历序列中的每一个元素    for x in range(0,len(L)):#将当前位置的元素定义此轮循环当中的最小值        minimum = L[x]#将该元素与剩下的元素依次比较寻找最小元素        for i in range(x+1,len(L)):            if L[i] &lt; minimum:                temp = L[i];                L[i] = minimum;                minimum = temp#将比较后得到的真正的最小值赋值给当前位置        L[x] = minimum  </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4. 堆排序  </span><br><span class="line">**堆的概念**：  </span><br><span class="line">堆：本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。   </span><br><span class="line">利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法。下面，我们通过大顶堆来实现。  </span><br><span class="line">**基本思想**：  </span><br><span class="line">堆排序可以按照以下步骤来完成：  </span><br><span class="line">1）首先将序列构建称为大顶堆；  </span><br><span class="line">（这样满足了大顶堆那条性质：位于根节点的元素一定是当前序列的最大值）  </span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1156494-596eee6397817ca2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  </span><br><span class="line">2）取出当前大顶堆的根节点，将其与序列末尾元素进行交换；  </span><br><span class="line">（此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质）  </span><br><span class="line">3）对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质；  </span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1156494-7e5c63ce1ed48ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  </span><br><span class="line">4）重复2.3步骤，直至堆中只有1个元素为止  </span><br><span class="line">**代码实现**：</span><br></pre></td></tr></table></figure><pre><code>#-------------------------堆排序--------------------------------#**********获取左右叶子节点**********def LEFT(i):    return 2*i + 1def RIGHT(i):    return 2*i + 2#********** 调整大顶堆 **********#L:待调整序列 length: 序列长度 i:需要调整的结点def adjust_max_heap(L,length,i):#定义一个int值保存当前序列最大值的下标    largest = i#执行循环操作：两个任务：1 寻找最大值的下标；2.最大值与父节点交换    while (1):#获得序列左右叶子节点的下标        left,right = LEFT(i),RIGHT(i)#当左叶子节点的下标小于序列长度 并且 左叶子节点的值大于父节点时，将左叶子节点的下标赋值给largest        if (left &lt; length) and (L[left] &gt; L[i]):            largest = left            print(&apos;左叶子节点&apos;)        else:            largest = i#当右叶子节点的下标小于序列长度 并且 右叶子节点的值大于父节点时，将右叶子节点的下标值赋值给largest        if (right &lt; length) and (L[right] &gt; L[largest]):            largest = right            print(&apos;右叶子节点&apos;)#如果largest不等于i 说明当前的父节点不是最大值，需要交换值        if (largest != i):            temp = L[i]            L[i] = L[largest]            L[largest] = temp            i = largest            print(largest)            continue        else:            break#********** 建立大顶堆 **********def build_max_heap(L):    length = len(L)    for x in range((int)((length-1)/2),-1,-1):        adjust_max_heap(L,length,x)#********** 堆排序 **********def heap_sort(L):#先建立大顶堆，保证最大值位于根节点；并且父节点的值大于叶子结点    build_max_heap(L)#i：当前堆中序列的长度.初始化为序列的长度    i = len(L)#执行循环：1. 每次取出堆顶元素置于序列的最后(len-1,len-2,len-3...)#         2. 调整堆，使其继续满足大顶堆的性质，注意实时修改堆中序列的长度    while (i &gt; 0):        temp = L[i-1]        L[i-1] = L[0]        L[0] = temp#堆中序列长度减1        i = i-1#调整大顶堆        adjust_max_heap(L,i,0)  </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5. 冒泡排序  </span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1156494-fef2b2e3edc03289.gif?imageMogr2/auto-orient/strip)  </span><br><span class="line">**算法思想**：  </span><br><span class="line">1）将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；</span><br><span class="line">（ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）  </span><br><span class="line">2）对序列当中剩下的n-1个元素再次执行步骤1。  </span><br><span class="line">3）对于长度为n的序列，一共需要执行n-1轮比较</span><br><span class="line">（利用while循环可以减少执行次数）  </span><br><span class="line">**代码实现**：</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>def bubble_sort(L):<br>    length = len(L)</p><pre><code># 序列长度为length，需要执行length-1轮交换for x in range(1, length):    # 对于每一轮交换，都将序列当中的左右元素进行比较    # 每轮交换当中，由于序列最后的元素一定是最大的，因此每轮循环到序列未排序的位置即可    for i in range(0,length-x):        if L[i] &gt; L[i+1]:            L[i], L[i+1] = L[i+1], L[i]</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6. 快速排序  </span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1156494-2d150e5550b700fa.gif?imageMogr2/auto-orient/strip)  </span><br><span class="line">**基本思想**：挖坑填数+分治法  </span><br><span class="line">1）从序列当中选择一个基准数(pivot)  </span><br><span class="line">在这里我们选择序列当中第一个数最为基准数  </span><br><span class="line">2）将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧  </span><br><span class="line">3）重复步骤1.2，直到所有子集当中只有一个元素为止。  </span><br><span class="line">用伪代码描述如下：  </span><br><span class="line">1.i =L; j = R; 将基准数挖出形成第一个坑a[i]。  </span><br><span class="line">2.j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。  </span><br><span class="line">3.i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。  </span><br><span class="line">4.再重复执行2,3二步，直到i==j，将基准数填入a[i]中  </span><br><span class="line">**代码实现**：</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h1 id="start-0"><a href="#start-0" class="headerlink" title="start = 0"></a>start = 0</h1><h1 id="end-len-nums-1"><a href="#end-len-nums-1" class="headerlink" title="end = len(nums) - 1"></a>end = len(nums) - 1</h1><h1 id="nums-为-待排序数组"><a href="#nums-为-待排序数组" class="headerlink" title="nums 为 待排序数组"></a>nums 为 待排序数组</h1><p>def quickSort(start, end, nums):<br>    if start &lt; end:<br>        i, j, pivot = start, end, nums[start]<br>        while i &lt; j:</p><pre><code>        # 从右开始向左寻找第一个小于pivot的值        while i &lt; j and nums[j] &gt;= pivot:            j = j - 1        # 找到后将小于pivot的值移到左边        if i &lt; j:            nums[i] = nums[j]            i = i + 1        # 从左开始向右寻找第一个大于pivot的值        while i &lt; j and nums[i] &lt;= pivot:            i = i + 1        # 找到后将小于pivot的值移到右边        if i &lt; j:            nums[j] = nums[i]            j = j - 1    # 循环结束后，说明 i=j，此时左边的值全都小于pivot,右边的值全都大于pivot    nums[i] = pivot    # pivot的位置移动正确，那么此时只需对左右两侧的序列调用此函数进一步排序即可    # 递归调用函数：左侧序列：start ~ i-1 右侧序列：i+1 ~ end    quickSort(start, i - 1, nums)    quickSort(i + 1, end, nums)return nums</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//快速排序<br>void quick_sort(int s[], int l, int r)<br>{    if (l &lt; r)<br>    {<br>        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1<br>        int i = l, j = r, x = s[l];<br>        while (i &lt; j)<br>        {<br>            while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数<br>                j–;<br>            if(i &lt; j)<br>                s[i++] = s[j];</p><pre><code>        while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数            i++;          if(i &lt; j)             s[j--] = s[i];    }    s[i] = x;    quick_sort(s, l, i - 1); // 递归调用     quick_sort(s, i + 1, r);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 7. 归并排序  </span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1156494-0597aa6877e219f0.gif?imageMogr2/auto-orient/strip)  </span><br><span class="line">**算法思想**：归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个典型的应用。它的基本操作是：将已有的子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。  </span><br><span class="line">**归并排序其实要做两件事**：  </span><br><span class="line">1）分解----将序列每次折半拆分</span><br><span class="line">2）合并----将划分后的序列段两两排序合并</span><br><span class="line">因此，归并排序实际上就是两个操作，拆分+合并  </span><br><span class="line">**如何合并？**  </span><br><span class="line">L[first...mid]为第一段，L[mid+1...last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first...last]并且也有序。  </span><br><span class="line">1）首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]  </span><br><span class="line">2）重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]  </span><br><span class="line">3）此时将temp[]中的元素复制给L[]，则得到的L[first...last]有序  </span><br><span class="line">**如何分解？**  </span><br><span class="line">在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。  </span><br><span class="line">**代码实现：**</span><br></pre></td></tr></table></figure><pre><code>#归并排序#将序列L[first...mid]与序列L[mid+1...last]进行合并def mergearray(L,first,mid,last,temp):#对i,j,k分别进行赋值  i,j,k = first,mid+1,0#当左右两边都有数时进行比较，取较小的数  while (i &lt;= mid) and (j &lt;= last):      if L[i] &lt;= L[j]:          temp[k] = L[i]          i = i+1          k = k+1      else:          temp[k] = L[j]          j = j+1          k = k+1#如果左边序列还有数  while (i &lt;= mid):      temp[k] = L[i]      i = i+1      k = k+1#如果右边序列还有数  while (j &lt;= last):      temp[k] = L[j]      j = j+1      k = k+1#将temp当中该段有序元素赋值给L待排序列使之部分有序  for x in range(0,k):      L[first+x] = temp[x]# 这是分组的函数def merge_sort(L,first,last,temp):  if first &lt; last:      mid = (int)((first + last) / 2)#使左边序列有序      merge_sort(L,first,mid,temp)#使右边序列有序      merge_sort(L,mid+1,last,temp)#将两个有序序列合并      mergearray(L,first,mid,last,temp)# 归并排序的函数def merge_sort_array(L):#声明一个长度为len(L)的空列表  temp = len(L)*[None]#调用归并排序  merge_sort(L,0,len(L)-1,temp)  </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 8. 基数排序  </span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/1156494-70872a75238d1269.gif?imageMogr2/auto-orient/strip)  </span><br><span class="line">**算法思想**：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。  </span><br><span class="line">分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中  </span><br><span class="line">收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]  </span><br><span class="line">对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束  </span><br><span class="line">**代码实现：**</span><br></pre></td></tr></table></figure><pre><code>#************************基数排序****************************#确定排序的次数#排序的顺序跟序列中最大数的位数相关def radix_sort_nums(L):  maxNum = L[0]#寻找序列中的最大数  for x in L:      if maxNum &lt; x:          maxNum = x#确定序列中的最大元素的位数  times = 0  while (maxNum &gt; 0):      maxNum = (int)(maxNum/10)      times = times+1  return times#找到num从低到高第pos位的数据def get_num_pos(num,pos):  return ((int)(num/(10**(pos-1))))%10#基数排序def radix_sort(L):  count = 10*[None]        #存放各个桶的数据统计个数  bucket = len(L)*[None]  #暂时存放排序结果#从低位到高位依次执行循环  for pos in range(1,radix_sort_nums(L)+1):      #置空各个桶的数据统计      for x in range(0,10):          count[x] = 0      #统计当前该位(个位，十位，百位....)的元素数目      for x in range(0,len(L)):          #统计各个桶将要装进去的元素个数          j = get_num_pos(int(L[x]),pos)          count[j] = count[j]+1      #count[i]表示第i个桶的右边界索引      for x in range(1,10):          count[x] = count[x] + count[x-1]      #将数据依次装入桶中      for x in range(len(L)-1,-1,-1):          #求出元素第K位的数字          j = get_num_pos(L[x],pos)          #放入对应的桶中，count[j]-1是第j个桶的右边界索引          bucket[count[j]-1] = L[x]          #对应桶的装入数据索引-1          count[j] = count[j]-1      # 将已分配好的桶中数据再倒出来，此时已是对应当前位数有序的表      for x in range(0,len(L)):          L[x] = bucket[x]  </code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装Tomcat</title>
      <link href="/2018/11/18/Linux-2/"/>
      <url>/2018/11/18/Linux-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下配置Tomcat"><a href="#Linux下配置Tomcat" class="headerlink" title="Linux下配置Tomcat"></a>Linux下配置Tomcat</h1><ol><li><p>先去官网查看Tomcat版本和JDK版本匹配关系<br> <a href="http://http://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">http://http://tomcat.apache.org/whichversion.html</a></p></li><li><p>下载Tomcat的Linux版本<br> 文件后缀是tar.gz</p></li><li><p>下载到Linux下解压<br> tar -zxvf apache-tomcat-8.0.46.tar.gz</p></li><li><p>进入到conf目录下修改server.xml文件的端口号  </p><pre><code>&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;            connectionTimeout=&quot;20000&quot;            redirectPort=&quot;8443&quot; /&gt;</code></pre></li><li><p>进入到bin目录下输入./startup.sh启动Tomcat服务器<br> 进入到logs目录下查看catalina.out文件，查看Tomcat服务器是否正常启动    </p></li><li><p>进入到bin目录下输入./shutdown.sh关闭Tomcat服务器<br> 进入到logs目录下查看catalina.out文件，查看Tomcat服务器是否正常关闭</p></li><li><p>把Windows下的工程导出为war包，放入到Linux下的Tomcat安装目录下的webapps目录下，启动Tomcat服务器自动就会解压出一个同工程名的文件夹</p></li><li><p>进入到工程名文件夹/MoviePlex/WEB-INF/classes下，修改conf.properties文件中的out_put路径<br> <code>output_file=/home/oracle/appdata/MoviePlex/activity</code></p></li><li><p>在Windows下浏览器地址栏输入<br> 虚拟机IP地址：Linux下的Tomcat端口号/工程名/login.jsp</p></li><li><p>报404错误</p><ul><li>Linux下的JDK版本与Tomcat版本和Windows下的JDK版本与Tomcat版本是否一致</li><li>Linux下的JDK版本和Tomcat版本是否兼容</li><li>在Linux下的Tomcat安装目录下输入 <code>chmod u+x *</code> 添加用户执行权限</li></ul></li><li><p>删除之前的JDK  </p><pre><code>输入su进入root输入rpm -qa|grep gcj查看所有Java版本信息输入rpm -e --nodeps 文件名 删除Java旧版本</code></pre></li><li><p>修改项目后先在本地运行一下，将编译好的.class文件覆盖掉Linux下项目的.class文件，重启Tomcat就可以了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker指令整理</title>
      <link href="/2018/11/18/Docker-3/"/>
      <url>/2018/11/18/Docker-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker指令整理"><a href="#Docker指令整理" class="headerlink" title="Docker指令整理"></a>Docker指令整理</h2><p><strong>管理员权限！！！</strong></p><p>查看docker版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker stop</span><br></pre></td></tr></table></figure><p>重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>测试 hello world</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker mxxd]# docker run hub.c.163.com/library/busybox:latest echo helloworld</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/c9lGJ1y.png" alt></p><p>查看信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>查看镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>列出run的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a 查看所有容器，包括已经停止的</span><br><span class="line">docker ps -l 查看刚刚启动的容器</span><br><span class="line">docker ps -q 只显示容器ID</span><br><span class="line">docker ps -l-q 返回刚刚启动的容器ID</span><br></pre></td></tr></table></figure><p>搜索镜像(默认从 dockerhub 中搜索)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search *****</span><br></pre></td></tr></table></figure><p>下载docker镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull *****</span><br><span class="line">镜像文件保存在本地的 /var/lib/docker 文件夹下</span><br><span class="line">默认是最新的版本，如果需要执行版本，使用下面指令</span><br><span class="line">docker pull XXX:tag</span><br><span class="line">tag为版本号</span><br></pre></td></tr></table></figure><p>运行docker容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run *****</span><br><span class="line">docker run -p 8888:8080 --name 自定义名称 -d 镜像名称</span><br><span class="line">run  = create + start 第一次创建完容器可以用run，之后再启动就用start</span><br><span class="line">-p：端口映射，主机端口:容器内部端口</span><br><span class="line">--name：自定义容器名称</span><br><span class="line">-d：后台运行</span><br></pre></td></tr></table></figure><p>查看容器日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器id</span><br></pre></td></tr></table></figure><p>退出docker容器但不停止运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+P+Q</span><br></pre></td></tr></table></figure><p>停止docker容器运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop *****（ContainerID）</span><br></pre></td></tr></table></figure><p>删除docker容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm *****（ContainerID）</span><br></pre></td></tr></table></figure><p>删除docker镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi *****（imageID）</span><br></pre></td></tr></table></figure><p><strong>删除镜像之前必须要保证镜像所在的容器是停止的，并且要先删除容器之后才能删除镜像文件</strong></p><p>启动docker容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start *****（ContainerID）</span><br></pre></td></tr></table></figure><p>打包镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o ./test.zip image名称</span><br></pre></td></tr></table></figure><p>导入镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; test.zip</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装Docker</title>
      <link href="/2018/11/18/Docker-2/"/>
      <url>/2018/11/18/Docker-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux下安装Docker"><a href="#Linux下安装Docker" class="headerlink" title="Linux下安装Docker"></a>Linux下安装Docker</h2><p><strong>全部都在管理员权限下进行操作！！！</strong>  </p><p>Docker 要求 Centos 内核版本高于3.10。使用 <code>uname -r</code> 来查看内核版本，如果低于3.10，通过 <code>yum update</code> 来更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: base</span><br></pre></td></tr></table></figure><p>解决：<br>su进入管理员  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d</span><br></pre></td></tr></table></figure><p>将里面的文件换成阿里源的文件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br></pre></td></tr></table></figure><p>更新生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>如果还是会报错的话，修改下面的文件<br>vi /etc/yum.repos.d/rpmforge.repo<br><img src="https://i.imgur.com/HaXXt8q.png" alt></p><p>修改这两项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">baseurl = http://mirrorlist.repoforge.org/el6/mirrors-rpmforge</span><br><span class="line">mirrorlist = http://mirrorlist.repoforge.org/el6/mirrors-rpmforge</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><p>安装Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https://get.docker.com/rpm/1.7.1/centos-6/RPMS/x86_64/docker-engine-1.7.1-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><p>查看docker版本  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>启动  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><p>关闭  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker stop</span><br></pre></td></tr></table></figure><p>重启  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>设置 docker 开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>测试 hello world  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker mxxd]# docker run hub.c.163.com/library/busybox:latest echo helloworld</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/MeBxfBS.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker简介</title>
      <link href="/2018/11/18/Docker-1/"/>
      <url>/2018/11/18/Docker-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Docker镜像"><a href="#1-Docker镜像" class="headerlink" title="1.Docker镜像"></a>1.Docker镜像</h3><p>要理解Docker镜像和Docker容器之间的区别，确实不容易。<br>假设Linux内核是第0层，那么无论怎么运行Docker，它都是运行于内核层之上的。这个Docker镜像，是一个只读的镜像，位于第1层，它不能被修改或不能保存状态。<br>一个Docker镜像可以构建于另一个Docker镜像之上，这种层叠关系可以是多层的。<br>第1层的镜像层我们称之为基础镜像（Base Image），其他层的镜像（除了最顶层）我们称之为父层镜像（Parent Image）。这些镜像继承了他们的父层镜像的所有属性和设置，并在Dockerfile中添加了自己的配置。<br>Docker镜像通过镜像ID进行识别。镜像ID是一个64字符的十六进制的字符串。但是当我们运行镜像时，通常我们不会使用镜像ID来引用镜像，而是使用镜像名来引用。要列出本地所有有效的镜像，可以使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>镜像可以发布为不同的版本，这种机制我们称之为标签（Tag）。<br><img src="https://i.imgur.com/xoJvMtW.jpg" alt></p><p>如上图所示，neo4j镜像有两个版本：lastest版本和2.1.5版本。<br>可以使用pull命令加上指定的标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br><span class="line">docker pull ubuntu:12.04</span><br></pre></td></tr></table></figure><h3 id="2-Docker容器"><a href="#2-Docker容器" class="headerlink" title="2.Docker容器"></a>2.Docker容器</h3><p>Docker容器可以使用命令创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run imagename</span><br></pre></td></tr></table></figure><p>它会在所有的镜像层之上增加一个可写层。这个可写层有运行在CPU上的进程，而且有两个不同的状态：运行态（Running）和退出态（Exited）。这就是Docker容器。当我们使用docker run启动容器，Docker容器就进入运行态，当我们停止Docker容器时，它就进入退出态。<br>当我们有一个正在运行的Docker容器时，从运行态到停止态，我们对它所做的一切变更都会永久地写到容器的文件系统中。要切记，对容器的变更是写入到容器的文件系统的，而不是写入到Docker镜像中的。<br>我们可以用同一个镜像启动多个Docker容器，这些容器启动后都是活动的，彼此还是相互隔离的。我们对其中一个容器所做的变更只会局限于那个容器本身。<br>如果对容器的底层镜像进行修改，那么当前正在运行的容器是不受影响的，不会发生自动更新现象。<br>如果想更新容器到其镜像的新版本，那么必须当心，确保我们是以正确的方式构建了数据结构，否则我们可能会导致损失容器中所有数据的后果。<br>64字符的十六进制的字符串来定义容器ID，它是容器的唯一标识符。容器之间的交互是依靠容器ID识别的，由于容器ID的字符太长，我们通常只需键入容器ID的前4个字符即可。当然，我们还可以使用容器名，但显然用4字符的容器ID更为简便。</p><h3 id="3-镜像、容器和仓库"><a href="#3-镜像、容器和仓库" class="headerlink" title="3.镜像、容器和仓库"></a>3.镜像、容器和仓库</h3><h4 id="3-1-镜像"><a href="#3-1-镜像" class="headerlink" title="3.1 镜像"></a>3.1 镜像</h4><p>Docker运行容器前需要本地存在对应的镜像。<br>镜像可以用来创建Docker容器的。一个镜像可以包含一个完整的操作系统环境和用户需要的其它应用程序。在docker hub 里面有大量现成的镜像提供下载。docker的镜像是只可读的，一个镜像可以创建多个容器。</p><h4 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h4><p>docker利用容器来开发、运行应用。<br>容器是镜像创建的实例。它可以被启动、开始、停止、删除。每个容器都是 相互隔离的、保证安全的平台。</p><h4 id="3-3-仓库"><a href="#3-3-仓库" class="headerlink" title="3.3 仓库"></a>3.3 仓库</h4><p>仓库是集中存放镜像文件的场所。<br>每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。<br>最大的公开仓库是DockerHub，存放了数量庞大的镜像供用户下载。国内的公开 仓库包括DockerPool等，可以提供大陆用户更稳定快速的访问。当然，用户也可以在本地网络内创建一个私有仓库。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下更新JDK版本</title>
      <link href="/2018/11/18/Linux-1/"/>
      <url>/2018/11/18/Linux-1/</url>
      
        <content type="html"><![CDATA[<h4 id="1-输入-su-进入管理员权限"><a href="#1-输入-su-进入管理员权限" class="headerlink" title="1.输入 su 进入管理员权限"></a>1.输入 su 进入管理员权限</h4><h4 id="2-输入-rpm-qa-grep-jdk-查看当前系统有哪些java版本"><a href="#2-输入-rpm-qa-grep-jdk-查看当前系统有哪些java版本" class="headerlink" title="2.输入 rpm -qa | grep jdk 查看当前系统有哪些java版本"></a>2.输入 rpm -qa | grep jdk 查看当前系统有哪些java版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker /]# rpm -qa | grep jdk  </span><br><span class="line">java-1.7.0-openjdk-1.7.0.171-2.6.13.0.el6_9.x86_64  </span><br><span class="line">java-1.6.0-openjdk-1.6.0.41-1.13.13.1.el6_8.x86_64</span><br></pre></td></tr></table></figure><h4 id="3-输入-rpm-e-–nodeps-java-1-6-0-openjdk-1-6-0-41-1-13-13-1-el6-8-x86-64-删除该版本"><a href="#3-输入-rpm-e-–nodeps-java-1-6-0-openjdk-1-6-0-41-1-13-13-1-el6-8-x86-64-删除该版本" class="headerlink" title="3.输入 rpm -e –nodeps java-1.6.0-openjdk-1.6.0.41-1.13.13.1.el6_8.x86_64 删除该版本"></a>3.输入 rpm -e –nodeps java-1.6.0-openjdk-1.6.0.41-1.13.13.1.el6_8.x86_64 删除该版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker /]# rpm -e --nodeps  </span><br><span class="line">java-1.6.0-openjdk-1.6.0.41-1.13.13.1.el6_8.x86_64</span><br><span class="line">[root@docker /]# rpm -qa | grep jdk</span><br><span class="line">java-1.7.0-openjdk-1.7.0.171-2.6.13.0.el6_9.x86_64</span><br></pre></td></tr></table></figure><p>全部删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker /]# rpm -e --nodeps  </span><br><span class="line">java-1.7.0-openjdk-1.7.0.171-2.6.13.0.el6_9.x86_64</span><br><span class="line">[root@docker /]# rpm -qa | grep jdk</span><br><span class="line">[root@docker /]# java -version</span><br><span class="line">bash: java: command not found</span><br></pre></td></tr></table></figure><h4 id="4-安装新的jdk"><a href="#4-安装新的jdk" class="headerlink" title="4.安装新的jdk"></a>4.安装新的jdk</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker /]# yum install java-1.8.0-openjdk</span><br></pre></td></tr></table></figure><h4 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5.配置环境变量"></a>5.配置环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker /]# vi /etc/profile</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-0.el6_10.x86_64</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><h4 id="6-让环境变量生效"><a href="#6-让环境变量生效" class="headerlink" title="6.让环境变量生效"></a>6.让环境变量生效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker /]# source /etc/profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hue</title>
      <link href="/2018/11/16/Hue/"/>
      <url>/2018/11/16/Hue/</url>
      
        <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>HUE=Hadoop User Experience</p><p>Hue是一个开源的Apache Hadoop UI系统，由Cloudera Desktop演化而来，最后Cloudera公司将其贡献给Apache基金会的Hadoop社区，它是基于Python Web框架Django实现的。通过使用Hue我们可以在浏览器端的Web控制台上与Hadoop集群进行交互来分析处理数据，例如操作HDFS上的数据，运行MapReduce Job，执行Hive的SQL语句，浏览HBase数据库等等。</p><p>Hue在数据库方面，默认使用的是SQLite数据库来管理自身的数据，包括用户认证和授权，另外，可以自定义为MySQL数据库、Postgresql数据库、以及Oracle数据库。其自身的功能包含有：</p><ul><li>对HDFS的访问，通过浏览器来查阅HDFS的数据。 </li><li>Hive编辑器：可以编写HQL和运行HQL脚本，以及查看运行结果等相关Hive功能。  </li><li>提供Solr搜索应用，并对应相应的可视化数据视图以及DashBoard。  </li><li>提供Impala的应用进行数据交互查询。  </li><li>最新的版本集成了Spark编辑器和DashBoard  </li><li>支持Pig编辑器，并能够运行编写的脚本任务。  </li><li>Oozie调度器，可以通过DashBoard来提交和监控Workflow、Coordinator以及Bundle。  </li><li>支持HBase对数据的查询修改以及可视化。  </li><li>支持对Metastore的浏览，可以访问Hive的元数据以及对应的HCatalog。  </li><li>另外，还有对Job的支持，Sqoop，ZooKeeper以及DB（MySQL，SQLite，Oracle等）的支持。  </li></ul><h3 id="二、安装配置"><a href="#二、安装配置" class="headerlink" title="二、安装配置"></a>二、安装配置</h3><ol><li><p>打开hiveserver2</p><pre><code>hive --service hiveserver2否则通过Hue Web控制无法执行Hive查询</code></pre></li><li><p>配置Hadoop的配置文件core-site.xml，添加以下内容   </p><pre><code>&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.hue.hosts&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.hue.groups&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;//如果在pseudo-distributed.ini中配置的是root  //server_user=root//server_group=root//default_user=root//default_hdfs_superuser=root//就把hue改成root，给root权限&lt;property&gt;&lt;name&gt;hadoop.proxyuser. client.hosts&lt;/name&gt;&lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hadoop.proxyuser. client.groups&lt;/name&gt;&lt;value&gt;*&lt;/value&gt;&lt;/property&gt;</code></pre></li><li><p>配置Hadoop的配置文件hdfs-site.xml，添加以下内容  </p><pre><code>&lt;property&gt;    &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;    &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;</code></pre></li><li><p>使用yum工具来添加maven源<br> 进入root权限  </p><p> <code>wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo</code></p></li><li><p>使用yum工具来安装依赖<br> 进入root权限</p><p> <code>yum install ant asciidoc cyrus-sasl-devel cyrus-sasl-gssapi cyrus-sasl-plain gcc gcc-c++ krb5-devel libffi-devel libxml2-devel libxslt-devel make mysql mysql-devel openldap-devel python-devel sqlite-devel gmp-devel</code></p></li><li><p>使用yum工具来安装git<br> 进入root权限  </p><pre><code>yum install git//默认安装路径在/usr/libexec/下</code></pre></li><li><p>下载源码<br> 进入root权限<br> <code>git clone https://github.com/cloudera/hue.git branch-3.9</code></p></li><li><p>安装python环境<br> 进入roor权限  </p><p> <code>yum install python-devel</code></p></li><li><p>安装可能缺少的依赖<br> 进入root权限  </p><pre><code>yum install libffi-develyum install gcc openssl-develyum install libxslt-develyum install mysql-server mysql mysql-develyum install gmp-develyum install sqlite-develyum install openldap-devel</code></pre></li><li><p>编译源码，编译完成后可以选择安装  </p><pre><code>cd branch-3.9  make apps  //编译出错后 make clean之后再编译//可选 make install</code></pre></li><li><p>进入到安装目录branch-3.9下，访问Hue（此时只能进去，但是无法查看里面的各个组件信息）<br>进入root权限</p><pre><code>build/env/bin/hue runserver //默认端口由Django服务器提供，端口号是127.0.0.1:8000build/env/bin/hue runserver 0.0.0.0:8000 //添加第三个参数 打开外网访问 linux ip地址：8000</code></pre></li><li><p>修改desktop/conf/pseudo-distributed.ini配置文件  </p><pre><code>[desktop]  http_host=0.0.0.0http_port=8000server_user=rootserver_group=rootdefault_user=rootdefault_hdfs_superuser=root——————————————————————————————————————————————————————————————————————————————————[hadoop]# Enter the filesystem urifs_defaultfs=hdfs://oracle:9000# Use WebHdfs/HttpFs as the communication mechanism.  # Domain should be the NameNode or HttpFs host.  # Default port is 14000 for HttpFs.webhdfs_url=http://oracle:50070/webhdfs/v1# Directory of the Hadoop configurationhadoop_hdfs_home=/home/oracle/hadoop-2.6.0  hadoop_bin=/home/oracle/hadoop-2.6.0/bin  hadoop_conf_dir=/home/oracle/hadoop-2.6.0/etc/hadoop——————————————————————————————————————————————————————————————————————————————————[[yarn_clusters]]# Enter the host on which you are running the ResourceManagerresourcemanager_host=oracle# The port where the ResourceManager IPC listens onresourcemanager_port=8032# Whether to submit jobs to this clustersubmit_to=True# Change this if your YARN cluster is Kerberos-securedsecurity_enabled=true# URL of the ResourceManager APIresourcemanager_api_url=http://oracle:8088# URL of the ProxyServer APIproxy_api_url=http://oracle:8088# URL of the HistoryServer APIhistory_server_api_url=http://oracle:19888——————————————————————————————————————————————————————————————————————————————————[[mapred_clusters]]# Enter the host on which you are running the Hadoop JobTrackerjobtracker_host=oracle# The port where the JobTracker IPC listens onjobtracker_port=8021# Whether to submit jobs to this clustersubmit_to=False# Change this if your MapReduce cluster is Kerberos-securedsecurity_enabled=true——————————————————————————————————————————————————————————————————————————————————[beeswax]# Host where HiveServer2 is running.# If Kerberos security is enabled, use fully-qualified domain name (FQDN).hive_server_host=oracle# Port where HiveServer2 Thrift server runs on.hive_server_port=10000# Hive configuration directory, where hive-site.xml is locatedhive_conf_dir=/home/oracle/apache-hive-1.2.1-bin/conf——————————————————————————————————————————————————————————————————————————————————</code></pre></li><li><p>配置Hadoop的配置文件yarn-site.xml，添加以下内容</p><pre><code>&lt;property&gt;&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;&lt;value&gt;oracle&lt;/value&gt;&lt;/property&gt;&lt;!-- historyserver############ --&gt;&lt;property&gt;&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;&lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;&lt;value&gt;106800&lt;/value&gt;&lt;/property&gt;&lt;!-- historyserver############ --&gt;</code></pre></li><li><p>在打开网页时，先启动Hadoop，HBase，HBase Thrift，Hive  </p><pre><code>hbase-daemon.sh start thrift -p 9090hive --service hiveserver2 // 不要关闭该选项卡</code></pre></li><li><p>在外网下访问端口号：8000</p><pre><code>Browsers → Files 进入File Browser，可以查看HDFS文件  Browsers → JObs 进入Job Browser，可以查看MapReduce的Job信息  Browsers → HBases 进入Hbase Browser，可以查看Hbase中的表单信息  Editor → Hive 进入Hive，可以对Hive中的表单进行操作  </code></pre></li><li><p>修改权限  </p><p><code>chown -R root:root branch-3.7.1/</code></p></li><li><p>出现database is locked错误  </p></li></ol><p>将hue自己的数据库迁移到mysql下</p><pre><code>//注意database不要找错了[[database]]# Database engine is typically one of:# postgresql_psycopg2, mysql, sqlite3 or oracle.## Note that for sqlite3, &apos;name&apos;, below is a path to the filename. For other backends, it is the database name.# Note for Oracle, options={&quot;threaded&quot;:true} must be set in order to avoid crashes.# Note for Oracle, you can use the Oracle Service Name by setting &quot;host=&quot; and &quot;port=&quot; and then &quot;name=&lt;host&gt;:&lt;port&gt;/&lt;service_name&gt;&quot;.# Note for MariaDB use the &apos;mysql&apos; engine.engine=mysqlhost=localhostport=3306user=rootpassword=root# conn_max_age option to make database connection persistent value in seconds# https://docs.djangoproject.com/en/1.9/ref/databases/#persistent-connections## conn_max_age=0# Execute this script to produce the database password. This will be used when &apos;password&apos; is not set.## password_script=/path/scriptname=hue## options={}</code></pre><p>进入root权限，进入hue安装目录下</p><pre><code>build/env/bin/hue syncdbbuild/env/bin/hue migrate</code></pre><p>再进入hue时需要使用在 syncdb 中设置的username和password<br>oracle 123456</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive sql函数</title>
      <link href="/2018/11/16/Hive-2/"/>
      <url>/2018/11/16/Hive-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Hive-sql函数"><a href="#Hive-sql函数" class="headerlink" title="Hive sql函数"></a>Hive sql函数</h2><h3 id="一、关系运算"><a href="#一、关系运算" class="headerlink" title="一、关系运算"></a>一、关系运算</h3><ol><li><p>等值比较: =<br> <code>select 1 from dual where 1 = 2;</code></p></li><li><p>等值比较:&lt;=&gt;<br>a &lt;=&gt; b</p></li><li><p>不等值比较: &lt;&gt;和!=<br>a != b || a &lt;&gt; b</p></li><li><p>小于比较: &lt;  a &lt; b</p></li><li><p>小于等于比较: &lt;=<br>a &lt;= b</p></li><li><p>大于比较: &gt;<br>a &gt; b</p></li><li><p>大于等于比较: &gt;=<br>a &gt;= b</p></li><li><p>区间比较？？？？？  </p><pre><code># step1 设定区间分类个数，此处设置为10m=10# step2 求解字段 result 的最大值和最小值section=`hive -e &quot;select max(result) as max_num,   min(result) as min_numfrom  tmp&quot;`max_num=`echo -e &quot;${section}&quot; | cut -f1`min_num=`echo -e &quot;${section}&quot; | cut -f2`# step3 求解区间的长度len_section=`hive -e &quot;select (${max_num} - ${min_num}) / ${m}from   dual&quot;`# step4 统计每个区间的个数hive -e &quot;select ${min_num} + floor((result - ${min_num}) / ${len_section}) * ${len_section} as section_flag,   count(*) as num  from   tmp&quot;</code></pre></li><li><p>空值判断: IS NULL<br> <code>select 1 from dual where A is null;</code></p></li><li><p>非空判断: IS NOT NULL<br><code>select 1 from dual where A is not null;</code></p></li><li><p>LIKE比较: A LIKE B<br><strong>B中字符”_“表示任意单个字符，而字符”%”表示任意数量的字符</strong><br><strong>否定比较的时候用 NOT A LIKE B</strong></p><pre><code>select 1 from dual where ‘key&apos; like &apos;foot%&apos;;  select 1 from dual where ‘key &apos; like &apos;foot____&apos;;</code></pre></li><li><p>JAVA的LIKE操作: A RLIKE B<br>如果字符串A或者字符串B为NULL，则返回NULL；如果字符串A符合JAVA正则表达式B的正则语法，则为TRUE；否则为FALSE  </p><pre><code>select 1 from dual where &apos;123456&apos; rlike &apos;^\\d+$&apos;    判断一个字符串是否都是数字</code></pre></li><li><p>REGEXP操作: A REGEXP B<br>功能和RLIKE一样  </p><pre><code>select 1 from dual where ‘key&apos; REGEXP &apos;^f.*r$&apos;;</code></pre></li></ol><h3 id="二、数学运算"><a href="#二、数学运算" class="headerlink" title="二、数学运算"></a>二、数学运算</h3><ol><li><p>加法操作: +</p></li><li><p>减法操作: –<br> <strong>结果的数值类型等于A的类型和B的类型的最小父类型</strong><br> 比如int ± int 一般结果为int类型，而int ± double 一般结果为double类型  </p></li><li><p>乘法操作: *   <strong>结果的数值类型等于A的类型和B的类型的最小父类型</strong><br> 如果A乘以B的结果超过默认结果类型的数值范围，则需要通过cast将结果转换成范围更大的数值类型</p></li><li><p>除法操作: /？？？？？<br> 返回A除以B的结果。结果的数值类型为double  </p><pre><code>注意：hive 中最高精度的数据类型是 double, 只精确到小数点后16位，做除法运算时要特别注意  hive&gt;select ceil(28.0/6.999999999999999999999) from dual limit 1;  结果为4  hive&gt;select ceil(28.0/6.99999999999999) from dual limit 1;  结果为5</code></pre></li><li><p>取余操作: %<br> 返回A除以B的余数。结果的数值类型等于A的类型和B的类型的最小父类型  </p><pre><code>注意：精度在 hive 中是个很大的问题，类似这样的操作最好通过 round 指定精度  hive&gt; select round(8.4 % 4 , 2) from dual;  0.4  </code></pre></li><li><p>位与操作: &amp;<br> 返回A和B按位进行与操作的结果。结果的数值类型等于A的类型和B的类型的最小父类型  </p><pre><code>hive&gt; select 4 &amp; 8 from dual;  0  hive&gt; select 6 &amp; 4 from dual;  4</code></pre></li><li><p>位或操作: |<br> 返回A和B按位进行或操作的结果。结果的数值类型等于A的类型和B的类型的最小父类型  </p><pre><code>hive&gt; select 4 | 8 from dual;  12  hive&gt; select 6 | 8 from dual;  14</code></pre></li><li><p>位异或操作: ^<br> 返回A和B按位进行异或操作的结果。结果的数值类型等于A的类型和B的类型的最小父类型</p><pre><code>hive&gt; select 4 ^ 8 from dual;  12  hive&gt; select 6 ^ 4 from dual;  2</code></pre></li><li><p>位取反操作: ~  返回A按位取反操作的结果。结果的数值类型等于A的类型。</p><pre><code>hive&gt; select ~6 from dual;  -7  hive&gt; select ~4 from dual;  -5  </code></pre><blockquote><p><strong>所有正整数的按位取反是其本身+1的负数</strong><br><strong>所有负整数的按位取反是其本身+1的绝对值</strong><br><strong>零的按位取反是 -1</strong></p></blockquote></li></ol><h3 id="三、逻辑运算"><a href="#三、逻辑运算" class="headerlink" title="三、逻辑运算"></a>三、逻辑运算</h3><ol><li><p>逻辑与操作: AND 、&amp;&amp;</p></li><li><p>逻辑或操作: OR 、||</p></li><li><p>逻辑非操作: NOT、!   NOT A：如果A为FALSE，或者A为NULL，则为TRUE；否则为FALSE  </p><pre><code>select 1 from dual where  not 1=2 ;</code></pre></li></ol><h3 id="四、复合类型构造函数"><a href="#四、复合类型构造函数" class="headerlink" title="四、复合类型构造函数"></a>四、复合类型构造函数</h3><ol><li><p>map结构<br> map (key1, value1, key2, value2,…)<br> 根据输入的key和value对构建map类型</p><pre><code>hive&gt; Create table lxw_test as select map(&apos;100&apos;,&apos;tom&apos;,&apos;200&apos;,&apos;mary&apos;)as t from lxw_dual;hive&gt; describe lxw_test;t   map&lt;string,string&gt;hive&gt; select t from lxw_test;{&quot;100&quot;:&quot;tom&quot;,&quot;200&quot;:&quot;mary&quot;}hive&gt; create table employee(id string, perf map&lt;string, int&gt;)   &gt; ROW FORMAT DELIMITED  &gt; FIELDS TERMINATED BY &apos;\t&apos;&gt; COLLECTION ITEMS TERMINATED BY &apos;,&apos;   &gt; MAP KEYS TERMINATED BY &apos;:&apos;;1   job:80,team:60,person:70  2   job:60,team:80  3   job:90,team:70,person:100hive&gt; load data local inpath &apos;/home/oracle/emp.txt&apos; into table employee;hive&gt; select perf[&apos;person&apos;] from employee;OK  70  NULL  100hive&gt; select perf[&apos;person&apos;] from employee where perf[&apos;person&apos;] is not null;70  100</code></pre></li></ol><blockquote><p>‘MAP KEYS TERMINATED BY’ ：key value分隔符</p></blockquote><ol start="2"><li><p>struct结构<br> struct(val1, val2, val3,…)<br> 根据输入的参数构建结构体struct类型</p><pre><code>hive&gt; create table student_test(id INT, info struct&lt;name:STRING, age:INT&gt;)  &gt; ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;,&apos; &gt; COLLECTION ITEMS TERMINATED BY &apos;:&apos;;hive&gt;load data local inpath &apos;/home/oracle/student_test.txt&apos; into table student_test;1,zhou:30  2,yan:30  3,chen:20  4,li:80hive&gt; select info.age from student_test;  30  30  20  80</code></pre></li></ol><blockquote><p>‘FIELDS TERMINATED BY’ ：字段与字段之间的分隔符<br>‘COLLECTION ITEMS TERMINATED BY’ ：一个字段各个item的分隔符</p></blockquote><ol start="3"><li><p>named_struct结构<br> named_struct(name1,val1,name2,val2,name3,val3,…)<br> 使用给定的表达式，构造一个指定列名的 struct 数据结构</p><pre><code>hive&gt; select named_struct(&apos;a&apos;,1,&apos;b&apos;,&apos;aaa&apos;,&apos;c&apos;,FALSE) from lxw1234; {&quot;a&quot;:1,&quot;b&quot;:&quot;aaa&quot;,&quot;c&quot;:false}</code></pre></li><li><p>array结构<br> array(val1, val2,…)<br> 根据输入的参数构建数组array类型</p><pre><code>hive&gt; create table lxw_test as selectarray(&quot;tom&quot;,&quot;mary&quot;,&quot;tim&quot;) as t from lxw_dual;hive&gt; describe lxw_test;t   array&lt;string&gt;hive&gt; select t from lxw_test;[&quot;tom&quot;,&quot;mary&quot;,&quot;tim&quot;]hive&gt; create table class_test(name string, student_id_list array&lt;INT&gt;)034,1:2:3:4  035,5:6  036,7:8:9:10hive&gt; select student_id_list[3] from class_test;4  NULL  10</code></pre></li><li><p>create_union (tag, val1, val2, …)<br> 使用给定的 tag 和表达式，构造一个 uniontype 数据结构。tag 表示使用第 tag 个 表达式作为 uniontype 的 value</p><pre><code>hive&gt; select create_union(0,&apos;ss&apos;,array(1,2,3)) from lxw1234; {0:&quot;ss&quot;}hive&gt; select create_union(1,&apos;ss&apos;,array(1,2,3)) from lxw1234; {1:[1,2,3]}</code></pre></li></ol><h3 id="五、复合类型操作符"><a href="#五、复合类型操作符" class="headerlink" title="五、复合类型操作符"></a>五、复合类型操作符</h3><ol><li><p>获取array中的元素 A[n]<br> 返回数组A中的第n个变量值。数组的起始下标为0。比如，A是个值为[‘foo’, ‘bar’]的数组类型，那么A[0]将返回’foo’,而A[1]将返回’bar’  </p><pre><code>hive&gt; create table lxw_test as selectarray(&quot;tom&quot;,&quot;mary&quot;,&quot;tim&quot;) as t from lxw_dual;hive&gt; select t[0],t[1],t[2] from lxw_test;tom   mary   timhive&gt; select array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)[1] from lxw1234;  b</code></pre></li><li><p>获取map中的元素 M[key]<br> 返回map类型M中，key值为指定值的value值。比如，M是值为{‘f’ -&gt; ‘foo’, ‘b’-&gt; ‘bar’, ‘all’ -&gt; ‘foobar’}的map类型，那么M[‘all’]将会返回’foobar’</p><pre><code>hive&gt; Create table lxw_test as selectmap(&apos;100&apos;,&apos;tom&apos;,&apos;200&apos;,&apos;mary&apos;) as t from lxw_dual;hive&gt; select t[&apos;200&apos;],t[&apos;100&apos;] from lxw_test;mary   tomhive&gt; select map(&apos;k1&apos;,&apos;v1&apos;)[&apos;k1&apos;];  v1</code></pre></li><li><p>获取struct中的元素 S.x<br> 返回结构体S中的x字段。比如，对于结构体struct foobar {int foo, int bar}，foobar.foo返回结构体中的foo字段</p><pre><code>hive&gt; create table lxw_test as select struct(&apos;tom&apos;,&apos;mary&apos;,&apos;tim&apos;)as t from lxw_dual;hive&gt; describe lxw_test;t   struct&lt;col1:string,col2:string,col3:string&gt;hive&gt; select t.col1,t.col3 from lxw_test;tom timhive&gt; select named_struct(&apos;a&apos;,1,&apos;b&apos;,&apos;aaa&apos;,&apos;c&apos;,FALSE).c;  false</code></pre></li></ol><h3 id="六、数值计算函数"><a href="#六、数值计算函数" class="headerlink" title="六、数值计算函数"></a>六、数值计算函数</h3><ol><li><p>取整函数: round(double a)<br> 返回double类型的整数值部分 （遵循四舍五入）</p><pre><code>hive&gt; select round(3.1415926) from dual;  3  hive&gt; select round(3.5) from dual;  4</code></pre></li><li><p>指定精度取整函数: round(double a, int d)<br> 返回指定精度d的double类型</p><pre><code>hive&gt; select round(3.1415926,4) from dual;  3.1416</code></pre></li><li><p>向下取整函数: floor(double a)<br> 返回等于或者小于该double变量的最大的整数</p><pre><code>hive&gt; select floor(3.1415926) from dual;  3  hive&gt; select floor(25) from dual;  25</code></pre></li><li><p>向上取整函数: ceil(double a)<br> 返回等于或者大于该double变量的最小的整数</p><pre><code>hive&gt; select ceil(3.1415926) from dual;  4  hive&gt; select ceil(46) from dual;  46</code></pre></li><li><p>向上取整函数: ceiling(double a)<br>与ceil功能相同</p><pre><code>hive&gt; select ceiling(3.1415926) from dual;  4  hive&gt; select ceiling(46) from dual;  46</code></pre></li><li><p>取随机数函数: rand(),rand(int seed)<br> 返回一个0到1范围内的随机数。如果指定种子seed，则会等到一个稳定的随机数序列</p><pre><code>hive&gt; select rand() from dual;  0.5577432776034763</code></pre></li><li><p>自然指数函数: exp(double a)<br> 返回自然对数e的a次方</p><pre><code>hive&gt; select exp(2) from dual;  7.38905609893065</code></pre></li><li><p>以10为底对数函数: log10(double a)<br> 返回以10为底的a的对数</p><pre><code>hive&gt; select log10(100) from dual;  2.0</code></pre></li><li><p>以2为底对数函数: log2(double a)<br> 返回以2为底的a的对数</p><pre><code>hive&gt; select log2(8) from dual;  3.0</code></pre></li><li><p>对数函数: log(double base, double a)<br>返回以base为底的a的对数</p><pre><code>hive&gt; select log(4,256) from dual;4.0</code></pre></li><li><p>幂运算函数: pow(double a, double p)<br>返回a的p次幂</p><pre><code>hive&gt; select pow(2,4) from dual;16.0</code></pre></li><li><p>幂运算函数: power(double a, double p)<br>返回a的p次幂,与pow功能相同</p><pre><code>hive&gt; select power(2,4) from dual;16.0</code></pre></li><li><p>开平方函数: sqrt(double a)<br>返回a的平方根</p><pre><code>hive&gt; select sqrt(16) from dual;4.0</code></pre></li><li><p>二进制函数: bin(BIGINT a)<br>返回a的二进制代码表示</p><pre><code>hive&gt; select bin(7) from dual;111</code></pre></li><li><p>十六进制函数: hex(BIGINT a)<br>如果变量是int类型，那么返回a的十六进制表示；如果变量是string类型，则返回该字符串的十六进制表示</p><pre><code>hive&gt; select hex(17) from dual;11hive&gt; select hex(‘abc’) from dual;616263</code></pre></li><li><p>反转十六进制函数: unhex(string a)<br>返回该十六进制字符串所代表的字符串</p><pre><code>hive&gt; select unhex(‘616263’) from dual;abchive&gt; select unhex(‘11’) from dual;-hive&gt; select unhex(616263) from dual;abc</code></pre></li><li><p>进制转换函数: conv(BIGINT num, int from_base, int to_base)<br>将数值num从from_base进制转化到to_base进制</p><pre><code>hive&gt; select conv(17,10,16) from dual;11hive&gt; select conv(17,10,2) from dual;10001</code></pre></li><li><p>绝对值函数: abs(double a) || abs(int a)<br>返回数值a的绝对值</p><pre><code>hive&gt; select abs(-3.9) from dual;3.9hive&gt; select abs(10.9) from dual;10.9</code></pre></li><li><p>正取余函数: pmod(int a, int b) || pmod(double a, double b)<br>返回正的a除以b的余数</p><pre><code>hive&gt; select pmod(9,4) from dual;1hive&gt; select pmod(-9,4) from dual;3// 如果参数是一正一负，先都看成正数 4 * 3 = 12 &gt; 9，则余数是 12 - 9 = 3// 找到比负数大的数，减去负数的绝对值</code></pre></li><li><p>正弦函数: sin(double a)<br>返回a的正弦值</p><pre><code>hive&gt; select sin(0.8) from dual;0.7173560908995228</code></pre></li><li><p>反正弦函数: asin(double a)<br>返回a的反正弦值</p><pre><code>hive&gt; select asin(0.7173560908995228) from dual;0.8</code></pre></li><li><p>余弦函数: cos(double a)<br>返回a的余弦值</p><pre><code>hive&gt; select cos(0.9) from dual;0.6216099682706644</code></pre></li><li><p>反余弦函数: acos(double a)<br>返回a的反余弦值</p><pre><code>hive&gt; select acos(0.6216099682706644) from dual;0.9</code></pre></li><li><p>positive函数: positive(int a) || positive(double a)<br>返回a</p><pre><code>hive&gt; select positive(-10) from dual;-10hive&gt; select positive(12) from dual;12</code></pre></li><li><p>negative函数: negative(int a) || negative(double a)<br>返回-a</p><pre><code>hive&gt; select negative(-5) from dual;5hive&gt; select negative(8) from dual;-8</code></pre></li></ol><h3 id="七、集合操作函数"><a href="#七、集合操作函数" class="headerlink" title="七、集合操作函数"></a>七、集合操作函数</h3><ol><li><p>map类型大小：size(Map&lt;K.V&gt;)<br> 返回map类型的长度</p><pre><code>hive&gt; select size(map(&apos;100&apos;,&apos;tom&apos;,&apos;101&apos;,&apos;mary&apos;)) from lxw_dual;2</code></pre></li><li><p>array类型大小：size(Array<t>)   返回array类型的长度</t></p><pre><code>hive&gt; select size(array(&apos;100&apos;,&apos;101&apos;,&apos;102&apos;,&apos;103&apos;)) from lxw_dual;4</code></pre></li><li><p>判断元素数组是否包含元素：array_contains(Array, value)<br> 返回 Array中是否包含元素 value</p><pre><code>hive&gt; select array_contains(array(1,2,3,4,5),3) from lxw1234; true</code></pre></li><li><p>获取map中所有value集合<br> map_values(Map)<br> 返回 Map中所有 value 的集合</p><pre><code>hive&gt; select map_values(map(&apos;k1&apos;,&apos;v1&apos;,&apos;k2&apos;,&apos;v2&apos;)) from lxw1234; [&quot;v2&quot;,&quot;v1&quot;]</code></pre></li><li><p>获取map中所有key集合<br> map_keys(Map)<br> 返回 Map中所有 key 的集合</p><pre><code>hive&gt; select map_keys(map(&apos;k1&apos;,&apos;v1&apos;,&apos;k2&apos;,&apos;v2&apos;)) from lxw1234; [&quot;k2&quot;,&quot;k1&quot;]</code></pre></li><li><p>数组排序<br> sort_array(Array)<br> 对 Array进行升序排序</p><pre><code>hive&gt; select sort_array(array(5,7,3,6,9)) from lxw1234;[3,5,6,7,9]</code></pre></li></ol><h3 id="八、类型转换函数"><a href="#八、类型转换函数" class="headerlink" title="八、类型转换函数"></a>八、类型转换函数</h3><ol><li><p>二进制转换：binary(string|binary)<br> 将输入的值转换成二进制</p><pre><code>hive&gt; select binary(&apos;4&apos;);4hive&gt; select binary(&apos;1111&apos;);1111hive&gt; select binary(&apos;abd&apos;);abd</code></pre></li><li><p>基础类型之间强制转换：cast(expr as <type>)   返回值：Expected “=” to follow “type”<br> 返回from之后的长度，如果是一张表就输出行数个expr</type></p><pre><code>hive&gt; select cast(1 as float);1.0hive&gt; select cast(2 as bigint) from tablss;222222</code></pre></li></ol><h3 id="九、日期函数"><a href="#九、日期函数" class="headerlink" title="九、日期函数"></a>九、日期函数</h3><ol><li><p>UNIX时间戳转日期函数: from_unixtime(bigint unixtime[, string format])<br> 转化UNIX时间戳（从1970-01-01 00:00:00 UTC到指定时间的秒数）到当前时区的时间格式</p><pre><code>hive&gt; select from_unixtime(1323308943,&apos;yyyyMMdd&apos;) from dual;20111208</code></pre></li><li><p>获取当前UNIX时间戳函数: unix_timestamp()<br> 获得当前时区的UNIX时间戳</p><pre><code>hive&gt; select unix_timestamp() from dual;1323309615</code></pre></li><li><p>日期转UNIX时间戳函数: unix_timestamp(string date)<br> 转换格式为”yyyy-MM-dd HH:mm:ss”的日期到UNIX时间戳。如果转化失败，则返回0</p><pre><code>hive&gt; select unix_timestamp(&apos;2011-12-07 13:01:03&apos;) from dual;1323234063</code></pre></li><li><p>指定格式日期转UNIX时间戳函数: unix_timestamp(string date, string pattern)<br> 转换pattern格式的日期到UNIX时间戳。如果转化失败，则返回0</p><pre><code>hive&gt; select unix_timestamp(&apos;20111207 13:01:03&apos;,&apos;yyyyMMdd HH:mm:ss&apos;) from dual;1323234063</code></pre></li><li><p>日期时间转日期函数: to_date(string timestamp)<br> 返回日期时间字段中的日期部分</p><pre><code>hive&gt; select to_date(&apos;2011-12-08 10:03:01&apos;) from dual;2011-12-08</code></pre></li><li><p>日期转年函数: year(string date)<br> 返回日期中的年</p><pre><code>hive&gt; select year(&apos;2011-12-08 10:03:01&apos;) from dual;2011hive&gt; select year(&apos;2012-12-08&apos;) from dual;2012</code></pre></li><li><p>日期转月函数: month (string date)<br> 返回日期中的月份</p><pre><code>hive&gt; select month(&apos;2011-12-08 10:03:01&apos;) from dual;12hive&gt; select month(&apos;2011-08-08&apos;) from dual;8</code></pre></li><li><p>日期转天函数: day (string date)<br> 返回日期中的天</p><pre><code>hive&gt; select day(&apos;2011-12-08 10:03:01&apos;) from dual;8hive&gt; select day(&apos;2011-12-24&apos;) from dual;24</code></pre></li><li><p>日期转小时函数: hour (string date)<br> 返回日期中的小时</p><pre><code>hive&gt; select hour(&apos;2011-12-08 10:03:01&apos;) from dual;10</code></pre></li><li><p>日期转分钟函数: minute (string date)<br>返回日期中的分钟</p><pre><code>hive&gt; select minute(&apos;2011-12-08 10:03:01&apos;) from dual;3</code></pre></li><li><p>日期转秒函数: second (string date)<br>返回日期中的秒</p><pre><code>hive&gt; select second(&apos;2011-12-08 10:03:01&apos;) from dual;1</code></pre></li><li><p>日期转周函数: weekofyear (string date)<br>返回日期在当前的周数</p><pre><code>hive&gt; select weekofyear(&apos;2011-12-08 10:03:01&apos;) from dual;49</code></pre></li><li><p>日期比较函数: datediff(string enddate, string startdate)<br>返回结束日期减去开始日期的天数</p><pre><code>hive&gt; select datediff(&apos;2012-12-08&apos;,&apos;2012-05-09&apos;) from dual;213</code></pre></li><li><p>日期增加函数: date_add(string startdate, int days)<br>返回开始日期startdate增加days天后的日期</p><pre><code>hive&gt; select date_add(&apos;2012-12-08&apos;,10) from dual;2012-12-18</code></pre></li><li><p>日期减少函数: date_sub (string startdate, int days)<br>返回开始日期startdate减少days天后的日期</p><pre><code>hive&gt; select date_sub(&apos;2012-12-08&apos;,10) from dual;2012-11-28</code></pre></li></ol><h3 id="十、条件函数"><a href="#十、条件函数" class="headerlink" title="十、条件函数"></a>十、条件函数</h3><ol><li><p>If函数: if(boolean testCondition, T valueTrue, T valueFalseOrNull)<br>  当条件testCondition为TRUE时，返回valueTrue；否则返回valueFalseOrNull</p><pre><code>hive&gt; select if(1=2,100,200) from dual;200hive&gt; select if(1=1,100,200) from dual;100</code></pre></li><li><p>非空查找函数: COALESCE(T v1, T v2, …)<br> 返回参数中的第一个非空值；如果所有值都为NULL，那么返回NULL</p><pre><code>hive&gt; select COALESCE(null,&apos;100&apos;,&apos;50′) from dual;100</code></pre></li><li><p>条件判断函数：CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END<br> 如果 a 等于 b ，那么返回 c ；如果 a 等于 d ，那么返回 e ；否则返回 f</p><pre><code>hive&gt; Select case 100 when 50 then &apos;tom&apos;   when 100 then &apos;mary&apos;   else &apos;tim&apos; end from dual;  mary</code></pre></li></ol><h3 id="十一、字符串函数"><a href="#十一、字符串函数" class="headerlink" title="十一、字符串函数"></a>十一、字符串函数</h3><ol><li><p>字符ascii码函数：ascii(str)<br> 返回字符串str第一个字符的ascii码</p><pre><code>hive&gt; select ascii(‘abcde’) from dual;  97</code></pre></li><li><p>base64字符串：base64(binary bin)<br> 将二进制bin转换成64位的字符串</p><pre><code>hive&gt; select base64(binary(‘lxw1234’));bHh3MTIzNA==</code></pre></li><li><p>字符串连接函数：concat(string A, string B…)<br> 返回输入字符串连接后的结果，支持任意个输入字符串</p><pre><code>hive&gt; select concat(‘abc’,&apos;def’,&apos;gh’) from dual;  abcdefgh</code></pre></li><li><p>带分隔符字符串连接函数：concat_ws(string SEP, string A, string B…)<br> 返回输入字符串连接后的结果，SEP表示各个字符串间的分隔符</p><pre><code>hive&gt; select concat_ws(‘,’,&apos;abc’,&apos;def’,&apos;gh’) from dual;  abc,def,ghhive&gt; select concat_ws(&apos;.&apos;,&apos;www&apos;,&apos;iteblog&apos;,&apos;com&apos;) from iteblog;www.iteblog.com</code></pre></li><li><p>数组转换成字符串的函数：concat_ws(string SEP, array<string>)   返回将数组链接成字符串后的结果，SEP 表示各个字符串间的分隔符</string></p><pre><code>hive&gt; select concat_ws(&apos;|&apos;,array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;));a|b|c</code></pre></li></ol><ol start="6"><li><p>小数位格式化成字符串函数：format_number(number x, int d)<br> 将数值X转换成”#,###,###.##”格式字符串，并保留d位小数，如果d为0，将进行四舍五入且不保留小数</p><pre><code>hive&gt; select format_number(5.23456,3) from lxw1234;5.235</code></pre></li><li><p>字符串截取函数：substr(string A, int start) || substring(string A, int start)<br> 返回字符串A从start位置到结尾的字符串 </p><pre><code>hive&gt; select substr(‘abcde’,3) from dual;  cde  hive&gt; select substring(‘abcde’,3) from dual;  cde  hive&gt;  select substr(‘abcde’,-1) from dual;  （和ORACLE相同）  e</code></pre></li><li><p>字符串截取函数：substr(string A, int start, int len) || substring(string A, int start, int len)<br> 返回字符串A从start位置开始，长度为len的字符串</p><pre><code>hiveselect substr(‘abcde’,3,2) from dual;  cd  hiveselect substring(‘abcde’,3,2) from dual;  cd  hive&gt;select substring(‘abcde’,-2,2) from dual;  de</code></pre></li><li><p>字符串查找函数：instr(string str, string substr)<br> 返回值为int<br> 查找字符串str中子字符串substr出现的位置，如果查找失败将返回0，如果任一参数为Null将返回null，注意位置为从1开始的</p><pre><code>hive&gt; select instr(&apos;abcdf&apos;,&apos;df&apos;) from lxw1234;4</code></pre></li><li><p>字符串长度函数：length(string A)<br>返回字符串A的长度</p><pre><code>hive&gt; select length(&apos;abcedfg&apos;) from dual;7</code></pre></li><li><p>字符串查找函数：locate(string substr, string str[, int pos])<br>查找字符串str中的pos位置后字符串substr第一次出现的位置</p><pre><code>hive&gt; select locate(&apos;a&apos;,&apos;abcda&apos;,1) from lxw1234;1hive&gt; select locate(&apos;a&apos;,&apos;abcda&apos;,2) from lxw1234;5</code></pre></li><li><p>字符串格式化函数：printf(String format, Obj… args)<br>按照printf风格格式输出字符串</p><pre><code>hive&gt; select printf(&quot;%08X&quot;,123) from lxw1234; 0000007B</code></pre></li><li><p>字符串转换成map函数：str_to_map(text[, delimiter1, delimiter2])<br>返回值：map&lt;string,string&gt;<br>将字符串str按照指定分隔符转换成Map，第一个参数是需要转换字符串，第二个参数是键值对之间的分隔符，默认为逗号;第三个参数是键值之间的分隔符，默认为”=”</p><pre><code>hive&gt; select str_to_map(&apos;k1:v1,k2:v2&apos;) from lxw1234;{&quot;k2&quot;:&quot;v2&quot;,&quot;k1&quot;:&quot;v1&quot;}hive&gt; select str_to_map(&apos;k1=v1,k2=v2&apos;,&apos;,&apos;,&apos;=&apos;) from lxw1234;{&quot;k2&quot;:&quot;v2&quot;,&quot;k1&quot;:&quot;v1&quot;}</code></pre></li><li><p>base64解码函数：unbase64(string str)<br>将64位的字符串转换二进制值</p><pre><code>hive&gt; select unbase64(&apos;bHh3MTIzNA==&apos;) from lxw1234;lxw1234</code></pre></li><li><p>字符串转大写函数：upper(string A) || ucase(string A)<br>返回字符串A的大写格式</p><pre><code>hive&gt; select upper(‘abSEd’) from dual;  ABSED  hive&gt; select ucase(‘abSEd’) from dual;  ABSED</code></pre></li><li><p>字符串转小写函数：lower(string A) || lcase(string A)<br>返回字符串A的小写格式</p><pre><code>hive&gt; select lower(‘abSEd’) from dual;  absed  hive&gt; select lcase(‘abSEd’) from dual;  absed</code></pre></li><li><p>去空格函数：trim(string A)<br>去除字符串两边的空格</p><pre><code>hive&gt; select trim(‘ abc ‘) from dual;  abc</code></pre></li><li><p>左边去空格函数：ltrim(string A)<br>去除字符串左边的空格</p><pre><code>hive&gt; select ltrim(‘ abc ‘) from dual;  abc</code></pre></li><li><p>右边去空格函数：rtrim(string A)<br>去除字符串右边的空格</p><pre><code>hive&gt; select rtrim(‘ abc ‘) from dual;  abc</code></pre></li><li><p>正则表达式替换函数：regexp_replace(string A, string B, string C)<br>将字符串A中的符合java正则表达式B的部分替换为C。注意，在有些情况下要使用转义字符,类似oracle中的regexp_replace函数</p><pre><code>hive&gt; select regexp_replace(&apos;foobar&apos;, &apos;oo|ar&apos;, &apos;&apos;) from lxw_dual;fb</code></pre></li><li><p>正则表达式解析函数：regexp_extract(string subject, string pattern, int index)<br>将字符串subject按照pattern正则表达式的规则拆分，返回index指定的字符,其中的index是按照正则字符串（）的位置。注意，在有些情况下要使用转义字符</p><pre><code>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 1) from dual;  the  hive&gt; select regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 2) from dual;  bar  hive&gt; select regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 0) from dual;  foothebar？？？？？</code></pre></li><li><p>URL解析函数：parse_url(url, partToExtract[, key])？？？？？<br>解析URL字符串，partToExtract的选项包含[HOST,PATH,QUERY,REF,PROTOCOL,FILE,AUTHORITY,USERINFO]。</p><pre><code>parse_url(&apos;http://facebook.com/path/p1.php?query=1&apos;, &apos;HOST&apos;)返回&apos;facebook.com&apos;   parse_url(&apos;http://facebook.com/path/p1.php?query=1&apos;, &apos;PATH&apos;)返回&apos;/path/p1.php&apos;   parse_url(&apos;http://facebook.com/path/p1.php?query=1&apos;, &apos;QUERY&apos;)返回&apos;query=1&apos;，  可以指定key来返回特定参数，例如  parse_url(&apos;http://facebook.com/path/p1.php?query=1&apos;, &apos;QUERY&apos;,&apos;query&apos;)返回&apos;1&apos;，  parse_url(&apos;http://facebook.com/path/p1.php?query=1#Ref&apos;, &apos;REF&apos;)返回&apos;Ref&apos;   parse_url(&apos;http://facebook.com/path/p1.php?query=1#Ref&apos;, &apos;PROTOCOL&apos;)返回&apos;http&apos; </code></pre></li><li><p>json解析函数：get_json_object(string json_string, string path)<br>解析json的字符串json_string,返回path指定的内容。如果输入的json字符串无效，那么返回NULL</p><pre><code>hive&gt; select  get_json_object(‘{“store”:  &gt;   {“fruit”:\[{&quot;weight&quot;:8,&quot;type&quot;:&quot;apple&quot;},{&quot;weight&quot;:9,&quot;type&quot;:&quot;pear&quot;}],  &gt;“bicycle”:{“price”:19.95,”color”:”red”}  &gt;   },  &gt;  “email”:”amy@only_for_json_udf_test.net”,  &gt;  “owner”:”amy”  &gt; }  &gt; ‘,’$.owner’) from dual;  amyselect get_json_object(&apos;{&quot;store&quot;:{&quot;fruit&quot;:\[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]},&quot;owner&quot;:&quot;amy&quot;}&apos;,&apos;$.store.fruit[0]&apos;) from test_msg limit 1;</code></pre></li><li><p>空格字符串函数：space(int n)<br>返回长度为n的字符串</p><pre><code>hive&gt; select space(10) from dual;  hive&gt; select length(space(10)) from dual;  10</code></pre></li><li><p>重复字符串函数：repeat(string str, int n)<br>返回重复n次后的str字符串</p><pre><code>hive&gt; select repeat(‘abc’,5) from dual;  abcabcabcabcabc</code></pre></li><li><p>左补足函数：lpad(string str, int len, string pad)<br>将str进行用pad进行左补足到len位</p><pre><code>hive&gt; select lpad(‘abc’,10,’td’) from dual;  tdtdtdtabc</code></pre></li><li><p>右补足函数：rpad(string str, int len, string pad)<br>将str进行用pad进行右补足到len位</p><pre><code>hive&gt; select rpad(‘abc’,10,’td’) from dual;  abctdtdtdt</code></pre></li><li><p>分割字符串函数: split(string str, string pat)<br>按照pat字符串分割str，会返回分割后的字符串数组</p><pre><code>hive&gt; select split(‘abtcdtef’,&apos;t’) from dual;  [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code></pre></li><li><p>集合查找函数: find_in_set(string str, string strList)<br>返回str在strlist第一次出现的位置，strlist是用逗号分割的字符串。如果没有找该str字符，则返回0</p><pre><code>hive&gt; select find_in_set(‘ab’,&apos;ef,ab,de’) from dual;  2  hive&gt; select find_in_set(‘at’,&apos;ef,ab,de’) from dual;  0</code></pre></li><li><p>分词函数：sentences(string str, string lang, string locale)<br>返回值: array<array><br>返回输入 str 分词后的单词数组<br><strong>分词函数先分句子，句号.会看成是一个单词，逗号,会被拆开，叹号！会被拆成两个句子</strong></array></p><pre><code>hive&gt; select sentences(&apos;hello word!hello hive,hi hive,hello hive&apos;)[[&quot;hello&quot;,&quot;word&quot;],[&quot;hello&quot;,&quot;hive&quot;,&quot;hi&quot;,&quot;hive&quot;,&quot;hello&quot;,&quot;hive&quot;]]  select sentences(&apos;hello word,hello hive,hi hive,hello hive&apos;);[[&quot;hello&quot;,&quot;word&quot;,&quot;hello&quot;,&quot;hive&quot;,&quot;hi&quot;,&quot;hive&quot;,&quot;hello&quot;,&quot;hive&quot;]]  hive&gt;select sentences(&apos;hello word.hello hive,hi hive,hello hive&apos;);[[&quot;hello&quot;,&quot;word.hello&quot;,&quot;hive&quot;,&quot;hi&quot;,&quot;hive&quot;,&quot;hello&quot;,&quot;hive&quot;]]</code></pre></li><li><p>分词后统计一起出现频次最高的TOP-K<br>ngrams(array<array>, int N, int K, int pf)<br>返回值: array&lt;struct&lt;string,double&gt;&gt;<br>与 sentences()函数一起使用，分词后，统计分词结果中一起出现频次最高的 TOP-K 结果  </array></p><pre><code>hive&gt; select ngrams(sentences(&apos;hello word!hello hive,hi hive,hello hive&apos;),2,2);  [{&quot;ngram&quot;:[&quot;hello&quot;,&quot;hive&quot;],&quot;estfrequency&quot;:2.0},{&quot;ngram&quot;:[&quot;hive&quot;,&quot;hi&quot;],&quot;estfrequency&quot;:1.0}]//该查询中，统计的是两个词在一起出现频次最高的 TOP\-2  //结果中，hello 与 hive 同时出现 2 次</code></pre></li><li><p>分词后统计与指定单词一起出现频次最高的TOP-K<br>context_ngrams(array<array>, array, int K, int pf)<br>返回值：array&lt;struct&lt;string,double&gt;&gt;<br>与 sentences()函数一起使用，分词后，统计分词结果中与数组中指定的单词一起出现(包括顺序)频次最高的 TOP-K 结果<br><strong>是紧跟着指定单词出现，可以跨越句子</strong></array></p><pre><code>hive&gt; select context_ngrams(sentences(&apos;hello word!hello hive,hi hive,hello hive&apos;),array(&apos;hello&apos;,null),3);[{&quot;ngram&quot;:[&quot;hive&quot;],&quot;estfrequency&quot;:2.0},{&quot;ngram&quot;:[&quot;word&quot;],&quot;estfrequency&quot;:1.0}]//该查询中，统计的是与&apos;hello&apos;一起出现，并且在 hello 后面的频次最高的 TOP-3//结果中，hello 与 hive 同时出现 2 次，hello 与 word 同时出现 1 次hive&gt; select context_ngrams(sentences(&apos;hello word!hello hive,hi hive,hello hive&apos;),array(null,&apos;hive&apos;),3);[{&quot;ngram&quot;:[&quot;hello&quot;],&quot;estfrequency&quot;:2.0},{&quot;ngram&quot;:[&quot;hi&quot;],&quot;estfrequency&quot;:1.0}]//该查询中，统计的是与&apos;hive&apos;一起出现，并且在 hive 之前的频次最高的 TOP-3hive&gt;select context\_ngrams(sentences(&apos;hello word hello hive,hi hive,hello hive&apos;),array(null,&apos;hive&apos;),3);  [{&quot;ngram&quot;:[&quot;hello&quot;],&quot;estfrequency&quot;:2.0},{&quot;ngram&quot;:[&quot;hi&quot;],&quot;estfrequency&quot;:1.0}]hive&gt;select context\_ngrams(sentences(&apos;hello hive,hello hive,hi hive,hello hive&apos;),array(null,&apos;hive&apos;),3);  [{&quot;ngram&quot;:[&quot;hello&quot;],&quot;estfrequency&quot;:3.0},{&quot;ngram&quot;:[&quot;hi&quot;],&quot;estfrequency&quot;:1.0}]hive&gt;select context\_ngrams(sentences(&apos;hello hive,hello hive,hello hive,hi hive,hello hive&apos;),array(null,&apos;hive&apos;),3);[{&quot;ngram&quot;:[&quot;hello&quot;],&quot;estfrequency&quot;:4.0},{&quot;ngram&quot;:[&quot;hi&quot;],&quot;estfrequency&quot;:1.0}]</code></pre></li><li><p>字符串反转函数： reverse(string A)<br>返回字符串A的反转结果</p><pre><code>hive&gt; select reverse(abcedfg’) from dual;gfdecba  </code></pre></li><li><p>重复字符串函数：repeat(string str, int n)<br>返回重复n次后的str字符串 </p><pre><code>hive&gt; select repeat(&apos;abc&apos;,5);abcabcabcabcabc</code></pre></li></ol><h3 id="十二、混合函数"><a href="#十二、混合函数" class="headerlink" title="十二、混合函数"></a>十二、混合函数</h3><ol><li><p>调用Java函数： java_method(class, method[, arg1[, arg2..]])<br> 返回值: varies<br> 调用 Java 中的方法处理数据  </p><pre><code>hive&gt; select reflect(&quot;java.net.URLEncoder&quot;, &quot;encode&quot;, &apos;http://lxw1234.com&apos;,&quot;UTF-8&quot;);http%3A%2F%2Flxw1234.com//该查询中调用 java.net.URLEncoder 中的encode方法，给该方法传的参数为&apos;http://lxw1234.com&apos;,&quot;UTF-8&quot;</code></pre></li><li><p>调用Java函数：reflect(class, method[, arg1[, arg2..]])<br> 返回值: varies<br> 调用 Java 中的方法处理数据  </p><pre><code>hive&gt; select reflect(&quot;java.net.URLDecoder&quot;, &quot;decode&quot;,&apos;http%3A%2F%2Flxw1234.com&apos;,&quot;UTF-8&quot;);http://lxw1234.com</code></pre></li><li><p>字符串的hash值：hash(a1[, a2…])<br> 返回值: int<br> 返回字符串的 hash 值  </p><pre><code>hive&gt; select hash(&apos;lxw1234.com&apos;);-809268416</code></pre></li></ol><h3 id="十三、XPath解析XML函数"><a href="#十三、XPath解析XML函数" class="headerlink" title="十三、XPath解析XML函数"></a>十三、XPath解析XML函数</h3><ol><li><p>xpath<br> (string xmlstr,string xpath_expression)<br> 返回值: array<br> 从 xml 字符串中返回匹配到表达式的结果数组  </p><pre><code>//获取 xml 字符串中 a/b/节点的值hive&gt; select xpath(&apos;b1b2c1&apos;,&apos;a/b/text()&apos;) from lxw1234;[&quot;b1&quot;,&quot;b2&quot;]//获取 xml 字符串中所有名为 id 的属性值hive&gt; select xpath(&apos;b1b2&apos;,&apos;//@id&apos;) from lxw1234;[&quot;foo&quot;,&quot;bar&quot;]</code></pre></li><li><p>xpath_string<br> xpath_string(string xmlstr,string xpath_expression)<br> 返回值: string<br> 默认情况下，从 xml 字符串中返回第一个匹配到表达式的节点的值  </p><pre><code>hive&gt; select xpath_string (&apos;b1b2&apos;, &apos;//b&apos;) from lxw1234;b13.//指定返回匹配到哪一个节点hive&gt; select xpath_string (&apos;b1b2&apos;, &apos;//b[2]&apos;) from lxw1234;b2</code></pre></li><li><p>xpath_boolean<br> xpath_boolean (string xmlstr,string xpath_expression)<br> 返回值: boolean<br> 返回 xml 字符串中是否匹配 xml 表达式  </p><pre><code>hive&gt; select xpath_boolean (&apos;b&apos;, &apos;a/b&apos;) from lxw1234;  truehive&gt; select xpath_boolean (&apos;10&apos;, &apos;a/b &lt; 10&apos;) from lxw1234;  false </code></pre></li><li><p>xpath_short, xpath_int, xpath_long<br> xpath_short (string xmlstr,string xpath_expression)<br> xpath_int (string xmlstr,string xpath_expression)<br> xpath_long (string xmlstr,string xpath_expression)<br> 返回值: int<br> 返回 xml 字符串中经过 xml 表达式计算后的值，如果不匹配，则返回0  </p><pre><code>hive&gt; SELECT xpath_int (&apos;this is not a number&apos;, &apos;a&apos;) FROM lxw1234;  0hive&gt; SELECT xpath_int (&apos;1248&apos;, &apos;sum(a/*)&apos;) FROM lxw1234;  15hive&gt; select xpath_long(&apos;10.511.2&apos;,&apos;sum(a/*)&apos;) from lxw1234;  21</code></pre></li><li><p>xpath_float, xpath_double, xpath_number<br> xpath_float (string xmlstr,string xpath_expression)<br> xpath_double (string xmlstr,string xpath_expression)<br> path_number (string xmlstr,string xpath_expression)<br> 返回值: number<br> 返回 xml 字符串中经过 xml 表达式计算后的值，如果不匹配，则返回0  </p><pre><code>hive&gt; select xpath_double(&apos;10.511.2&apos;,&apos;sum(a/*)&apos;) from lxw1234;  21.7</code></pre></li></ol><h3 id="十四、汇总统计函数（UDAF）"><a href="#十四、汇总统计函数（UDAF）" class="headerlink" title="十四、汇总统计函数（UDAF）"></a>十四、汇总统计函数（UDAF）</h3><ol><li><p>个数统计函数: count(*) || count(expr) || count(DISTINCT expr[, expr_.])  </p><p> count(*)统计检索出的行的个数，包括NULL值的行<br> count(expr)返回指定字段的非空值的个数<br> count(DISTINCTexpr[, expr_.])返回指定字段的不同的非空值的个数</p><pre><code>hive&gt; select count(*) from lxw_dual;20hive&gt; select count(distinct t) from lxw_dual;10</code></pre></li><li><p>总和统计函数: sum(col) || sum(DISTINCT col)<br> sum(col)统计结果集中col的相加的结果<br> sum(DISTINCT col)统计结果中col不同值相加的结果</p><pre><code>hive&gt; select sum(t) from lxw_dual;100hive&gt; select sum(distinct t) from lxw_dual;70</code></pre></li><li><p>平均值统计函数: avg(col) || avg(DISTINCT col)<br> avg(col)统计结果集中col的平均值<br> avg(DISTINCT col)统计结果中col不同值相加的平均值</p><pre><code>hive&gt; select avg(t) from lxw_dual;50hive&gt; select avg (distinct t) from lxw_dual;30</code></pre></li><li><p>最小值统计函数: min(col)<br> 统计结果集中col字段的最小值</p><pre><code>hive&gt; select min(t) from lxw_dual;20</code></pre></li><li><p>最大值统计函数: max(col)<br> 统计结果集中col字段的最大值</p><pre><code>hive&gt; select max(t) from lxw_dual;120</code></pre></li><li><p>非空集合总体变量函数: var_pop(col)<br> 返回值: double<br> 统计结果集中col非空集合的总体变量（忽略null）</p></li><li><p>非空集合样本变量函数: var_samp (col)<br> 返回值: double<br> 统计结果集中col非空集合的样本变量（忽略null）</p></li><li><p>总体标准偏离函数: stddev_pop(col)<br> 返回值: double<br> 该函数计算总体标准偏离，并返回总体变量的平方根，其返回值与VAR_POP函数的平方根相同</p></li><li><p>样本标准偏离函数: stddev_samp (col)<br> 返回值: double<br> 该函数计算样本标准偏离</p></li><li><p>中位数函数: percentile  </p><ul><li><p>percentile(BIGINT col, p)<br>求准确的第pth个百分位数，p必须介于0和1之间，但是col字段目前只支持整数，不支持浮点数类型  </p><pre><code>hive&gt;select percentile(id,0.2) from student;2.0</code></pre></li><li><p>percentile(BIGINT col, array(p1 [, p2]…))<br>功能和上述类似，之后后面可以输入多个百分位数，返回类型也为array<double>，其中为对应的百分位数</double></p><pre><code>hive&gt;select percentile(id,array(0.2,0.4)) from student；  [2.0,2.4000000000000004]</code></pre></li></ul></li><li><p>近似中位数函数: percentile_approx(DOUBLE col, p [, B])<br>求近似的第pth个百分位数，p必须介于0和1之间，返回类型为double，但是col字段支持浮点类型。参数B控制内存消耗的近似精度，B越大，结果的准确度越高。默认为10,000。当col字段中的distinct值的个数小于B时，结果为准确的百分位数</p></li></ol><ol start="12"><li><p>直方图: histogram_numeric(col, b)<br>返回值：array&lt;struct {‘x’,’y’}&gt;<br>以b为基准计算col的直方图信息  </p><pre><code>hive&gt; select histogram_numeric(100,5) from lxw_dual;[{&quot;x&quot;:100.0,&quot;y&quot;:1.0}]</code></pre></li><li><p>集合去重数：collect_set(col)<br>只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段</p><pre><code>如下数据记录，要统计每种no下的score，这里就可以配合group by 产生奇效no  score1   21   31   32   22   42   4hive&gt;select no，collect_set(score) from tablss group by no;1    [2,3]2    [2,4]hive&gt; select * from student;1    zhangsan    222    lisi    213    wangwu    174    zhaoliu    252    lisi    213    wangwu    174    zhaoliu    25hive&gt;select name,collect_set(id) from student group by name;lisi [2]wangwu [3]zhangsan [1]zhaoliu [4]</code></pre></li><li><p>集合不去重函数：collect_list (col)<br>返回值: array<br>将 col 字段合并成一个数组,不去重  </p><pre><code>hive&gt; select no,collect_list(score) from tablss group by no;1    [2,3,3]2    [2,4,4]hive&gt; select name,collect_list(id) from student group by name;lisi    [2,2]wangwu    [3,3]zhangsan    [1]zhaoliu    [4,4]</code></pre></li></ol><h3 id="十五、表格生成函数Table-Generating-Functions-UDTF"><a href="#十五、表格生成函数Table-Generating-Functions-UDTF" class="headerlink" title="十五、表格生成函数Table-Generating Functions (UDTF)"></a>十五、表格生成函数Table-Generating Functions (UDTF)</h3><ol><li><p>数组拆分成多行：explode  </p><ul><li><p>explode(array<type> a)<br>  返回值：Array Type<br>  对于a中的每个元素，将生成一行且包含该元素  </type></p><pre><code>hive&gt; select explode(split(concat_ws(&apos;,&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;),&apos;,&apos;)) from test.dual;  1  2  3  4  5  6  7  8  9</code></pre></li></ul></li><li><p>Map拆分成多行：explode  </p><ul><li><p>explode(MAP)<br>  map中每个key-value对，生成一行，key为一列，value为一列</p><pre><code>hive&gt; select explode(map(&apos;k1&apos;,&apos;v1&apos;,&apos;k2&apos;,&apos;v2&apos;));k1    v1k2    v2</code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive</title>
      <link href="/2018/11/16/Hive-1/"/>
      <url>/2018/11/16/Hive-1/</url>
      
        <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>要访问HDFS上的数据可以通过shell命令和API<br>如果要处理HDFS上的数据可以通过MapReduce，但MR的操作门槛比较高，eg：需要不断的进行调试，如果无法在本地运行，需要不断地导出jar包放到linux下进行调试  </p><p><strong>Hive</strong>是通过一种叫做HQL的类SQL语句来处理HDFS上的数据，但是和SQL不一样的是，HQL语言会转换为MR程序执行（select * from table不需要，因为select * from table只是对全部文件数据进行读取，并没有对数据进行操作）  </p><p><strong>Hive元数据</strong>：指在Hive中创建的数据库、表、视图等信息。这些元数据存储在关系型数据库中，比如MySQL  </p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><ol><li><p>解压<br> tar -zxvf apache-hive-1.2.1-bin.tar.gz  </p></li><li><p>设置环境变量<br> 需要用root权限，修改/etc/profile文件，退出root权限，输入source /etc/profile使环境变量生效  </p><pre><code>HIVE_HOME=/home/hadoop/app/apache-hive-1.0.0-bin  export PATH=$PATH:$HIVE_HOME/bin</code></pre></li><li><p>修改hive-env.sh<br> 进入conf目录，将hive-env.sh.template复制并改名为hive-env.sh  </p><pre><code>#Set HADOOP_HOME to point to a specific hadoop install directory  HADOOP_HOME=/home/hadoop/app/hadoop-2.6.0</code></pre></li><li><p>修改hive-site.xml<br> 进入conf目录，将hive-site.xml放进去  </p><pre><code>&lt;configuration&gt;  &lt;property&gt;&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;&lt;value&gt;jdbc:mysql://localhost:3306/hive&lt;/value&gt;&lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;&lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;&lt;value&gt;root&lt;/value&gt;&lt;description&gt;password to use against metastore database&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;&lt;name&gt;hive.hwi.listen.port&lt;/name&gt;&lt;value&gt;9999&lt;/value&gt;&lt;description&gt;This is the port the Hive Web Interface will listen on&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;&lt;name&gt;datanucleus.autoCreateSchema&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;description&gt;creates necessary schema on a startup if one doesn&apos;t exist. set this to false, after creating it once&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;&lt;value&gt;root&lt;/value&gt;&lt;description&gt;Username to use against metastore database&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;&lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt;&lt;value&gt;/home/oracle/appdata/hivetmp/iotmp&lt;/value&gt;&lt;description&gt;Local scratch space for Hive jobs&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;&lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt;&lt;value&gt;/home/oracle/appdata/hivetmp/iotmp&lt;/value&gt;&lt;description&gt;Temporary local directory for added resources in the remote file system.&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;&lt;name&gt;hive.querylog.location&lt;/name&gt;&lt;value&gt;/home/oracle/appdata/hivetmp/iotmp&lt;/value&gt;&lt;description&gt;Location of Hive run time structured log file&lt;/description&gt;  &lt;/property&gt;&lt;/configuration&gt;  </code></pre></li><li><p>拷贝mysql-connector-java-5.0.8-bin.jar到hive 的lib下面  </p></li><li><p>在linux下安装mysql，需在root权限下进行操作 <strong>记得设置密码</strong>  </p><ul><li>安装mysql：yum install mysql-server mysql mysql-devel  </li><li>开启mysql服务：service mysqld start  </li><li>设置mysql密码：mysqladmin -u root password ‘root’  </li><li>mysql服务开机启动：chkconfig mysqld on  <br></li></ul></li><li><p>把jline-2.12.jar拷贝到hadoop相应的目录下，替代jline-0.9.94.jar，否则启动会报错  </p><pre><code>cp hive/lib/jline-2.12.jar  hadoop-2.6.0/share/hadoop/yarn/lib/</code></pre></li></ol><h3 id="三、启动Hive"><a href="#三、启动Hive" class="headerlink" title="三、启动Hive"></a>三、启动Hive</h3><ol><li>MySql<br> 先启动MySQL创建hive数据库  create database hive;  </li><li>Hadoop<br> 启动hadoop sbin/start-all.sh </li><li>Hive<br> 输入hive进入到hive shell  </li></ol><p><strong>Hive默认存储在hadoop下的/user/hive/warehouse下</strong>  </p><h3 id="四、Hive使用"><a href="#四、Hive使用" class="headerlink" title="四、Hive使用"></a>四、Hive使用</h3><ol><li><p>Hive默认数据库是default，直接创建table会建在defaul数据库中，同时会在/user/hive/warehouse下创建对应表名的一个目录  </p></li><li><p>如果创建了一个新的数据库，会在/user/hive/warehouse下新建一个对应库名的目录，以.db结尾，该新建数据库的所有table都会存在该目录下  </p></li><li><p>内部表的三种插入数据方式：      </p><ul><li>insert  </li><li>hive的load命令，加载数据<br><code>load data local inpath &#39;/home/hadoop/student.txt&#39; into table student;</code></li><li>直接把数据文件复制到相应的HDFS目录中  <br></li></ul></li><li><p>外部表只有前两种插入数据方式<br> 因为创建外部表的时候，不会在HDFS的数据库目录下创建该表的目录，在向表里添加数据时，也不在表目录中存储，删除外部表的时候，只会把表信息删除，不会删除表里的数据</p></li></ol><p>###五、使用Hive解析Json</p><ol><li><p>把json-serde-1.3.6-SNAPSHOT-jar-with-dependencies.jar复制到hive的lib目录下，重新进入hive  </p></li><li><p>建表：  </p><pre><code>create table user_movie(custid string, sno string, genreid string, movieid string) ROW FORMAT SERDE &apos;org.openx.data.jsonserde.JsonSerDe&apos;  STORED AS TEXTFILE;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yarn</title>
      <link href="/2018/11/16/Hadoop-3/"/>
      <url>/2018/11/16/Hadoop-3/</url>
      
        <content type="html"><![CDATA[<ol><li><p>Yarn的简介<br>Yarn是Hadoop集群的资源管理系统,Hadoop2.0对MapReduce框架做了彻底的设计重构。<br>Hadoop1.x对MapReduce job的调度管理方式主要包括两部分功能：** ResourceManagement 资源管理** 和 <strong>JobScheduling/JobMonitoring 任务调度监控</strong>。  到了Hadoop2.x也就是Yarn，它的目标是将这两部分功能分开，也就是分别用两个进程来管理这两个任务，将此拆分成了<strong>ResourceManager</strong> 和 <strong>ApplicationMaster</strong>。  需要注意的是，在Yarn中我们把job的概念换成了application，因为在新的Hadoop2.x中，运行的应用不只是MapReduce了，还有可能是其它应用如一个DAG（有向无环图Directed Acyclic Graph，例如storm应用）。  </p></li><li><p>Yarn的组件及架构<br> Yarn主要由以下几个组件组成：  </p><pre><code>1. ResourceManager：Global（全局）的进程  2. NodeManager：运行在每个节点上的进程  3. ApplicationMaster：Application-specific（应用级别）的进程  - *Scheduler：是ResourceManager的一个组件*  - *Container：节点上一组CPU和内存资源*  </code></pre><p> Container是Yarn对计算机计算资源的抽象，它其实就是一组CPU和内存资源，所有的应用都会运行在Container中。<br> ApplicationMaster是对运行在Yarn中某个应用的抽象，它其实就是某个类型应用的实例，ApplicationMaster是应用级别的，它的主要功能就是向ResourceManager（全局的）申请计算资源（Containers）并且和NodeManager交互来执行和监控具体的task。<br> Scheduler是ResourceManager专门进行资源管理的一个组件，负责分配NodeManager上的Container资源，NodeManager也会不断发送自己Container使用情况给ResourceManager。  </p><p> ResourceManager和NodeManager两个进程主要负责系统管理方面的任务。<br> ResourceManager有一个Scheduler，负责各个集群中应用的资源分配。对于每种类型的每个应用，都会对应一个ApplicationMaster实例，ApplicationMaster通过和ResourceManager沟通获得Container资源来运行具体的job，并跟踪这个job的运行状态、监控运行进度。  </p></li><li><p>Yarn 框架相对于老的 MapReduce 框架什么优势呢？  </p><pre><code>这个设计大大减小了 ResourceManager 的资源消耗，并且让监测每一个 Job 子任务 (tasks) 状态的程序分布式化了，更安全、更优美。在新的 Yarn 中，ApplicationMaster 是一个可变更的部分，用户可以对不同的编程模型写自己的 AppMst，让更多类型的编程模型能够跑在 Hadoop 集群中，可以参考 hadoop Yarn 官方配置模板中的 ``mapred-site.xml`` 配置。对于资源的表示以内存为单位 ( 在目前版本的 Yarn 中，没有考虑 cpu 的占用 )，比之前以剩余 slot 数目更合理。老的框架中，JobTracker 一个很大的负担就是监控 job 下的 tasks 的运行状况，现在，这个部分就扔给 ApplicationMaster 做了，而 ResourceManager 中有一个模块叫做 ApplicationsManager，它是监测 ApplicationMaster 的运行状况，如果出问题，会将其在其他机器上重启。Container 是 Yarn 为了将来作资源隔离而提出的一个框架。这一点应该借鉴了 Mesos 的工作，目前是一个框架，仅仅提供 java 虚拟机内存的隔离 ,hadoop 团队的设计思路应该后续能支持更多的资源调度和控制 , 既然资源表示成内存量，那就没有了之前的 map slot/reduce slot 分开造成集群资源闲置的尴尬情况。</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Yarn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop生态圈</title>
      <link href="/2018/11/16/Hadoop-2/"/>
      <url>/2018/11/16/Hadoop-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Hadoop"><a href="#一、Hadoop" class="headerlink" title="一、Hadoop"></a>一、Hadoop</h2><ol><li><p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构  </p></li><li><p>充分利用集群的威力进行高速运算和存储，具有可靠、高效、可伸缩的特点  </p></li><li><p>Hadoop的核心是Yarn、HDFS和MapReduce</p><ul><li>适合大数据的分布式存储与计算平台</li><li>HDFS: Hadoop Distributed File System分布式文件系统</li><li>MapReduce：并行计算框架</li></ul></li></ol><h2 id="二、HDFS-Hadoop分布式文件系统"><a href="#二、HDFS-Hadoop分布式文件系统" class="headerlink" title="二、HDFS(Hadoop分布式文件系统)"></a>二、HDFS(Hadoop分布式文件系统)</h2><ol><li>Hadoop Distributed File System  </li><li>HDFS是Hadoop体系中数据存储管理的基础  </li><li>高容错；高吞吐量；在项目里处理大数据集；流式访问文件系统数据；可以构建在普通的硬件之上  </li><li>一次写入多次读取；数据以块的形式，同时分布在集群不同物理机器上</li></ol><h2 id="三、MapReduce-分布式计算框架"><a href="#三、MapReduce-分布式计算框架" class="headerlink" title="三、MapReduce(分布式计算框架)"></a>三、MapReduce(分布式计算框架)</h2><ol><li>MapReduce是一种分布式计算模型，用以进行大数据量的计算</li><li>它屏蔽了分布式计算框架细节，将计算抽象成map和reduce两部分，其中Map对数据集上的独立元素进行指定的操作，生成键-值对形式中间结果。Reduce则对中间结果中相同“键”的所有“值”进行规约，以得到最终结果</li></ol><h2 id="四、Hbase-分布式列存数据库"><a href="#四、Hbase-分布式列存数据库" class="headerlink" title="四、Hbase(分布式列存数据库)"></a>四、Hbase(分布式列存数据库)</h2><ol><li><p>HBase是一个建立在HDFS之上，面向列的针对结构化数据的可伸缩、高可靠、高性能、分布式和面向列的动态模式数据库</p></li><li><p>HBase利用Hadoop HDFS作为其文件存储系统，利用Hadoop MapReduce来处理HBase中的海量数据</p></li><li><p>一次写多次读，对修改支持很少</p></li><li><p>表 行键 列族 列 值</p><ul><li>Google Bigtable的开源实现</li><li>列式数据库</li><li>可集群化</li><li>可以使用shell、web、api等多种方式访问</li><li>适合高读写(insert)的场景</li><li>HQL查询语言</li><li>NoSQL的典型代表产品</li></ul></li></ol><h2 id="五、Hive-数据仓库"><a href="#五、Hive-数据仓库" class="headerlink" title="五、Hive(数据仓库)"></a>五、Hive(数据仓库)</h2><ol><li><p>Hive定义了一种类似SQL的查询语言(HQL),将SQL转化为MapReduce任务在Hadoop上执行</p></li><li><p>通常用于离线分析</p><ul><li>数据仓库工具。可以把Hadoop下的原始结构化数据变成Hive中的表</li><li>支持一种与SQL几乎完全相同的语言HiveQL。除了不支持更新、索引和事务，几乎SQL的其它特征都能支持</li><li>可以看成是从SQL到Map-Reduce的映射器</li><li>提供shell、JDBC/ODBC、Thrift、Web等接口</li></ul></li></ol><blockquote><p>数据仓库和关系型数据库的关系<br>一般来说，一个项目通常都有专门的数据库进行存储数据，这时候用到的一般都是关系型数据库，存储的数据都是较少的有针对性的数据，可以快速的存取<br>数据仓库中存储的数据是庞大的，并且种类繁多，所能执行的语句也很多  </p></blockquote><h2 id="六、Sqoop-数据ETL-同步工具"><a href="#六、Sqoop-数据ETL-同步工具" class="headerlink" title="六、Sqoop(数据ETL/同步工具)"></a>六、Sqoop(数据ETL/同步工具)</h2><ol><li><p>SQL-to-Hadoop</p></li><li><p>主要用于传统数据库和Hadoop之前传输数据,可以将一个关系型数据库中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中  </p></li><li><p>数据的导入和导出本质上是Mapreduce程序，充分利用了MR的并行化和容错性</p><ul><li>用于在Hadoop和关系型数据库之间交换数据</li><li>通过JDBC接口连入关系型数据库</li></ul></li></ol><h2 id="七、Flume-日志收集工具"><a href="#七、Flume-日志收集工具" class="headerlink" title="七、Flume(日志收集工具)"></a>七、Flume(日志收集工具)</h2><ol><li>Cloudera开源的日志收集系统，具有分布式、高可靠、高容错、易于定制和扩展的特点  </li><li>它将数据从产生、传输、处理并最终写入目标的路径的过程抽象为数据流，在具体的数据流中，数据源支持在Flume中定制数据发送方，从而支持收集各种不同协议数据  </li><li>同时，Flume数据流提供对日志数据进行简单处理的能力，如过滤、格式转换等。此外，Flume还具有能够将日志写往各种数据目标（可定制）的能力</li></ol><h2 id="八、Yarn-分布式资源管理器"><a href="#八、Yarn-分布式资源管理器" class="headerlink" title="八、Yarn(分布式资源管理器)"></a>八、Yarn(分布式资源管理器)</h2><ol><li>将JobTracker的两个主要功能（资源管理和作业调度/监控）分离，主要方法是创建一个全局的ResourceManager（RM）和若干个针对应用程序的ApplicationMaster（AM）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop1.0 和 Hadoop2.0</title>
      <link href="/2018/11/16/Hadoop-1/"/>
      <url>/2018/11/16/Hadoop-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-从Hadoop整体框架来说"><a href="#1-从Hadoop整体框架来说" class="headerlink" title="1.从Hadoop整体框架来说"></a>1.从Hadoop整体框架来说</h3><p>1.1 Hadoop1.0即第一代Hadoop，由分布式存储系统HDFS和分布式计算框架MapReduce组成，其中HDFS由一个NameNode和多个DateNode组成，MapReduce由一个JobTracker和多个TaskTracker组成。<br>1.2 Hadoop2.0为克服Hadoop1.0中的不足：<strong>针对Hadoop1.0单NameNode制约HDFS的扩展性问题</strong>，提出HDFS Federation，它让多个NameNode分管不同的目录进而实现访问隔离和横向扩展，同时彻底解决了NameNode单点故障问题；<br>针对Hadoop1.0中的MapReduce在扩展性和多框架支持等方面的不足，它将JobTracker中的资源管理和作业控制分开，分别由ResourceManager（负责所有应用程序的资源分配）和ApplicationMaster（负责管理一个应用程序）实现，即<strong>引入了资源管理框架Yarn</strong>。同时Yarn作为Hadoop2.0中的资源管理系统，它是一个通用的资源管理模块，可为各类应用程序进行资源管理和调度，不仅限于MapReduce一种框架，也可以为其他框架使用，如Tez、Spark、Storm等</p><h3 id="2-从MapReduce计算框架来说"><a href="#2-从MapReduce计算框架来说" class="headerlink" title="2.从MapReduce计算框架来说"></a>2.从MapReduce计算框架来说</h3><p>2.1 MapReduce1.0计算框架主要由三部分组成：编程模型、数据处理引擎和运行时环境。它的基本编程模型是将问题抽象成Map和Reduce两个阶段，其中Map阶段将输入的数据解析成key/value，迭代调用map()函数处理后，再以key/value的形式输出到本地目录，Reduce阶段将key相同的value进行规约处理，并将最终结果写到HDFS上；它的数据处理引擎由MapTask和ReduceTask组成，分别负责Map阶段逻辑和Reduce阶段的逻辑处理；它的运行时环境由一个JobTracker和若干个TaskTracker两类服务组成，其中JobTracker负责资源管理和所有作业的控制，TaskTracker负责接收来自JobTracker的命令并执行它。<br>2.2 MapReducer2.0具有与MRv1相同的编程模型和数据处理引擎，唯一不同的是运行时环境。MRv2是在MRv1基础上经加工之后，运行于资源管理框架Yarn之上的计算框架MapReduce。它的运行时环境不再由JobTracker和TaskTracker等服务组成，而是变为通用资源管理系统Yarn和作业控制进程ApplicationMaster，其中Yarn负责资源管理的调度而ApplicationMaster负责作业的管理。</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo相关配置</title>
      <link href="/2018/11/16/Hexo-2/"/>
      <url>/2018/11/16/Hexo-2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-配置Hexo基本信息"><a href="#1-配置Hexo基本信息" class="headerlink" title="1.配置Hexo基本信息"></a>1.配置Hexo基本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">title: 猫熊小才天の书院  #博客标题</span><br><span class="line">subtitle:   #博客副标题</span><br><span class="line">description: 凡事都想试一试的某某  #博客描述</span><br><span class="line">author: Mxxct  #博客作者</span><br><span class="line">language: zh-Hans #语言</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 5</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># 可以添加以下内容</span><br><span class="line">archive_generator:</span><br><span class="line">  per_page: 10 ##归档页面默认10篇文章标题</span><br><span class="line">  yearly: true  ##生成年视图</span><br><span class="line">  monthly: true ##生成月视图</span><br><span class="line">  </span><br><span class="line">tag_generator:</span><br><span class="line">  per_page: 10 ##标签分类页面默认10篇文章</span><br><span class="line">  </span><br><span class="line">category_generator:</span><br><span class="line">   per_page: 10 ###分类页面默认10篇文章</span><br></pre></td></tr></table></figure><h3 id="2-更换主题Next"><a href="#2-更换主题Next" class="headerlink" title="2.更换主题Next"></a>2.更换主题Next</h3><h4 id="2-1-安装主题"><a href="#2-1-安装主题" class="headerlink" title="2.1 安装主题"></a>2.1 安装主题</h4><p>输入以下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>下载完成后，修改根目录下_config.yml文件的theme字段为next即可启用NexT主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">## theme: landscape</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><h4 id="2-2-配置主题"><a href="#2-2-配置主题" class="headerlink" title="2.2 配置主题"></a>2.2 配置主题</h4><p>在footer部分，可以将powered和theme全部只为false，就可以屏蔽掉尾注<br>menu部分只打开home、tags、categories、archives即可<br>scheme按照喜好选择<br>将enable置为true，避免首页一次显示文章全部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure><h3 id="3-添加分类和标签功能"><a href="#3-添加分类和标签功能" class="headerlink" title="3.添加分类和标签功能"></a>3.添加分类和标签功能</h3><p>进入到博客根目录，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>成功后会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2018-11-16 17:00:00</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>添加type: “categories”到内容中，添加后文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2018-11-16 17:00:00</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>同理，如上操作创建标签功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2018-11-16 17:00:00</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>给文章添加分类和标签的样式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: windows搭建hexo系统</span><br><span class="line">date: 2018-11-16 17:10:51</span><br><span class="line">categories:</span><br><span class="line">  - hexo</span><br><span class="line">tags:</span><br><span class="line">   - hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>可以打开scaffolds/post.md文件，在tages:上面加入categories:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存后，之后执行hexo new 文章名命令生成的文件会自动加上categories</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows搭建Hexo系统</title>
      <link href="/2018/11/16/Hexo-1/"/>
      <url>/2018/11/16/Hexo-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h3><p>下载Windows下的<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git客户端</a>并安装，安装很简单，基本一路Next下去  </p><h3 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h3><p>下载<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>，安装Node.js也是一路Next下去，打开命令行输入node如果出现一个向右的箭头就说明安装成功</p><h3 id="3-配置Github"><a href="#3-配置Github" class="headerlink" title="3.配置Github"></a>3.配置Github</h3><h4 id="3-1-注册账户"><a href="#3-1-注册账户" class="headerlink" title="3.1 注册账户"></a>3.1 注册账户</h4><h4 id="3-2-新建repository"><a href="#3-2-新建repository" class="headerlink" title="3.2 新建repository"></a>3.2 新建repository</h4><p><strong>owner是ABC的话，那么Repository.name就必须是 ABC.github.io，与你的github账号的名称一致，否则在之后输入网址时会报404错误</strong></p><p><img src="https://i.imgur.com/PyRjUmt.png" alt></p><h4 id="3-3-配置Github-SSH密钥"><a href="#3-3-配置Github-SSH密钥" class="headerlink" title="3.3 配置Github SSH密钥"></a>3.3 配置Github SSH密钥</h4><p>打开Git Bash，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your&apos;s emaill address&quot;</span><br></pre></td></tr></table></figure><p><strong>注意要加引号</strong><br>然后回车，会提示你文件保存的路径，这时候按回车键确认<br>然后会提示你输入密码，输入即可（输入密码是看不到的），然后会确认输入一次，就可以在刚刚的路径看到生成了两个文件，一个是id_rsa，另一个是id_rsa.pub，打开id_rsa.pub然后选中里面的全部内容，复制下来。  </p><p>登录github，点击头像可以看到setting选项，点击进入<br>然后可以看到左边有一个SSH and GPG keys选项<br>点击就可以看到以下界面，点击New SSH</p><p><img src="https://i.imgur.com/mpCNAXo.jpg" alt></p><p>Title随便填写，主要是为了方便管理密钥，然后把刚刚拷贝的内容粘贴到Key里面去，然后点击Add SSH key。<br>Github上的配置就完成了</p><h4 id="3-4-创建本地仓库与Github同步"><a href="#3-4-创建本地仓库与Github同步" class="headerlink" title="3.4 创建本地仓库与Github同步"></a>3.4 创建本地仓库与Github同步</h4><p>在本地任意一个分区的任意位置创建一个文件夹，路径及文件夹名不要有中文。打开Git Bash，cd 进入到刚创建的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git config --global user.name &quot;Your&apos;s name&quot;</span><br><span class="line">git config --global user.email &quot;Your&apos;s email address&quot;</span><br></pre></td></tr></table></figure><p><strong>要带着引号</strong><br>其中的Your’s name替换成github账户的名称，Your’s email address替换成你的邮件地址即可<br>然后再当前的文件夹下面新建一个README.md文件，然后右键用notepad++打开，随便写入一点内容，做一次简单的提交，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin git@github.com:yourname/yourname.github.io.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>运行成功之后，进入到git仓库中就可以看到有README.md文件</p><h3 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4.安装Hexo"></a>4.安装Hexo</h3><h4 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h4><p>打开Git Bash，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>敲完回车可能没有任何提示，请一定要耐心等待<br>安装成功后，可以输入以下命令测试以下Hexo是否安装成功  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure><p>如果能看到hexo的版本号信息，就表示安装成功了</p><h4 id="4-2-初始化Hexo"><a href="#4-2-初始化Hexo" class="headerlink" title="4.2 初始化Hexo"></a>4.2 初始化Hexo</h4><p>在本地任意一个分区的任意位置创建一个文件夹，路径及文件夹名不要有中文。打开Git Bash，cd 进入到刚创建的文件夹，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>这时候在浏览器中打开 localhost:4000 就可以看到hexo生成的博客</p><blockquote><p>hexo常用指令<br>hexo g 生成静态文件<br>hexo s 启动本地服务器进行预览<br>hexo d 部署到github上发布<br>hexo clean 清除缓存<br>hexo new “abc” 新建文章 在source_posts路径下<br>hexo new page “pageName” 新建页面</p></blockquote><h4 id="4-3-配置Hexo到Github上"><a href="#4-3-配置Hexo到Github上" class="headerlink" title="4.3 配置Hexo到Github上"></a>4.3 配置Hexo到Github上</h4><p>在hexo的文件夹中打开_config.yml文件，修改文件最后部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">  type: git</span><br><span class="line">  repository: http://github.com/yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>yourname是github的账户名</strong><br>保存，然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>如果出现以下异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure><p>尝试输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后再次输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时候会弹出一个对话框，输入github上的账号和密码，运行成功后，在浏览器中输入<a href="http://yourname.github.io查看博客首页" target="_blank" rel="noopener">http://yourname.github.io查看博客首页</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2018/07/15/Vue-1/"/>
      <url>/2018/07/15/Vue-1/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ol><li><p>定位（float 、 position等）会脱离文档流，即对div判定高度会有影响。可以在需要定位的div中再套一层div，在父div中clear：both，或者修改需要定位的div属性从float改到text-align</p></li><li><p>route跳转</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">path: &apos;/second/Build_Detail&apos;,</span><br><span class="line">query: &#123;</span><br><span class="line">stageIndex: index</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"># 下一个页面获取参数</span><br><span class="line">Index: this.$route.query.stageIndex</span><br></pre></td></tr></table></figure><ol start="3"><li>多个$axios嵌套会导致异步问题，换成ajax就可以了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">this.$jquery.ajax(&#123;</span><br><span class="line">type: &apos;post&apos;,</span><br><span class="line">dataType: &apos;json&apos;,</span><br><span class="line">url: &apos;/&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">dataTable: &quot;&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">async: false, // false是同步</span><br><span class="line">success:function (response) &#123;</span><br><span class="line">var data = response.data;</span><br><span class="line">console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>for循环获取元素id</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; len; i++)&#123;</span><br><span class="line">var str = &quot;#bt&quot; + &quot;_&quot; + i; // #bt_1</span><br><span class="line">$(str).removeClass(&quot;button_act&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>如果对 对象、数组等非直接变量查询赋值之后页面没有刷新</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.object = JSON.parse(JSON.stringify(this.object));</span><br></pre></td></tr></table></figure><blockquote><p>通过使用JSON先转换再解析的方式，可以骗浏览器这是一个新的对象，就可以实现局部渲染。如果页面是通过循环来输出对象中的值那就并不需要这一步。</p></blockquote><ol start="6"><li>动态计算进度条宽度</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;color&quot; :style=&quot;&#123; width : done != &apos;-&apos; ? (done &gt; all) ? &apos;100%&apos; : (done*100/all) + &apos;%&apos; : &apos;0%&apos;&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>通过 Set() 去重，然后转换成数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var prctrSet = new Set();</span><br><span class="line">for (var i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">prctrSet.add(data[i].prctr);</span><br><span class="line">&#125;</span><br><span class="line">this.prcArray = Array.from(prctrSet);</span><br></pre></td></tr></table></figure><ol start="8"><li><p>“v-show”所包含的组件也会在呈现页面的时候获取数据</p></li><li><p>页面第一次显示数组中的数据（以json形式存储）的时候，可能会因为没有key值而报错，导致整个页面无法呈现。所以需要在初始化的时候把数组全部key值写出来，value写空</p></li><li><p>div中的文字垂直居中</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">parentElement&#123;</span><br><span class="line">position:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">childElement&#123;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">transform: translateY(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>阻止旋转屏幕时自动调整字体大小</li></ol><p>移动端开发时，屏幕有竖屏和横屏模式，当屏幕进行旋转时，字体大小则有可能会发生变化，从而影响页面布局的整体样式，为避免此类情况发生，只需设置如下样式即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  -webkit-text-size-adjust: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li>iOS 下取消 input 在输入的时候英文首字母的默认大写</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; autocapitalize=&quot;none&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="13"><li>禁止 iOS 识别长串数字为电话</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</span><br></pre></td></tr></table></figure><ol start="14"><li>禁止 iOS 弹出各种操作窗口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-touch-callout: none;</span><br></pre></td></tr></table></figure><ol start="15"><li>禁止 ios 和 android 用户选中文字</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-user-select: none;</span><br></pre></td></tr></table></figure><ol start="16"><li>浮动子元素撑开父元素盒子高度</li></ol><p>解决方法如下：</p><pre><code>1. 父元素设置为 overflow: hidden;2. 父元素设置为 display: inline-block; 等</code></pre><p>这里两种方法都是通过设置css属性将浮动元素的父元素变成间接变成BFC元素，然后使得子元素高度可以撑开父元素。这里需要注意的时，最好使用方法1， 因为inline-block元素本身会自带一些宽高度撑开其本身。</p><ol start="17"><li>往返缓存问题</li></ol><p>点击浏览器的回退，有时候不会自动执行js，特别是在mobilesafari中。这与往返缓存(bfcache)有关系。 解决方法 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.onunload = function () &#123;&#125;;</span><br></pre></td></tr></table></figure><ol start="18"><li>overflow-x: auto 在iOS有兼容问题; 滑动卡顿</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-overflow-scrolling: touch;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop 指令</title>
      <link href="/2018/04/30/Hadoop-4/"/>
      <url>/2018/04/30/Hadoop-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Hadoop-指令"><a href="#Hadoop-指令" class="headerlink" title="Hadoop 指令"></a>Hadoop 指令</h2><h3 id="1-ls"><a href="#1-ls" class="headerlink" title="1.ls"></a>1.ls</h3><pre><code>hadoop fs -ls  /</code></pre><p>列出hdfs文件系统根目录下的目录和文件</p><pre><code>hadoop fs -ls -R /</code></pre><p>列出hdfs文件系统所有的目录和文件</p><h3 id="2-put"><a href="#2-put" class="headerlink" title="2.put"></a>2.put</h3><pre><code>hadoop fs -put &lt; local file &gt; &lt; hdfs file &gt;</code></pre><p>hdfs file的父目录一定要存在，否则命令不会执行</p><pre><code>hadoop fs -put  &lt; local file or dir &gt;...&lt; hdfs dir &gt;</code></pre><p>hdfs dir 一定要存在，否则命令不会执行</p><pre><code>hadoop fs -put - &lt; hdsf  file&gt;</code></pre><p>从键盘读取输入到hdfs file中，按Ctrl+D结束输入，hdfs file不能存在，否则命令不会执行</p><h4 id="2-1-moveFromLocal"><a href="#2-1-moveFromLocal" class="headerlink" title="2.1.moveFromLocal"></a>2.1.moveFromLocal</h4><pre><code>hadoop fs -moveFromLocal  &lt; local src &gt; ... &lt; hdfs dst &gt;</code></pre><p>与put相类似，命令执行后源文件 local src 被删除，也可以从从键盘读取输入到hdfs file中</p><h4 id="2-2-copyFromLocal"><a href="#2-2-copyFromLocal" class="headerlink" title="2.2.copyFromLocal"></a>2.2.copyFromLocal</h4><pre><code>hadoop fs -copyFromLocal  &lt; local src &gt; ... &lt; hdfs dst &gt;</code></pre><p>与put相类似，也可以从从键盘读取输入到hdfs file中</p><p>###3.get</p><pre><code>hadoop fs -get &lt; hdfs file &gt; &lt; local file or dir&gt;</code></pre><p>local file不能和 hdfs file名字不能相同，否则会提示文件已存在，没有重名的文件会复制到本地</p><pre><code>hadoop fs -get &lt; hdfs file or dir &gt; ... &lt; local  dir &gt;</code></pre><p>拷贝多个文件或目录到本地时，本地要为文件夹路径  </p><p>注意：如果用户不是root， local 路径要为用户文件夹下的路径，否则会出现权限问题，</p><h4 id="3-1-moveToLocal"><a href="#3-1-moveToLocal" class="headerlink" title="3.1.moveToLocal"></a>3.1.moveToLocal</h4><p>当前版本中还未实现此命令</p><h4 id="3-2-copyToLocal"><a href="#3-2-copyToLocal" class="headerlink" title="3.2.copyToLocal"></a>3.2.copyToLocal</h4><pre><code>hadoop fs -copyToLocal &lt; local src &gt; ... &lt; hdfs dst &gt;</code></pre><p>与get相类似</p><h3 id="4-rm"><a href="#4-rm" class="headerlink" title="4.rm"></a>4.rm</h3><pre><code>hadoop fs -rm &lt; hdfs file &gt; ...hadoop fs -rm -r &lt; hdfs dir&gt;...</code></pre><p>每次可以删除多个文件或目录</p><h3 id="5-mkdir"><a href="#5-mkdir" class="headerlink" title="5.mkdir"></a>5.mkdir</h3><pre><code>hadoop fs -mkdir &lt; hdfs path&gt;</code></pre><p>只能一级一级的建目录，父目录不存在的话使用这个命令会报错</p><pre><code>hadoop fs -mkdir -p &lt; hdfs path&gt; </code></pre><p>所创建的目录如果父目录不存在就创建该父目录</p><h3 id="6-getmerge"><a href="#6-getmerge" class="headerlink" title="6.getmerge"></a>6.getmerge</h3><pre><code>hadoop fs -getmerge &lt; hdfs dir &gt;  &lt; local file &gt;</code></pre><p>将hdfs指定目录下所有文件排序后合并到local指定的文件中，文件不存在时会自动创建，文件存在时会覆盖里面的内容</p><pre><code>hadoop fs -getmerge -nl  &lt; hdfs dir &gt;  &lt; local file &gt;</code></pre><p>加上nl后，合并到local file中的hdfs文件之间会空出一行</p><h3 id="7-cp"><a href="#7-cp" class="headerlink" title="7.cp"></a>7.cp</h3><pre><code>hadoop fs -cp  &lt; hdfs file &gt;  &lt; hdfs file &gt;</code></pre><p>目标文件不能存在，否则命令不能执行，相当于给文件重命名并保存，源文件还存在</p><pre><code>hadoop fs -cp &lt; hdfs file or dir &gt;... &lt; hdfs dir &gt;</code></pre><p>目标文件夹要存在，否则命令不能执行</p><h3 id="8-mv"><a href="#8-mv" class="headerlink" title="8.mv"></a>8.mv</h3><pre><code>hadoop fs -mv &lt; hdfs file &gt;  &lt; hdfs file &gt;</code></pre><p>目标文件不能存在，否则命令不能执行，相当于给文件重命名并保存，源文件不存在</p><pre><code>hadoop fs -mv  &lt; hdfs file or dir &gt;...  &lt; hdfs dir &gt;</code></pre><p>源路径有多个时，目标路径必须为目录，且必须存在。  </p><p>注意：跨文件系统的移动（local到hdfs或者反过来）都是不允许的</p><h3 id="9-count"><a href="#9-count" class="headerlink" title="9.count"></a>9.count</h3><pre><code>hadoop fs -count &lt; hdfs path &gt;</code></pre><p>统计hdfs对应路径下的目录个数，文件个数，文件总计大小  </p><p>显示为目录个数，文件个数，文件总计大小，输入路径</p><h3 id="10-du"><a href="#10-du" class="headerlink" title="10.du"></a>10.du</h3><pre><code>hadoop fs -du &lt; hdsf path&gt; </code></pre><p>显示hdfs对应路径下每个文件夹和文件的大小</p><pre><code>hadoop fs -du -s &lt; hdsf path&gt; </code></pre><p>显示hdfs对应路径下所有文件和的大小</p><pre><code>hadoop fs -du - h &lt; hdsf path&gt; </code></pre><p>显示hdfs对应路径下每个文件夹和文件的大小,文件的大小用方便阅读的形式表示，例如用64M代替67108864</p><h3 id="11-text"><a href="#11-text" class="headerlink" title="11.text"></a>11.text</h3><pre><code>hadoop fs -text &lt; hdsf file&gt;</code></pre><p>将文本文件或某些格式的非文本文件通过文本格式输出</p><h3 id="12-setrep"><a href="#12-setrep" class="headerlink" title="12.setrep"></a>12.setrep</h3><pre><code>hadoop fs -setrep -R 3 &lt; hdfs path &gt;</code></pre><p>改变一个文件在hdfs中的副本个数，上述命令中数字3为所设置的副本个数，-R选项可以对一个人目录下的所有目录+文件递归执行改变副本个数的操作</p><h3 id="13-stat"><a href="#13-stat" class="headerlink" title="13.stat"></a>13.stat</h3><pre><code>hdoop fs -stat [format] &lt; hdfs path &gt;</code></pre><p>返回对应路径的状态信息   </p><p>[format]可选参数有：%b（文件大小），%o（Block大小），%n（文件名），%r（副本个数），%y（最后一次修改日期和时间）  </p><p>可以这样书写hadoop fs -stat %b%o%n &lt; hdfs path &gt;，不过不建议，这样每个字符输出的结果不是太容易分清楚</p><h3 id="14-tail"><a href="#14-tail" class="headerlink" title="14.tail"></a>14.tail</h3><pre><code>hadoop fs -tail &lt; hdfs file &gt;</code></pre><p>在标准输出中显示文件末尾的1KB数据</p><h3 id="15-archive"><a href="#15-archive" class="headerlink" title="15.archive"></a>15.archive</h3><pre><code>hadoop archive -archiveName name.har -p &lt; hdfs parent dir &gt; &lt; src &gt;* &lt; hdfs dst &gt;</code></pre><p>命令中参数</p><p>name：压缩文件名，自己任意取；</p><p>&lt; hdfs parent dir &gt; ：压缩文件所在的父目录；</p><p>&lt; src &gt;：要压缩的文件名；</p><p>&lt; hdfs dst &gt;：压缩文件存放路径</p><p>示例：<code>hadoop archive -archiveName hadoop.har -p /user 1.txt 2.txt /des</code>  </p><p>示例中将hdfs中/user目录下的文件1.txt，2.txt压缩成一个名叫hadoop.har的文件存放在hdfs中/des目录下，如果1.txt，2.txt不写就是将/user目录下所有的目录和文件压缩成一个名叫hadoop.har的文件存放在hdfs中/des目录下</p><p>显示har的内容可以用如下命令：</p><pre><code>hadoop fs -ls /des/hadoop.har</code></pre><p>显示har压缩的是那些文件可以用如下命令</p><pre><code>hadoop fs -ls -R har:///des/hadoop.har</code></pre><p>注意：har文件不能进行二次压缩。如果想给.har加文件，只能找到原来的文件，重新创建一个。har文件中原来文件的数据并没有变化，har文件真正的作用是减少NameNode和DataNode过多的空间浪费。</p><h3 id="16-balancer"><a href="#16-balancer" class="headerlink" title="16.balancer"></a>16.balancer</h3><pre><code>hdfs balancer</code></pre><p>如果管理员发现某些DataNode保存数据过多，某些DataNode保存数据相对较少，可以使用上述命令手动启动内部的均衡过程</p><h3 id="17-dfsadmin"><a href="#17-dfsadmin" class="headerlink" title="17.dfsadmin"></a>17.dfsadmin</h3><pre><code>hdfs dfsadmin -help</code></pre><p>管理员可以通过dfsadmin管理HDFS，用法可以通过上述命令查看</p><pre><code>hdfs dfsadmin -report</code></pre><p>显示文件系统的基本数据</p><pre><code>hdfs dfsadmin -safemode &lt; enter | leave | get | wait &gt;</code></pre><p>enter：进入安全模式；<br>leave：离开安全模式；<br>get：获知是否开启安全模式；<br>wait：等待离开安全模式</p><h3 id="18-distcp"><a href="#18-distcp" class="headerlink" title="18.distcp"></a>18.distcp</h3><p>用来在两个HDFS之间拷贝数据</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个人</title>
      <link href="/2014/11/20/Novel-1/"/>
      <url>/2014/11/20/Novel-1/</url>
      
        <content type="html"><![CDATA[<p>一个人走进另一个人的世界是多么美好的一件事啊。</p><p>从相见到相识，从相知到相认，从独立的生命个体到相互牵连的二人世界。</p><p>每一个过程，每一个细节，都是这个世界上最美好的东西。</p><p>无需言说的默契，随时依靠的臂膀，默默注视的目光，不曾离去的身影，共赴未来的信心，心系彼此的牵挂，随时随地的想念，患难与共的执着。</p><p>两个人，意味着你不再是一个人，意味着你的生命开始有了另一个人的影子，意味着你从现在开始所做的每一个决定所下的每一个决心，都不再仅仅是你一个人的事。</p><p>是的，这样会很麻烦。你需要考虑什么时候出去，去哪个地方，你需要为另一个人考虑很多，你需要把两个人的时间全部考虑进来，并且做出一个较好的选择。在这些选择中不会有最好的。</p><p>是的，这样会很麻烦。你需要在照顾你的同时去照顾另一个人，就像是另一个自己，让自己牵肠挂肚。你不能敷衍。你宁可敷衍自己也不能敷衍另一个人。你要去记住一些事情，这些事情也许是另一个人的生日，你们的纪念日，你们两个的秘密，另一个人的秘密，诸如此类。</p><p>是的，这样会很麻烦。你需要在学习上帮助另一个人，你需要在工作上帮助另一个人，你需要在很多时候去为另一个人寻找一些捷径。</p><p>你本不需要这样做。你可以一个人去上课，一个人去吃饭，一个人去上自习，一个人回宿舍，一个人去生活，背着一个人的包，听着一个人的歌，走着一个人的路，过着一个人的生活。这样的生活简单，不需你额外的操心。</p><p>但是我们都不曾拒绝另一个人的出现。</p><p>我们会幼稚，但是会为了那个人而变得成熟；我们会胆怯，但是会为了那个人而变得勇敢；我们会脆弱，但是会为了那个人而变得坚强；我们会退缩，但是会为了那个人而变得进取。</p><p>我们会丢掉给自己的时间，我们会妥协自己的安排，我们会改变自己的一些习惯，甚至可能会改变自己最初的目标，但是我们会收获另一个人的陪伴，会看见另一个自己，会发现自己的改变。</p><p>之前写过一篇短文，题目是《鱼儿》。很短，大体是说一个女生因为放不下前男友而无法接受男生对她的好。两个人在一起，每一个人的行为都会给对方留下很深的印象，这些印象会一直保留着，哪怕是最后分开了，那些特定的行为习惯也会在潜意识中不断浮现。</p><p>两个人在一起，需要做的不是强求去做什么，而是随性地表达自己，不刻意就好。你的一言一行一定会给那个人留下深刻的印象，这个印象是你们共同的回忆。</p><p>牵着你的手，耳边流动的是你动人的声音，风起了，为你围上围巾，为你披上外套，做你的守护者，那条洒满阳光的路，从这头走到那头，用了彼此最美好的年华。</p><p>一个人走进另一个人的世界是多么美好的一件事啊。</p><p>哪怕想想也是美好的。</p>]]></content>
      
      
      <categories>
          
          <category> Novel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Novel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sword Art Online 刀剑神域</title>
      <link href="/2014/10/06/Novel-2/"/>
      <url>/2014/10/06/Novel-2/</url>
      
        <content type="html"><![CDATA[<h5 id="【一】"><a href="#【一】" class="headerlink" title="【一】"></a>【一】</h5><p>他和她，第一次相见是在游戏里，两个角色的对话。现在说来都不算是正式见面呢。</p><p>“你好。”</p><p>“……”</p><p>“那个，他们都组完队了，就剩下咱俩了……”</p><p>“……”</p><p>“我叫桐人，你呢？”</p><p>“……</p><p>他的每一句得到的都是对方无言的回复。</p><p>算了，组队要紧。他发组队申请发了过去。五秒钟后，收到了对方同意的回复。</p><p>第一次见面算是……圆满结束？</p><h5 id="【二】"><a href="#【二】" class="headerlink" title="【二】"></a>【二】</h5><p>这是一个游戏，一个被人篡改的游戏，一个被人设下了陷阱的游戏。</p><p>原先只是当做大脑潜行运行的4D技术游戏，结果进来之后发现整个游戏被开发者私自篡改了：如果不能闯过世界之塔就无法安全离开，游戏中的死亡亦会带来现实中的身体的死亡。</p><p>并不是所有人都适合游戏，也不是所有人都适合战斗。愤怒，紧张，焦虑，猜疑，诸多负面情绪使游戏一开始就有不少玩家死亡，真正的死亡。</p><p>相反地，有一部分人开始组建起来，结合众人之力，一起攻塔，情报共享，资源共享。这样的组织在这个广袤的游戏世界里有很多，最厉害的一个是圣龙骑士团，而她是这个组织的副团长，他则是一个独行侠。这是后话。</p><p>正如世界之初，有清澄便会有混沌，有光明便会有黑暗，有为了拯救玩家而奋斗的组织自然也会有只为自己趁机烧杀抢夺的组织：微笑棺材。于是就会出现维持正义与秩序的组织，例如护卫队。</p><h5 id="【三】"><a href="#【三】" class="headerlink" title="【三】"></a>【三】</h5><p>他与她的第一次组队，两人表现出极高的默契度。</p><p>他作为该游戏的内测玩家，在这次正式版中知道了比普通玩家更多的情报，拥有更强的预判能力，被称为“封弊者”；而她拥有一个剑士所必需的敏捷与速度。这两点让他们配合的游刃有余，更为重要的是他们相信彼此。如果说这个世界上还有什么值得追求，那就是友情，可以放心把背后交给彼此的友情。</p><p>说起这次组队，其实是仅仅是为了攻塔而临时组起来的。所以在任务完成之后，他们登上更高的一层之后，组队结束。他又恢复了原先的独行侠身份，而她则继续提升自己。</p><p>亚丝娜。真是个不错的名字。你的成长很快，如果以后有组织向你发出申请，好好把握机会吧。</p><h5 id="【四】"><a href="#【四】" class="headerlink" title="【四】"></a>【四】</h5><p>先前的内测让他更加熟悉这个世界，虽然有些许的改动，但在基础阶段还是足以应付，所以他的等级算是所有玩家里最高的。只是别的玩家等级不够，无法窥视等级，加上他不说，所以不会有人知道他的实力。</p><p>他其实很享受这个游戏，帮帮弱者，做做任务，不加任何组织，偶尔想念一个人。</p><h5 id="【五】"><a href="#【五】" class="headerlink" title="【五】"></a>【五】</h5><p>再见面，是在一次动员大会上。她作为圣龙骑士团的副团长，号召玩家一起攻打新一层的最终Boss。他与她意见不合，吵了嘴，会议不欢而散。</p><p>他和她每次在开会的时候都会这样，所以大家都已经习以为常了。解决矛盾是他和她的事，参不参加攻塔之战是大家的选择。</p><p>“干嘛每次都要和我反着来？”</p><p>“因为你的战策会伤害到无辜的人。”</p><p>“那些NPC就算消失，过一段时间也会自我补充，如果是我们的士兵消失，怎么弥补我们的损失？”</p><p>“就因为这样所以损伤无辜吗……”</p><p>事实上每次吵架都非常的没意义，因为不管怎样，他都会听她的，毕竟她才是副团长。</p><h5 id="【六】"><a href="#【六】" class="headerlink" title="【六】"></a>【六】</h5><p>他之前加过一个组织，大家的等级很低，认识他们是因为路过出手相救。至于为什么会答应他们的请求，他说在那个组织里感受到了家的温暖。</p><p>一群小人物为了自己的目标，一直在努力着，生活很艰难，但总是充满欢乐，他相信他们会见到梦想中的阳光。</p><p>可是游戏像命运一样令人难以捉摸。在一次探险中误入陷阱，传送水晶失效，全员覆灭。他看着同伴一个个被屠杀，就在他的面前，尸体渐渐晶体化，最终消失，不留痕迹，除了心底的伤痛。</p><p>就在那一次之后他发誓再也不会加入任何组织。因为他不想再看到自己的同伴在自己的面前消失。</p><p>不过事与愿违，为了她，他和团长约战，如果他赢了就可以带走她，如果他输了就必须加入圣龙骑士团。</p><p>结果是，他进了圣龙骑士团。</p><h5 id="【七】"><a href="#【七】" class="headerlink" title="【七】"></a>【七】</h5><p>其实并不只是他很享受游戏。</p><p>人类是一种坚强而又软弱的动物，有的人懂得迎难而上，有的人知道知难而退。很多人知道凭借自己的能力是无法攻塔成功的，亦不会登出成功，所以他们选择生活，平静的生活，一个个家庭，一个个村庄，享受着现代生活中早已消失不见的悠闲。</p><p>在某层某个村落旁，他买下了一座房子，和她一直在那儿，享受两个月的蜜月。</p><p>在不断的攻塔战争中，他和她一直延续着第一次的默契配合，于是她提出了一直组队的要求，在威逼利诱之下他答应了。日久生情吧，两人在一次次的战斗中产生了彼此的依赖感，在他加入圣龙骑士团的时候他们结婚了，并申请了两个月的假期。远离前线，享受生活。</p><h5 id="【八】"><a href="#【八】" class="headerlink" title="【八】"></a>【八】</h5><p>之后的情节就真的是情节了。双刀流，击败最终的Boss，却发现这只是开发者的一个意识投影，仅仅是为了观察人类的大脑。</p><p>不过这对他无所谓，因为有她在就好。很快他和她都会在真实世界里醒来，他和她很快就会见面。</p><p>当他在病房里见到她时，她已经坐起来了，窗外的月光流进了室内，洒在窗台上的那盆郁金香上，还有她的身上，像极了一身银白色婚纱。</p><p>“初次见面，我叫亚丝娜。”</p><p>这次换来的是他的无言答复。</p><p>他只是紧紧抱着她。</p><p>回来，真好。</p><p>你在，就好。</p>]]></content>
      
      
      <categories>
          
          <category> Novel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Novel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>士不可以不弘毅</title>
      <link href="/2014/03/16/Novel-4/"/>
      <url>/2014/03/16/Novel-4/</url>
      
        <content type="html"><![CDATA[<p>在月亮爬上山之前，他终于抢先一步，站到了那山巅之上。  </p><p>剑山。帝国第一山。是当年剑圣柳白潜心铸剑的地方。那时的剑山还不叫剑山，仅仅只是人们口中的那山，但那山的命运在柳白决定入山静修的便注定不平凡。柳白铸剑三十三年，那些剑意在他铸剑成功的那一刻达到巅峰，那无上的剑意从抽象到具象，化作凌厉的风，也化作锋利的顽石，不断侵削，不断累积，于是那山的命运开始改变，由钝至利，由缓到陡，不过瞬间，却如天地造化般持久。从此那山有了自己的名字，剑山。因为它的陡，因为它的锋，更因为它是剑圣柳白倾尽三十三年所铸造的第一把也是最后一把剑。</p><p>他回头望了一下那些已经距他不足二百米的银白色幽灵––帝国最骁勇的战士，以其不同于普通士兵的银白色铠甲、长矛而著称。幽灵们此时正努力地向上爬着，不足二百米的距离，在近乎垂直的剑山之上则近乎天距。不过他们已经很快了，比起逃亡多年身上早已伤痕累累的弘毅。  </p><p>剑山之上是剑阁，或者说是曾经的剑阁。因为这里已经成了一片真正的冢地。四周散乱着一些或立着或倒着的残缺碑位，那是曾经的剑阁里最强大的代表。可惜剑阁破裂，早就没有人再来清扫。如今这些碑位在风雨中饱受侵蚀，就像旁边的破石屋，仿佛下一刻就会倒下。在最中央放着的是剑圣柳白的碑，或许是因为那碑是昔日剑圣的，无人敢动，于是那玉碑依旧保存着自己的完整，甚至在今夜的月光映衬下更显高大，但毕竟剑阁不在，在这破败环境之中，自然也会显得破败。  </p><p>真是嘲讽啊。弘毅看着剑阁的废墟，仿佛看见了那日三师叔反叛剑阁，那日帝国士兵第一次闯进剑阁，那日剑阁被一把火烧个半死，只剩下现在的废墟。弘毅突然大笑起来，全然不顾每一次大笑使肌肉拉伸所带来的疼痛，也全然不顾临近的危险。当年我们如此保护帝国，如今却被帝国追杀，真是嘲讽啊。  </p><p>弘毅抚过师父的墓碑，流下眼泪。墓碑是师兄弟偷偷回来立的，可惜他们没能活着下山。帝国想到了一切的可能，整个剑山布置了大量的兵力，其中还有一些曾经的剑阁弟子。如果不是念及旧情，弘毅可能还没上山就已经死了。  </p><p>弘毅想起当日师父对自己说过的话：剑阁弟子，为帝国生，为帝国死。只要还有一口气，便要保帝国无恙。弘毅还清楚地记得师父说这话的时候的自豪，身为剑阁之首，怎能不自豪？只是那时的豪情从三年前便开始不复存在了。  </p><p>三年前，帝国送走了最后一位明君也迎来了第一位暴君，在小人的怂恿下这位暴君下令将剑阁抹杀：顺者昌逆者亡。剑阁曾为帝国保驾护航数百年，再大的困难也没有让他们皱一下眉，但这次不一样。弘毅的二师叔于朝野上被上万名御林军围攻，通晓杀敌之术的二师叔却不懂如何向自己人拔剑，何况罪魁祸首也不是他们这些服从命令效忠帝国的士兵，而是高高在上的君王，只是君王不在场，如何拔剑？  </p><p>半个月后三师叔归顺帝国，或者说是归顺于那位暴君，同时还有一大半剑阁弟子。师父带着还有跟着自己的弟子开始逃亡生活。一路上有不少弟子死了，有的人战死了，有的人因饥饿而死，有的人因生病而死，但不管怎样，比起那些屈服的弟子，他们是真正的剑阁弟子。半年后，剑阁依旧存在于世，只是再也不是曾经的剑阁了。两年前师父为保众弟子牺牲了，那天以后，剑阁便再无辉煌可言。  </p><p>“师父，”弘毅对着师父的碑鞠了三躬，“我带着师兄弟们回来了。”弘毅身后是一块新的墓碑，上面用剑刻着这几年逃亡路上位剑阁荣誉牺牲的弟子的姓名。“我想他们有资格在这剑山之上拥有一块属于自己的地方，至于我，我终究只是您当年所收养的那个孤儿，不算是真正的剑阁弟子。得您厚爱是我莫大的荣幸，您的恩情弘毅来世再报。”  </p><p>弘毅向山下望去，还有不足一百米的距离了。那些白色盔甲在夜里更显清冷，像逝去的人的面孔，毫无表情，毫无感情。  </p><p>时间不多了。弘毅想起师父的嘱托，转身向剑圣柳白的墓碑走去，深深鞠了一躬，道了一声道歉，接着一剑劈下，用上好玉石制成的墓碑顿时裂开。一个用玉石做的剑盒落在地上，剑盒里装的自然是剑。  </p><p>这把剑很普通，外表普通，剑柄普通，花纹也普通。但这把剑却散发出一种强大的剑意，仿佛有水从天上来，波涛汹涌，又仿佛有山自远方来，不可抗拒。这些剑意是剑圣柳白用了三十三年积累下的，是足以在一瞬间将一座山雕成一把剑的力量。昔日铸剑成功之后，柳白命人将剑山的母玉打造成剑盒封进自己的墓碑里，只有历代掌门才能知晓的秘密。如今这把剑已和这座山融为一体，剑便是山，山便是剑，剑意便是山意。  </p><p>这把剑有个普通的名字，叫山剑。  </p><p>这座山有个普通的名字，叫剑山。  </p><p>不过他们都是剑圣柳白所创，如何普通？  </p><p>弘毅看着手中的剑，感受着那磅礴的剑意，想着这几年剑阁的变化、亲人的离去，这些不幸全因一个人的决定，而那个人在东方，在那最大的宫殿之内。于是弘毅剑指东方，山剑便是剑山，剑意便是山意，一股未曾有过的磅礴之势向东方掠去，仿佛有一座山于天地间行走。  </p><p>“君不见黄河之水天上来，奔流到海不复回。”百年前剑圣柳白于黄河前悟剑，创立了一个新的剑派––大河剑。摒弃传统剑法的繁多招式和无尽套路，大河剑只有一种形式，只是在那一剑中既有水的轻柔，又有水的刚强。一剑便是一种气势，一种排山倒海无可比拟的气势。如今剑意带着山意向东方掠去，有山的厚重，也有水的灵动。“醉翁之意不在酒，在乎山水之间也。”有山有水，便是天下，天下既来，如何抗拒？  </p><p>两年逃亡路，两千里旅途。不过顷刻剑意便到了。然后那宫殿便崩塌了，将那位暴君深埋其下。那被压毁的地基的形状，正是剑山地基的形状。  </p><p>起初弘毅并不认为自己有能力挥出这一剑，因为这是剑圣柳白的剑，里面的剑意是最强势的力量，而且此时已伤痕累累的似乎也承受不起那一剑带来的伤害。越是强大的剑，伤人的同时也一定会伤己。所以几乎同时，弘毅便倒下了。  </p><p>但是他不后悔，甚至为此付出性命也不后悔。所以当那白色铠甲和白色长矛出现在他最后的视野里时，他留给人间的是一个微笑，一个心满意足的微笑。  </p><p>因为他叫柳弘毅。  </p><p>因为他是剑阁弟子。  </p><p>因为师父曾说过：士不可以不弘毅。</p>]]></content>
      
      
      <categories>
          
          <category> Novel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Novel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脑桥Brain-Pons</title>
      <link href="/2014/02/01/Novel-3/"/>
      <url>/2014/02/01/Novel-3/</url>
      
        <content type="html"><![CDATA[<h5 id="【一】"><a href="#【一】" class="headerlink" title="【一】"></a>【一】</h5><p>“2025.7.3.Brain-Pons?Expeiment?Underway?28th?day。前50位实验品已彻底死亡。明天将考虑启用下一组实验品……Dr.C提议不再进行这项实验，裁决组大多同意他的意见，仅有少数人和我一样坚持。我，感到很孤单……”  </p><p>“2025.7.7.Brain-Pons?Expeiment?Underway?32nd?day。裁决组已全票通过Dr.C的意见。这意味着‘脑桥’实验就这么结束了，五年的前后工作就这样废了，那些实验品就这样白白浪费了。我不要这样，我必须做点什么……”<br>“2025.7.8.由于裁决组的决定，‘脑桥’实验被正式搁置。董事会已下令禁止再向实验室运送罪犯（实验品）。另外董事会决定销毁实验室，大家都已经开始收拾东西准备撤离了。我的时间不多了。”  </p><p>“2025.7.10.Brain-Pons?Expeiment?Ceased?2nd?day。我封闭了实验室，将那些想要撤离的人都关在冷冻区。他们的喊叫声还回响在我的耳边，但我不能放他们走，不能放弃‘脑桥’实验。绝对不能！”  </p><p>“2025.7.11.Brain-Pons?Expeiment?Ceased?3rd?day。人们已经被彻底冰封住。我解冻了其中五人。我用刀将他们的肚子割开了。为了确保他们的大脑的活跃度，我不知道用什么方法比这个更有效果。我只有四分钟的时间。我把他们放入类子宫培养器中。保存下他们的意识，希望有用……另外今天发生了一件怪事。冷冻区的人数凭空少了两个。他们的身体就从冷冻舱内凭空消失了！舱内外没有任何破坏的痕迹。我莫名地感觉好孤单。”  </p><p>“2025.7.12.Brain-Pons?Expeiment?Restarted?1st?day。我决定亲自实验。我躺进培养器中，给自己注入200ml药物，希望能连接上他们其中一位。事实证明我是正确的，电脑数据显示我和Dr.C的脑电波已达40%同步率。祝明天好运。另外冷冻舱内的人数又减少了两人，监控视频里没有任何有用的信息。我怀疑我的意识被‘入侵’了，希望只是我的猜测。”  </p><p>“2025.7.13.Brain-Pons?Expeiment?Restarted?2nd?day。同步率达到80%。我好累。”  </p><p>“2025.7.14.Brain-Pons?Expeiment?Restarted?3rd?day。同步率无法突破85%。我试着加入药物但毫无起色，我不明白。我在想方法。另外对于我的猜测，我不得不说，我可能是正确的。我曾经试着连接那50位实验品的其中一位，我只进去不到一分钟，头疼了一下，我以为没有成功，或许那次其中一位的意识进入到我的潜意识，蛰伏着……”  </p><p>“2025.7.17.Brain-Pons?Expeiment?Restarted?6th?day。我想我知道了，人体对实验用药物排斥力的强度远超我的预想。我想这种药物最多不能使用3次。我需要找到一种更加强大的药物。不知道为什么，我感觉我对周围的事物越来越陌生，甚至是我之前的同事，我都快记不清他们的脸了，我感觉自己有时候就像一个灵魂，独自一人工作在实验室，难道这是我的报应？”  </p><p>“2025.7.20.Brain-Pons?Expeiment?Restarted?9th?day。新药物研制失败了。我想我只能赌一次，明天我会加大药物量。2000ml，我想应该足够了。另外，我开始出现幻视幻听，我的意识已经开始变得不稳定了。我想这是因为连接上Dr.C的意识的原因，我们的意识已经开始在我的大脑中共存，我看见了希望，我知道我一定会成功。”  </p><p>“2025.7.21.Brain-Pons?Expeiment?Restarted?10th?day。<br>……<br>系统自动记录失败。”  </p><p>“远程操作：切入实验室监控。权限：最高级。”  </p><p>“AI智能：操作批准。正在切换……切换失败。Dr.W接入。”  </p><p>“‘脑桥’实验成功！我已经和Dr.C的意识共享，我可以看见他的记忆碎片，但不稳定，我需要时间好好拼接。<br>啊！这是……我？Dr.W？怎么会这样？莫非他成功？<br>不要！我不要被你控制！”  </p><p>监控的另一边。  </p><p>“虚拟‘脑桥’实验第一阶段成功。接下来怎么做，Dr.C？”  </p><p>“切断Dr.W的意识连接，清楚记忆，进入第二阶段。”Dr.C有些惊异于耳机中传来的董事长的命令，不过相比于此，他更惊异于他和Dr.W的意识竟可以同步到如此地步。  </p><p>不愧是你啊。Dr.C望向浸泡在培养器中的Dr.W的遗体，笑了。  </p><h5 id="【二】"><a href="#【二】" class="headerlink" title="【二】"></a>【二】</h5><p>大脑是一个个体。  </p><p>作为一个个体，每一个大脑有着自己专属的意识。这些意识共同决定一个人的性格——乐观、悲观、激愤、安静、沉稳……这些意识不受外界干扰，孤傲地存在。  </p><p>大脑又不仅仅是一个个体。  </p><p>每一个大脑有着相似的结构，这些结构让大脑可以在一定程度上进行无形的交流——意识上的交流。同时一定几率下的大脑电磁场的重合度也会使大脑之间进行信息共享。  </p><p>Brain-Pons?Expeiment，脑桥实验，通过药物、电激等方式，引导不同大脑产生相同磁场，从而使实验者的意识共享，完成信息交流。当然，前提是大脑之间必须具备极高的同步率。  </p><p>如果实验成功，那么这项技术便可以推广到军事，无论是防御还是进攻，都将提升到一个前人无法企及的高度！  </p><p>——《Brain-Pons?Expeiment?Proposal》  </p><p>By Dr.W&amp;Dr.C  </p><h5 id="【三】"><a href="#【三】" class="headerlink" title="【三】"></a>【三】</h5><p>“2025.7.3.Brain-Pons?Expeiment?Underway?28th?day。前50位实验品已彻底死亡。裁决组已向董事会申请新一批罪犯，将会于明天送到。Dr.C提出建议，他希望我和他进入实验室做一次实验。我不知道，我……上次私自实验注入药物，我体内已经产生抗体，不能被发现……”  </p><p>“2025.7.7.Brain-Pons?Expeiment?Underway?29th?day。新实验品已经冷冻保存。我同意了Dr.C的意见，我会在明天和他进入实验室亲自进行实验。我怀疑人体的抗药性已经非常强大了，我要增大加入量，才不会被他们发现。最近，他们，同事、裁决组、董事会，他们似乎都在关注我，或者说，都非常关注这次实验，远超以往，我感觉有些不大对劲，希望是我多虑了。哦，对了，最近头疼病又犯了。”  </p><p>“2025.7.9.Brain-Pons?Expeiment?Underway?31st?day。昨天实验时我偷偷给自己注入了两倍的量，我不知道自己为什么要这样做，但似乎我以前这样做过？实验效果很好，数据表明我和Dr.C的脑电波同步率已达45%，裁决组表示推迟使用新一批实验品的计划，明天我会和Dr.C再次进行实验。”<br>“2025.7.10.Brain-Pons?Expeiment?Underway?32nd?day。同步率达到80%。我可以看到Dr.C的记忆碎片，我需要时间进行拼接，我好累，头好疼。”  </p><p>“2025.7.13.Brain-Pons?Expeiment?Underway?35th?day。实验失败。我们能做到的只有这一点。最近几天的思考让我有了新的发现……啊！！！”<br>监控的另一边。  </p><p>“Dr.W的意识稳定度下降至85%，75%，70%，60%……是否切断连接，Dr.C？”  </p><p>“切断连接，清楚记忆。将这段视频发到我的办公室。先不要通知裁决组和董事会。”Dr.C回到自己的办公室，察看着视频。就在刚才看视频的时候，他发现了Dr.W的某个手势，他和Dr.W共同工作数十年，两人彼此非常熟悉，自然熟悉属于两个人之间的“暗语”。这个手势由两部分组成，分别代表“见我”“救我”。  </p><p>他无奈地苦笑了。不愧是Dr.W，竟然发现了。  </p><p>“这可不大好办啊。”</p><h5 id="【四】"><a href="#【四】" class="headerlink" title="【四】"></a>【四】</h5><p>大脑，真的是非常神奇。  </p><p>作为一个人的最高级的处理器，每天都要处理大量信息——家庭纠纷、事业交易、人生浮沉……并尽最大可能做出最适当的选择。开发度不超过8%，却能指导人类去发现、认识新世界，不得不说，它是无可替代的“统领”。  </p><p>作为一个统领，它需要不断地补充兵力，如今Dr.W的统领已经快撑不住了，但它既然决定了Dr.W的不服输的性格，那它就必然也是这样的。所以它在选了一个特定的部位，偷偷地补充兵力。  </p><p>真的很不容易。这些细胞在大脑的指挥下慢慢地、坚强地成长，不顾同伴的不断衰亡，或者说它们早已忽略了这个问题。它们将外界的刺激当成养料，疯狂地成长着，可惜的是，脑细胞死亡的速度真的是太快了。药物只能延缓脑死亡的时间但这并不代表是停止，哪怕是无限期延缓，也终有一天会死亡。  </p><p>所以那些细胞最后只是形成了一个很小很小的细胞团，不过这已经足够了。统领也表示出它的奖赏——它们将负责处理自脑死亡之后发生的所有事情。  </p><p>就在Dr.C第一次下令清楚记忆时，就在药物开始不断冲击大脑时，统领以及它的部下都失去了记忆。不过它们没有。它们活了下来，并记录下发生的一切，然后一个细胞开始产生神经冲动，接着两个、三个、四个……直到那个细胞团整个都在产生神经冲动，激活Dr.W的潜意识。  </p><p>于是Dr.W开始头疼。处理的信息越多，记忆碎片浮现的越多，他的头就越疼，也越来越频繁。直到某一天某一刻，在与Dr.C的意识连接时，他发现了那些缺少的记忆碎片，然后它们为他拼接起来，也为他想出了一个计划……  </p><p>除了疯狂，Dr.W想不出别的词来形容了。</p>]]></content>
      
      
      <categories>
          
          <category> Novel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Novel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二月二，龙抬头</title>
      <link href="/2013/08/17/Novel-5/"/>
      <url>/2013/08/17/Novel-5/</url>
      
        <content type="html"><![CDATA[<p>公元642年，武则天于泰山祭祀天地。  </p><p>“我，武曌，发大誓愿，为天地立心，为生民立命。愿奉天意，福佑万民。”武曌将龙樽中的酒洒于身前，缓缓叩拜。  </p><p>武则天登基为帝，是为则天神圣皇帝，寰宇震惊。  </p><p>南天门，凌霄殿内。  </p><p>“成何体统？！”玉帝一声怒喝，右手落在祥龙玉座之上，大殿之内，恍若雷霆。  </p><p>“玉帝息怒。玉帝息怒。”</p><p>“武则天登基之事，颠倒阴阳，祸乱乾坤，不可不罚。四海龙王听令，三年之内，不得向人间降雨！！以此天罚，警示众生！”</p><p>水晶宫外。</p><p>“少爷大事不好了！”一个童仆急匆匆地从宫中跑出。</p><p>“怎么了，小顺子？”</p><p>“今天天庭朝会你居然没去。那个武则天，明明是个女的，居然当了皇帝。玉帝一生气，就下令四海龙王三年不得向人间降雨。”</p><p>天河龙王似乎没听见，看着河里游来游去的鱼儿，“然后呢？”</p><p>“雷公电母都没事干了！天河龙王只剩个名头。可惜我刚给少爷你求个司职……”说着，小顺子竟有了要哭出来的感觉。</p><p>天河龙王轻笑，抚摸着小顺子的头，“既然朝会已散，去准备一下，随我下界。”</p><p>大唐边境，渭城内。</p><p>“这遍地饿殍，叹天地不仁啊……”天河龙王感叹道。</p><p>“少爷，这人还有救。”“全力救治！”“是！”</p><p>看这土地的裂痕，此地恐怕干旱三月有余……天河龙王面露忧色。</p><p>“这位公子，劳烦借一步说话。”一名骑马的官兵打断了天河龙王的思考。</p><p>“公子，下官乃陇右道下属驿丞奉则天神圣皇帝令，传令各道黎民。公子可知此处百姓情况？”</p><p>“此地旱情惨重，十室九空，有何令可传？”</p><p>“公子有所不知，奉天子旨意，赳赳大周共赴国难。特传令迁旱处百姓往水源之地，沿路水粮均由朝廷资助。”</p><p>洛阳城内。</p><p>“人真不少啊，都是从干旱地区迁过来的啊……”</p><p>“如此看来，这天灾定能安然而过，我也就放心了。”</p><p>“有那么容易吗？玉帝可是说了三年不给下雨，再怎么挨着河川，也……”</p><p>“无关河川不竭。小顺子，你看那边，”天河龙王指着街角的那棵树，“你可觉得它葱郁欲滴？既无雨水滋润，必有人日日浇灌。天佑灾祸以人力救之，如此不屈的精神才是度此绝境的唯一法门。”</p><p>“公子此言差矣。”</p><p>天河龙王回头一看，竟是一位算命先生。</p><p>“今武贼称帝，颠倒阴阳，故而天降此灾，非人力可挽。公子既从来处来，可知此祸缘起，不可信口胡言。”</p><p>“哪来的糟老头！我家少爷身份尊贵，岂容尔等说三道四！”</p><p>“你这童儿好生无礼！老夫好意提醒……”</p><p>“老不修！你……”</p><p>“雨顺，休得无礼，”天河龙王打断了童仆的话，“凡间奇人异士迭出，今日能遇上先生乃是有缘。先生说此旱乃天祸，愿闻其详。”</p><p>“乾坤阴阳自有定数，牝鸡司晨惹怒上苍，此乃天道不受，怒及凡尘。”老头手抚胡须，如是说。</p><p>“你我各执其理，我却愿和先生打个赌，若尽力为之，当可解此九州困境。若如先生所言，天道不容，则纵使人力穷尽，亦不会有半滴甘露降下，对不对？”</p><p>老头眉头一挑，似乎预感到什么。</p><p>“昔日我得仙人求雨符三张，若能降下雨来，则乃先生之言偏颇。第一道符——风·起。”霎时一股狂风吹起。<br>“公子不可意气用事，此乃逆天而行……”</p><p>“先生谬矣，若是逆天，又怎可降下雨来？第二道符——云·涌！”顿时空中乌云密布。面对童仆的阻止，天河龙王只是丢下两个字：退下。</p><p>“第三道符——雨·降！”话音刚落，空中开始飘起小雨，继而雨势变大，倾盆而下。</p><p>“天河龙王你……”老头无论怎么猜也猜不到他竟敢违背天条。</p><p>“你既知我身份，当知泽被凡尘乃我分内之事，无人可阻。”天河龙王转身离去，发现近乎全城人都在街上，听着众人口中激动的言语，长笑两声：“哈哈哈！痛快，痛快！！”</p><p>雨落之时，上阳宫外，武瞾跪拜天地，张开双臂，仿佛拥天抱地，“天佑我大周，天佑我大周啊……”</p><p>数日暴雨降后，凡间三月旱情不再。</p><p>夜。上阳宫内。</p><p>“武曌，武曌武则天，你可听见？”</p><p>“谁？谁人唤我？”武曌睁开双眼，发现自己竟睡在一片草丛之中，“此乃何处？”</p><p>“此处乃东岳泰山，你当日祭祀天地登基之处。可还记得？”</p><p>“泰山？我本在上阳宫，缘何在此？你是何人？”武曌视线所及之处，除峰顶云烟，竟毫无一人。</p><p>“我乃天河龙王，有话问你，故托梦唤你至此。”</p><p>“可是行云布雨之龙？我且问你，为何令我人间大旱，雨草不生？”</p><p>“天地不仁，以万物为刍狗。你若问我缘由，我便如你所愿。此番天降大旱，乃是源自你一介妇人妄自称帝，颠倒阴阳，惹怒玉帝。凡间因你而遭此劫难，你又有何话可说？”话语间，云间深处恍有龙形显现。<br>“若真如此，事已至此，我亦将竭力补救！如我曾发之大誓愿，如我之名，如日之暖，如月之明，高悬于空，泽被四海苍生！”</p><p>“好个日月凌空，泽被苍生的誓愿……”一条青龙显现，继而化为人形。“你若能守得此誓，殚精竭虑治理天下，便不枉我担此重罪，救九州于大旱。天行健，君子以自强不息。牢记此言，不可妄自菲薄，有一日懈怠。”一声大喝，仿佛青龙长啸，云烟缭绕，人形隐去。</p><p>“陛下，陛下？”</p><p>“我这是在哪儿？”</p><p>“陛下，您做梦了？这是上阳宫啊。”</p><p>原来是南柯一梦啊……武曌揉揉脑袋，“我睡了多久？”</p><p>“约莫半个时辰。”</p><p>“可有奏表呈上？”</p><p>“礼部呈上河南道八百里加急，言称天现异象。”</p><p>“呈上来。”</p><p>南天门，凌霄殿内。</p><p>“擅自在人间行云布雨之龙，无视天规，恣意妄为。天河龙王，你可知罪？”</p><p>“行云布雨乃我族天职，我不认罪。”</p><p>“妄言天道，你可知天道为何物？牝鸡司晨颠倒阴阳，此例一开天下大乱，故而有此灾劫。你不服管束，自作主张，又欲有何辩解？”</p><p>“前日我与童仆下日，曾见凡间惨状，自玉帝下令，天庭不过半日，下界三月无雨，十室九空，生机将断……</p><p>天之道，损有余而补不足。凡人羸弱不堪大旱，求玉帝收回成命。为四海风调雨顺，我甘愿受罚。”</p><p>龙王降雨犯天规<br>当受人间千秋罪<br>若欲重登凌霄殿<br>须得金豆开花时  </p><p>公元2013年，某月某日某地。</p><p>“咦？居然有这种事？那龙王后来呢？”</p><p>“后来金豆开花了，龙王就放出来了。”</p><p>“金豆开花是什么？好看吗？”</p><p>“小曌不是很聪明吗？你猜呀。”</p><p>“姑姑跟人家说嘛！”小曌嘟起小嘴。</p><p>“提示：不是花，是吃的哟。”</p><p>“这些凡人真是的！天上一天地上一年，少爷受千年之苦，他们说的如此轻松！”</p><p>“哈哈，我都不生气，小顺子你生什么气。我入尘千年，如今看到这满眼繁华，已觉心中甚慰，并无半丝怨念。”</p><p>“可是……”</p><p>“别什么可是不可是的了，今天可是少爷我脱困的日子，忘了不成？”</p><p>“怎么会忘！今天是金豆开花之日！”谈及此，雨顺开心地笑了。</p><p>一颗爆米花入口，人间恍有青龙，长啸三声，直上九霄。</p><p>二月二，龙抬头。</p>]]></content>
      
      
      <categories>
          
          <category> Novel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Novel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将夜之武逆</title>
      <link href="/2013/01/31/Novel-6/"/>
      <url>/2013/01/31/Novel-6/</url>
      
        <content type="html"><![CDATA[<p>当宁缺决定挥出那一刀的瞬间，他的逆天之路便再无回头之路。<br>——题记</p><p>回头崖上。</p><p>宁缺身上的衣服已由白色变成红黑色，先前的伤口还在向外渗着血。然而他似乎已经感受不到任何疼痛了。</p><p>他用手拭去嘴角的血水，看着面前这个强大的敌人，右手握紧朴刀，想要出击却发现自己竟迈步过身前一尺之地。</p><p>“这是？”</p><p>“樊笼。虽不及神殿里那位的厉害，但要困住书院最弱的天下行走，想来也不是什么难事。”</p><p>樊笼。他在心里念了一遍。继而大笑，笑得很大声，以至整个山崖都在回荡着他的笑声。</p><p>这是一种痴迷于战斗的狂热，也是一种遇强则强的放肆。</p><p>“不知十三先生为何而笑？”</p><p>“笑我这个书院最弱的天下行走也会被施以天下最强的御敌之术。”</p><p>或许这一种狂热与放肆对普通人有效，但这一次，毫无效果。</p><p>耳边传来对方的大笑。“世人皆称十三先生为书院最弱，然而十三先生两个月连破三境，其速度仅次于昔日神座、当今夫子，就算是书院最弱，我二十三年蝉又如何敢轻敌？”</p><p>“传闻你一朝入关便是二十三年不问世事，出关之时便是一片蝉鸣，恍若天乐奏响，不知传闻可是真的？”</p><p>“都是后辈们无聊时的言语罢了。”</p><p>“或许吧。不过我比较关心你出关之后的事，比如，”宁缺用手指了指二十三年蝉的身体，“你入魔一事。”</p><p>二十三年蝉低头看了一眼正冒着白气的伤口。此时伤口正以缓慢而稳定的速度自我愈合。“十三先生好眼力。”他从怀中掏出一块肉塞入口中，细细咀嚼着。“修行界流传着十三先生打架时必定会闲聊，从心理上先胜一筹，今日所见，果然如此。”</p><p>“不过只是为了恢复一下而已。”宁缺倒也实诚，趁着这个时机放松了一下手腕。</p><p>“那我也满足一下你的好奇心。当年出关之后看到人事变迁，长生的愿望开始膨胀，越来越强烈。我以佛宗首座的身份阅读了三卷天书，试着找到一种可以维持肉身不坏的方法。幸运的是，我找到了。不幸的是，那个方法的前提是必须入魔。控制不住对长生的渴望，于是我入魔了。”</p><p>宁缺想不到他入魔的原因竟如此简单，又被他如此平淡地说出来。</p><p>“魔宗中有一秘法，名曰‘饕餮’，修行此法需要生食活人肉，将活人的生气转化为己用。后来我改进了一下，吃死人肉就行了。”说完，二十三年蝉从怀中又掏出一块肉塞入口中。此事他身上的伤口已愈合大半。</p><p>“怪不得。”</p><p>“说来你的‘浩然剑’也颇有长进，加上元十三箭，就连我的魔宗护体也要惧上三分，不过你终究不是轲疯子。况且我先入佛再入魔，如今已近乎圣体，而你想要逾境杀我，岂不是要逆天？”</p><p>逆天？一个陌生而熟悉的字眼进入宁缺的耳中。他缓缓地闭上眼中。</p><p>“看来你也知道这不可能了。那我就来结束你的噩梦吧。”说完，二十三年蝉一个箭步冲向宁缺。速度之快，竟挟着一股山风。</p><p>然而他想错了，宁缺之所以闭眼，并不是想要放弃，而是想到了一件有趣的事。</p><p>昔日踏上书院二层楼时，宁缺曾与夫子在咫尺峰上彻夜长谈。</p><p>“我曾去渭城看过，知道你以前的警力，想你踏入书院的路也绝非常人所能做到的。”夫子躺在槐树下，品着酒。</p><p>“如果有人经历过我的经历，那么他一定会很想改变。我不过只是更加渴望而已。”</p><p>夫子看了他一眼，有些心喜，也有些担忧。“你以后便是书院的天下行走，便要接受天下所有修行之人的挑战。不过你如今如此低的境界，想要改变，岂不是要登天，不，比逆天还难？”夫子笑着品了一口酒，他对自己的用词很满意。</p><p>宁缺看着夫子，一字一字地说道：“那我便要逆天。”</p><p>夫子听到这句话，看着自己的弟子，笑了，“既在天中，何以逆天？”</p><p>宁缺沉默了，因为他不知道如何回答。如今经过和二十三年蝉的对话，他似乎知道了答案。</p><p>他慢慢向后退了一步，举起手中的朴刀，挥了下去。</p><p>既然在天道之中便无法逆天，那我就站在天道之外！</p><p>找到属于自己的答案之后，宁缺的脑中所有的招式便只剩下挥刀。简单地挥刀。</p><p>有时候，因为简单，所以强大。</p><p>上一刻，朴刀挥。</p><p>这一刻，樊笼破。</p><p>下一刻，剑气至。</p><p>二十三年蝉还在好奇宁缺是如何挣脱樊笼的束缚的，突然间发现一股浩然气突破他的魔宗护体，紧接着一股滚热的液体从口中喷出。</p><p>“想不到你竟又破镜了。”</p><p>“那还要感谢你的帮助。”破镜后的宁缺突然感觉眼前的世界竟变得不一样了。甚至连二十三年蝉是伤口处外渗的魔宗元气也感受得到。</p><p>“看来书院自你小师叔之后又出了一个奇迹。”再度被浩然气所重伤，二十三年蝉已无法再迅速用“饕餮”来恢复了。</p><p>“我就当是赞美了。多谢。”话音落，朴刀挥，一股更加刚烈、醇厚的浩然气突破二十三年蝉的魔宗护体，将其生生斩成两半。</p><p>一场恶战终于结束。</p><p>宁缺拖着疲惫的身躯朝来时的路走去，突然感觉有些不妥，反手在空中比划几下，确认碑上的字已改，才放心地走下山崖。</p><p>从此世间，回头崖逝，无头崖立。</p>]]></content>
      
      
      <categories>
          
          <category> Novel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Novel </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
